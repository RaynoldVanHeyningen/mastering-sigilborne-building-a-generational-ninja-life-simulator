
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../08-chapter-8/">
      
      
        <link rel="next" href="../10-chapter-10/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Chapter 1.9: Scene Composition - Standardizing Godot Scenes - Mastering Sigilborne: Building a Generational Ninja Life Simulator</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="sky" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-19-scene-composition-standardizing-godot-scenes" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-header__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mastering Sigilborne: Building a Generational Ninja Life Simulator
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 1.9: Scene Composition - Standardizing Godot Scenes
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-nav__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Mastering Sigilborne: Building a Generational Ninja Life Simulator
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-chapter-1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.1: Project Setup for Godot 4.5 with C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-chapter-2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.2: The Brain (C#) - Headless Simulation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-chapter-3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-chapter-4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.4: Directory Structure - Enforcing Separation of Concerns
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-chapter-5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.5: Entity Model - Lightweight ECS-lite in C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../06-chapter-6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.6: Component Architecture - Composition over Inheritance
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07-chapter-7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.7: Job System & Concurrency - Multithreaded Processing
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../08-chapter-8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.8: Thread Safety - Command Buffers & Double Buffering
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.9: Scene Composition - Standardizing Godot Scenes
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.9: Scene Composition - Standardizing Godot Scenes
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-19-scene-composition-standardizing-godot-scenes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 1.9: Scene Composition - Standardizing Godot Scenes
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1.9: Scene Composition - Standardizing Godot Scenes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-view-vs-controller-philosophy" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The "View" vs. "Controller" Philosophy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-the-canonical-entity-root-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. The Canonical Entity Root Hierarchy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-script-responsibilities-entityviewgd" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Script Responsibilities: EntityView.gd
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-entityview-with-the-c-brain" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating EntityView with the C# Brain
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-connecting-the-body-to-the-brains-events-conceptually" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Connecting the Body to the Brain's Events (Conceptually)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../10-chapter-10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.10: Naming Conventions & Scene Interfaces
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../11-chapter-11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.11: Animation Event Protocol - Syncing Brain & Body
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../12-chapter-12/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.12: Interop Layer - C# to GDScript Communication
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../13-chapter-13/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.13: Global State Management - Data Ownership
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../14-chapter-14/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.14: Debugging Tools - Console & State Inspector
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../15-chapter-15/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.15: Main Loop Execution Order - Tick vs. Frame
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../16-chapter-16/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../17-chapter-17/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.2: Standard Movement Logic - Velocity & Friction (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../18-chapter-18/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../19-chapter-19/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.4: Physics Layer - Hybrid Movement Pipeline
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../20-chapter-20/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../21-chapter-21/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../22-chapter-22/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../23-chapter-23/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.4: Subtypes & Modifiers - Procedural Nuance for Glyphs (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../24-chapter-24/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.5: Glyph Acquisition - Teachers & Scrolls (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../25-chapter-25/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../26-chapter-26/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../27-chapter-27/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../28-chapter-28/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../29-chapter-29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.5: Visual Feedback - Particles & Animations (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../30-chapter-30/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.1: Biological Simulation - The Bio-Tick (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../31-chapter-31/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.2: Core Stats (Struct)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../32-chapter-32/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../33-chapter-33/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.4: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../34-chapter-34/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.5: Damage & Recovery Pipeline - Wounds & Status Effects (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../35-chapter-35/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../36-chapter-36/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../37-chapter-37/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.8: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../38-chapter-38/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.1: Physics Layer - Hitbox & Hurtbox Detection (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../39-chapter-39/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.2: The Math Layer - Damage Calculator (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../40-chapter-40/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.3: Equipment & Inventory - Inventory Data Structure (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../41-chapter-41/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.4: Equipment Logic - Recalculating Stats (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../42-chapter-42/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../43-chapter-43/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.6: Titan AI State - Specialized State Machine (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../44-chapter-44/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.1: Perception System - Spatial Hashing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../45-chapter-45/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.2: The Senses - Vision, Hearing & Chakra Sense (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../46-chapter-46/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.3: Stealth Mechanics - Visibility & Detection Meter (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../47-chapter-47/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.4: Decision Making: Utility AI (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../48-chapter-48/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.5: Ecology Simulation - Virtual Agents (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../49-chapter-49/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.6: Spawning & Despawning - Hydration/Dehydration (Brain & Body)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../50-chapter-50/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.1: Faction System - The Relationship Graph (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../51-chapter-51/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.2: The Simulation Clock - Game Time & Load Balancing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../52-chapter-52/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.3: Market Simulation - Supply & Demand (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../53-chapter-53/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.4: Trade Routes - Caravans as Arteries (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../54-chapter-54/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.5: Crime & Justice - The Heat System (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../55-chapter-55/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.6: Bounty & Punishment - Escalation & Consequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../56-chapter-56/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.1: Ritual System - Pattern Matching & Execution (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../57-chapter-57/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.2: Seals & Locks - Logical Locks (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../58-chapter-58/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.3: Ritual System - Simple, Advanced & Forbidden (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../59-chapter-59/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.4: Forbidden Contracts & Spirit Contracts (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../60-chapter-60/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.5: Corruption Pacts & Multi-Life Persistence of Rituals (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-19-scene-composition-standardizing-godot-scenes" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 1.9: Scene Composition - Standardizing Godot Scenes
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1.9: Scene Composition - Standardizing Godot Scenes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-view-vs-controller-philosophy" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The "View" vs. "Controller" Philosophy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-the-canonical-entity-root-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. The Canonical Entity Root Hierarchy
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-script-responsibilities-entityviewgd" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Script Responsibilities: EntityView.gd
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-entityview-with-the-c-brain" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating EntityView with the C# Brain
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-connecting-the-body-to-the-brains-events-conceptually" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Connecting the Body to the Brain's Events (Conceptually)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Chapter 1.9: Scene Composition - Standardizing Godot Scenes</h1>

<h2 id="chapter-19-scene-composition-standardizing-godot-scenes">Chapter 1.9: Scene Composition - Standardizing Godot Scenes</h2>
<p>With our C# Brain's architecture taking shape, it's time to formalize how the GDScript Body visualizes its data. This chapter focuses on standardizing Godot Scene composition, particularly for entities, as outlined in TDD 16. The goal is to create a predictable, maintainable, and efficient structure where <code>EntityView.gd</code> acts as the sole communication point between the Brain's data and the Body's visuals. This prevents "Scene Spaghetti" and ensures a clean separation of concerns.</p>
<h3 id="1-the-view-vs-controller-philosophy">1. The "View" vs. "Controller" Philosophy</h3>
<p>In our Brain &amp; Body architecture:</p>
<ul>
<li><strong>Brain (C#)</strong>: Is the <strong>Controller</strong> (and Model). It dictates what <em>should</em> happen.</li>
<li><strong>Body (GDScript)</strong>: Is the <strong>View</strong>. It displays what <em>is</em> happening.</li>
</ul>
<p>This means Godot scenes and their scripts should primarily focus on:</p>
<ul>
<li><strong>Visuals</strong>: Sprites, animations, particles, UI.</li>
<li><strong>Audio</strong>: Sound effects, music.</li>
<li><strong>Input Capture</strong>: Forwarding raw input to the Brain.</li>
<li><strong>Interpolation</strong>: Smoothly animating between Brain states.</li>
</ul>
<p><strong>Scenes should NOT contain logic for:</strong></p>
<ul>
<li>Calculating damage.</li>
<li>Determining AI decisions.</li>
<li>Managing inventory data.</li>
<li>Storing authoritative game state (e.g., actual health values).</li>
</ul>
<h3 id="2-the-canonical-entity-root-hierarchy">2. The Canonical Entity Root Hierarchy</h3>
<p>TDD 16.2 provides a strict template for every active entity scene. This consistency is vital for systems that need to generically interact with entity visuals (e.g., <code>EntityManager</code> spawning, <code>VFXManager</code> attaching particles).</p>
<p>Let's create a generic <code>EntityRoot</code> scene that other entity types (Player, NPC, Projectile) will inherit from or instantiate.</p>
<ol>
<li>In Godot, go to <code>Scene &gt; New Scene</code>.</li>
<li>Add a <code>CharacterBody2D</code> as the root node.<ul>
<li>Rename this node to <code>EntityRoot</code>.</li>
<li><strong>Reasoning</strong>: <code>CharacterBody2D</code> is ideal for entities that move and collide in 2D space, providing built-in <code>move_and_slide()</code> functionality.</li>
</ul>
</li>
<li>As a child of <code>EntityRoot</code>, add a <code>Node2D</code>.<ul>
<li>Rename this node to <code>Visuals</code>.</li>
<li><strong>Reasoning</strong>: This node will contain all visual elements (sprites, animations). Rotating or flipping this node will affect all visuals without changing the <code>CharacterBody2D</code>'s collision or physics.</li>
</ul>
</li>
<li>As a child of <code>Visuals</code>, add a <code>Sprite2D</code>.<ul>
<li>Rename this node to <code>Sprite</code>.</li>
<li><strong>Reasoning</strong>: The main visual representation.</li>
</ul>
</li>
<li>As a child of <code>Visuals</code>, add another <code>Node2D</code>.<ul>
<li>Rename this node to <code>VFX</code>.</li>
<li><strong>Reasoning</strong>: A dedicated attachment point for particle effects, ensuring they move and rotate with the main visual.</li>
</ul>
</li>
<li>As a child of <code>EntityRoot</code>, add a <code>CollisionShape2D</code>.<ul>
<li>Rename this node to <code>Collision</code>.</li>
<li><strong>Reasoning</strong>: Defines the entity's physical collision bounds. You'll need to assign a <code>Shape2D</code> (e.g., <code>RectangleShape2D</code>, <code>CapsuleShape2D</code>) to it in the Inspector.</li>
</ul>
</li>
<li>As a child of <code>EntityRoot</code>, add a <code>Node2D</code>.<ul>
<li>Rename this node to <code>Audio</code>.</li>
<li><strong>Reasoning</strong>: A dedicated attachment point for <code>AudioStreamPlayer2D</code> nodes, allowing sounds to originate from the entity's position.</li>
</ul>
</li>
<li>As a child of <code>EntityRoot</code>, add a <code>Control</code> node.<ul>
<li>Rename this node to <code>UI</code>.</li>
<li><strong>Reasoning</strong>: An attachment point for UI elements like health bars, name tags, or interaction prompts, ensuring they stay positioned relative to the entity.</li>
</ul>
</li>
</ol>
<p>Your scene tree for <code>EntityRoot.tscn</code> should look like this:</p>
<pre><code>EntityRoot (CharacterBody2D)
├── Visuals (Node2D)
│   ├── Sprite (Sprite2D)
│   └── VFX (Node2D)
├── Collision (CollisionShape2D)
├── Audio (Node2D)
└── UI (Control)
</code></pre>
<p>Save this scene as <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</p>
<h3 id="3-script-responsibilities-entityviewgd">3. Script Responsibilities: <code>EntityView.gd</code></h3>
<p>TDD 16.2 explicitly states: "<code>EntityView.gd</code>: The ONLY script that talks to the Brain." This script is the entity's "puppet master" in the Body, listening to C# signals and updating the visual scene.</p>
<p>Create a new GDScript and attach it to the <code>EntityRoot</code> node in <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</p>
<ol>
<li>Select the <code>EntityRoot</code> node.</li>
<li>Click the script icon in the Inspector.</li>
<li>Create a new script:<ul>
<li><strong>Language</strong>: <code>GDScript</code>.</li>
<li><strong>Class Name</strong>: <code>EntityView</code>.</li>
<li><strong>Inherits</strong>: <code>CharacterBody2D</code> (this should be auto-filled).</li>
<li><strong>Path</strong>: <code>res://_Body/Scripts/Visuals/EntityView.gd</code> (create <code>Visuals</code> folder if it doesn't exist).</li>
<li>Click <code>Create</code>.</li>
</ul>
</li>
</ol>
<p>Open <code>EntityView.gd</code> and modify it:</p>
<pre><code class="language-gdscript"># _Body/Scripts/Visuals/EntityView.gd
class_name EntityView extends CharacterBody2D

# --- Public Properties ---
# The EntityID from the C# Brain that this visual representation corresponds to.
var entity_id: int = -1 # Store as int for simplicity, but conceptually it's EntityID.Index

# --- Node References ---
@onready var visuals: Node2D = $Visuals
@onready var sprite: Sprite2D = $Visuals/Sprite
# @onready var animation_player: AnimationPlayer = $Visuals/AnimationPlayer # Add this if you have an AnimationPlayer
@onready var vfx_attachment_point: Node2D = $Visuals/VFX
@onready var audio_attachment_point: Node2D = $Audio
@onready var ui_attachment_point: Control = $UI

# --- Visual Interpolation Parameters (TDD 16.4) ---
# The target position received from the Brain.
var brain_target_position: Vector2 = Vector2.ZERO
# The smoothing speed for visual interpolation.
const SMOOTHING_SPEED: float = 10.0 # Adjust as needed

# --- Signals ---
# This signal is emitted when an animation event occurs.
# It's caught by the Brain (C#) via GameEvents.
signal anim_event(type: String, payload: Dictionary)


## Initializes this EntityView with its corresponding C# EntityID.
## This function is called by the C# Brain via the EventBus when an entity is spawned.
## (TDD 16.4: The &quot;Setup&quot; Function)
func setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:
    entity_id = id
    global_position = initial_position
    brain_target_position = initial_position
    visuals.rotation_degrees = initial_rotation

    # Example: Set sprite texture based on definition_id
    # var texture_path = &quot;res://_Body/Art/Characters/%s.png&quot; % definition_id
    # if ResourceLoader.exists(texture_path):
    #     sprite.texture = load(texture_path)
    # else:
    #     push_warning(&quot;EntityView: No sprite found for definition_id: %s&quot; % definition_id)

    GD.print(&quot;EntityView: Setup for C# EntityID %s (Def: %s) at %s&quot; % [entity_id, definition_id, global_position])

    # --- Connect to Brain Signals (TDD 16.4) ---
    # We will establish these connections more formally in Chapter 1.12 (Interop Layer).
    # For now, conceptual connections:
    # GameManager.Instance.Events.Connect(&quot;entity_moved&quot;, Callable(self, &quot;_on_entity_moved&quot;))
    # GameManager.Instance.Events.Connect(&quot;entity_health_changed&quot;, Callable(self, &quot;_on_entity_health_changed&quot;))
    pass

## Called every physics frame (fixed rate) to update the visual position.
## (TDD 16.4: Visual Interpolation)
func _physics_process(delta: float) -&gt; void:
    # Interpolate towards the Brain's authoritative target position.
    # We use global_position here to affect the CharacterBody2D directly.
    global_position = global_position.lerp(brain_target_position, delta * SMOOTHING_SPEED)

    # If this entity needs to send input to the Brain, it would do so here.
    # Example: if entity_id == GameManager.Instance.Player.PlayerEntityID:
    #    InputManager.instance.send_player_input_to_brain()
    pass

## Placeholder for reacting to C# entity movement signals.
## This method would be connected to an event from the C# Brain.
func _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:
    if entity_id == id:
        brain_target_position = new_position
        visuals.rotation_degrees = new_rotation
        # GD.print(&quot;EntityView %s: Received new position %s&quot; % [entity_id, new_position])
</code></pre>
<p><strong>Explanation of <code>EntityView.gd</code>:</strong></p>
<ul>
<li><strong><code>entity_id: int</code></strong>: This <code>EntityView</code> stores the <code>Index</code> of its corresponding C# <code>EntityID</code>.</li>
<li><strong><code>@onready var ...</code></strong>: Efficiently gets references to child nodes.</li>
<li><strong><code>brain_target_position</code></strong>: This <code>Vector2</code> stores the <em>last authoritative position</em> received from the C# Brain.</li>
<li><strong><code>_physics_process(delta: float)</code></strong>: This is where <code>Visual Interpolation</code> happens (TDD 16.4). The <code>EntityView</code> smoothly moves towards <code>brain_target_position</code>, providing fluid visuals even if the C# Brain updates at a lower tick rate.</li>
<li><strong><code>setup(id: int, ...)</code></strong>: This is the "Setup" function (TDD 16.4). The C# Brain will call this via the <code>EventBus</code> when it spawns a new entity, passing its <code>EntityID</code> and initial state.</li>
<li><strong><code>_on_entity_moved(...)</code></strong>: A placeholder for a signal handler. In Chapter 1.12, we'll connect this to a C# event that the <code>TransformSystem</code> will emit.</li>
</ul>
<h3 id="4-integrating-entityview-with-the-c-brain">4. Integrating EntityView with the C# Brain</h3>
<p>For the <code>EntityView</code> to be useful, the C# Brain needs to:
1.  <strong>Emit events</strong> when entities are spawned, moved, or destroyed.
2.  The GDScript <code>EntityView</code> needs to <strong>listen</strong> to these events.</p>
<p>We already set up <code>EntityManager</code> to emit <code>EntitySpawnedEvent</code> and <code>EntityDespawnedEvent</code>. We will modify <code>TransformSystem</code> to emit <code>EntityMovedEvent</code>.</p>
<p>First, let's define the <code>EntityMovedEvent</code> struct in <code>_Brain/Entities/EntityManager.cs</code> so our <code>EventBus</code> can handle it:</p>
<pre><code class="language-csharp">// _Brain/Entities/EntityManager.cs (inside Sigilborne.Entities namespace)
// ...
        // --- Helper Events for Body Sync (TDD 11.4) ---
        public struct EntitySpawnedEvent { public EntityID ID; public EntityType Type; public string DefinitionID; public Vector2 InitialPosition; public float InitialRotation; }
        public struct EntityDespawnedEvent { public EntityID ID; }
        public struct EntityMovedEvent { public EntityID ID; public Vector2 NewPosition; public float NewRotation; } // Add this struct
    }
}
</code></pre>
<p><strong>Note</strong>: We updated <code>EntitySpawnedEvent</code> to include initial position and rotation, as the <code>EntityView.gd</code> <code>setup</code> function now expects it.</p>
<p>Now, modify <code>_Brain/Systems/TransformSystem.cs</code> to emit this event:</p>
<pre><code class="language-csharp">// _Brain/Systems/TransformSystem.cs
using Godot;
using System;
using System.Collections.Generic;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Entities.Components;

namespace Sigilborne.Systems
{
    public class TransformSystem
    {
        private Dictionary&lt;EntityID, TransformComponent&gt; _transforms = new Dictionary&lt;EntityID, TransformComponent&gt;();
        private EntityManager _entityManager;
        private EventBus _eventBus; // Store EventBus reference

        public TransformSystem(EntityManager entityManager, EventBus eventBus)
        {
            _entityManager = entityManager;
            _eventBus = eventBus; // Store EventBus reference
            eventBus.OnEntitySpawned += OnEntitySpawned;
            eventBus.OnEntityDespawned += OnEntityDespawned;
            GD.Print(&quot;TransformSystem: Initialized.&quot;);
        }

        private void OnEntitySpawned(EntityManager.EntitySpawnedEvent e)
        {
            // All entities get a TransformComponent by default for simplicity in this example
            _transforms.Add(e.ID, new TransformComponent(e.InitialPosition, e.InitialRotation)); // Use initial position from event
            GD.Print($&quot;TransformSystem: Added transform for {e.ID}&quot;);
        }

        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)
        {
            if (_transforms.ContainsKey(e.ID))
            {
                _transforms.Remove(e.ID);
                GD.Print($&quot;TransformSystem: Removed transform for {e.ID}&quot;);
            }
        }

        // ... (TryGetTransform, TrySetTransform, GetTransformRef methods) ...

        public void Tick(double delta)
        {
            // Example: Simple movement for all entities with a transform
            foreach (var kvp in _transforms)
            {
                EntityID id = kvp.Key;
                ref TransformComponent transform = ref _transforms.GetValueRef(id);

                // Simulate simple movement for testing: move right
                transform.Position += new Vector2(10 * (float)delta, 0); // Move 10 units/sec to the right
                transform.RotationDegrees += 50 * (float)delta; // Rotate 50 degrees/sec

                // TDD 11.4: Emit OnEntityMoved for Body sync
                _eventBus.Publish(new EntityManager.EntityMovedEvent { ID = id, NewPosition = transform.Position, NewRotation = transform.RotationDegrees });
            }
        }
    }
}
</code></pre>
<p>Now, we need to adjust <code>GameManager.CreateEntity</code> to pass initial position and rotation.</p>
<pre><code class="language-csharp">// _Brain/Core/GameManager.cs (inside CreateEntity and test section)
// ...
        public EntityID CreateEntity(EntityType type, string definitionID, Vector2 initialPosition = default, float initialRotation = 0f)
        {
            if (_freeIndices.Count == 0)
            {
                GD.PrintErr(&quot;EntityManager: No free entity slots available!&quot;);
                return EntityID.Invalid;
            }

            int index = _freeIndices[_freeIndices.Count - 1];
            _freeIndices.RemoveAt(_freeIndices.Count - 1);

            _entityMetas[index].Generation++;
            _entityMetas[index].IsActive = true;
            _entityMetas[index].Type = type;
            _entityMetas[index].DefinitionID = definitionID;

            EntityID newId = new EntityID(index, _entityMetas[index].Generation);
            GD.Print($&quot;EntityManager: Created {type} entity {newId} (Def: {definitionID})&quot;);

            // Publish with initial position and rotation
            _eventBus.Publish(new EntitySpawnedEvent { ID = newId, Type = type, DefinitionID = definitionID, InitialPosition = initialPosition, InitialRotation = initialRotation });

            return newId;
        }
// ...
// Inside GameManager._Ready():
// ...
        // --- Test Entity Management &amp; Components ---
        GD.Print(&quot;\n--- Testing Entity Management &amp; Components ---&quot;);
        // Pass initial position and rotation
        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, &quot;player_default&quot;, new Vector2(200, 200), 0f);
        GD.Print($&quot;Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}&quot;);

        // The TransformSystem will pick up this initial position from the EntitySpawnedEvent.
        // No need to manually set it here, as Transforms.TrySetTransform will override.
        // Let's remove the manual set/get for playerTransform here to show event-driven init.
        // The TransformSystem.Tick will then immediately start moving it.

        EntityID npcEntity = Entities.CreateEntity(EntityType.NPC, &quot;goblin_grunt&quot;, new Vector2(100, 100), 90f);
        GD.Print($&quot;Created NPC: {npcEntity}. IsValid: {Entities.IsValid(npcEntity)}&quot;);

        Entities.DestroyEntity(playerEntity);
        GD.Print($&quot;Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}&quot;);

        if (!Transforms.TryGetTransform(playerEntity, out TransformComponent destroyedTransform))
        {
            GD.Print($&quot;Attempted to get transform for destroyed entity {playerEntity}, it correctly failed.&quot;);
        }

        GD.Print(&quot;--- End Testing Entity Management &amp; Components ---\n&quot;);
// ...
</code></pre>
<p>Finally, we need to modify <code>EventBus.cs</code> to declare the new event types.</p>
<pre><code class="language-csharp">// _Brain/Core/EventBus.cs
using System;
using System.Collections.Concurrent;
using Godot;
using Sigilborne.Entities; // Add this using directive for EntityID, EntityType, Vector2

namespace Sigilborne.Core
{
    public class EventBus
    {
        // ... (existing OnGameStateChanged event) ...

        // Declare events for entity lifecycle and movement
        public event Action&lt;EntityManager.EntitySpawnedEvent&gt; OnEntitySpawned;
        public event Action&lt;EntityManager.EntityDespawnedEvent&gt; OnEntityDespawned;
        public event Action&lt;EntityManager.EntityMovedEvent&gt; OnEntityMoved; // New event

        private ConcurrentQueue&lt;Action&gt; _commandBuffer = new ConcurrentQueue&lt;Action&gt;();

        public void Publish&lt;TEvent&gt;(TEvent eventData)
        {
            // Use specific event types for publishing
            if (eventData is EntityManager.EntitySpawnedEvent spawnedEvent)
            {
                OnEntitySpawned?.Invoke(spawnedEvent);
            }
            else if (eventData is EntityManager.EntityDespawnedEvent despawnedEvent)
            {
                OnEntityDespawned?.Invoke(despawnedEvent);
            }
            else if (eventData is EntityManager.EntityMovedEvent movedEvent) // New condition
            {
                OnEntityMoved?.Invoke(movedEvent);
            }
            else if (eventData is string gameState) // Existing example
            {
                OnGameStateChanged?.Invoke(gameState);
            }
            else
            {
                GD.PrintErr($&quot;EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}&quot;);
            }
        }
        // ... (AddCommand and FlushCommands methods) ...
    }
}
</code></pre>
<h3 id="5-connecting-the-body-to-the-brains-events-conceptually">5. Connecting the Body to the Brain's Events (Conceptually)</h3>
<p>The actual connection between C# <code>Action</code> delegates and GDScript signals is handled by the Interop Layer (Chapter 1.12). For now, conceptually, <code>EntityView.gd</code> would connect to these events.</p>
<p>We can illustrate this by adding a placeholder <code>EntityViewManager.gd</code> to manage the spawning and despawning of <code>EntityView</code> scenes.</p>
<p>Create <code>res://_Body/Scripts/Visuals/EntityViewManager.gd</code>:</p>
<pre><code class="language-gdscript"># _Body/Scripts/Visuals/EntityViewManager.gd
class_name EntityViewManager extends Node

# --- Singleton Instance ---
static var instance: EntityViewManager

# Dictionary to hold active EntityView instances, mapped by C# EntityID.Index
var _active_entity_views: Dictionary = {}

# Preload our generic EntityRoot scene
const ENTITY_ROOT_SCENE: PackedScene = preload(&quot;res://_Body/Scenes/Entities/EntityRoot.tscn&quot;)

func _init():
    if instance != null:
        push_error(&quot;EntityViewManager: More than one instance detected!&quot;)
        queue_free()
        return
    instance = self

func _ready():
    # Connect to C# Events from GameManager.Instance.Events (will be done in Chapter 1.12)
    # For now, we'll simulate the connection.
    GD.print(&quot;EntityViewManager: Initialized. Waiting for C# entity events.&quot;)
    # This is a conceptual connection. In Chapter 1.12, we'll write the C# side to expose these.
    # GameManager.Instance.Events.OnEntitySpawned += Callable(self, &quot;_on_entity_spawned&quot;)
    # GameManager.Instance.Events.OnEntityDespawned += Callable(self, &quot;_on_entity_despawned&quot;)
    # GameManager.Instance.Events.OnEntityMoved += Callable(self, &quot;_on_entity_moved&quot;)
    pass

## Handler for C# EntitySpawnedEvent.
func _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:
    if ENTITY_ROOT_SCENE == null:
        push_error(&quot;EntityViewManager: ENTITY_ROOT_SCENE not loaded!&quot;)
        return

    var entity_view: EntityView = ENTITY_ROOT_SCENE.instantiate()
    add_child(entity_view) # Add to the scene tree

    # Call the setup function on the EntityView
    entity_view.setup(id, initial_position, initial_rotation, definition_id)

    _active_entity_views[id] = entity_view
    GD.print(&quot;EntityViewManager: Spawned visual for C# EntityID %s (Type: %s)&quot; % [id, type])

## Handler for C# EntityDespawnedEvent.
func _on_entity_despawned(id: int) -&gt; void:
    if _active_entity_views.has(id):
        var entity_view: EntityView = _active_entity_views[id]
        entity_view.queue_free() # Remove from scene tree
        _active_entity_views.erase(id)
        GD.print(&quot;EntityViewManager: Despawned visual for C# EntityID %s&quot; % id)
    else:
        push_warning(&quot;EntityViewManager: Attempted to despawn non-existent visual for C# EntityID %s&quot; % id)

## Handler for C# EntityMovedEvent.
func _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:
    if _active_entity_views.has(id):
        var entity_view: EntityView = _active_entity_views[id]
        entity_view.brain_target_position = new_position
        entity_view.visuals.rotation_degrees = new_rotation # Directly set rotation for now. Interpolation can be added later.
    # else:
        # push_warning(&quot;EntityViewManager: Received move event for non-existent visual for C# EntityID %s&quot; % id)
</code></pre>
<p>Now, add <code>EntityViewManager</code> to <code>Main.tscn</code> as a child of <code>Main</code>:</p>
<pre><code>Main (Node)
├── GameManager (GameManager.cs)
├── SceneLoader (SceneLoader.gd)
└── EntityViewManager (EntityViewManager.gd)
</code></pre>
<p>Finally, let's test this.</p>
<ol>
<li>Save all C# and GDScript files.</li>
<li>Run <code>Main.tscn</code>.</li>
</ol>
<p><strong>Expected Output:</strong></p>
<ul>
<li>The game will load <code>Gameplay.tscn</code>.</li>
<li>In the Output console, you'll see:<ul>
<li><code>EntityViewManager: Spawned visual for C# EntityID 0 (Type: 0)</code> (Player)</li>
<li><code>EntityViewManager: Spawned visual for C# EntityID 1 (Type: 1)</code> (NPC)</li>
<li><code>EntityViewManager: Despawned visual for C# EntityID 0</code> (Player)</li>
</ul>
</li>
<li>On the <code>Gameplay.tscn</code> scene, you should see one <code>EntityRoot</code> (the NPC) moving to the right and rotating. The player entity will briefly appear and then be removed.</li>
</ul>
<p>This confirms the <code>EntityViewManager</code> is correctly spawning and despawning <code>EntityView</code> instances based on C# events, and the <code>TransformSystem</code> is driving their movement.</p>
<h3 id="summary">Summary</h3>
<p>You have successfully standardized Godot Scene composition for entities, defining a canonical <code>EntityRoot</code> hierarchy and implementing <code>EntityView.gd</code> as the dedicated communication interface for the Body. By integrating <code>EntityViewManager.gd</code> to dynamically spawn, manage, and despawn these visual representations based on C# events, you've established a robust, reactive presentation layer that adheres strictly to TDD 16's specifications. This setup ensures a clean separation between simulation logic and visual feedback, paving the way for efficient development and high performance.</p>
<h3 id="next-steps">Next Steps</h3>
<p>In the next chapter, we will formalize our naming conventions across all project assets and scripts, ensuring consistency and readability, which are crucial for maintaining a large-scale project like Sigilborne.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.sections", "navigation.expand", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>