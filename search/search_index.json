{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Mastering Sigilborne: Building a Generational Ninja Life Simulator","text":"<p>This course guides you through the technical and design journey of creating \"Sigilborne,\" a unique ninja-life simulator where player characters are ephemeral, but the world and its history are persistent across generations. We will build a deeply simulated, procedurally generated magical world, focusing on systemic gameplay, emergent narratives, and a composition-first, production-grade architecture using Godot 4.5 and C#.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#module-1-core-architecture-the-brain-body-paradigm","title":"Module 1: Core Architecture - The Brain &amp; Body Paradigm","text":"<p>This module lays the foundational architectural principles, establishing the strict separation of simulation logic (C# Brain) from visual presentation (GDScript Body). You'll learn how to set up this hybrid environment for optimal performance and maintainability.</p> <ul> <li>Chapter 1.1: Project Setup for Godot 4.5 with C#<ul> <li>Initialize a new Godot 4.5 project with C# support.</li> <li>Configure the C# solution and build pipeline.</li> </ul> </li> <li>Chapter 1.2: The Brain (C#) - Headless Simulation Layer<ul> <li>Understand the role of C# for heavy simulation, data, and AI.</li> <li>Implement the <code>GameManager</code> as the C# entry point and system bootstrapper.</li> </ul> </li> <li>Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer<ul> <li>Understand the role of GDScript for rendering, UI, and animation.</li> <li>Implement <code>SceneLoader</code> for managing high-level game state transitions.</li> </ul> </li> <li>Chapter 1.4: Directory Structure - Enforcing Separation of Concerns<ul> <li>Establish the <code>_Brain/</code>, <code>_Body/</code>, and <code>_Shared/</code> directory structure.</li> <li>Detail naming conventions for C# and GDScript files and assets.</li> </ul> </li> <li>Chapter 1.5: Entity Model - Lightweight ECS-lite in C#<ul> <li>Define the <code>EntityID</code> struct for unique entity identification.</li> <li>Implement the <code>EntityManager</code> for entity creation, destruction, and validation.</li> </ul> </li> <li>Chapter 1.6: Component Architecture - Composition over Inheritance<ul> <li>Design <code>TransformComponent</code>, <code>TypeComponent</code>, and <code>StateComponent</code> as core data structs.</li> <li>Understand component storage patterns (SoA vs. Dictionary).</li> </ul> </li> <li>Chapter 1.7: Job System &amp; Concurrency - Multithreaded Processing<ul> <li>Implement the <code>JobManager</code> with worker thread pools and priority queues.</li> <li>Design <code>IJob</code> interface and <code>EcologyUpdateJob</code> example.</li> </ul> </li> <li>Chapter 1.8: Thread Safety - Command Buffers &amp; Double Buffering<ul> <li>Enforce the \"No-Node\" rule for jobs.</li> <li>Implement <code>CommandBuffer</code> for main thread synchronization.</li> <li>Understand double buffering for concurrent read/write operations.</li> </ul> </li> <li>Chapter 1.9: Scene Composition - Standardizing Godot Scenes<ul> <li>Define the <code>EntityRoot</code> hierarchy for all active entity scenes.</li> <li>Establish <code>EntityView.gd</code> as the sole script communicating with the Brain.</li> </ul> </li> <li>Chapter 1.10: Naming Conventions &amp; Scene Interfaces<ul> <li>Standardize naming for scenes, scripts, and nodes.</li> <li>Implement <code>setup(id: int)</code> function for scene initialization.</li> </ul> </li> <li>Chapter 1.11: Animation Event Protocol - Syncing Brain &amp; Body<ul> <li>Define the <code>anim_event(type: String, payload: Dictionary)</code> signal standard.</li> <li>Implement standard event types like \"hit_frame\" and \"cast_release\".</li> </ul> </li> <li>Chapter 1.12: Interop Layer - C# to GDScript Communication<ul> <li>Implement the EventBus using C# <code>Action&lt;T&gt;</code> delegates for Brain-to-Body signals.</li> <li>Detail thread-safe event batching and error handling.</li> </ul> </li> <li>Chapter 1.13: Global State Management - Data Ownership<ul> <li>Establish the Brain as the sole owner of authoritative game state.</li> <li>Detail how the Body only displays interpolated visual states.</li> </ul> </li> <li>Chapter 1.14: Debugging Tools - Console &amp; State Inspector<ul> <li>Implement a Quake-style debug console for runtime command execution.</li> <li>Develop a runtime state inspector for entity data visualization.</li> </ul> </li> <li>Chapter 1.15: Main Loop Execution Order - Tick vs. Frame<ul> <li>Detail the <code>_Process</code> (GDScript) and <code>_PhysicsProcess</code> (C#) execution flow.</li> <li>Explain the roles of Input Processing, Simulation Tick, and Visual Interpolation.</li> </ul> </li> </ul>"},{"location":"#module-2-player-input-core-movement","title":"Module 2: Player Input &amp; Core Movement","text":"<p>This module focuses on how player input is captured and translated into character actions, including standard movement, unique \"Shift-Sliding,\" and the hybrid physics system that ensures smooth, responsive control.</p> <ul> <li>Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)<ul> <li>Implement <code>InputManager.gd</code> to capture hardware events.</li> <li>Normalize input (e.g., WASD to <code>Vector2</code>).</li> </ul> </li> <li>Chapter 2.2: Input Frame - Snapshot for the Brain (C#)<ul> <li>Define the <code>PlayerInputFrame</code> struct for sending input snapshots to C#.</li> <li>Buffer input for processing in the Brain's tick.</li> </ul> </li> <li>Chapter 2.3: Standard Movement Logic - Velocity &amp; Friction (C#)<ul> <li>Implement basic <code>MoveVector</code> to <code>Velocity</code> calculations.</li> <li>Apply friction for snappy movement stops.</li> </ul> </li> <li>Chapter 2.4: Shift-Sliding Mechanic - Direction Lock (C#)<ul> <li>Implement the \"Shift-Sliding\" logic to maintain movement direction.</li> <li>Manage <code>LastMoveVector</code> for persistent directional input.</li> </ul> </li> <li>Chapter 2.5: Physics Layer - Hybrid Movement Pipeline<ul> <li>Understand the Brain's role in calculating <code>TargetVelocity</code> and <code>ProposedPosition</code>.</li> <li>Understand the Body's role in <code>move_and_slide()</code> for collision resolution.</li> </ul> </li> <li>Chapter 2.6: Physics Reconciliation - Syncing Brain &amp; Body Positions<ul> <li>Implement the reconciliation step where the Brain overwrites its position with the Body's <code>FinalPosition</code>.</li> <li>Explain why Godot handles collision resolution locally.</li> </ul> </li> <li>Chapter 2.7: Interactions &amp; Pushes - Knockback &amp; Entity-vs-Entity<ul> <li>Implement knockback by modifying the Brain's <code>Velocity</code>.</li> <li>Leverage <code>CharacterBody2D</code> for automatic soft collision pushes.</li> </ul> </li> <li>Chapter 2.8: Physics Layers - Standardizing Collision Interactions<ul> <li>Define physics layers for World, Player, Enemy, Projectile, Interaction, and Hitbox.</li> <li>Configure collision masks for proper interaction.</li> </ul> </li> </ul>"},{"location":"#module-3-the-glyph-system-language-of-ninjutsu","title":"Module 3: The Glyph System - Language of Ninjutsu","text":"<p>Dive deep into Sigilborne's unique glyph-based magic system. This module covers the procedural generation of glyph meanings, player discovery mechanics, and the underlying logic that makes every world's magic feel unique.</p> <ul> <li>Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)<ul> <li>Separate abstract <code>Concepts</code> (Fire, Water) from <code>Symbols</code> (Triangle, Circle).</li> <li>Store procedural mappings in <code>WorldData.GlyphMap</code>.</li> </ul> </li> <li>Chapter 3.2: Glyph Generation Logic - World Seed Mapping (C#)<ul> <li>Implement the world-seed-based shuffling and assignment of Symbols to Concepts.</li> <li>Ensure unique glyph meanings per playthrough.</li> </ul> </li> <li>Chapter 3.3: Glyph Discovery System - Player Knowledge State (C#)<ul> <li>Track player <code>KnowledgeState</code> for each glyph (Hidden, Seen, Known).</li> <li>Implement the feedback loop for revealing glyph meanings upon successful cast.</li> </ul> </li> <li>Chapter 3.4: Glyph Experimentation - Trial &amp; Error Casting (C#)<ul> <li>Process player input to attempt combos with unknown glyphs.</li> <li>Provide feedback for successful discovery or fizzle/stability damage.</li> </ul> </li> <li>Chapter 3.5: Subtypes &amp; Modifiers - Procedural Nuance for Glyphs (C#)<ul> <li>Implement procedural generation of <code>Subtypes</code> for each glyph variant.</li> <li>Assign float modifiers to define unique behaviors (e.g., Blue Flame vs. Red Flame).</li> </ul> </li> <li>Chapter 3.6: Glyph Acquisition - Teachers &amp; Scrolls (C#)<ul> <li>Design <code>Scroll</code> items to grant <code>Known</code> status for glyphs.</li> <li>Implement <code>Teacher</code> NPCs that demonstrate combos, enabling player learning.</li> </ul> </li> <li>Chapter 3.7: Glyph Stability &amp; Category Resonance (GDD B01)<ul> <li>Define per-glyph <code>Stability Rating</code> and its effects on casting.</li> <li>Implement <code>Category Resonance</code> logic for environmental interactions (e.g., Bloom in forests).</li> </ul> </li> <li>Chapter 3.8: World Mapping Logic - Glyph to Subtype Table (C#)<ul> <li>Generate the global <code>glyph -&gt; category -&gt; subtype</code> table per world.</li> <li>Implement environmental modulation of subtype behavior.</li> </ul> </li> <li>Chapter 3.9: Glyph Interaction Rules - High-Level Principles (GDD B01)<ul> <li>Implement glyph interactions based on category relationships, subtypes, and sequence order.</li> <li>Ensure world-specific variations via subtypes.</li> </ul> </li> <li>Chapter 3.10: Forbidden Glyphs &amp; Glyph Loss (GDD B01)<ul> <li>Define <code>Forbidden Glyphs</code> with inherent instability and danger.</li> <li>Implement mechanics for glyph loss or corruption due to residue, miscasts, or bloodline mutations.</li> </ul> </li> </ul>"},{"location":"#module-4-combos-casting-the-art-of-ninjutsu","title":"Module 4: Combos &amp; Casting - The Art of Ninjutsu","text":"<p>This module focuses on the dynamic combo system, where glyph sequences transform into powerful techniques. You'll build the input pipeline, spell resolution, and the mastery system that allows players to discover and evolve their unique ninjutsu.</p> <ul> <li>Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)<ul> <li>Implement a circular <code>InputBuffer</code> to store <code>InputFrame</code> structs with timestamps.</li> <li>Efficiently retrieve recent inputs for combo detection.</li> </ul> </li> <li>Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)<ul> <li>Implement a Prefix Tree (Trie) to efficiently detect glyph sequences.</li> <li>Optimize Trie storage for cache locality.</li> </ul> </li> <li>Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)<ul> <li>Define <code>SpellDefinition</code> as a data resource, including sequence, costs, and component data.</li> <li>Support <code>Mythic Evolution</code> through data mutation or swapping.</li> </ul> </li> <li>Chapter 4.4: Casting State Machine - Player Casting Flow (C#)<ul> <li>Implement a <code>CastState</code> enum (Idle, Channeling, Casting, Recovery).</li> <li>Manage state transitions and timers for spell execution.</li> </ul> </li> <li>Chapter 4.5: Visual Feedback - Particles &amp; Animations (GDScript)<ul> <li>Implement a <code>ParticleManager</code> and <code>AnimationController</code> to react to casting signals.</li> <li>Use <code>GPUParticles2D</code> pools for optimized visual effects.</li> </ul> </li> <li>Chapter 4.6: Hotbar Input &amp; Casting - Recursive Mastery Deck (GDD B05)<ul> <li>Implement the 10-slot hotbar system for glyphs and shortcuts.</li> <li>Design the \"Recursive Chaining\" macro system for complex combos.</li> </ul> </li> <li>Chapter 4.7: Combo Input Rhythm &amp; Dynamic Timing Windows (GDD B05)<ul> <li>Implement rhythmic input processing for glyph sequences.</li> <li>Dynamically adjust <code>Combo Timing Windows</code> based on player mastery.</li> </ul> </li> <li>Chapter 4.8: Combo Resolution Model - Outcomes &amp; Experimentation (GDD B05)<ul> <li>Implement the H1 Combo Resolution Model (Full, Partial, Experimental, Solo-Cast, Fizzle).</li> <li>Support player experimentation and accidental technique discovery.</li> </ul> </li> <li>Chapter 4.9: Interruptibility &amp; Mobility While Casting (GDD B05)<ul> <li>Implement dynamic interruptibility based on mastery and combo length.</li> <li>Enable fully mobile casting with mastery-dependent penalties.</li> </ul> </li> <li>Chapter 4.10: Combo System Overview &amp; Interpreter (GDD B02)<ul> <li>Implement the <code>Combo Interpreter</code> to evaluate sequences based on order, categories, subtypes, and external factors.</li> <li>Define outcomes like Full Technique, Partial, Fizzle, Miscast, Forbidden Surge.</li> </ul> </li> <li>Chapter 4.11: Combo Formation Rules &amp; Repetition (GDD B02)<ul> <li>Enforce rules that any sequence can be attempted, order matters, and repetition matters.</li> <li>Implement how categories define structure and subtypes define nuance.</li> </ul> </li> <li>Chapter 4.12: Combo Length Tiers &amp; Discovery Through Repetition (GDD B02)<ul> <li>Define <code>Combo Length Tiers</code> (Single-Glyph to 7+ Glyphs).</li> <li>Implement <code>Discovery Through Repetition</code> for natural combo improvement.</li> </ul> </li> <li>Chapter 4.13: Player-Invented Techniques &amp; The Combo Journal (GDD B02)<ul> <li>Allow players to name and record unique, discovered techniques.</li> <li>Implement the <code>Combo Journal</code> for tracking attempted sequences and annotations.</li> </ul> </li> <li>Chapter 4.14: Mastery Structure &amp; Glyph Mastery (GDD B04)<ul> <li>Implement <code>Internal</code> (continuous) and <code>External</code> (tiered) mastery.</li> <li>Track <code>Glyph Mastery</code> and its effects on strain, stability, and visuals.</li> </ul> </li> <li>Chapter 4.15: Combo Mastery &amp; Unlocking Shortcut Glyphs (GDD B04)<ul> <li>Implement <code>Combo Mastery</code> and its benefits (rhythm, flow, reliability).</li> <li>Design the system for unlocking <code>Shortcut Glyphs</code> through combined mastery and bloodline resonance.</li> </ul> </li> <li>Chapter 4.16: Shortcut Glyph Behavior &amp; Evolution Paths (GDD B04)<ul> <li>Define <code>Shortcut Glyph</code> properties (visuals, hotbar integration, benefits).</li> <li>Implement <code>Shortcut Evolution Paths</code> influenced by residue, bloodline, and world events.</li> </ul> </li> <li>Chapter 4.17: Legendary Techniques &amp; NPC Combo Literacy (GDD B02/B04)<ul> <li>Define conditions for <code>Legendary Techniques</code> (long sequence, high stability, bloodline).</li> <li>Implement <code>NPC Combo Literacy</code> with tiers and evolving knowledge.</li> </ul> </li> </ul>"},{"location":"#module-5-chakra-life-systems","title":"Module 5: Chakra &amp; Life Systems","text":"<p>Explore the intricate biological and environmental simulation that governs character well-being, chakra flow, and the dangerous accumulation of chaos residue.</p> <ul> <li>Chapter 5.1: Biological Simulation - The Bio-Tick (C#)<ul> <li>Implement a <code>BiologicalSim</code> with a slower <code>Bio-Tick</code> rate (e.g., 1Hz).</li> <li>Define <code>BioState</code> struct for core stats (Health, Stamina, Chakra, Hunger, Thirst, BodyTemp).</li> </ul> </li> <li>Chapter 5.2: Metabolism System - Dynamic Decay Rates (C#)<ul> <li>Implement <code>Hunger</code> and <code>Thirst</code> decay based on <code>ActivityLevel</code> and <code>WeatherMultiplier</code>.</li> <li>Integrate Chakra consumption with Hunger spikes.</li> </ul> </li> <li>Chapter 5.3: Weather System - Global Environmental State (C#)<ul> <li>Implement <code>WeatherSystem</code> as a global singleton with <code>WeatherType</code>, <code>WindDirection</code>, <code>Temperature</code>, <code>Humidity</code>.</li> <li>Define <code>Environmental Pressure</code> effects on <code>BioState</code> (e.g., Cold increases Hunger).</li> </ul> </li> <li>Chapter 5.4: Damage &amp; Recovery Pipeline - Wounds &amp; Status Effects (C#)<ul> <li>Implement the <code>Damage Pipeline</code> (Raw, Mitigation, Application, Wound Generation).</li> <li>Define <code>Recovery Logic</code> for healing and status effect management.</li> </ul> </li> <li>Chapter 5.5: Status Effect Data - Definition vs. Instance (C#)<ul> <li>Define <code>EffectDefinition</code> for static effect data (ID, Type, Stacks, Duration).</li> <li>Manage <code>ActiveEffect</code> instances on entities with <code>TimeRemaining</code> and <code>Stacks</code>.</li> </ul> </li> <li>Chapter 5.6: Status Effect Lifecycle - Application &amp; Tick Loop (C#)<ul> <li>Implement <code>ApplyEffect()</code> logic (refresh, stack).</li> <li>Design the <code>StatusEffectSystem</code> tick loop for DoT and StatMod effects.</li> </ul> </li> <li>Chapter 5.7: Void Sickness &amp; Bleed Mechanics (C#)<ul> <li>Implement <code>Void Sickness</code> (C04) with permanent effects and escalating consequences.</li> <li>Implement <code>Bleed</code> (B12) as a movement-based DoT.</li> </ul> </li> <li>Chapter 5.8: Chakra Strain System - Accumulation &amp; Consequences (GDD B03)<ul> <li>Implement <code>Per-Glyph Strain</code> and <code>Per-Technique Final Spike</code> accumulation.</li> <li>Define <code>High Strain Consequences</code> (Fatigue, Distortion, Unreliability, Burnout).</li> </ul> </li> <li>Chapter 5.9: Chakra Regeneration &amp; Pool Growth (GDD B03)<ul> <li>Implement <code>Strain Reset Mechanisms</code> (Natural, Meditation, Food/Rest, Sacred Locations).</li> <li>Design <code>Chakra Pool Growth</code> over lifespan (Age, Training, Bloodline).</li> </ul> </li> <li>Chapter 5.10: Chaos Residue System - Accumulation &amp; Distribution (GDD B03)<ul> <li>Implement <code>Residue Accumulation</code> from miscasts, forbidden sequences, etc.</li> <li>Distribute <code>Residue</code> to <code>Player Residue</code> and <code>World Residue</code> (by chunk).</li> </ul> </li> <li>Chapter 5.11: Effects of Residue on the World &amp; Player (GDD B03)<ul> <li>Implement <code>World Residue</code> effects (Biome Distortion, Anomaly Formation, Wildlife Corruption).</li> <li>Implement <code>Player Residue</code> effects (Miscast Chance, Subtype Mutations, Power Increases).</li> </ul> </li> <li>Chapter 5.12: Chakra Biology - Aging, Training &amp; Bloodline Influence (GDD B08)<ul> <li>Implement <code>Natural Aging Curve</code> for chakra capacity.</li> <li>Define <code>Training</code> as the primary growth driver and <code>Bloodline Influence</code> on quirks.</li> </ul> </li> <li>Chapter 5.13: Chakra Network Injuries &amp; Recovery (GDD B08/B12)<ul> <li>Implement <code>Chakra Network Injuries</code> (micro-tears, residue burns) and their effects.</li> <li>Design <code>Injury Repair</code> mechanisms (discipline, healing, rituals).</li> </ul> </li> <li>Chapter 5.14: Pain System &amp; Pain Suppression (GDD B12)<ul> <li>Implement <code>Pain</code> as a mechanical factor affecting movement, casting, and focus.</li> <li>Design <code>Pain Suppression</code> with its associated strain and instability costs.</li> </ul> </li> <li>Chapter 5.15: Medical Ninjutsu &amp; Bloodline Healing (GDD B12)<ul> <li>Implement <code>Medical Ninjutsu</code> as a skill-based discipline with chakra costs and miscast risks.</li> <li>Define <code>Bloodline Healing Influence</code> (regenerative, cursed lines).</li> </ul> </li> <li>Chapter 5.16: Survival &amp; Environmental Discipline - Fatigue, Sleep &amp; Weather (GDD B14)<ul> <li>Implement <code>Sleep &amp; Fatigue</code> as core survival mechanics (no hunger/thirst).</li> <li>Integrate <code>Weather Effects</code> on visibility, stealth, and chakra stability.</li> </ul> </li> <li>Chapter 5.17: Sickness, Poison &amp; Disease - Dynamic Threats (GDD B14)<ul> <li>Implement <code>Sickness, Poison &amp; Disease</code> mechanics (sources, effects, recovery).</li> <li>Integrate <code>Mental Fatigue</code> from trauma and chakra overuse.</li> </ul> </li> </ul>"},{"location":"#module-6-combat-tactical-engagement","title":"Module 6: Combat &amp; Tactical Engagement","text":"<p>Master the fast-paced, systemic combat of Sigilborne. This module covers physics-based detection, detailed damage calculation, stealth and sensing mechanics, and the strategic use of weapons and tools.</p> <ul> <li>Chapter 6.1: Physics Layer - Hitbox &amp; Hurtbox Detection (GDScript)<ul> <li>Implement <code>Area2D</code> nodes for <code>Hitbox</code> and <code>Hurtbox</code> detection.</li> <li>Define <code>BodyPart</code> and <code>DamageProfileID</code> for hit data.</li> </ul> </li> <li>Chapter 6.2: Detection Logic - HitEvent Pipeline (Brain &amp; Body)<ul> <li>Implement <code>area_entered</code> signal to send <code>HitEvent</code> to the Brain.</li> <li>Design <code>CombatSystem</code> to calculate damage and emit <code>OnDamageTaken</code> signals.</li> </ul> </li> <li>Chapter 6.3: Damage Calculator - Complex Math Layer (C#)<ul> <li>Implement <code>DamageResult</code> struct for final damage, crit, block, and type.</li> <li>Develop <code>Calculate()</code> function for base damage, mitigation, and multipliers.</li> </ul> </li> <li>Chapter 6.4: Combat Fundamentals - Pace, Lethality &amp; Reading Opponents (GDD B09)<ul> <li>Implement fast, high-pressure, reactive combat mechanics.</li> <li>Design <code>Lethality &amp; Danger Gradient</code> based on enemy type and context.</li> </ul> </li> <li>Chapter 6.5: Ninja Movement &amp; Chakra-Enhanced Mobility (GDD B09)<ul> <li>Implement <code>Movement</code> as a core skill with dodges, slides, and aerial control.</li> <li>Design <code>Chakra-Enhanced Mobility</code> (Surge dash, Veil slide) with mastery reduction.</li> </ul> </li> <li>Chapter 6.6: Interruptibility &amp; Casting Mobility (GDD B09)<ul> <li>Implement universal <code>Interruptibility</code> for non-instant techniques.</li> <li>Design <code>Casting Mobility</code> allowing movement while weaving signs, with mastery reducing penalties.</li> </ul> </li> <li>Chapter 6.7: Taijutsu Integration &amp; Priority Rules (GDD B09)<ul> <li>Implement <code>Taijutsu</code> as a non-chakra-based martial art.</li> <li>Design <code>Chakra-Enhanced Taijutsu</code> variants and <code>Casting vs. Taijutsu Priority Rules</code>.</li> </ul> </li> <li>Chapter 6.8: Combat Symmetry &amp; Enemy Intelligence (GDD B09)<ul> <li>Implement <code>Enemy Intelligence Spectrum</code> from low-tier to legendary.</li> <li>Ensure <code>Combat Symmetry</code> where enemies follow player rules (signs, strain, miscast).</li> </ul> </li> <li>Chapter 6.9: Stealth Progression &amp; Types (GDD B10)<ul> <li>Implement <code>Stealth Progression Curve</code> (weak early, powerful late).</li> <li>Design <code>Physical Stealth</code>, <code>Chakra Stealth</code>, and <code>Corrupted Stealth</code> modes.</li> </ul> </li> <li>Chapter 6.10: Detection Systems &amp; Enemy Learning (GDD B10)<ul> <li>Implement <code>Detection Types</code> (Sight, Sound, Chakra Sensing, Resonance, Bloodline).</li> <li>Design <code>Enemy Learning Behavior</code> for intelligent adaptation and coordination.</li> </ul> </li> <li>Chapter 6.11: Glyph-Based Stealth Techniques (GDD B10)<ul> <li>Implement <code>Veil</code>, <code>Echo</code>, <code>Flux</code>, <code>Bloom</code>, and <code>Consume</code> techniques for stealth.</li> <li>Integrate <code>Chakra Usage</code> and <code>Residue Interaction</code> with stealth.</li> </ul> </li> <li>Chapter 6.12: Stealth Failure &amp; Environmental Influence (GDD B10)<ul> <li>Implement a <code>Multi-State Detection Model</code> for stealth failure.</li> <li>Design <code>Environmental Influence</code> on stealth (buffs/penalties from terrain, weather, resonance).</li> </ul> </li> <li>Chapter 6.13: Chakra Sensing Fundamentals &amp; Trainable Skill (GDD B11)<ul> <li>Implement <code>Chakra Sensing</code> as a trainable skill with tiers.</li> <li>Define <code>Who Can Sense Chakra</code> and how sensing ability improves.</li> </ul> </li> <li>Chapter 6.14: Sensing Range, Clarity &amp; Combat Intuition (GDD B11)<ul> <li>Implement <code>Sensing Range Tiers</code> and <code>What Can Be Sensed</code> (Chakra Quantity, Residue, Bloodline Signatures).</li> <li>Design <code>Combat Intuition</code> to provide subtle anticipatory feedback.</li> </ul> </li> <li>Chapter 6.15: Specialized Sensing Schools &amp; Residue Interaction (GDD B11)<ul> <li>Implement <code>Echo Sensing</code>, <code>Veil Sensing</code>, <code>Flux Sensing</code>, <code>Consume Sensing</code>, <code>Bloom Sensing</code>.</li> <li>Integrate <code>Residue Corruption</code> effects on sensing.</li> </ul> </li> <li>Chapter 6.16: Weapon Philosophy &amp; Mastery (GDD B13)<ul> <li>Define <code>Weapon Philosophy</code> as supplemental, not central to power.</li> <li>Implement <code>Weapon Mastery</code> for movement style, rhythm, and chakra infusion.</li> </ul> </li> <li>Chapter 6.17: Chakra Interaction with Weapons &amp; Types (GDD B13)<ul> <li>Implement <code>Chakra Infusion System</code> for weapon enhancement (Bloom, Veil, Echo, Surge).</li> <li>Categorize <code>Weapon Types</code> (Traditional, Clan, Chakra-Forged, Residue-Corrupted).</li> </ul> </li> <li>Chapter 6.18: Ninja Tools &amp; The Tool Belt (GDD B13)<ul> <li>Implement <code>Ninja Tools</code> (smoke bombs, tags, traps, sensors).</li> <li>Design the <code>Tool Belt</code> with dedicated slots separate from glyphs.</li> </ul> </li> </ul>"},{"location":"#module-7-the-living-world-ecology-ai","title":"Module 7: The Living World - Ecology &amp; AI","text":"<p>Build the dynamic, simulated ecosystem where NPCs, animals, and spirits coexist and evolve. This module covers perception, decision-making, and the background simulation that makes the world feel alive even when the player isn't directly observing it.</p> <ul> <li>Chapter 7.1: Perception System - Spatial Hashing (C#)<ul> <li>Implement a <code>Spatial Hash Grid</code> for efficient entity detection.</li> <li>Optimize queries for entities within range.</li> </ul> </li> <li>Chapter 7.2: The Senses - Vision, Hearing &amp; Chakra Sense (C#)<ul> <li>Implement <code>PerceptionComponent</code> with <code>Vision</code> (cone check), <code>Hearing</code> (circle check).</li> <li>Design <code>Chakra Sense</code> (B11) for detecting active spells through walls.</li> </ul> </li> <li>Chapter 7.3: Stealth Mechanics - Visibility &amp; Detection Meter (C#)<ul> <li>Implement <code>Visibility</code> as a float value (light, movement, camouflage).</li> <li>Design <code>Detection Meter</code> to trigger NPC alert states.</li> </ul> </li> <li>Chapter 7.4: Decision Making - Utility AI (C#)<ul> <li>Implement <code>Utility AI</code> (Scoring) for NPC action selection.</li> <li>Design <code>Scorer</code> functions for actions like EatFood, AttackEnemy, Sleep.</li> </ul> </li> <li>Chapter 7.5: The Scheduler - Daily Routines &amp; Overrides (C#)<ul> <li>Implement <code>Daily Routines</code> for NPCs (Work, Socialize, Sleep).</li> <li>Design <code>Override</code> logic for threats or major events.</li> </ul> </li> <li>Chapter 7.6: Ecology Simulation - Virtual Agents (C#)<ul> <li>Implement <code>Virtual Agents</code> for entities in unloaded chunks.</li> <li>Design <code>Background Simulation</code> for updating virtual agents at a slow tick rate.</li> </ul> </li> <li>Chapter 7.7: Spawning &amp; Despawning - Hydration/Dehydration (Brain &amp; Body)<ul> <li>Implement <code>Hydration</code> (Virtual to Active) when player approaches chunks.</li> <li>Design <code>Dehydration</code> (Active to Virtual) when player leaves chunks.</li> </ul> </li> <li>Chapter 7.8: Natural Animals &amp; Ecosystem Interaction (GDD B15)<ul> <li>Implement <code>Full Wildlife Ecosystems</code> with realistic behavior.</li> <li>Design <code>Animal Interaction</code> with stealth and combat (flee, warn, attack).</li> </ul> </li> <li>Chapter 7.9: Spirit Creatures - Taxonomy &amp; Visibility Tiers (GDD B15)<ul> <li>Implement <code>Spirit Creatures</code> as a layered ecosystem (Forest, Shadow, Echo, Guardians).</li> <li>Design <code>Spirit Visibility Tiers</code> (resonance zones, trained sensors, rituals).</li> </ul> </li> <li>Chapter 7.10: Spirit Intelligence &amp; Resonance Interaction (GDD B15)<ul> <li>Implement <code>Spirit Intelligence</code> (negotiate, form pacts, teach, threaten).</li> <li>Design <code>Resonance Interaction</code> for spirits based on their nature.</li> </ul> </li> <li>Chapter 7.11: Corrupted &amp; Mythical Creatures (GDD B15)<ul> <li>Implement <code>Corrupted Creatures</code> (mutated animals/spirits) from residue.</li> <li>Design <code>Mythical Creatures</code> (titanic guardians, sky serpents) as rare, late-game entities.</li> </ul> </li> <li>Chapter 7.12: Procedural Species Variability &amp; Territory Behavior (GDD B15)<ul> <li>Implement <code>Procedural Species</code> generation for unique fauna per world.</li> <li>Design <code>Territory Behavior</code> for creatures (dens, nests, patrol routes).</li> </ul> </li> <li>Chapter 7.13: NPC Identity Architecture - Personality &amp; Social Bonds (GDD B18)<ul> <li>Define <code>Core Personality</code> (courage, curiosity, discipline) for NPCs.</li> <li>Implement <code>Social Bonds</code> (friends, rivals, mentors) affecting behavior.</li> </ul> </li> <li>Chapter 7.14: NPC Profession Roles &amp; Clan Alignment (GDD B18)<ul> <li>Define <code>Profession Roles</code> (farmer, guard, monk) for daily life.</li> <li>Implement <code>Clan Alignment</code> (loyal, clanless, defect) affecting literacy and training.</li> </ul> </li> <li>Chapter 7.15: Autonomy &amp; Decision-Making - Personality &amp; Social Drivers (GDD B18)<ul> <li>Implement <code>NPC Decision-Making</code> driven by personality weighting and social bonds.</li> <li>Design <code>Anomaly Influence</code> and <code>Faction Politics</code> on NPC choices.</li> </ul> </li> <li>Chapter 7.16: Emergent NPC Learning - Observation &amp; Social Transmission (GDD B18)<ul> <li>Implement <code>Observation Learning</code> (watching player/NPC casts, anomalies).</li> <li>Design <code>Social Transmission</code> (rumors, training tips) for knowledge spread.</li> </ul> </li> <li>Chapter 7.17: NPC Reaction Model - Instant, Gradual &amp; Slow (GDD B18)<ul> <li>Implement <code>NPC Reactions</code> at three speeds: instant (danger), gradual (politics), slow (culture).</li> <li>Ensure NPCs adapt schedules dynamically.</li> </ul> </li> <li>Chapter 7.18: NPC Mastery Speed &amp; Glyph Progression (GDD B19)<ul> <li>Implement <code>NPC Mastery Speed</code> with personality, clan, and environmental modifiers.</li> <li>Define <code>Five Stages of NPC Glyph Mastery</code> (Unstable to Shortcut).</li> </ul> </li> <li>Chapter 7.19: NPC Glyph Learning - Clan Training &amp; Anomaly-Based (GDD B19)<ul> <li>Implement <code>Observation Learning</code>, <code>Social Transmission</code>, <code>Clan Training Programs</code>.</li> <li>Design <code>Anomaly-Based Learning</code> and <code>Trauma-Based Learning</code>.</li> </ul> </li> <li>Chapter 7.20: NPC Combo Development &amp; Mutation-Driven Growth (GDD B19)<ul> <li>Implement <code>NPC Combo Development</code> from clan standards to personal experiments.</li> <li>Design <code>Mutation-Driven Skill Growth</code> from residue and forbidden events.</li> </ul> </li> </ul>"},{"location":"#module-8-society-politics-economy","title":"Module 8: Society, Politics &amp; Economy","text":"<p>Construct the complex social and economic fabric of Sigilborne. This module covers faction dynamics, settlement structures, a knowledge-centric economy, and how crime and justice operate in a morally ambiguous world.</p> <ul> <li>Chapter 8.1: Faction System - The Relationship Graph (C#)<ul> <li>Implement <code>FactionRelation</code> struct for tracking inter-faction relationships.</li> <li>Design <code>Faction AI</code> with goals and actions (DeclareWar, SendCaravan).</li> </ul> </li> <li>Chapter 8.2: The Simulation Clock - Game Time &amp; Load Balancing (C#)<ul> <li>Implement a \"Game Time\" system with a slower tick rate (e.g., 1 min = 1 real sec).</li> <li>Stagger heavy system updates across the daily cycle (<code>FactionAI</code>, <code>MarketSim</code>).</li> </ul> </li> <li>Chapter 8.3: Market Simulation - Supply &amp; Demand (C#)<ul> <li>Implement <code>MarketSim</code> where prices are local and dynamic.</li> <li>Design <code>Price</code> calculation based on <code>Demand / Supply</code> and event modifiers (War, Famine).</li> </ul> </li> <li>Chapter 8.4: Trade Routes - Caravans as Arteries (C#)<ul> <li>Implement <code>CaravanSystem</code> for NPC caravans moving between settlements.</li> <li>Design <code>Trade Interruption</code> logic (player/bandit destruction affecting prices).</li> </ul> </li> <li>Chapter 8.5: Crime &amp; Justice - The Heat System (C#)<ul> <li>Implement <code>Heat System</code> to track crime per faction.</li> <li>Design <code>Witness</code> mechanics for crime recording.</li> </ul> </li> <li>Chapter 8.6: Bounty &amp; Punishment - Escalation &amp; Consequences (C#)<ul> <li>Implement <code>Bounty</code> system with escalating hunter squad responses.</li> <li>Define <code>Consequences</code> for crimes (refusal to talk, attack on sight).</li> </ul> </li> <li>Chapter 8.7: Settlement Formation Logic - Templates &amp; Inputs (GDD B16)<ul> <li>Implement procedural <code>Settlement Formation</code> based on biome, faction ancestry, anomalies.</li> <li>Design <code>Settlement Templates</code> (Village, Clan District, Monastic, Trade Hub).</li> </ul> </li> <li>Chapter 8.8: District System - Modular Subdivisions (GDD B16)<ul> <li>Implement <code>District Types</code> (Common, Clan, Monastic, Marketplace, Spirit, Corrupted).</li> <li>Assign unique rules, hierarchies, and literacy patterns per district.</li> </ul> </li> <li>Chapter 8.9: NPC Population Model - Individuated Agents (GDD B16)<ul> <li>Implement NPCs as individual agents with literacy, relationships, political alignment.</li> <li>Ensure <code>Dynamic Village Story</code> through NPC actions and memories.</li> </ul> </li> <li>Chapter 8.10: Internal Social Structure - Multi-Hierarchy Stack (GDD B16)<ul> <li>Implement <code>Civic</code>, <code>Clan</code>, <code>Monastic</code>, <code>Spirit</code>, and <code>Corruption</code> hierarchies.</li> <li>Design interactions where hierarchies can support, compete, or undermine each other.</li> </ul> </li> <li>Chapter 8.11: Faction Presence in Settlements - Dynamic Tension (GDD B16)<ul> <li>Implement <code>Multiple Factions</code> competing over knowledge, anomaly management, and succession within settlements.</li> <li>Ensure <code>Constant Dynamic Tension</code> through their interactions.</li> </ul> </li> <li>Chapter 8.12: Economic System - Knowledge-Centric Economy (GDD B16/B23)<ul> <li>Implement an economy built around <code>Magical Scarcity</code> and <code>Knowledge Exchange</code>.</li> <li>Define <code>Cores of the Economy</code> (Scroll fragments, Glyph diagrams, Anomaly reagents).</li> </ul> </li> <li>Chapter 8.13: Settlement Borders &amp; Influence Zones (GDD B16)<ul> <li>Implement <code>Settlement Influence Zones</code> with patrols, wards, and resonance markers.</li> <li>Design <code>Magical Gradients</code> for borders that affect glyph behavior.</li> </ul> </li> <li>Chapter 8.14: Dynamic Settlement Events &amp; Multigenerational Evolution (GDD B16)<ul> <li>Implement <code>Procedural Story Engine</code> for settlement events (corruption outbreak, ward collapse).</li> <li>Design <code>Multigenerational Evolution</code> for knowledge drift, leadership cycles, and legacy interactions.</li> </ul> </li> <li>Chapter 8.15: Clans, Factions &amp; Political Actors (GDD B17)<ul> <li>Define <code>Clans</code> as micro-factions, <code>Major Factions</code> as macro powers, and <code>Supra-Faction Forces</code>.</li> <li>Implement <code>Faction AI</code> for strategic moves, alliances, and conflicts.</li> </ul> </li> <li>Chapter 8.16: Clan Architecture - Ideology &amp; Leadership (GDD B17)<ul> <li>Implement <code>Clan Identity</code> across <code>Category Ideology</code> (Bloom+Bind) and <code>Leadership Structure</code>.</li> <li>Design dynamic leadership changes via trials, corruption, or anomaly events.</li> </ul> </li> <li>Chapter 8.17: Clan Lifecycle - Formation, Growth, Merging &amp; Dissolution (GDD B17)<ul> <li>Implement <code>Clan Formation</code> (schism, charismatic founder, player influence).</li> <li>Design <code>Clan Growth</code>, <code>Merging</code>, and <code>Dissolution</code> mechanics.</li> </ul> </li> <li>Chapter 8.18: Diplomacy &amp; Relationships - Cross-Faction Web (GDD B17)<ul> <li>Implement <code>Diplomatic State</code> (Ally, Neutral, Hostile) with internal numeric meters.</li> <li>Design <code>Diplomacy Drivers</code> (ideological conflict, territory disputes, player involvement).</li> </ul> </li> <li>Chapter 8.19: Political Heat &amp; Volatility (GDD B17)<ul> <li>Implement <code>Political Heat</code> system from corruption, forbidden arts, NPC deaths.</li> <li>Design <code>Heat Triggers</code> for diplomatic shifts, clan splits, and revolts.</li> </ul> </li> <li>Chapter 8.20: Economy Core Principles &amp; Currency (GDD B23)<ul> <li>Implement a <code>Local, Systemic Economy</code> where knowledge, materials, and relationships outweigh gold.</li> <li>Define <code>Gold Usage</code> (bribery, travel) vs. non-gold transactions (glyphs, rituals).</li> </ul> </li> <li>Chapter 8.21: Categories of Goods - Basic to Illicit (GDD B23)<ul> <li>Categorize <code>Goods</code> into Basic, Crafting, Magical Reagents, Anomaly-Derived, Corrupted, Spiritual, Illicit.</li> <li>Implement their usage and value within the economy.</li> </ul> </li> <li>Chapter 8.22: Trade Systems - Ideological Markets &amp; Caravans (GDD B23)<ul> <li>Implement <code>Settlement Economies</code> as ideological, with preferred/banned goods.</li> <li>Design <code>Caravans</code> as arteries with dynamic routes, risks, and consequences.</li> </ul> </li> <li>Chapter 8.23: Black Markets &amp; Goods Flow Simulation (GDD B23)<ul> <li>Implement <code>Black Markets</code> for outlaw networks (corruption, assassins-for-hire).</li> <li>Design <code>Goods Flow Simulation</code> for resource movement, shortages, and NPC reactions.</li> </ul> </li> <li>Chapter 8.24: Player Housing Types &amp; Availability (GDD B24)<ul> <li>Implement <code>Dynamic Housing</code> (Purchasable, Clan-Granted, Outlaw, Spirit, Claimed).</li> <li>Design <code>Realistic Availability</code> based on population, disasters, and politics.</li> </ul> </li> <li>Chapter 8.25: Housing Functions &amp; Upgrades (GDD B24)<ul> <li>Implement <code>Functional Perks</code> (meditation, training, crafting, rituals, storage).</li> <li>Design <code>Medium-Depth Upgrades</code> (Meditation Alcove, Ritual Circle, Corruption Chamber).</li> </ul> </li> </ul>"},{"location":"#module-9-advanced-world-mechanics-player-impact","title":"Module 9: Advanced World Mechanics &amp; Player Impact","text":"<p>This module delves into the complex systems of seals, rituals, contracts, and how player actions drive emergent missions, crime, and justice in the world.</p> <ul> <li>Chapter 9.1: Ritual System - Pattern Matching &amp; Execution (C#)<ul> <li>Implement <code>RitualManager</code> to detect spatial arrangement of items for rituals.</li> <li>Design <code>Execution</code> logic for consuming components and triggering effects.</li> </ul> </li> <li>Chapter 9.2: Seals &amp; Locks - Logical Locks (C#)<ul> <li>Implement <code>Seal</code> as a logical lock component on objects (Physical, Magical, Blood, Time).</li> <li>Design <code>Global Seals</code> that affect the entire world state.</li> </ul> </li> <li>Chapter 9.3: Ritual System - Simple, Advanced &amp; Forbidden (GDD B27)<ul> <li>Implement <code>Simple/Medium Rituals</code> (healing, cleansing, ward maintenance).</li> <li>Design <code>Advanced Rituals</code> (anomaly stabilization, spirit summoning) with complex requirements.</li> <li>Implement <code>Forbidden Rituals</code> (resurrection, corruption ascension) with irreversible consequences.</li> </ul> </li> <li>Chapter 9.4: Forbidden Contracts &amp; Spirit Contracts (GDD B27)<ul> <li>Implement <code>Forbidden Contracts</code> as pacts with powerful forces (spirits, corruption, anomalies).</li> <li>Design <code>Spirit Contracts</code> (C3) with deep relational bonds and high risk.</li> </ul> </li> <li>Chapter 9.5: Corruption Pacts &amp; Multi-Life Persistence of Rituals (GDD B27)<ul> <li>Implement <code>Corruption Pacts</code> (C4) for mutation growth and corrupted abilities.</li> <li>Ensure <code>Multi-Life Persistence</code> for seals, rituals, and contracts across generations.</li> </ul> </li> <li>Chapter 9.6: Mission Categories - Morally Ambiguous Tasks (GDD B20)<ul> <li>Implement <code>Mission Categories</code> (Settlement, Clan, NPC, Anomaly, Corruption, Political, Forbidden).</li> <li>Ensure tasks emerge from <code>Systemic World State</code> and are morally ambiguous.</li> </ul> </li> <li>Chapter 9.7: Mission Delivery Methods &amp; Tracking (GDD B20)<ul> <li>Implement <code>Diegetic Delivery</code> via NPC dialogue, overheard conversations, environmental clues.</li> <li>Design <code>Mission Tracking</code> solely through a <code>Diegetic Journal</code> (no UI markers).</li> </ul> </li> <li>Chapter 9.8: Mission Rewards &amp; Group Missions (GDD B20)<ul> <li>Implement <code>Rewards</code> (Gold, Materials, Knowledge, Access, Political Favor, Reputation Echo).</li> <li>Design <code>Group Missions</code> where NPCs join based on trust, clan orders, or crisis.</li> </ul> </li> <li>Chapter 9.9: Crime &amp; Justice Legal Architecture (GDD B21)<ul> <li>Implement <code>Regional Faction Codes</code> and <code>Clan-Level Variation</code> for laws.</li> <li>Define <code>Crime Categories</code> (Martial, Political, Magical, Economic, Spiritual, Corruption).</li> </ul> </li> <li>Chapter 9.10: Detection, Suspicion &amp; Witnesses (GDD B21)<ul> <li>Implement <code>Crime Detection</code> based on witnesses, evidence, rumors, and magical traces.</li> <li>Design <code>NPC Personality</code> and ideology to affect reporting behavior.</li> </ul> </li> <li>Chapter 9.11: Bounty System &amp; Prison Simulation (GDD B21)<ul> <li>Implement a <code>Dynamic Multi-Faction Bounty Network</code> (kill, capture, humiliate).</li> <li>Design a <code>Full Prison World-Simulation</code> with prison factions, dynamics, and gameplay loops.</li> </ul> </li> <li>Chapter 9.12: Outlaw Path &amp; Intergenerational Crime Memory (GDD B21)<ul> <li>Implement <code>Fully Viable Outlaw Gameplay Loop</code> (black markets, rogue clans, assassination).</li> <li>Ensure <code>Intergenerational Crime Memory</code> where past crimes shape future NPC reactions.</li> </ul> </li> </ul>"},{"location":"#module-10-the-mythic-meta-game-legacy-collapse-multiverse","title":"Module 10: The Mythic &amp; Meta Game - Legacy, Collapse &amp; Multiverse","text":"<p>This final module integrates all systems into the grand vision of Sigilborne. You'll explore how player actions lead to world-shaping events, mythic transformations, and the generational persistence that defines the game's unique meta-narrative.</p> <ul> <li>Chapter 10.1: World Generation &amp; Streaming - Chunk Architecture (C#)<ul> <li>Implement <code>Chunk Architecture</code> (64x64 tiles) with <code>Active Radius</code> loading.</li> <li>Design <code>Threaded Loading</code> for efficient chunk generation and mesh application.</li> </ul> </li> <li>Chapter 10.2: World Persistence - The \"Diff\" Strategy (C#)<ul> <li>Implement <code>Delta Compression</code> for saving only chunk modifications.</li> <li>Design <code>Serialization Format</code> (binary Protobuf) and <code>Save Versioning</code>.</li> </ul> </li> <li>Chapter 10.3: Virtual Agent Sync - Handover &amp; Restoration (C#)<ul> <li>Implement <code>Handover</code> (Active to Virtual) and <code>Restoration</code> (Virtual to Active) for NPCs.</li> <li>Ensure persistence of NPC stats across loaded/unloaded states.</li> </ul> </li> <li>Chapter 10.4: World Instability Index (WII) &amp; Collapse Seeds (GDD B29)<ul> <li>Implement <code>WorldStability</code> metric (Doom Clock) influenced by corruption, anomalies, clan wars.</li> <li>Design <code>Collapse Seeds</code> (Corruption, Anomaly, Spirit, Political) as early threats.</li> </ul> </li> <li>Chapter 10.5: Regional Threats &amp; Global Collapse States (GDD B29)<ul> <li>Implement <code>Regional Threats</code> (Corruption Bloom, Anomaly Storm, Spirit Awakening).</li> <li>Design <code>Global Collapse States</code> (Corruption Surge, Anomaly Cascade, Spirit Cataclysm) triggered by converging crises.</li> </ul> </li> <li>Chapter 10.6: Player Influence &amp; Recovery Logic for Collapse (GDD B29)<ul> <li>Implement <code>Player Influence</code> to prevent, delay, redirect, or accelerate collapse.</li> <li>Design <code>Manual, Slow, Multi-Generation Recovery</code> requiring deliberate effort.</li> </ul> </li> <li>Chapter 10.7: Mythic Evolution Philosophy &amp; The Evolution Engine (GDD C01)<ul> <li>Define <code>Mythic Evolution</code> as emergent metamorphosis, not content to chase.</li> <li>Implement the <code>Evolution Engine</code> combining chakra signature, world resonance, and instability.</li> </ul> </li> <li>Chapter 10.8: Three Stages of Mythic Evolution - Distortion to Emergence (GDD C01)<ul> <li>Implement <code>Resonant Distortion</code>, <code>Metaphysical Fracture</code>, and <code>Mythic Emergence</code>.</li> <li>Design <code>Catastrophic Instability</code> and <code>World Reaction</code> during evolution.</li> </ul> </li> <li>Chapter 10.9: High-Tier Techniques &amp; Emergent Evolution (GDD C02)<ul> <li>Implement <code>10+ Sign Combo Complexity</code> for reality-adjacent power.</li> <li>Design <code>Technique Evolution</code> based on internal/external factors and world state.</li> </ul> </li> <li>Chapter 10.10: Spirit Contracts &amp; Ancestral Pacts - Tiered Relationships (GDD C03)<ul> <li>Implement <code>Spirit Taxonomy</code> (Lesser, Domain, Greater, Forbidden Echo Entities).</li> <li>Design <code>Contract Arcs</code> with environmental alignment, ritual components, and dream/spirit trials.</li> </ul> </li> <li>Chapter 10.11: Forbidden Arts &amp; Aberration Metamorphosis (GDD C04)<ul> <li>Define <code>Corrupted Chakra</code> as a volatile overclocking phenomenon.</li> <li>Implement <code>Aberration Forms</code> as dangerous, ninja-shaped metamorphosis.</li> </ul> </li> <li>Chapter 10.12: Residue Overgrowth &amp; Forbidden Glyph Sequences (GDD C04)<ul> <li>Implement <code>Residue Overgrowth</code> as a world-affecting spread.</li> <li>Design <code>Forbidden Glyph Sequences</code> as unstable, painful, chaotic combos.</li> </ul> </li> <li>Chapter 10.13: World Bosses, Titans &amp; Primordial Entities (GDD C05)<ul> <li>Define <code>Titans</code> as hybrid spirit-anomaly-corruption entities.</li> <li>Implement <code>Behavioral Identity</code> (ecological/political actors) and <code>Procedural Mutation</code>.</li> </ul> </li> <li>Chapter 10.14: Titan Domains &amp; Reincarnation (GDD C05)<ul> <li>Implement <code>Titan Domains</code> as living regions reshaping terrain and ecology.</li> <li>Design <code>Titan Reincarnation</code> (mutated return) for persistent challenges.</li> </ul> </li> <li>Chapter 10.15: Climax &amp; Catastrophe - Collapse Triggers &amp; Recovery (GDD C06)<ul> <li>Implement <code>Collapse Types</code> (Corruption Cascade, Anomaly Surge, Spirit Uprising).</li> <li>Design <code>Political Response</code> and <code>Player Influence</code> during collapse.</li> </ul> </li> <li>Chapter 10.16: Meta-System: Reincarnation &amp; Legacy - World Memory (GDD B30/C07)<ul> <li>Implement <code>Total World Persistence</code> (no mechanical inheritance for new characters).</li> <li>Design <code>Social, Mythic, and Corruption Memory</code> for past lives.</li> </ul> </li> <li>Chapter 10.17: Legacy Influence &amp; Past-Life Echoes (GDD B30/C07)<ul> <li>Implement <code>Legacy Influence</code> across NPC dialogue, political shifts, spiritual reactions.</li> <li>Design <code>Past-Life Echoes</code> as common dream illusions and rare manifestations.</li> </ul> </li> <li>Chapter 10.18: Endless Mode &amp; The Multiverse (GDD C08)<ul> <li>Implement <code>Hybrid Infinite Worlds</code> (unlimited seeds, parallel existing worlds, independent timelines).</li> <li>Design <code>Cross-World Influence</code> (Echo bleedthrough) and <code>Player Identity Across Worlds</code> (Echo awareness).</li> </ul> </li> <li>Chapter 10.19: The Echo Layer &amp; Cosmology - Foundation of All Worlds (GDD C09)<ul> <li>Define the <code>Echo Layer</code> as the metaphysical substrate for all reality.</li> <li>Explain its role in the <code>Origin of Chakra, Spirits, Corruption, Anomalies, Titans, Glyphs, Collapse, and Infinite Worlds</code>.</li> </ul> </li> <li>Chapter 10.20: Meaning of Sigilborne &amp; Final Canon (GDD C09)<ul> <li>Define a <code>Sigilborne</code> as one attuned to Echo resonance.</li> <li>Establish <code>No Single Canon</code> but an infinite multiverse of player-created stories.</li> </ul> </li> <li>Chapter 10.21: System Integration &amp; World Simulation (GDD B31)<ul> <li>Implement <code>Staggered Global Tick Architecture</code> with cross-system influence.</li> <li>Design <code>Multi-Layer Simulation</code> (Political, Magical, Ecological, Corruption, Anomaly) with player agency.</li> </ul> </li> </ul> <p>[[BLUEPRINT_GENERATED]]</p>"},{"location":"01-chapter-1/","title":"Chapter 1.1: Project Setup for Godot 4.5 with C#","text":""},{"location":"01-chapter-1/#chapter-11-project-setup-for-godot-45-with-c","title":"Chapter 1.1: Project Setup for Godot 4.5 with C","text":"<p>Welcome to the first chapter of building Sigilborne! This foundational step is crucial for establishing a robust development environment. We'll set up a new Godot 4.5 project with C# support, laying the groundwork for our hybrid \"Brain &amp; Body\" architecture. A correct initial setup ensures smooth compilation, efficient workflow, and adherence to the architectural principles outlined in our Technical Design Document (TDD).</p>"},{"location":"01-chapter-1/#1-downloading-and-installing-godot-45","title":"1. Downloading and Installing Godot 4.5","text":"<p>First, ensure you have the correct version of the Godot Engine.</p> <ol> <li>Navigate to the official Godot Engine website.</li> <li>Download the .NET version of Godot 4.5 for your operating system. This is crucial as it includes the necessary .NET runtime and C# tooling.</li> <li>Extract the downloaded archive to a convenient location on your machine. This executable is all you need to run Godot.</li> </ol>"},{"location":"01-chapter-1/#2-creating-a-new-godot-project-with-c-support","title":"2. Creating a New Godot Project with C# Support","text":"<p>Now, let's create our project.</p> <ol> <li>Launch the Godot Engine executable.</li> <li>In the Project Manager, click the \"New Project\" button.</li> <li>Project Name: Enter <code>Sigilborne</code>.</li> <li>Project Path: Choose a suitable directory where you want your project files to reside. Godot will create a <code>Sigilborne</code> folder within this path.</li> <li>Renderer: For a 2D game like Sigilborne, <code>Compatibility</code> is often sufficient and offers broader hardware support. <code>Forward+</code> is also an option if you plan for more advanced 2D lighting effects, but it's not strictly necessary for our core mechanics. Choose <code>Compatibility</code> for now to keep things lean.</li> <li>Language: This is the most critical step for our hybrid architecture. Select \"C#\" from the dropdown menu.</li> <li>Click \"Create &amp; Edit\".</li> </ol> <p>Godot will now create the project, including the necessary C# solution (<code>.sln</code>) and project (<code>.csproj</code>) files at the root of your <code>res://</code> directory.</p>"},{"location":"01-chapter-1/#3-confirming-initial-project-structure","title":"3. Confirming Initial Project Structure","text":"<p>After creation, your project directory (visible in Godot's FileSystem dock) should look something like this:</p> <pre><code>res://\n\u251c\u2500\u2500 .godot/           # Godot's internal cache and configuration\n\u251c\u2500\u2500 project.godot     # Godot project settings\n\u251c\u2500\u2500 Sigilborne.csproj # C# project file (defines C# source, references, etc.)\n\u251c\u2500\u2500 Sigilborne.sln    # C# solution file (groups one or more .csproj files)\n\u2514\u2500\u2500 (other auto-generated files/folders)\n</code></pre> <p>The presence of <code>Sigilborne.csproj</code> and <code>Sigilborne.sln</code> confirms that C# support has been correctly integrated.</p>"},{"location":"01-chapter-1/#4-installing-net-sdk-if-not-already-present","title":"4. Installing .NET SDK (If Not Already Present)","text":"<p>Godot 4.5 with C# requires a compatible .NET SDK (Software Development Kit) to compile your C# code. Godot 4.x typically uses .NET 6.0 SDK or .NET 7.0 SDK.</p> <ol> <li>To check if you have it, open your system's command prompt or terminal and type:     <code>dotnet --list-sdks</code></li> <li>If you see an entry for <code>6.0.x</code> or <code>7.0.x</code>, you're likely good to go.</li> <li>If not, download and install the latest .NET 6.0 SDK from the official .NET website.</li> </ol>"},{"location":"01-chapter-1/#5-opening-the-c-solution-in-an-ide","title":"5. Opening the C# Solution in an IDE","text":"<p>For a productive C# development experience, you'll need an Integrated Development Environment (IDE).</p> <ul> <li>Visual Studio Code (Recommended for Cross-Platform):<ol> <li>Install Visual Studio Code.</li> <li>Install the \"C# Dev Kit\" extension from the VS Code Marketplace. This bundle includes C# language support, debugger, and project management features.</li> <li>Open VS Code and go to <code>File &gt; Open Folder...</code>. Select your <code>Sigilborne</code> project folder.</li> <li>VS Code should automatically detect the <code>Sigilborne.sln</code> file and prompt you to load the project.</li> </ol> </li> <li>Visual Studio (Windows/Mac):<ol> <li>Install Visual Studio (Community Edition is free). Ensure you select the \".NET desktop development\" workload during installation.</li> <li>Open Visual Studio and go to <code>File &gt; Open &gt; Project/Solution...</code>.</li> <li>Navigate to your <code>Sigilborne</code> project folder and select <code>Sigilborne.sln</code>.</li> </ol> </li> </ul> <p>Once opened, your IDE should display the C# project structure, and you should be able to build it without errors (though there's no C# code yet to actually compile).</p>"},{"location":"01-chapter-1/#6-first-c-script-and-build-test","title":"6. First C# Script and Build Test","text":"<p>Let's create our first C# script to confirm everything is working. This will also be the first step in organizing our project according to the TDD's <code>_Brain/</code> structure.</p> <ol> <li>In the Godot editor's FileSystem dock, right-click on the <code>res://</code> root.</li> <li>Select <code>New Folder</code> and name it <code>_Brain</code>.</li> <li>Inside <code>_Brain</code>, create another new folder named <code>Core</code>.</li> <li>Right-click on <code>res://_Brain/Core/</code>.</li> <li>Select <code>New Script...</code>.</li> <li>Language: Choose <code>C#</code>.</li> <li>Class Name: Enter <code>GameManager</code>.</li> <li>Inherits: Ensure it inherits <code>Node</code>.</li> <li>Path: Confirm the path is <code>res://_Brain/Core/GameManager.cs</code>.</li> <li>Click <code>Create</code>.</li> </ol> <p>Now, open <code>GameManager.cs</code> in your IDE or Godot's script editor. It should look like this (as per TDD 01):</p> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\n\npublic partial class GameManager : Node\n{\n    // We'll add more to this class in later chapters.\n    public override void _Ready()\n    {\n        GD.Print(\"GameManager (C#) is ready!\");\n    }\n}\n</code></pre> <p>Next, let's attach this script to a scene to run it:</p> <ol> <li>In the Godot editor, go to <code>Scene &gt; New Scene</code>.</li> <li>Add a <code>Node</code> as the root. Rename it <code>Main</code>.</li> <li>Save the scene as <code>res://Main.tscn</code>.</li> <li>Select the <code>Main</code> node in the Scene dock.</li> <li>In the Inspector dock, click the script icon next to \"Script\".</li> <li>Load <code>res://_Brain/Core/GameManager.cs</code>.</li> <li>Go to <code>Project &gt; Project Settings... &gt; Application &gt; Run</code>.</li> <li>Set the <code>Main Scene</code> to <code>res://Main.tscn</code>.</li> <li>Close Project Settings.</li> <li>Click the \"Play Scene\" button (the button with a film strip and play icon).</li> </ol> <p>Godot should compile your C# project, and if successful, you'll see \"GameManager (C#) is ready!\" printed in the Output console at the bottom of the editor. This confirms that your C# environment is correctly set up and integrated with Godot.</p>"},{"location":"01-chapter-1/#7-integrating-tdd-directory-structure","title":"7. Integrating TDD Directory Structure","text":"<p>With C# compilation confirmed, let's fully establish the project structure as defined in TDD 00 for better organization and adherence to the Brain/Body paradigm.</p> <ol> <li>In the Godot editor's FileSystem dock, if you haven't already:<ul> <li>Create a new folder <code>res://_Body/</code>.</li> <li>Inside <code>res://_Body/</code>, create <code>Scenes/</code>, <code>Scripts/</code>, <code>Art/</code>, <code>Audio/</code>.</li> <li>Inside <code>res://_Body/Scripts/</code>, create <code>Core/</code>.</li> <li>Inside <code>res://_Brain/</code>, you already have <code>Core/</code>. Now add <code>Systems/</code>, <code>Data/</code>, <code>Utils/</code>.</li> <li>Create a new folder <code>res://_Shared/</code>.</li> <li>Inside <code>res://_Shared/</code>, create <code>Config/</code>.</li> </ul> </li> </ol> <p>Your <code>res://</code> directory should now visually reflect the TDD's structure:</p> <pre><code>res://\n\u251c\u2500\u2500 _Brain/                 # C# Source Code (The Simulation)\n\u2502   \u251c\u2500\u2500 Core/               # Main Loop, Event Bus, Time\n\u2502   \u2502   \u2514\u2500\u2500 GameManager.cs  # Our first C# script\n\u2502   \u251c\u2500\u2500 Systems/            # Magic, Combat, Ecology, Economy\n\u2502   \u251c\u2500\u2500 Data/               # Static Data (Items, Spells)\n\u2502   \u2514\u2500\u2500 Utils/              # Math, Extensions\n\u251c\u2500\u2500 _Body/                  # Godot Assets (The Visuals)\n\u2502   \u251c\u2500\u2500 Scenes/             # .tscn files\n\u2502   \u251c\u2500\u2500 Scripts/            # .gd files (Visual logic only)\n\u2502   \u2502   \u2514\u2500\u2500 Core/           # Core GDScript\n\u2502   \u251c\u2500\u2500 Art/                # Sprites, Textures, Shaders\n\u2502   \u2514\u2500\u2500 Audio/              # Banks, Streams\n\u251c\u2500\u2500 _Shared/                # Resources used by both (if any)\n\u2502   \u2514\u2500\u2500 Config/             # Settings, Constants\n\u251c\u2500\u2500 Main.tscn               # Entry Point\n\u251c\u2500\u2500 .godot/\n\u251c\u2500\u2500 project.godot\n\u251c\u2500\u2500 Sigilborne.csproj\n\u2514\u2500\u2500 Sigilborne.sln\n</code></pre> <p>This completes the initial project setup. You now have a Godot 4.5 project with a fully functional C# backend, organized according to the TDD's core architectural principles.</p>"},{"location":"01-chapter-1/#next-steps","title":"Next Steps","text":"<p>In the next chapter, we will begin implementing the core components of the <code>GameManager</code> in C#, establishing the Brain's main loop and essential systems.</p>"},{"location":"02-chapter-2/","title":"Chapter 1.2: The Brain (C#) - Headless Simulation Layer","text":""},{"location":"02-chapter-2/#chapter-12-the-brain-c-headless-simulation-layer","title":"Chapter 1.2: The Brain (C#) - Headless Simulation Layer","text":"<p>In Sigilborne, the \"Brain\" is our C# simulation layer, operating largely independently of Godot's visual nodes. Its primary responsibilities are heavy simulation, managing game data, driving AI decisions, and handling all procedural generation. This headless approach is crucial for performance, determinism, and future scalability, as it allows the core logic to run efficiently without being tied to the rendering pipeline.</p> <p>This chapter will focus on implementing the <code>GameManager</code> class in C#. As per TDD 01, <code>GameManager</code> acts as the single entry point for all C# logic, a central singleton, and the bootstrapper for our core systems.</p>"},{"location":"02-chapter-2/#1-understanding-the-role-of-the-brain-c","title":"1. Understanding the Role of the Brain (C#)","text":"<p>The C# layer embodies the \"Brain\" of our game. It's where all the fundamental rules, calculations, and state management occur. Think of it as a local server running your game's universe.</p> <p>Key Characteristics of the Brain:</p> <ul> <li>Headless: Ideally, it should not directly interact with Godot's visual nodes (<code>Sprite2D</code>, <code>Node2D</code>, <code>Control</code>, etc.). Its world is one of pure data: structs, classes, and arrays.</li> <li>Authoritative: All game state (player health, NPC positions, inventory, world time, faction relationships) is owned and managed by the Brain.</li> <li>Deterministic: For a simulation-heavy game, especially with potential future multiplayer, the Brain's logic should be deterministic, meaning the same inputs always produce the same outputs.</li> <li>Performance-Oriented: C# allows for efficient data structures (structs, <code>Span&lt;T&gt;</code>, <code>NativeArray</code> equivalents via <code>Unsafe</code> code if needed) and multithreading (via the Job System, TDD 13) to handle complex simulations without bogging down the main thread.</li> </ul>"},{"location":"02-chapter-2/#2-implementing-the-gamemanager-singleton","title":"2. Implementing the GameManager Singleton","text":"<p>The <code>GameManager</code> is the heart of our C# architecture. It will be a <code>Node</code> in the Godot scene tree, but its primary purpose is to bootstrap and manage other C# systems, not to perform visual tasks. It adheres to the Singleton pattern, providing global access to core systems.</p> <p>Open <code>_Brain/Core/GameManager.cs</code> in your IDE and modify it as follows:</p> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core; // Assuming Core namespace for TimeSystem, EventBus\n\npublic partial class GameManager : Node\n{\n    // Static instance for global access (Singleton pattern)\n    public static GameManager Instance { get; private set; }\n\n    // --- Core Systems ---\n    // These will be initialized here and accessible globally.\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; } // Represents the main world simulation logic\n\n    // --- Godot Lifecycle Methods ---\n    public override void _Ready()\n    {\n        // Ensure only one instance of GameManager exists\n        if (Instance != null)\n        {\n            GD.PrintErr(\"GameManager: More than one instance detected! Destroying duplicate.\");\n            QueueFree(); // Remove this duplicate node\n            return;\n        }\n        Instance = this;\n\n        // Initialize all core C# systems\n        InitializeSystems();\n\n        GD.Print(\"GameManager (C#) initialized and ready.\");\n    }\n\n    // _PhysicsProcess runs on a fixed timestep, making it suitable for our simulation tick.\n    public override void _PhysicsProcess(double delta)\n    {\n        // The Heartbeat of the Brain: Advance the world simulation\n        // The TDD specifies World.Tick(delta), which we'll implement in TDD 01.3\n        // For now, let's ensure our core systems get their update calls.\n        Time.Tick(delta); // Update game time\n        Events.FlushCommands(); // Process any batched events from background jobs\n        World.Tick(delta); // Main world simulation update\n    }\n\n    /// &lt;summary&gt;\n    /// Initializes all core C# systems managed by the GameManager.\n    /// &lt;/summary&gt;\n    private void InitializeSystems()\n    {\n        // 1. Initialize EventBus first, as other systems may need to register/emit events.\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        // 2. Initialize TimeSystem (manages game time, day/night cycle, etc.)\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        // 3. Initialize the main WorldSimulation (this will encompass other systems like Ecology, AI, etc.)\n        // We'll flesh out WorldSimulation in a later chapter.\n        World = new WorldSimulation(); // Placeholder for now\n        GD.Print(\"  - WorldSimulation initialized.\");\n\n        // Add more system initializations here as we build them\n        // Example: CombatSystem, EcologySystem, FactionSystem, etc.\n        // Combat = new CombatSystem();\n        // Ecology = new EcologySystem();\n    }\n}\n</code></pre> <p>Explanation of Changes:</p> <ul> <li><code>Instance</code> Property: This static property implements the Singleton pattern, allowing any other C# class to access core systems via <code>GameManager.Instance.Time</code> or <code>GameManager.Instance.Events</code>.</li> <li>System Properties: <code>Time</code>, <code>Events</code>, and <code>World</code> are declared as properties, making them accessible after initialization.</li> <li><code>_Ready()</code> Method:<ul> <li>Contains a check to ensure only one <code>GameManager</code> instance exists, preventing potential bugs from duplicate nodes.</li> <li>Calls <code>InitializeSystems()</code> to set up all our C# backend logic.</li> </ul> </li> <li><code>_PhysicsProcess(double delta)</code>:<ul> <li>As per TDD 01, this Godot method, which runs on a fixed timestep, is designated as the \"Heartbeat of the Brain.\"</li> <li>Here, we call <code>Tick()</code> or <code>FlushCommands()</code> on our core systems, ensuring they update in a consistent order.</li> </ul> </li> <li><code>InitializeSystems()</code> Method: A private method responsible for creating instances of our various C# systems. This keeps <code>_Ready()</code> clean and organized.</li> </ul>"},{"location":"02-chapter-2/#3-creating-placeholder-core-systems","title":"3. Creating Placeholder Core Systems","text":"<p>The <code>GameManager</code> now expects <code>TimeSystem</code>, <code>EventBus</code>, and <code>WorldSimulation</code> to exist. Let's create minimal placeholder classes for these in the <code>_Brain/Core</code> directory.</p>"},{"location":"02-chapter-2/#31-eventbuscs","title":"3.1 <code>EventBus.cs</code>","text":"<p>This will be our central hub for C# to C# and C# to GDScript communication.</p> <p>Create a new C# script <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent; // For ConcurrentQueue\nusing Godot; // For GD.PrintErr in error handling\n\nnamespace Sigilborne.Core\n{\n    // This namespace helps organize our C# code as per TDD 00\n    // and prevents naming conflicts.\n    public class EventBus\n    {\n        // TDD 01 specifies Action&lt;T&gt; delegates for C# to GDScript (and C# to C#)\n        // For simplicity in this early stage, we'll use a generic Action for C# to C#\n        // and define specific signals for C# to GDScript later.\n\n        // Example: A generic event for when a game state changes\n        public event Action&lt;string&gt; OnGameStateChanged;\n\n        // TDD 01 also mentions batching events from background jobs.\n        // This ConcurrentQueue will hold commands to be processed on the main thread.\n        private ConcurrentQueue&lt;Action&gt; _commandBuffer = new ConcurrentQueue&lt;Action&gt;();\n\n        /// &lt;summary&gt;\n        /// Publishes an event for C# subscribers.\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"TEvent\"&gt;The type of the event.&lt;/typeparam&gt;\n        /// &lt;param name=\"eventData\"&gt;The event data.&lt;/param&gt;\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // This is a simplified generic publish.\n            // In a real system, you'd have a dictionary of event types to their delegates.\n            // For now, we'll rely on specific named events (like OnGameStateChanged).\n            if (eventData is string gameState)\n            {\n                OnGameStateChanged?.Invoke(gameState);\n            }\n            // Add more specific event types here as needed.\n        }\n\n        /// &lt;summary&gt;\n        /// Adds a command to be executed on the main thread during the next flush.\n        /// Used by background jobs.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"command\"&gt;The action to execute.&lt;/param&gt;\n        public void AddCommand(Action command)\n        {\n            _commandBuffer.Enqueue(command);\n        }\n\n        /// &lt;summary&gt;\n        /// Flushes all commands from the buffer, executing them on the main thread.\n        /// Called once per main thread tick (e.g., in _PhysicsProcess).\n        /// &lt;/summary&gt;\n        public void FlushCommands()\n        {\n            while (_commandBuffer.TryDequeue(out var command))\n            {\n                try\n                {\n                    command.Invoke();\n                }\n                catch (Exception e)\n                {\n                    GD.PrintErr($\"EventBus: Error executing batched command: {e.Message}\\n{e.StackTrace}\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Note on Namespaces: We've introduced the <code>Sigilborne.Core</code> namespace. This is a good practice in C# to organize code and prevent naming collisions, especially in larger projects. Remember to add <code>using Sigilborne.Core;</code> at the top of any C# file that needs to access classes from this namespace.</p>"},{"location":"02-chapter-2/#32-timesystemcs","title":"3.2 <code>TimeSystem.cs</code>","text":"<p>This system will manage the in-game clock, day/night cycle, and other time-related logic.</p> <p>Create a new C# script <code>_Brain/Core/TimeSystem.cs</code>:</p> <pre><code>// _Brain/Core/TimeSystem.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Core\n{\n    public class TimeSystem\n    {\n        public double CurrentGameTime { get; private set; } // Total game time in seconds\n        public int CurrentDay { get; private set; }\n        public int CurrentHour { get; private set; }\n        public int CurrentMinute { get; private set; }\n\n        private const float REAL_SECONDS_PER_GAME_MINUTE = 1.0f; // 1 real second = 1 game minute\n        private const float GAME_MINUTES_PER_HOUR = 60.0f;\n        private const float GAME_HOURS_PER_DAY = 24.0f;\n\n        public TimeSystem()\n        {\n            CurrentGameTime = 0.0;\n            CurrentDay = 1;\n            CurrentHour = 8; // Start at 8 AM\n            CurrentMinute = 0;\n            GD.Print($\"TimeSystem: Initialized. Day {CurrentDay}, {CurrentHour:D2}:{CurrentMinute:D2}\");\n        }\n\n        public void Tick(double delta)\n        {\n            // Convert real delta time to game minutes\n            double gameMinutesToAdd = delta / REAL_SECONDS_PER_GAME_MINUTE;\n            CurrentGameTime += gameMinutesToAdd;\n\n            // Update game clock\n            CurrentMinute += (int)Math.Floor(gameMinutesToAdd);\n            if (CurrentMinute &gt;= GAME_MINUTES_PER_HOUR)\n            {\n                CurrentHour += CurrentMinute / (int)GAME_MINUTES_PER_HOUR;\n                CurrentMinute %= (int)GAME_MINUTES_PER_HOUR;\n\n                if (CurrentHour &gt;= GAME_HOURS_PER_DAY)\n                {\n                    CurrentDay += CurrentHour / (int)GAME_HOURS_PER_DAY;\n                    CurrentHour %= (int)GAME_HOURS_PER_DAY;\n                    // GameManager.Instance.Events.Publish(\"NewDay\", CurrentDay); // Example event\n                }\n                // GameManager.Instance.Events.Publish(\"NewHour\", CurrentHour); // Example event\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"02-chapter-2/#33-worldsimulationcs","title":"3.3 <code>WorldSimulation.cs</code>","text":"<p>This will be the parent system for all other simulation systems (Ecology, Combat, Economy, etc.).</p> <p>Create a new C# script <code>_Brain/Core/WorldSimulation.cs</code>:</p> <pre><code>// _Brain/Core/WorldSimulation.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Core\n{\n    public class WorldSimulation\n    {\n        // Placeholder for other systems\n        // public EcologySystem Ecology { get; private set; }\n        // public CombatSystem Combat { get; private set; }\n\n        public WorldSimulation()\n        {\n            // Initialize child systems here\n            // Ecology = new EcologySystem();\n            // Combat = new CombatSystem();\n            GD.Print(\"WorldSimulation: Initialized.\");\n        }\n\n        public void Tick(double delta)\n        {\n            // Update child systems here\n            // Ecology.Tick(delta);\n            // Combat.Tick(delta);\n            // GD.Print($\"WorldSimulation: Tick at {GameManager.Instance.Time.CurrentGameTime:F2}\"); // Example\n        }\n    }\n}\n</code></pre>"},{"location":"02-chapter-2/#4-testing-the-initial-brain-setup","title":"4. Testing the Initial Brain Setup","text":"<p>Now, let's run the game again to ensure our <code>GameManager</code> correctly initializes and ticks these systems.</p> <ol> <li>Save all your C# files.</li> <li>Go back to the Godot editor. It might prompt you to re-import C# projects. Allow it.</li> <li>Ensure <code>Main.tscn</code> is still set as your main scene (Project Settings -&gt; Application -&gt; Run).</li> <li>Click the \"Play Scene\" button.</li> </ol> <p>In the Output console, you should now see:</p> <pre><code>GameManager (C#) initialized and ready.\n  - EventBus initialized.\n  - TimeSystem initialized. Day 1, 08:00\n  - WorldSimulation initialized.\n</code></pre> <p>And as the game runs, you'll see repeated output from <code>TimeSystem</code> (if you uncommented the <code>GD.Print</code> in <code>TimeSystem.Tick</code>). This confirms that our <code>GameManager</code> is acting as the central orchestrator for our C# simulation.</p>"},{"location":"02-chapter-2/#summary","title":"Summary","text":"<p>You have successfully implemented the <code>GameManager</code> as the entry point for the C# Brain, establishing it as a global singleton and the bootstrapper for core systems like <code>EventBus</code>, <code>TimeSystem</code>, and <code>WorldSimulation</code>. This lays a robust foundation for our hybrid architecture, ensuring that all complex simulation logic is managed in C# on a fixed timestep, ready to be decoupled from Godot's visual layer.</p>"},{"location":"02-chapter-2/#next-steps","title":"Next Steps","text":"<p>In the next chapter, we will implement the \"Body\" (GDScript) presentation layer and begin to define how it reacts to the state provided by the Brain.</p>"},{"location":"03-chapter-3/","title":"Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer","text":""},{"location":"03-chapter-3/#chapter-13-the-body-gdscript-reactive-presentation-layer","title":"Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer","text":"<p>In Sigilborne's hybrid architecture, the \"Body\" is our GDScript layer, solely responsible for the game's visual presentation. It's a reactive layer, meaning it doesn't calculate game outcomes or own authoritative data; instead, it listens for state updates from the C# Brain and visualizes them. This separation ensures optimal framerates, allows for rapid iteration on visuals, and keeps our codebase clean and modular.</p> <p>This chapter will focus on implementing the <code>SceneLoader</code> in GDScript, as outlined in TDD 01. <code>SceneLoader</code> will manage high-level game state transitions, such as moving between the main menu, loading screens, and core gameplay.</p>"},{"location":"03-chapter-3/#1-understanding-the-role-of-the-body-gdscript","title":"1. Understanding the Role of the Body (GDScript)","text":"<p>The GDScript layer is the \"Body\" of our game, the puppet show that brings the Brain's simulation to life.</p> <p>Key Characteristics of the Body:</p> <ul> <li>Reactive: It primarily listens to events and signals emitted by the C# Brain. It should not initiate game logic that affects the core simulation state.</li> <li>Visual-Centric: Its responsibilities include rendering sprites, playing animations, handling UI, managing particle effects, and playing audio.</li> <li>Input Capture: It captures raw player input and forwards it to the C# Brain for processing.</li> <li>Performance-Oriented: GDScript excels at rapid prototyping and visual scripting. Keeping its logic focused on presentation ensures Godot can render frames as fast as possible.</li> </ul>"},{"location":"03-chapter-3/#2-implementing-the-sceneloader","title":"2. Implementing the SceneLoader","text":"<p>The <code>SceneLoader</code> will be a central GDScript singleton that orchestrates scene changes. It will handle the visual aspects of loading, like showing a loading screen, fading transitions, and informing the C# Brain when a new level is requested.</p> <p>First, let's create the necessary directory structure for our GDScript core components, as per TDD 00.</p> <ol> <li> <p>In the Godot editor's FileSystem dock, if you haven't already, ensure you have:</p> <ul> <li><code>res://_Body/Scripts/Core/</code></li> </ul> </li> <li> <p>Now, create a new GDScript in <code>res://_Body/Scripts/Core/</code>:</p> <ul> <li>Right-click on <code>res://_Body/Scripts/Core/</code>.</li> <li>Select <code>New Script...</code>.</li> <li>Language: Choose <code>GDScript</code>.</li> <li>Class Name: Enter <code>SceneLoader</code>.</li> <li>Inherits: Ensure it inherits <code>Node</code>.</li> <li>Path: Confirm the path is <code>res://_Body/Scripts/Core/SceneLoader.gd</code>.</li> <li>Click <code>Create</code>.</li> </ul> </li> </ol> <p>Open <code>SceneLoader.gd</code> and modify it as follows:</p> <pre><code># _Body/Scripts/Core/SceneLoader.gd\nclass_name SceneLoader extends Node\n\n# --- Signals ---\n# Emitted when a scene has finished loading and is ready to be displayed.\n# This signal can be listened to by UI elements (e.g., to hide a loading screen).\nsignal scene_loaded(scene_path: String)\n\n# --- Singleton Instance ---\n# Provides global access to the SceneLoader from other GDScript classes.\nstatic var instance: SceneLoader\n\nfunc _init():\n    if instance != null:\n        # This prevents multiple instances if SceneLoader is accidentally added to multiple scenes.\n        # In our setup, it will be a child of Main.tscn, ensuring only one instance.\n        push_error(\"SceneLoader: More than one instance detected! This should not happen.\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    # Connect to C# events (if any are relevant for scene loading, e.g., world_gen_complete)\n    # For now, we'll assume the C# GameManager is already present in the scene.\n    # We will establish this connection more formally in Chapter 1.12 (Interop Layer).\n    pass\n\n# --- Public Methods ---\n\n## Loads a new game level or scene.\n## This method handles the visual transition, but the actual world generation/setup\n## is expected to be handled by the C# Brain (e.g., GameManager.World.GenerateWorld()).\n##\n## @param level_path: The resource path to the target scene (e.g., \"res://_Body/Scenes/Gameplay.tscn\").\nfunc load_level(level_path: String) -&gt; void:\n    if not ResourceLoader.exists(level_path):\n        push_error(\"SceneLoader: Cannot load level. Resource does not exist: %s\" % level_path)\n        return\n\n    GD.print(\"SceneLoader: Initiating level load for: %s\" % level_path)\n\n    # 1. Show Loading Screen (Placeholder)\n    # In a real game, you would instantiate and add a loading screen UI scene here.\n    # Example: var loading_screen = preload(\"res://_Body/Scenes/UI/LoadingScreen.tscn\").instantiate()\n    # add_child(loading_screen)\n    # await get_tree().create_timer(0.5).timeout # Simulate loading screen delay\n\n    # 2. Request World Generation from Brain (Placeholder)\n    # This is where we'd call a C# method to start the heavy lifting.\n    # Example: GameManager.Instance.World.RequestWorldGeneration(level_path)\n    # We await a signal from C# when it's done.\n    # await GameManager.Instance.Events.world_gen_complete # This will be set up later.\n\n    # For now, we simulate the C# Brain's work with a simple delay.\n    GD.print(\"SceneLoader: (Simulating C# Brain's world generation...)\")\n    await get_tree().create_timer(2.0).timeout # Simulate heavy world generation\n\n    # 3. Load the actual scene resource\n    var next_scene: PackedScene = ResourceLoader.load(level_path)\n    if next_scene == null:\n        push_error(\"SceneLoader: Failed to load PackedScene for %s\" % level_path)\n        # Handle error, maybe go back to main menu\n        return\n\n    # 4. Change the current scene in the scene tree\n    # This frees the current scene and replaces it with the new one.\n    get_tree().change_scene_to_packed(next_scene)\n\n    # 5. Hide Loading Screen (Placeholder) and Fade In\n    # Example: loading_screen.queue_free()\n    # (Perform a fade-in animation here)\n\n    GD.print(\"SceneLoader: Level loaded successfully: %s\" % level_path)\n    scene_loaded.emit(level_path) # Emit signal to notify other parts of the game\n</code></pre> <p>Explanation of Changes:</p> <ul> <li><code>class_name SceneLoader extends Node</code>: This declares <code>SceneLoader</code> as a custom type, making it easier to reference in other scripts and in the editor.</li> <li><code>signal scene_loaded(scene_path: String)</code>: This signal is emitted when a scene successfully loads. Other GDScript nodes (e.g., UI elements that show/hide loading screens) can connect to this.</li> <li><code>static var instance: SceneLoader</code>: Implements the Singleton pattern in GDScript, providing global access via <code>SceneLoader.instance</code>. The <code>_init()</code> method includes a check for duplicate instances.</li> <li><code>_ready()</code>: A placeholder for future connections to C# events.</li> <li><code>load_level(level_path: String)</code>:<ul> <li>Takes a <code>level_path</code> (e.g., <code>res://_Body/Scenes/Gameplay.tscn</code>).</li> <li>Includes placeholders for showing a loading screen and awaiting C# world generation. For now, it uses <code>await get_tree().create_timer(X).timeout</code> to simulate these asynchronous operations.</li> <li><code>ResourceLoader.load()</code> loads the scene resource.</li> <li><code>get_tree().change_scene_to_packed(next_scene)</code> performs the actual scene switch, replacing the current scene with the new one.</li> <li>Emits <code>scene_loaded</code> upon completion.</li> </ul> </li> </ul>"},{"location":"03-chapter-3/#3-integrating-sceneloader-into-the-main-scene","title":"3. Integrating SceneLoader into the Main Scene","text":"<p>For <code>SceneLoader</code> to function, it needs to be part of our initial scene. We'll add it as a child of our <code>Main</code> scene.</p> <ol> <li>Open <code>res://Main.tscn</code> in Godot.</li> <li>Select the <code>Main</code> node.</li> <li>Click the \"Add Child Node\" button (the <code>+</code> icon).</li> <li>Search for <code>SceneLoader</code> and add it.</li> <li>Save <code>Main.tscn</code>.</li> </ol> <p>Your <code>Main.tscn</code> scene tree should now look like this:</p> <pre><code>Main (Node)\n\u2514\u2500\u2500 GameManager (GameManager.cs)\n\u2514\u2500\u2500 SceneLoader (SceneLoader.gd)\n</code></pre>"},{"location":"03-chapter-3/#4-creating-a-placeholder-gameplay-scene","title":"4. Creating a Placeholder Gameplay Scene","text":"<p>To test our <code>SceneLoader</code>, we need a target scene to load. Let's create a very simple \"Gameplay\" scene.</p> <ol> <li>In Godot, go to <code>Scene &gt; New Scene</code>.</li> <li>Add a <code>Node2D</code> as the root. Rename it <code>Gameplay</code>.</li> <li>Add a <code>Label</code> node as a child of <code>Gameplay</code>.</li> <li>In the <code>Label</code>'s Inspector, set its <code>Text</code> property to \"Welcome to Sigilborne's World!\".</li> <li>Center the label roughly on the screen by setting its <code>Position</code> (e.g., <code>x=200, y=100</code>).</li> <li>Save the scene as <code>res://_Body/Scenes/Gameplay.tscn</code>.</li> </ol>"},{"location":"03-chapter-3/#5-testing-sceneloader-functionality","title":"5. Testing SceneLoader Functionality","text":"<p>Now, let's modify <code>GameManager.cs</code> to trigger the <code>SceneLoader</code> to load our <code>Gameplay</code> scene after initialization. This demonstrates the C# Brain initiating a visual command on the GDScript Body.</p> <p>Open <code>_Brain/Core/GameManager.cs</code> and add the following to its <code>_Ready()</code> method, after <code>InitializeSystems();</code>:</p> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n\n    public override void _Ready()\n    {\n        if (Instance != null)\n        {\n            GD.PrintErr(\"GameManager: More than one instance detected! Destroying duplicate.\");\n            QueueFree();\n            return;\n        }\n        Instance = this;\n\n        InitializeSystems();\n\n        GD.Print(\"GameManager (C#) initialized and ready.\");\n\n        // --- Test Scene Loading ---\n        // This demonstrates the C# Brain requesting a scene change from the GDScript Body.\n        // We ensure SceneLoader is ready before calling it.\n        if (SceneLoader.instance != null)\n        {\n            GD.Print(\"GameManager: Requesting SceneLoader to load Gameplay scene.\");\n            // We cannot directly await GDScript methods from C# like this in _Ready,\n            // as _Ready is synchronous. We'll queue it or use await for later.\n            // For now, let's just call it. The GDScript side handles the await.\n            SceneLoader.instance.load_level(\"res://_Body/Scenes/Gameplay.tscn\");\n        }\n        else\n        {\n            GD.PrintErr(\"GameManager: SceneLoader instance not found! Cannot load gameplay scene.\");\n        }\n    }\n\n    // ... (rest of GameManager.cs) ...\n}\n</code></pre> <p>Save <code>GameManager.cs</code>. Godot will recompile.</p> <p>Now, run the <code>Main.tscn</code> scene.</p> <p>Expected Outcome:</p> <ol> <li>Godot starts with <code>Main.tscn</code>.</li> <li><code>GameManager</code> and <code>SceneLoader</code> get initialized.</li> <li><code>GameManager</code> calls <code>SceneLoader.instance.load_level()</code>.</li> <li>You'll see \"SceneLoader: (Simulating C# Brain's world generation...)\" in the output for 2 seconds.</li> <li>The scene should then switch to <code>Gameplay.tscn</code>, displaying \"Welcome to Sigilborne's World!\".</li> </ol> <p>This confirms that our GDScript <code>SceneLoader</code> is working correctly as the visual orchestrator, responding to requests from the C# Brain.</p>"},{"location":"03-chapter-3/#summary","title":"Summary","text":"<p>You have successfully implemented the <code>SceneLoader</code> in GDScript, establishing it as the primary component for managing high-level visual game state transitions. This <code>SceneLoader</code> now acts as the \"Body's\" orchestrator, responding to the C# \"Brain's\" commands to load new scenes and handle visual feedback. This crucial step solidifies the separation of concerns, ensuring that our GDScript layer remains focused on presentation while the C# layer drives the core simulation.</p>"},{"location":"03-chapter-3/#next-steps","title":"Next Steps","text":"<p>In the next chapter, we will formalize our project's directory structure, enforcing the strict separation of concerns that is fundamental to our Brain &amp; Body architecture. This will be critical for maintaining a clean, scalable, and manageable codebase as Sigilborne grows in complexity.</p>"},{"location":"04-chapter-4/","title":"Chapter 1.4: Directory Structure - Enforcing Separation of Concerns","text":""},{"location":"04-chapter-4/#chapter-14-directory-structure-enforcing-separation-of-concerns","title":"Chapter 1.4: Directory Structure - Enforcing Separation of Concerns","text":"<p>A well-defined and strictly adhered-to directory structure is paramount for any large-scale project, especially one employing a hybrid architecture like Sigilborne. Our TDD 00 outlines a clear separation between the \"Brain\" (C# simulation) and \"Body\" (GDScript visuals) layers. This chapter will formalize that structure, explaining the rationale behind each folder and establishing consistent naming conventions.</p>"},{"location":"04-chapter-4/#1-the-rationale-why-a-strict-structure","title":"1. The Rationale: Why a Strict Structure?","text":"<p>The core principle behind our directory structure is separation of concerns.</p> <ul> <li>Clarity: Developers can immediately tell if a file belongs to the simulation logic or the visual presentation.</li> <li>Maintainability: Changes in one layer (e.g., refactoring C# game logic) are less likely to accidentally break code in another layer (e.g., GDScript UI).</li> <li>Performance: C# code focused on data and algorithms can be optimized without concern for rendering, and vice-versa for GDScript.</li> <li>Scalability: As the project grows, new systems can be added to their respective layers without cluttering the entire project.</li> <li>Collaboration: Multiple developers can work on different parts of the game (e.g., one on C# AI, another on GDScript animations) with minimal merge conflicts and clear responsibilities.</li> </ul>"},{"location":"04-chapter-4/#2-the-canonical-directory-structure","title":"2. The Canonical Directory Structure","text":"<p>As defined in TDD 00, our <code>res://</code> (project root) directory will be organized as follows:</p> <pre><code>res://\n\u251c\u2500\u2500 .godot/                 # Godot's internal cache and configuration (managed by Godot)\n\u251c\u2500\u2500 project.godot           # Godot project settings (managed by Godot)\n\u251c\u2500\u2500 Sigilborne.csproj       # C# project file (managed by Godot/IDE)\n\u251c\u2500\u2500 Sigilborne.sln          # C# solution file (managed by Godot/IDE)\n\u251c\u2500\u2500 Main.tscn               # Entry Point (our initial scene)\n\u251c\u2500\u2500 _Brain/                 # C# Source Code (The Simulation)\n\u2502   \u251c\u2500\u2500 Core/               # Main Loop, Event Bus, Time\n\u2502   \u251c\u2500\u2500 Systems/            # Magic, Combat, Ecology, Economy\n\u2502   \u251c\u2500\u2500 Data/               # Static Data (Items, Spells), Save Data\n\u2502   \u2514\u2500\u2500 Utils/              # Math, Extensions, Debugging\n\u251c\u2500\u2500 _Body/                  # Godot Assets &amp; GDScript (The Visuals)\n\u2502   \u251c\u2500\u2500 Scenes/             # .tscn files (UI, Entities, World Chunks)\n\u2502   \u2502   \u251c\u2500\u2500 Entities/       # Player, NPCs, Animals, Projectiles\n\u2502   \u2502   \u251c\u2500\u2500 UI/             # HUD, Menus, Inventory\n\u2502   \u2502   \u2514\u2500\u2500 World/          # Terrain, Environment props\n\u2502   \u251c\u2500\u2500 Scripts/            # .gd files (Visual logic only)\n\u2502   \u2502   \u251c\u2500\u2500 Core/           # InputManager, SceneLoader, CameraController\n\u2502   \u2502   \u251c\u2500\u2500 Visuals/        # EntityView, AnimationControllers, VFX/Audio Hooks\n\u2502   \u2502   \u2514\u2500\u2500 UI/             # UI Controllers, Menu Logic\n\u2502   \u251c\u2500\u2500 Art/                # Sprites, Textures, Shaders, TileSets\n\u2502   \u2502   \u251c\u2500\u2500 Characters/     # Player, NPCs, Animals\n\u2502   \u2502   \u251c\u2500\u2500 Environment/    # Tiles, Props, Backgrounds\n\u2502   \u2502   \u251c\u2500\u2500 VFX/            # Particle textures, Shader graphs\n\u2502   \u2502   \u2514\u2500\u2500 UI/             # Icons, UI elements\n\u2502   \u2514\u2500\u2500 Audio/              # Banks, Streams, SFX, Music\n\u2502       \u251c\u2500\u2500 Music/\n\u2502       \u2514\u2500\u2500 SFX/\n\u2514\u2500\u2500 _Shared/                # Resources used by both (if any)\n    \u251c\u2500\u2500 Config/             # Settings, Constants, Enums\n    \u2514\u2500\u2500 Resources/          # Shared data (e.g., custom resource files)\n</code></pre>"},{"location":"04-chapter-4/#3-creating-the-full-structure","title":"3. Creating the Full Structure","text":"<p>Let's ensure your project's <code>res://</code> directory matches this canonical structure. You've already started this in Chapter 1.1, but let's complete it.</p> <ol> <li>Open your <code>Sigilborne</code> project in Godot.</li> <li>In the FileSystem dock, right-click on <code>res://</code> and select <code>New Folder</code> to create any missing top-level folders (<code>_Brain</code>, <code>_Body</code>, <code>_Shared</code>).</li> <li>Navigate into each of these and create their respective subfolders as listed above.</li> </ol> <p>For example, to create <code>res://_Body/Scenes/Entities/</code>: *   Right-click <code>res://_Body/</code>. *   <code>New Folder</code> -&gt; <code>Scenes</code>. *   Right-click <code>res://_Body/Scenes/</code>. *   <code>New Folder</code> -&gt; <code>Entities</code>.</p> <p>Repeat this process until your FileSystem dock is fully populated according to the TDD.</p>"},{"location":"04-chapter-4/#4-naming-conventions","title":"4. Naming Conventions","text":"<p>Consistent naming is vital for readability and quick navigation.</p>"},{"location":"04-chapter-4/#41-c-the-brain-tdd-00-tdd-011","title":"4.1. C# (The Brain) - TDD 00, TDD 01.1","text":"<ul> <li>Files/Classes: <code>PascalCase</code> (e.g., <code>GameManager.cs</code>, <code>TimeSystem.cs</code>, <code>SpellDefinition.cs</code>).</li> <li>Methods/Properties: <code>PascalCase</code> (e.g., <code>CalculateDamage()</code>, <code>CurrentGameTime</code>).</li> <li>Local Variables/Parameters: <code>camelCase</code> (e.g., <code>currentHealth</code>, <code>delta</code>).</li> <li>Structs: <code>PascalCase</code> (e.g., <code>EntityID</code>, <code>InputFrame</code>).</li> <li>Enums: <code>PascalCase</code> (e.g., <code>GlyphType</code>, <code>CastState</code>).</li> <li>Namespaces: <code>PascalCase</code> (e.g., <code>Sigilborne.Core</code>, <code>Sigilborne.Systems.Magic</code>).</li> </ul>"},{"location":"04-chapter-4/#42-gdscript-the-body-tdd-00-tdd-162","title":"4.2. GDScript (The Body) - TDD 00, TDD 16.2","text":"<ul> <li>Files/Classes (custom types): <code>PascalCase</code> (e.g., <code>SceneLoader.gd</code>, <code>PlayerController.gd</code>).</li> <li>Variables/Functions: <code>snake_case</code> (e.g., <code>play_animation()</code>, <code>current_health</code>).</li> <li>Signals: <code>snake_case</code> (e.g., <code>scene_loaded</code>, <code>entity_moved</code>).</li> <li>Node Paths: <code>PascalCase</code> (e.g., <code>get_node(\"PlayerCharacter/Visuals/Sprite\")</code>).</li> <li>Typing: ALWAYS use static typing (<code>var health: float = 100.0</code>).</li> </ul>"},{"location":"04-chapter-4/#43-godot-assets-scenes-resources-art-tdd-161","title":"4.3. Godot Assets (Scenes, Resources, Art) - TDD 16.1","text":"<ul> <li>Scenes (<code>.tscn</code>): <code>PascalCase</code> (e.g., <code>PlayerCharacter.tscn</code>, <code>IronSword.tscn</code>, <code>MainMenu.tscn</code>).</li> <li>Resources (<code>.tres</code>, <code>.res</code>): <code>PascalCase</code> (e.g., <code>PlayerStats.tres</code>, <code>FireballEffect.tres</code>).</li> <li>Art Assets (<code>.png</code>, <code>.wav</code>, <code>.ogg</code>, etc.): <code>snake_case</code> (e.g., <code>icon_fire_ball.png</code>, <code>sfx_footstep_grass.wav</code>, <code>bgm_forest_loop.ogg</code>).</li> <li>Nodes in Scene Tree: <code>PascalCase</code> for functional nodes (<code>Sprite</code>, <code>CollisionShape</code>, <code>AnimationPlayer</code>). <code>PascalCase</code> for unique nodes (<code>MainCamera</code>, <code>WorldEnvironment</code>). Custom nodes should also be <code>PascalCase</code> (e.g., <code>PlayerCharacter</code>, <code>EnemyGoblin</code>).</li> </ul>"},{"location":"04-chapter-4/#5-applying-naming-conventions-to-existing-files","title":"5. Applying Naming Conventions to Existing Files","text":"<p>Let's ensure our existing files follow these conventions.</p> <ol> <li><code>res://Main.tscn</code>: This is correct as <code>PascalCase</code>.</li> <li><code>res://_Brain/Core/GameManager.cs</code>: Correct as <code>PascalCase</code>.</li> <li><code>res://_Brain/Core/EventBus.cs</code>: Correct as <code>PascalCase</code>.</li> <li><code>res://_Brain/Core/TimeSystem.cs</code>: Correct as <code>PascalCase</code>.</li> <li><code>res://_Brain/Core/WorldSimulation.cs</code>: Correct as <code>PascalCase</code>.</li> <li><code>res://_Body/Scripts/Core/SceneLoader.gd</code>: Correct as <code>PascalCase</code> for its <code>class_name</code>.</li> </ol>"},{"location":"04-chapter-4/#6-importance-of-godots-class_name-and-static-typing","title":"6. Importance of Godot's Class_Name and Static Typing","text":"<ul> <li><code>class_name</code>: In GDScript, <code>class_name</code> (e.g., <code>class_name SceneLoader extends Node</code>) registers your script as a global type. This allows you to:<ul> <li>Reference it directly in other GDScripts without <code>preload()</code> or <code>load()</code>.</li> <li>Instantiate it directly (e.g., <code>var loader = SceneLoader.new()</code>).</li> <li>See it in the \"Add Node\" dialog in the editor.</li> <li>This is why <code>GameManager.cs</code> could call <code>SceneLoader.instance.load_level()</code> even though <code>SceneLoader</code> is a GDScript.</li> </ul> </li> <li>Static Typing: (e.g., <code>var health: float = 100.0</code>) is mandatory for all GDScript. It improves:<ul> <li>Code readability and maintainability.</li> <li>Error detection during development.</li> <li>Performance (Godot can optimize typed code better).</li> <li>IDE autocompletion.</li> </ul> </li> </ul>"},{"location":"04-chapter-4/#7-verifying-the-structure-and-running-the-project","title":"7. Verifying the Structure and Running the Project","text":"<p>After creating all the folders and confirming naming, try running your project (<code>Main.tscn</code>) again. Everything should still work as before. If you encounter any errors, double-check your folder paths and script names.</p> <p>This structured approach might seem like overhead initially, but it's an investment that pays dividends in large, complex projects like Sigilborne, preventing \"spaghetti code\" and making the game much easier to develop and maintain in the long run.</p>"},{"location":"04-chapter-4/#summary","title":"Summary","text":"<p>You have successfully established the canonical directory structure for Sigilborne, strictly separating the C# \"Brain\" from the GDScript \"Body\" and other shared resources. You've also reviewed and committed to consistent naming conventions for files, classes, methods, and nodes across both languages and assets. This robust organizational framework is a critical step towards building a scalable, maintainable, and collaborative game.</p>"},{"location":"04-chapter-4/#next-steps","title":"Next Steps","text":"<p>With our project structure firmly in place, we will now implement the core <code>Entity</code> model using a lightweight Entity-Component-System (ECS-lite) approach in C#, which will serve as the atomic unit of our simulation.</p>"},{"location":"05-chapter-5/","title":"Chapter 1.5: Entity Model - Lightweight ECS-lite in C#","text":""},{"location":"05-chapter-5/#chapter-15-entity-model-lightweight-ecs-lite-in-c","title":"Chapter 1.5: Entity Model - Lightweight ECS-lite in C","text":"<p>In Sigilborne, our world will be teeming with thousands of dynamic elements: players, NPCs, animals, projectiles, items, and more. Managing these efficiently requires a robust \"atomic unit\" for our simulation. This chapter introduces a lightweight Entity-Component-System (ECS-lite) architecture in C#, as outlined in TDD 11. This approach prioritizes performance, flexibility, and data-oriented design, moving away from heavy Godot nodes for our core simulation data.</p>"},{"location":"05-chapter-5/#1-the-need-for-an-ecs-lite","title":"1. The Need for an ECS-lite","text":"<p>While Godot's Node system is excellent for visuals and hierarchical scenes, it's not ideal for managing thousands of pure data-driven entities in a simulation.</p> <p>Why ECS-lite in the Brain?</p> <ul> <li>Performance: Nodes carry a lot of overhead (scene tree management, signals, visual properties). Our C# entities will be pure data, making them cache-friendly and faster to process in bulk.</li> <li>Flexibility: Entities are just IDs. Components (pure data) are attached to them, allowing for highly flexible combinations of behaviors without complex inheritance hierarchies.</li> <li>Data-Oriented Design (DOD): ECS encourages thinking about data first, leading to more efficient memory access and easier multithreading (TDD 13).</li> <li>Decoupling: Simulation logic is completely separate from visual representation. An entity can exist in the Brain without a visual counterpart in the Body (e.g., an \"unloaded\" NPC, TDD 11.5).</li> </ul>"},{"location":"05-chapter-5/#2-entity-id-structure","title":"2. Entity ID Structure","text":"<p>An \"Entity\" in our ECS-lite is simply an <code>EntityID</code>: a unique identifier, not an object or a class. As per TDD 11.2, it's a <code>readonly struct</code> for efficiency.</p> <p>Let's create the <code>EntityID</code> struct.</p> <ol> <li>In <code>res://_Brain/Entities/</code>, create a new folder named <code>Components/</code>.</li> <li>In <code>res://_Brain/Entities/</code>, create a new C# script named <code>EntityID.cs</code>:</li> </ol> <pre><code>// _Brain/Entities/EntityID.cs\nusing System;\n\nnamespace Sigilborne.Entities\n{\n    /// &lt;summary&gt;\n    /// Represents a unique identifier for an entity in the ECS-lite.\n    /// It's a readonly struct for efficiency and immutability.\n    /// &lt;/summary&gt;\n    public readonly struct EntityID : IEquatable&lt;EntityID&gt;\n    {\n        // TDD 11.2: Index - The slot in the global entity array.\n        public readonly int Index;\n        // TDD 11.2: Generation - A version counter to detect \"Use After Free\" bugs.\n        public readonly int Generation;\n\n        // A special ID to represent a non-existent or invalid entity.\n        public static readonly EntityID Invalid = new EntityID(-1, -1);\n\n        public EntityID(int index, int generation)\n        {\n            Index = index;\n            Generation = generation;\n        }\n\n        // --- IEquatable Implementation ---\n        public bool Equals(EntityID other)\n        {\n            return Index == other.Index &amp;&amp; Generation == other.Generation;\n        }\n\n        public override bool Equals(object obj)\n        {\n            return obj is EntityID other &amp;&amp; Equals(other);\n        }\n\n        public override int GetHashCode()\n        {\n            return HashCode.Combine(Index, Generation);\n        }\n\n        public static bool operator ==(EntityID left, EntityID right)\n        {\n            return left.Equals(right);\n        }\n\n        public static bool operator !=(EntityID left, EntityID right)\n        {\n            return !(left == right);\n        }\n\n        public override string ToString()\n        {\n            return $\"EntityID({Index}, Gen:{Generation})\";\n        }\n\n        public bool IsValid()\n        {\n            return Index != -1 &amp;&amp; Generation != -1;\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>readonly struct</code>: Ensures immutability and memory efficiency, as structs are value types.</li> <li><code>Index</code>: Points to the entity's actual data in an array.</li> <li><code>Generation</code>: A crucial safety mechanism. When an entity is destroyed, its <code>Index</code> slot might be reused. Incrementing <code>Generation</code> for the new entity in that slot prevents old <code>EntityID</code> references from accidentally accessing the wrong (or new) entity.</li> <li><code>IEquatable&lt;EntityID&gt;</code>: Provides efficient comparisons for <code>EntityID</code>s.</li> <li><code>Invalid</code>: A static property for representing a null or non-existent entity.</li> </ul>"},{"location":"05-chapter-5/#3-the-entity-registry-entitymanager","title":"3. The Entity Registry (EntityManager)","text":"<p>The <code>EntityManager</code> is the central component responsible for creating, destroying, and managing the lifecycle of <code>EntityID</code>s. It will also hold basic metadata about each entity. As per TDD 11.2, it avoids <code>Dictionary</code> for core lookup, preferring direct array access.</p> <p>Create a new C# script <code>_Brain/Entities/EntityManager.cs</code>:</p> <pre><code>// _Brain/Entities/EntityManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic; // For List&lt;int&gt; and Dictionary (for sparse data)\nusing Sigilborne.Core; // For EventBus\n\nnamespace Sigilborne.Entities\n{\n    /// &lt;summary&gt;\n    /// Represents the core metadata for an entity.\n    /// This is stored directly in the EntityManager's array.\n    /// &lt;/summary&gt;\n    public struct EntityMeta\n    {\n        public int Generation; // Current generation of the entity in this slot\n        public bool IsActive;   // Whether this slot is currently in use\n        public EntityType Type; // Player, NPC, Animal, Projectile, etc.\n        public string DefinitionID; // Reference to static data (e.g., \"goblin_scout\", \"player_default\")\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the broad categories of entities in the simulation.\n    /// &lt;/summary&gt;\n    public enum EntityType\n    {\n        Player,\n        NPC,\n        Animal,\n        Projectile,\n        Item,\n        WorldObject, // Interactable objects like Chests, Doors\n        Effect,      // Visual effects that are entities (e.g., a persistent poison cloud)\n        Invalid\n    }\n\n    /// &lt;summary&gt;\n    /// Manages the creation, destruction, and basic lifecycle of all entities.\n    /// Provides direct O(1) access to entity metadata via Index.\n    /// &lt;/summary&gt;\n    public class EntityManager\n    {\n        private const int MAX_ENTITIES = 10_000; // TDD 11.2: Fixed size entity array\n        private EntityMeta[] _entityMetas = new EntityMeta[MAX_ENTITIES];\n        private List&lt;int&gt; _freeIndices = new List&lt;int&gt;(MAX_ENTITIES); // List of available slots\n\n        private EventBus _eventBus; // To emit events like OnEntitySpawned, OnEntityDespawned\n\n        public EntityManager(EventBus eventBus)\n        {\n            _eventBus = eventBus;\n\n            // Populate free indices initially\n            for (int i = 0; i &lt; MAX_ENTITIES; i++)\n            {\n                _freeIndices.Add(i);\n            }\n            GD.Print($\"EntityManager: Initialized with {MAX_ENTITIES} slots.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Creates a new entity and returns its unique EntityID.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"type\"&gt;The type of entity to create.&lt;/param&gt;\n        /// &lt;param name=\"definitionID\"&gt;The ID of the static definition for this entity.&lt;/param&gt;\n        /// &lt;returns&gt;A valid EntityID if successful, otherwise EntityID.Invalid.&lt;/returns&gt;\n        public EntityID CreateEntity(EntityType type, string definitionID)\n        {\n            if (_freeIndices.Count == 0)\n            {\n                GD.PrintErr(\"EntityManager: No free entity slots available!\");\n                return EntityID.Invalid;\n            }\n\n            int index = _freeIndices[_freeIndices.Count - 1]; // Get last free index\n            _freeIndices.RemoveAt(_freeIndices.Count - 1);    // Remove from free list\n\n            // Increment generation for safety (TDD 11.2)\n            _entityMetas[index].Generation++;\n            _entityMetas[index].IsActive = true;\n            _entityMetas[index].Type = type;\n            _entityMetas[index].DefinitionID = definitionID;\n\n            EntityID newId = new EntityID(index, _entityMetas[index].Generation);\n            GD.Print($\"EntityManager: Created {type} entity {newId} (Def: {definitionID})\");\n\n            // TDD 11.4: Emit OnEntitySpawned for Body sync\n            _eventBus.Publish(new EntitySpawnedEvent { ID = newId, Type = type, DefinitionID = definitionID });\n\n            return newId;\n        }\n\n        /// &lt;summary&gt;\n        /// Destroys an entity, making its ID invalid and its slot available for reuse.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;The EntityID to destroy.&lt;/param&gt;\n        public void DestroyEntity(EntityID id)\n        {\n            if (!IsValid(id))\n            {\n                GD.PrintErr($\"EntityManager: Attempted to destroy invalid entity {id}.\");\n                return;\n            }\n\n            int index = id.Index;\n            _entityMetas[index].IsActive = false;\n            // Generation is not incremented here, but when a new entity reuses the slot.\n            // This ensures old IDs point to an \"invalid\" generation.\n\n            _freeIndices.Add(index); // Add back to free list\n            GD.Print($\"EntityManager: Destroyed entity {id}.\");\n\n            // TDD 11.4: Emit OnEntityDespawned for Body sync\n            _eventBus.Publish(new EntityDespawnedEvent { ID = id });\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if an EntityID is currently valid and refers to an active entity.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"id\"&gt;The EntityID to validate.&lt;/param&gt;\n        /// &lt;returns&gt;True if the ID is valid and active, false otherwise.&lt;/returns&gt;\n        public bool IsValid(EntityID id)\n        {\n            if (!id.IsValid() || id.Index &gt;= MAX_ENTITIES || id.Index &lt; 0)\n            {\n                return false;\n            }\n            // TDD 11.2: Validation - Generation check is critical\n            return _entityMetas[id.Index].IsActive &amp;&amp; _entityMetas[id.Index].Generation == id.Generation;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the metadata for a given EntityID.\n        /// Throws an exception if the ID is invalid, so always call IsValid() first.\n        /// &lt;/summary&gt;\n        public ref EntityMeta GetEntityMeta(EntityID id)\n        {\n            if (!IsValid(id))\n            {\n                throw new InvalidOperationException($\"Attempted to get metadata for invalid entity {id}.\");\n            }\n            return ref _entityMetas[id.Index];\n        }\n\n        // --- Helper Events for Body Sync (TDD 11.4) ---\n        // These are simple structs to pass data through the EventBus.\n        public struct EntitySpawnedEvent { public EntityID ID; public EntityType Type; public string DefinitionID; }\n        public struct EntityDespawnedEvent { public EntityID ID; }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>EntityMeta</code> struct: Stores essential metadata for each entity directly in the <code>_entityMetas</code> array.</li> <li><code>EntityType</code> enum: Categorizes our entities for better organization and system processing.</li> <li><code>MAX_ENTITIES</code>: A fixed-size array (<code>_entityMetas</code>) for fast O(1) access by index.</li> <li><code>_freeIndices</code>: A <code>List&lt;int&gt;</code> to quickly find available slots for new entities.</li> <li><code>CreateEntity()</code>:<ul> <li>Finds a free index.</li> <li>Increments the <code>Generation</code> counter for that slot.</li> <li>Initializes <code>EntityMeta</code>.</li> <li>Returns a new <code>EntityID</code>.</li> <li>Crucially: Publishes an <code>EntitySpawnedEvent</code> via the <code>EventBus</code> so the GDScript Body can create a visual representation.</li> </ul> </li> <li><code>DestroyEntity()</code>:<ul> <li>Marks the slot as inactive.</li> <li>Adds the index back to <code>_freeIndices</code>.</li> <li>Crucially: Publishes an <code>EntityDespawnedEvent</code> for the GDScript Body to remove its visual representation.</li> </ul> </li> <li><code>IsValid()</code>: The core validation method, using both <code>Index</code> and <code>Generation</code> to prevent stale references.</li> <li><code>GetEntityMeta()</code>: Provides safe, direct access to the <code>EntityMeta</code> struct.</li> <li><code>EntitySpawnedEvent</code> / <code>EntityDespawnedEvent</code>: These nested structs define the data payload for our <code>EventBus</code> signals, enabling the Body to react to entity lifecycle changes.</li> </ul>"},{"location":"05-chapter-5/#4-integrating-entitymanager-into-gamemanager","title":"4. Integrating EntityManager into GameManager","text":"<p>Now, we need to make <code>EntityManager</code> a core system managed by our <code>GameManager</code>.</p> <p>Open <code>_Brain/Core/GameManager.cs</code> and modify it:</p> <ol> <li>Add <code>using Sigilborne.Entities;</code> at the top.</li> <li>Add an <code>EntityManager</code> property.</li> <li>Initialize <code>EntityManager</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities; // Add this using directive\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; } // Add EntityManager property\n\n    public override void _Ready()\n    {\n        if (Instance != null)\n        {\n            GD.PrintErr(\"GameManager: More than one instance detected! Destroying duplicate.\");\n            QueueFree();\n            return;\n        }\n        Instance = this;\n\n        InitializeSystems();\n\n        GD.Print(\"GameManager (C#) initialized and ready.\");\n\n        // --- Test Scene Loading (from previous chapter) ---\n        if (SceneLoader.instance != null)\n        {\n            GD.Print(\"GameManager: Requesting SceneLoader to load Gameplay scene.\");\n            SceneLoader.instance.load_level(\"res://_Body/Scenes/Gameplay.tscn\");\n        }\n        else\n        {\n            GD.PrintErr(\"GameManager: SceneLoader instance not found! Cannot load gameplay scene.\");\n        }\n        // --- End Test Scene Loading ---\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Time.Tick(delta);\n        Events.FlushCommands();\n        World.Tick(delta);\n        // EntityManager doesn't have a Tick method, its operations are event/command driven.\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        // Initialize EntityManager, passing the EventBus so it can publish events\n        Entities = new EntityManager(Events); // Initialize EntityManager here\n        GD.Print(\"  - EntityManager initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"05-chapter-5/#5-testing-entity-creation","title":"5. Testing Entity Creation","text":"<p>Let's add a simple test to <code>GameManager</code> to create and destroy an entity.</p> <p>Add the following to the end of <code>GameManager</code>'s <code>_Ready()</code> method (after the <code>SceneLoader</code> call):</p> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method)\n// ...\n        // --- Test Entity Management ---\n        GD.Print(\"\\n--- Testing Entity Management ---\");\n        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, \"player_default\");\n        GD.Print($\"Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        EntityID npcEntity = Entities.CreateEntity(EntityType.NPC, \"goblin_grunt\");\n        GD.Print($\"Created NPC: {npcEntity}. IsValid: {Entities.IsValid(npcEntity)}\");\n\n        Entities.DestroyEntity(playerEntity);\n        GD.Print($\"Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        // Attempt to create a new entity, reusing the slot\n        EntityID newPlayerEntity = Entities.CreateEntity(EntityType.Player, \"player_reborn\");\n        GD.Print($\"Created New Player: {newPlayerEntity}. IsValid: {Entities.IsValid(newPlayerEntity)}\");\n        GD.Print($\"Old Player ID {playerEntity} now IsValid: {Entities.IsValid(playerEntity)}\"); // Should be false!\n\n        GD.Print(\"--- End Testing Entity Management ---\\n\");\n// ...\n</code></pre> <p>Save all C# files and run <code>Main.tscn</code>. In the Output console, after the scene loads, you should see output similar to this:</p> <pre><code>--- Testing Entity Management ---\nEntityManager: Created Player entity EntityID(0, Gen:1) (Def: player_default)\nCreated Player: EntityID(0, Gen:1). IsValid: True\nEntityManager: Created NPC entity EntityID(1, Gen:1) (Def: goblin_grunt)\nCreated NPC: EntityID(1, Gen:1). IsValid: True\nEntityManager: Destroyed entity EntityID(0, Gen:1).\nDestroyed Player: EntityID(0, Gen:1). IsValid: False\nEntityManager: Created Player entity EntityID(0, Gen:2) (Def: player_reborn)\nCreated New Player: EntityID(0, Gen:2). IsValid: True\nOld Player ID EntityID(0, Gen:1) now IsValid: False\n--- End Testing Entity Management ---\n</code></pre> <p>Notice how <code>EntityID(0, Gen:1)</code> becomes invalid after destruction, and the new entity reusing index <code>0</code> gets <code>Gen:2</code>. This confirms our generation counter mechanism is working as intended.</p>"},{"location":"05-chapter-5/#summary","title":"Summary","text":"<p>You have successfully implemented the core Entity model for Sigilborne using a lightweight ECS-lite architecture in C#. This includes the <code>EntityID</code> struct for unique identification and the <code>EntityManager</code> for handling entity lifecycle. By integrating <code>EntityManager</code> into <code>GameManager</code> and confirming its functionality, you've established a performant, flexible, and data-oriented foundation for all simulation entities, strictly adhering to TDD 11's specifications.</p>"},{"location":"05-chapter-5/#next-steps","title":"Next Steps","text":"<p>In the next chapter, we will build upon this by designing and implementing core components, focusing on <code>TransformComponent</code>, <code>TypeComponent</code>, and <code>StateComponent</code>, and explore how they are stored and accessed within our ECS-lite framework.</p>"},{"location":"06-chapter-6/","title":"Chapter 1.6: Component Architecture - Composition over Inheritance","text":""},{"location":"06-chapter-6/#chapter-16-component-architecture-composition-over-inheritance","title":"Chapter 1.6: Component Architecture - Composition over Inheritance","text":"<p>Building upon our <code>EntityID</code> and <code>EntityManager</code>, this chapter dives into the \"Component\" aspect of our ECS-lite architecture. Components are pure data structures that describe an entity's attributes. By attaching various components to an <code>EntityID</code>, we define its behavior and properties through composition rather than complex inheritance chains. This approach, as per TDD 11.3, promotes flexibility, reusability, and efficient data processing.</p> <p>We will design and implement <code>TransformComponent</code>, <code>TypeComponent</code>, and <code>StateComponent</code> as our foundational components.</p>"},{"location":"06-chapter-6/#1-understanding-component-based-design","title":"1. Understanding Component-Based Design","text":"<p>In an ECS-lite, an entity is just an ID. Its capabilities come from the components attached to it.</p> <p>Key Principles of Components:</p> <ul> <li>Pure Data: Components should primarily contain data, not logic. Logic resides in \"Systems\" that operate on components.</li> <li>Small and Focused: Each component should represent a single, clear aspect of an entity (e.g., <code>TransformComponent</code> for position, <code>HealthComponent</code> for health).</li> <li>Composition: An entity gets its behavior by composing multiple components. A <code>Player</code> entity might have <code>TransformComponent</code>, <code>HealthComponent</code>, <code>InputComponent</code>, and <code>InventoryComponent</code>. A <code>Projectile</code> might only have <code>TransformComponent</code> and <code>DamageComponent</code>.</li> <li>Reusability: Components can be reused across vastly different entity types.</li> <li>Cache-Friendliness: Storing components of the same type together (e.g., all <code>TransformComponents</code> in one array) improves CPU cache performance when systems iterate over them.</li> </ul>"},{"location":"06-chapter-6/#2-component-storage-strategy","title":"2. Component Storage Strategy","text":"<p>TDD 11.3 outlines two primary patterns for component storage:</p> <ul> <li>Structure of Arrays (SoA): For \"hot path\" components that are frequently iterated over (like <code>TransformComponent</code>, <code>VelocityComponent</code>), we store them in large arrays. This is excellent for cache locality.</li> <li>Dictionary: For \"sparse\" components that only a subset of entities possess (like <code>InventoryComponent</code>, <code>ManaComponent</code>), a <code>Dictionary&lt;EntityID, ComponentData&gt;</code> is more memory-efficient.</li> </ul> <p>For our core components, <code>TransformComponent</code> will likely be SoA-like (stored in a system that iterates all transforms), while <code>TypeComponent</code> and <code>StateComponent</code> will be direct metadata or part of the <code>EntityManager</code>'s internal structure.</p> <p>Let's create the <code>_Brain/Entities/Components</code> folder if you haven't already.</p>"},{"location":"06-chapter-6/#3-core-components-implementation","title":"3. Core Components Implementation","text":""},{"location":"06-chapter-6/#31-transformcomponentcs","title":"3.1 <code>TransformComponent.cs</code>","text":"<p>Every entity in our game world will have a position and rotation. This component is fundamental for movement, rendering, and spatial queries.</p> <p>Create <code>res://_Brain/Entities/Components/TransformComponent.cs</code>:</p> <pre><code>// _Brain/Entities/Components/TransformComponent.cs\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Entities.Components\n{\n    /// &lt;summary&gt;\n    /// Stores the position and rotation of an entity in world space.\n    /// This is a common component for all spatially aware entities.\n    /// &lt;/summary&gt;\n    public struct TransformComponent\n    {\n        public Vector2 Position;\n        public float RotationDegrees; // Rotation in degrees\n\n        public TransformComponent(Vector2 position, float rotationDegrees = 0f)\n        {\n            Position = position;\n            RotationDegrees = rotationDegrees;\n        }\n\n        public override string ToString()\n        {\n            return $\"Pos: {Position}, Rot: {RotationDegrees}\u00b0\";\n        }\n    }\n}\n</code></pre> <p>Note: We use Godot's <code>Vector2</code> struct directly here. While the TDD mentions the Brain should be headless, <code>Vector2</code> is a fundamental mathematical type for 2D games, and its inclusion doesn't tie the Brain to Godot's visual nodes.</p>"},{"location":"06-chapter-6/#32-typecomponentcs","title":"3.2 <code>TypeComponent.cs</code>","text":"<p>This component defines the broad category of an entity. We've already implicitly defined this with <code>EntityType</code> in <code>EntityManager.cs</code>, so we can consider <code>EntityType</code> itself as the <code>TypeComponent</code> data, stored directly within <code>EntityMeta</code>.</p> <p>To formalize this, ensure your <code>EntityManager.cs</code> explicitly uses the <code>EntityType</code> enum. (We already did this in Chapter 1.5).</p> <pre><code>// Excerpt from _Brain/Entities/EntityManager.cs\n// ...\n    public struct EntityMeta\n    {\n        public int Generation;\n        public bool IsActive;\n        public EntityType Type; // This is our TypeComponent data\n        public string DefinitionID;\n    }\n// ...\n    public enum EntityType // This enum defines the possible types\n    {\n        Player,\n        NPC,\n        Animal,\n        Projectile,\n        Item,\n        WorldObject,\n        Effect,\n        Invalid\n    }\n// ...\n</code></pre>"},{"location":"06-chapter-6/#33-statecomponentcs","title":"3.3 <code>StateComponent.cs</code>","text":"<p>This component holds various boolean flags that describe an entity's current state (e.g., active, sleeping, dead).</p> <p>Create <code>res://_Brain/Entities/Components/StateComponent.cs</code>:</p> <pre><code>// _Brain/Entities/Components/StateComponent.cs\nnamespace Sigilborne.Entities.Components\n{\n    /// &lt;summary&gt;\n    /// Stores various boolean flags representing an entity's current state.\n    /// &lt;/summary&gt;\n    public struct StateComponent\n    {\n        public bool IsActive;    // Whether the entity is currently active in the simulation (beyond EntityManager's IsActive)\n        public bool IsSleeping;  // For NPCs/Animals\n        public bool IsDead;      // For all living entities\n        public bool IsStunned;   // For combat\n        public bool IsInvisible; // For stealth\n\n        public StateComponent(bool isActive = true)\n        {\n            IsActive = isActive;\n            IsSleeping = false;\n            IsDead = false;\n            IsStunned = false;\n            IsInvisible = false;\n        }\n\n        public override string ToString()\n        {\n            return $\"Active: {IsActive}, Sleeping: {IsSleeping}, Dead: {IsDead}, Stunned: {IsStunned}, Invisible: {IsInvisible}\";\n        }\n    }\n}\n</code></pre>"},{"location":"06-chapter-6/#4-component-storage-and-retrieval-within-systems","title":"4. Component Storage and Retrieval within Systems","text":"<p>Now, let's consider how a \"System\" would manage these components. For <code>TransformComponent</code>, which almost all entities will have, a dedicated <code>TransformSystem</code> would store them efficiently. For <code>StateComponent</code>, we can store it similarly, or integrate some flags directly into <code>EntityMeta</code> for very common states.</p> <p>Let's create a placeholder <code>TransformSystem</code> to demonstrate component management.</p> <p>Create <code>res://_Brain/Systems/TransformSystem.cs</code>:</p> <pre><code>// _Brain/Systems/TransformSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\n\nnamespace Sigilborne.Systems\n{\n    /// &lt;summary&gt;\n    /// Manages all TransformComponents for active entities.\n    /// Example of a system that holds its own component data.\n    /// &lt;/summary&gt;\n    public class TransformSystem\n    {\n        // TDD 11.3: SoA Pattern - Dictionary for sparse data, but still efficient for many entities.\n        // For very high performance (millions of entities), this might be a NativeArray&lt;TransformComponent&gt;\n        // and a separate NativeArray&lt;EntityID&gt; for indices.\n        private Dictionary&lt;EntityID, TransformComponent&gt; _transforms = new Dictionary&lt;EntityID, TransformComponent&gt;();\n        private EntityManager _entityManager; // Reference to validate EntityIDs\n\n        public TransformSystem(EntityManager entityManager, EventBus eventBus)\n        {\n            _entityManager = entityManager;\n            // Subscribe to entity lifecycle events to manage transforms\n            eventBus.OnEntitySpawned += OnEntitySpawned;\n            eventBus.OnEntityDespawned += OnEntityDespawned;\n            GD.Print(\"TransformSystem: Initialized.\");\n        }\n\n        // --- Event Handlers for Entity Lifecycle ---\n        private void OnEntitySpawned(EntityManager.EntitySpawnedEvent e)\n        {\n            // All entities get a TransformComponent by default for simplicity in this example\n            // In a real game, only spatially aware entities would get one.\n            _transforms.Add(e.ID, new TransformComponent(Vector2.Zero)); // Default position\n            GD.Print($\"TransformSystem: Added transform for {e.ID}\");\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            if (_transforms.ContainsKey(e.ID))\n            {\n                _transforms.Remove(e.ID);\n                GD.Print($\"TransformSystem: Removed transform for {e.ID}\");\n            }\n        }\n\n        // --- Public API for Systems to Access/Modify Transforms ---\n\n        /// &lt;summary&gt;\n        /// Attempts to get the TransformComponent for a given entity.\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;True if the component exists and is retrieved, false otherwise.&lt;/returns&gt;\n        public bool TryGetTransform(EntityID id, out TransformComponent transform)\n        {\n            if (!_entityManager.IsValid(id))\n            {\n                transform = default;\n                return false;\n            }\n            return _transforms.TryGetValue(id, out transform);\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to set the TransformComponent for a given entity.\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;True if the component exists and is set, false otherwise.&lt;/returns&gt;\n        public bool TrySetTransform(EntityID id, TransformComponent transform)\n        {\n            if (!_entityManager.IsValid(id) || !_transforms.ContainsKey(id))\n            {\n                return false;\n            }\n            _transforms[id] = transform;\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Provides a mutable reference to the TransformComponent for direct modification.\n        /// Use with caution and ensure the ID is valid.\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;A ref to the TransformComponent.&lt;/returns&gt;\n        /// &lt;exception cref=\"InvalidOperationException\"&gt;If the entity is invalid or doesn't have a transform.&lt;/exception&gt;\n        public ref TransformComponent GetTransformRef(EntityID id)\n        {\n            if (!_entityManager.IsValid(id) || !_transforms.ContainsKey(id))\n            {\n                throw new InvalidOperationException($\"Entity {id} is invalid or does not have a TransformComponent.\");\n            }\n            return ref _transforms.GetValueRef(id); // GetValueRef is a C# 7.0+ feature for ref return from Dictionary\n        }\n\n        // --- Tick Method (if this system needs to update transforms) ---\n        public void Tick(double delta)\n        {\n            // Example: A simple movement system would iterate here\n            // foreach (var kvp in _transforms)\n            // {\n            //     // Get velocity component from another system\n            //     // kvp.Value.Position += velocity * delta;\n            // }\n        }\n    }\n}\n</code></pre> <p>Note on <code>GetValueRef()</code>: This is a C# 7.0+ feature that allows returning a <code>ref</code> to a value in a <code>Dictionary</code>. If you're using an older C# version or prefer not to use <code>ref</code> returns, you would get a copy of the struct, modify it, and then set it back: <code>_transforms[id] = modifiedTransform;</code>.</p>"},{"location":"06-chapter-6/#5-integrating-transformsystem-into-gamemanager","title":"5. Integrating TransformSystem into GameManager","text":"<p>Now, let's add <code>TransformSystem</code> to our <code>GameManager</code>.</p> <p>Open <code>_Brain/Core/GameManager.cs</code> and modify it:</p> <ol> <li>Add <code>using Sigilborne.Systems;</code> at the top.</li> <li>Add a <code>TransformSystem</code> property.</li> <li>Initialize <code>TransformSystem</code> in <code>InitializeSystems()</code>, passing <code>Entities</code> and <code>Events</code>.</li> <li>Call <code>TransformSystem.Tick(delta)</code> in <code>_PhysicsProcess</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems; // Add this using directive\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; }\n    public TransformSystem Transforms { get; private set; } // Add TransformSystem property\n\n    public override void _Ready()\n    {\n        if (Instance != null)\n        {\n            GD.PrintErr(\"GameManager: More than one instance detected! Destroying duplicate.\");\n            QueueFree();\n            return;\n        }\n        Instance = this;\n\n        InitializeSystems();\n\n        GD.Print(\"GameManager (C#) initialized and ready.\");\n\n        // --- Test Scene Loading ---\n        if (SceneLoader.instance != null)\n        {\n            GD.Print(\"GameManager: Requesting SceneLoader to load Gameplay scene.\");\n            SceneLoader.instance.load_level(\"res://_Body/Scenes/Gameplay.tscn\");\n        }\n        else\n        {\n            GD.PrintErr(\"GameManager: SceneLoader instance not found! Cannot load gameplay scene.\");\n        }\n        // --- End Test Scene Loading ---\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Time.Tick(delta);\n        Events.FlushCommands();\n        World.Tick(delta);\n        Transforms.Tick(delta); // Call TransformSystem's tick method\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        // Initialize TransformSystem, passing EntityManager and EventBus\n        Transforms = new TransformSystem(Entities, Events); // Initialize TransformSystem here\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"06-chapter-6/#6-testing-component-attachment-and-retrieval","title":"6. Testing Component Attachment and Retrieval","text":"<p>Let's modify our entity testing in <code>GameManager._Ready()</code> to demonstrate setting and getting a <code>TransformComponent</code>.</p> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method, replace previous test entity code)\n// ...\n        // --- Test Entity Management &amp; Components ---\n        GD.Print(\"\\n--- Testing Entity Management &amp; Components ---\");\n        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, \"player_default\");\n        GD.Print($\"Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        // Set player's initial position\n        Transforms.TrySetTransform(playerEntity, new TransformComponent(new Vector2(100, 50), 45f));\n        if (Transforms.TryGetTransform(playerEntity, out TransformComponent playerTransform))\n        {\n            GD.Print($\"Player {playerEntity} Transform: {playerTransform}\");\n        }\n\n        // Get a ref and modify directly\n        ref TransformComponent playerTransformRef = ref Transforms.GetTransformRef(playerEntity);\n        playerTransformRef.Position = new Vector2(150, 75);\n        playerTransformRef.RotationDegrees = 90f;\n        GD.Print($\"Player {playerEntity} New Transform (via ref): {Transforms.GetTransformRef(playerEntity)}\");\n\n\n        EntityID npcEntity = Entities.CreateEntity(EntityType.NPC, \"goblin_grunt\");\n        GD.Print($\"Created NPC: {npcEntity}. IsValid: {Entities.IsValid(npcEntity)}\");\n        // NPCs also get a default transform via OnEntitySpawned\n\n        Entities.DestroyEntity(playerEntity);\n        GD.Print($\"Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        // Attempt to get transform for destroyed entity (should fail gracefully)\n        if (!Transforms.TryGetTransform(playerEntity, out TransformComponent destroyedTransform))\n        {\n            GD.Print($\"Attempted to get transform for destroyed entity {playerEntity}, it correctly failed.\");\n        }\n\n        GD.Print(\"--- End Testing Entity Management &amp; Components ---\\n\");\n// ...\n</code></pre> <p>Save all C# files and run <code>Main.tscn</code>. The output should now reflect the component creation, modification, and proper removal upon entity destruction.</p> <pre><code>--- Testing Entity Management &amp; Components ---\nEntityManager: Created Player entity EntityID(0, Gen:1) (Def: player_default)\nTransformSystem: Added transform for EntityID(0, Gen:1)\nCreated Player: EntityID(0, Gen:1). IsValid: True\nPlayer EntityID(0, Gen:1) Transform: Pos: (100, 50), Rot: 45\u00b0\nPlayer EntityID(0, Gen:1) New Transform (via ref): Pos: (150, 75), Rot: 90\u00b0\nEntityManager: Created NPC entity EntityID(1, Gen:1) (Def: goblin_grunt)\nTransformSystem: Added transform for EntityID(1, Gen:1)\nCreated NPC: EntityID(1, Gen:1). IsValid: True\nEntityManager: Destroyed entity EntityID(0, Gen:1).\nTransformSystem: Removed transform for EntityID(0, Gen:1)\nDestroyed Player: EntityID(0, Gen:1). IsValid: False\nAttempted to get transform for destroyed entity EntityID(0, Gen:1), it correctly failed.\n--- End Testing Entity Management &amp; Components ---\n</code></pre>"},{"location":"06-chapter-6/#summary","title":"Summary","text":"<p>You have successfully implemented the foundational components (<code>TransformComponent</code>, <code>TypeComponent</code>, <code>StateComponent</code>) for Sigilborne's ECS-lite architecture, emphasizing composition over inheritance. By designing a <code>TransformSystem</code> that manages <code>TransformComponent</code> data and integrates with <code>EntityManager</code>'s lifecycle events, you've established a flexible and efficient system for defining entity properties. This crucial step adheres to TDD 11's specifications, providing a scalable and performant way to manage thousands of entities in our simulation.</p>"},{"location":"06-chapter-6/#next-steps","title":"Next Steps","text":"<p>With our core entity and component architecture in place, the next module will tackle the Job System and Concurrency, enabling our Brain to perform heavy tasks like ecology simulation and world generation across multiple threads without impacting performance.</p>"},{"location":"07-chapter-7/","title":"Chapter 1.7: Job System & Concurrency - Multithreaded Processing","text":""},{"location":"07-chapter-7/#chapter-17-job-system-concurrency-multithreaded-processing","title":"Chapter 1.7: Job System &amp; Concurrency - Multithreaded Processing","text":"<p>Sigilborne is a simulation-heavy game. Updating thousands of virtual agents, generating vast procedural terrain, and calculating complex pathfinding for numerous NPCs concurrently on a single thread would inevitably lead to crippling performance issues. This chapter introduces a robust Job System to offload these heavy computations to worker threads, ensuring our game remains smooth and responsive, as detailed in TDD 13.</p> <p>We will design the core <code>JobManager</code>, define an <code>IJob</code> interface, and demonstrate how to schedule and execute jobs safely.</p>"},{"location":"07-chapter-7/#1-the-challenge-of-concurrency-in-godot-with-c","title":"1. The Challenge of Concurrency in Godot with C","text":"<p>Godot's main thread (where <code>_Process</code> and <code>_PhysicsProcess</code> run) is sacred. Any long-running operation on it will cause a \"hiccup\" or \"stutter.\"</p> <p>Why a Job System is Essential:</p> <ul> <li>Smooth Performance: Complex simulations (ecology, AI, world generation) can run in the background.</li> <li>Scalability: Easily scale computations by adding more worker threads (up to the logical core count of the CPU).</li> <li>Responsiveness: The game remains interactive while heavy tasks are being processed.</li> <li>Data-Oriented: Jobs inherently encourage data-oriented design, as they operate on chunks of data rather than complex objects.</li> </ul>"},{"location":"07-chapter-7/#2-the-job-architecture-jobmanager","title":"2. The Job Architecture: JobManager","text":"<p>The <code>JobManager</code> will be a central singleton in our C# Brain, responsible for managing a pool of worker threads and scheduling jobs. For simplicity and to leverage .NET's built-in threading capabilities, we'll use <code>System.Threading.Tasks</code> for our worker pool.</p> <p>First, let's create the <code>_Brain/Utils</code> folder if you haven't already, as per TDD 00.</p> <p>Create <code>res://_Brain/Utils/JobSystem.cs</code>:</p> <pre><code>// _Brain/Utils/JobSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Threading.Tasks;\nusing Sigilborne.Core; // For EventBus\n\nnamespace Sigilborne.Utils\n{\n    /// &lt;summary&gt;\n    /// Interface for any job that can be executed by the JobSystem.\n    /// Jobs should be pure data structs to avoid GC and capture context.\n    /// &lt;/summary&gt;\n    public interface IJob\n    {\n        void Execute();\n    }\n\n    /// &lt;summary&gt;\n    /// Manages a pool of worker threads and schedules IJob instances.\n    /// Uses System.Threading.Tasks for concurrency.\n    /// &lt;/summary&gt;\n    public class JobSystem\n    {\n        // TDD 13.2: Queues - We'll simplify to one queue for now, but could add priority.\n        private ConcurrentQueue&lt;Action&gt; _mainThreadCompletionQueue = new ConcurrentQueue&lt;Action&gt;();\n        private EventBus _eventBus;\n\n        public JobSystem(EventBus eventBus)\n        {\n            _eventBus = eventBus;\n            // The EventBus's FlushCommands will be used to process _mainThreadCompletionQueue.\n            // We just need to ensure the JobSystem adds to it.\n            GD.Print(\"JobSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Schedules a job to be executed on a background thread.\n        /// Once the job completes, an optional callback can be added to the main thread queue.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"job\"&gt;The IJob to execute.&lt;/param&gt;\n        /// &lt;param name=\"onCompleteMainThread\"&gt;An optional action to run on the main thread after the job finishes.&lt;/param&gt;\n        public void Schedule(IJob job, Action onCompleteMainThread = null)\n        {\n            Task.Run(() =&gt;\n            {\n                try\n                {\n                    job.Execute();\n                }\n                catch (Exception e)\n                {\n                    GD.PrintErr($\"JobSystem: Error executing background job: {e.Message}\\n{e.StackTrace}\");\n                }\n\n                if (onCompleteMainThread != null)\n                {\n                    // TDD 13.3: Command Buffers - Add completion callback to EventBus's main thread queue\n                    _eventBus.AddCommand(onCompleteMainThread);\n                }\n            });\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>IJob</code> Interface: Defines the <code>Execute()</code> method that all jobs must implement. Jobs will typically be <code>structs</code> to minimize garbage collection.</li> <li><code>JobSystem</code> Class:<ul> <li><code>_mainThreadCompletionQueue</code>: A <code>ConcurrentQueue&lt;Action&gt;</code> is used to safely queue actions that need to be executed back on the main thread (e.g., updating Godot nodes or <code>EntityManager</code>). The <code>EventBus</code> will be responsible for flushing this queue.</li> <li><code>Schedule()</code> Method:<ul> <li>Uses <code>Task.Run()</code> to execute the <code>job.Execute()</code> method on a .NET thread pool thread.</li> <li>Includes basic error handling for background jobs.</li> <li>If <code>onCompleteMainThread</code> is provided, it enqueues that <code>Action</code> into the <code>EventBus</code>'s command buffer for main thread execution, adhering to TDD 13.3's command buffer strategy.</li> </ul> </li> </ul> </li> </ul>"},{"location":"07-chapter-7/#3-thread-safety-strategy-the-no-node-rule-and-command-buffers","title":"3. Thread Safety Strategy: The \"No-Node\" Rule and Command Buffers","text":"<p>CRITICAL: The most important rule for concurrency is: Jobs NEVER access Godot Nodes directly.</p> <ul> <li>\"No-Node\" Rule: Background jobs must only operate on C# data (Plain Old C# Objects - POCOs, structs, or thread-safe collections). If a job needs to affect Godot's scene tree or a <code>Node</code>, it must do so indirectly.</li> <li>Command Buffers: When a job completes its work and needs to update the main game state (e.g., spawn an entity, update a visual property), it creates a \"command\" (an <code>Action</code> or a data struct describing the change) and adds it to a <code>ConcurrentQueue</code>.<ul> <li>The <code>EventBus</code>'s <code>FlushCommands()</code> method (called on the main thread in <code>GameManager._PhysicsProcess</code>) then processes these commands safely.</li> </ul> </li> </ul>"},{"location":"07-chapter-7/#4-integrating-jobsystem-into-gamemanager","title":"4. Integrating JobSystem into GameManager","text":"<p>Let's make <code>JobSystem</code> a core component of our <code>GameManager</code>.</p> <p>Open <code>_Brain/Core/GameManager.cs</code> and modify it:</p> <ol> <li>Add <code>using Sigilborne.Utils;</code> at the top.</li> <li>Add a <code>JobSystem</code> property.</li> <li>Initialize <code>JobSystem</code> in <code>InitializeSystems()</code>, passing the <code>EventBus</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Utils; // Add this using directive\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; }\n    public TransformSystem Transforms { get; private set; }\n    public JobSystem Jobs { get; private set; } // Add JobSystem property\n\n    public override void _Ready()\n    {\n        if (Instance != null)\n        {\n            GD.PrintErr(\"GameManager: More than one instance detected! Destroying duplicate.\");\n            QueueFree();\n            return;\n        }\n        Instance = this;\n\n        InitializeSystems();\n\n        GD.Print(\"GameManager (C#) initialized and ready.\");\n\n        // --- Test Scene Loading ---\n        if (SceneLoader.instance != null)\n        {\n            GD.Print(\"GameManager: Requesting SceneLoader to load Gameplay scene.\");\n            SceneLoader.instance.load_level(\"res://_Body/Scenes/Gameplay.tscn\");\n        }\n        else\n        {\n            GD.PrintErr(\"GameManager: SceneLoader instance not found! Cannot load gameplay scene.\");\n        }\n        // --- End Test Scene Loading ---\n\n        // --- Test Entity Management &amp; Components ---\n        GD.Print(\"\\n--- Testing Entity Management &amp; Components ---\");\n        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, \"player_default\");\n        GD.Print($\"Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        Transforms.TrySetTransform(playerEntity, new TransformComponent(new Vector2(100, 50), 45f));\n        if (Transforms.TryGetTransform(playerEntity, out TransformComponent playerTransform))\n        {\n            GD.Print($\"Player {playerEntity} Transform: {playerTransform}\");\n        }\n\n        ref TransformComponent playerTransformRef = ref Transforms.GetTransformRef(playerEntity);\n        playerTransformRef.Position = new Vector2(150, 75);\n        playerTransformRef.RotationDegrees = 90f;\n        GD.Print($\"Player {playerEntity} New Transform (via ref): {Transforms.GetTransformRef(playerEntity)}\");\n\n        Entities.DestroyEntity(playerEntity);\n        GD.Print($\"Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        if (!Transforms.TryGetTransform(playerEntity, out TransformComponent destroyedTransform))\n        {\n            GD.Print($\"Attempted to get transform for destroyed entity {playerEntity}, it correctly failed.\");\n        }\n\n        GD.Print(\"--- End Testing Entity Management &amp; Components ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Time.Tick(delta);\n        Events.FlushCommands(); // This processes the _mainThreadCompletionQueue from JobSystem\n        World.Tick(delta);\n        Transforms.Tick(delta);\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events); // Initialize JobSystem here\n        GD.Print(\"  - JobSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"07-chapter-7/#5-creating-and-scheduling-a-test-job","title":"5. Creating and Scheduling a Test Job","text":"<p>Let's create a simple test job to demonstrate multithreaded processing and main thread completion.</p> <p>First, define a simple <code>TestJob</code> struct in <code>_Brain/Utils/TestJob.cs</code>:</p> <pre><code>// _Brain/Utils/TestJob.cs\nusing Godot;\nusing System;\nusing System.Threading; // For Thread.Sleep\n\nnamespace Sigilborne.Utils\n{\n    /// &lt;summary&gt;\n    /// A simple job that performs a long-running calculation on a background thread.\n    /// &lt;/summary&gt;\n    public struct TestJob : IJob\n    {\n        public string JobName;\n        public int Iterations;\n        public double StartTime; // To measure duration\n\n        public void Execute()\n        {\n            GD.Print($\"[Job:{JobName}] Starting job on background thread... (Main Thread Time: {GameManager.Instance.Time.CurrentGameTime:F2})\");\n            double sum = 0;\n            for (int i = 0; i &lt; Iterations; i++)\n            {\n                sum += Math.Sqrt(i); // Simulate some computation\n                // Simulate a delay (DO NOT USE Thread.Sleep in real jobs, this is just for demo)\n                // Thread.Sleep(1);\n            }\n            GD.Print($\"[Job:{JobName}] Finished computation. Sum: {sum:F2}\");\n        }\n    }\n}\n</code></pre> <p>Now, schedule this job in <code>GameManager._Ready()</code>, after all other initializations.</p> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method, after entity tests)\n// ...\n        // --- Testing JobSystem ---\n        GD.Print(\"\\n--- Testing JobSystem ---\");\n        Jobs.Schedule(new TestJob { JobName = \"HeavyCompute\", Iterations = 1_000_000, StartTime = Time.CurrentGameTime },\n            () =&gt; {\n                // This callback runs on the main thread after the job finishes.\n                GD.Print($\"[Main Thread] Job 'HeavyCompute' completed callback. (Main Thread Time: {Time.CurrentGameTime:F2})\");\n            });\n        GD.Print(\"[Main Thread] Scheduled 'HeavyCompute' job. Continuing main thread execution.\");\n\n        Jobs.Schedule(new TestJob { JobName = \"AnotherJob\", Iterations = 500_000, StartTime = Time.CurrentGameTime },\n            () =&gt; {\n                GD.Print($\"[Main Thread] Job 'AnotherJob' completed callback. (Main Thread Time: {Time.CurrentGameTime:F2})\");\n            });\n        GD.Print(\"[Main Thread] Scheduled 'AnotherJob' job. Continuing main thread execution.\");\n\n        GD.Print(\"--- End Testing JobSystem ---\\n\");\n// ...\n</code></pre> <p>Save all C# files and run <code>Main.tscn</code>.</p> <p>Expected Output:</p> <p>You should see output similar to this (timestamps will vary):</p> <pre><code>... (previous initializations and entity tests) ...\n\n--- Testing JobSystem ---\n[Main Thread] Scheduled 'HeavyCompute' job. Continuing main thread execution.\n[Main Thread] Scheduled 'AnotherJob' job. Continuing main thread execution.\n--- End Testing JobSystem ---\n\n[Job:HeavyCompute] Starting job on background thread... (Main Thread Time: 0.00)\n[Job:AnotherJob] Starting job on background thread... (Main Thread Time: 0.00)\n[Job:HeavyCompute] Finished computation. Sum: 210818.00\n[Job:AnotherJob] Finished computation. Sum: 70709.00\n[Main Thread] Job 'HeavyCompute' completed callback. (Main Thread Time: 2.01)\n[Main Thread] Job 'AnotherJob' completed callback. (Main Thread Time: 2.01)\n</code></pre> <p>Key Observations:</p> <ul> <li>The <code>[Main Thread] Scheduled...</code> messages appear immediately, showing that the main thread continues without waiting.</li> <li>The <code>[Job:...] Starting...</code> messages appear after the main thread, indicating the jobs started on background threads.</li> <li>The <code>[Job:...] Finished...</code> messages appear before the <code>[Main Thread] Job '...' completed callback</code> messages. This is because the job finishes on its background thread, then enqueues its callback to the main thread's <code>EventBus</code> command buffer, which is flushed in <code>_PhysicsProcess</code>.</li> <li>The <code>Main Thread Time</code> in the callbacks will be slightly later than when the jobs started, as time passed during the background computation.</li> </ul> <p>This demonstrates that our Job System successfully offloads work to background threads and safely processes completion callbacks on the main thread, respecting Godot's threading model.</p>"},{"location":"07-chapter-7/#summary","title":"Summary","text":"<p>You have successfully implemented the core <code>JobSystem</code> for Sigilborne, enabling multithreaded processing for heavy computations. By defining the <code>IJob</code> interface and integrating <code>JobSystem</code> with the <code>EventBus</code>, you've established a robust mechanism for offloading tasks to background threads while ensuring safe main thread synchronization through command buffers. This adheres strictly to TDD 13's specifications, providing a critical foundation for scalable performance in our simulation-heavy game.</p>"},{"location":"07-chapter-7/#next-steps","title":"Next Steps","text":"<p>With the Job System in place, the next chapter will focus on standardizing how Godot Scenes are composed and how <code>EntityView.gd</code> acts as the crucial communication bridge between our C# Brain and GDScript Body, ensuring visual data is always reactive and decoupled from simulation logic.</p>"},{"location":"08-chapter-8/","title":"Chapter 1.8: Thread Safety - Command Buffers & Double Buffering","text":""},{"location":"08-chapter-8/#chapter-18-thread-safety-command-buffers-double-buffering","title":"Chapter 1.8: Thread Safety - Command Buffers &amp; Double Buffering","text":"<p>In the previous chapter, we established the <code>JobSystem</code> for multithreaded processing. However, concurrency introduces complex challenges, primarily thread safety. Background threads cannot directly manipulate Godot's scene tree or the main simulation state without risking race conditions, crashes, or data corruption. This chapter details our strategies for safe multithreaded operations: the \"No-Node\" Rule, Command Buffers, and an introduction to Double Buffering, as specified in TDD 13.3.</p>"},{"location":"08-chapter-8/#1-the-no-node-rule-foundation-of-thread-safety","title":"1. The \"No-Node\" Rule: Foundation of Thread Safety","text":"<p>The most fundamental rule in our Brain &amp; Body architecture for thread safety is:</p> <p>Background Jobs (C#) MUST NEVER directly access Godot Nodes (GDScript or C#).</p> <ul> <li>Why?: Godot's API is generally not thread-safe. Accessing a <code>Node2D.position</code> or calling <code>Node.AddChild()</code> from a background thread can lead to undefined behavior, crashes, or corrupt the scene tree.</li> <li>What this means: Any code within an <code>IJob.Execute()</code> method, or any code called by it, must operate purely on C# data structures (structs, POCOs, thread-safe collections).</li> </ul> <p>If a job needs to affect something visual or part of the scene tree, it must do so indirectly via a message or command that is processed on the main thread.</p>"},{"location":"08-chapter-8/#2-command-buffers-safe-main-thread-updates","title":"2. Command Buffers: Safe Main Thread Updates","text":"<p>Command Buffers are our primary mechanism for background threads to request changes to the main game state or visuals.</p> <p>How it Works:</p> <ol> <li>Job (Background Thread): Performs its computation. When it needs to make a change that affects the main thread (e.g., spawn a visual entity, update an NPC's on-screen health bar, mark an entity as dead), it doesn't do it directly. Instead, it creates a small, serializable \"command\" (often an <code>Action</code> or a data struct) and adds it to a <code>ConcurrentQueue</code>.</li> <li>EventBus (Main Thread): Our <code>EventBus</code> (<code>_Brain/Core/EventBus.cs</code>) already has a <code>_commandBuffer</code> (<code>ConcurrentQueue&lt;Action&gt;</code>) and a <code>FlushCommands()</code> method. This is precisely what TDD 13.3 refers to for processing batched commands.</li> <li>Main Thread Execution: During <code>GameManager._PhysicsProcess()</code>, <code>EventBus.FlushCommands()</code> is called. This method dequeues and executes all pending commands, ensuring they run safely on the main thread.</li> </ol> <p>We already implemented this basic structure in Chapter 1.7. Let's ensure our <code>EventBus</code> is robust enough for this.</p> <p>Review <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot; // For GD.PrintErr in error handling\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing event Action definitions) ...\n\n        // TDD 01.3 specifies a ConcurrentQueue for batching events from Background Jobs.\n        // TDD 13.3 specifies this as the Command Buffer.\n        private ConcurrentQueue&lt;Action&gt; _commandBuffer = new ConcurrentQueue&lt;Action&gt;();\n\n        /// &lt;summary&gt;\n        /// Adds a command to be executed on the main thread during the next flush.\n        /// Used by background jobs or any code that needs to defer execution to the main thread.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"command\"&gt;The action to execute.&lt;/param&gt;\n        public void AddCommand(Action command)\n        {\n            _commandBuffer.Enqueue(command);\n        }\n\n        /// &lt;summary&gt;\n        /// Flushes all commands from the buffer, executing them on the main thread.\n        /// Called once per main thread tick (e.g., in GameManager._PhysicsProcess).\n        /// &lt;/summary&gt;\n        public void FlushCommands()\n        {\n            while (_commandBuffer.TryDequeue(out var command))\n            {\n                try\n                {\n                    command.Invoke();\n                }\n                catch (Exception e)\n                {\n                    // TDD 01.3: Error Handling - Listeners are wrapped in try/catch.\n                    // This ensures one command's error doesn't crash the entire flush.\n                    GD.PrintErr($\"EventBus: Error executing batched command: {e.Message}\\n{e.StackTrace}\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This <code>EventBus</code> setup correctly implements the command buffer pattern for safe main thread updates. Our <code>JobSystem.Schedule()</code> method already uses <code>_eventBus.AddCommand()</code> for job completion callbacks, so this pipeline is functional.</p>"},{"location":"08-chapter-8/#3-double-buffering-safe-readwrite-for-concurrent-state","title":"3. Double Buffering: Safe Read/Write for Concurrent State","text":"<p>For systems where background jobs need to read a state while simultaneously writing a new state (e.g., updating thousands of virtual agents in the <code>EcologyManager</code>), direct modification can lead to race conditions (job A reads old data while job B writes new data to the same location, leading to corrupted state).</p> <p>Double Buffering solves this by providing two copies of the state:</p> <ol> <li><code>State_Read</code> (Current): The authoritative state that all jobs and the main thread read from. This state is immutable during a frame/tick.</li> <li><code>State_Write</code> (Next): A buffer where background jobs write their changes.</li> <li>Swap: At a safe synchronization point (e.g., the end of the simulation tick on the main thread), <code>State_Read</code> is replaced with <code>State_Write</code>.</li> </ol> <p>This ensures that:</p> <ul> <li>All readers (jobs, main thread) always see a consistent, complete snapshot of the data.</li> <li>Writers (jobs) never interfere with readers.</li> </ul> <p>Example: Ecology Simulation (TDD 13.4)</p> <p>Let's illustrate how <code>EcologyManager</code> (which we'll implement later) might use double buffering for its <code>VirtualAgent</code> data.</p> <p>Conceptual <code>EcologyManager</code> (will be implemented in Module 7):</p> <pre><code>// _Brain/Systems/Ecology/EcologyManager.cs (Conceptual)\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading; // For Interlocked if needed for index swaps\n\nnamespace Sigilborne.Systems.Ecology\n{\n    // A simplified struct for a virtual agent\n    public struct VirtualAgent\n    {\n        public int DefID;\n        public Vector2 Pos; // Godot.Vector2 for simplicity\n        public float Health;\n        public float Hunger;\n    }\n\n    public class EcologyManager\n    {\n        // Two buffers for VirtualAgent data\n        private List&lt;VirtualAgent&gt;[] _agentBuffers = new List&lt;VirtualAgent&gt;[2];\n        private int _readBufferIndex = 0; // Index of the buffer currently being read from\n        private int _writeBufferIndex = 1; // Index of the buffer currently being written to\n\n        public EcologyManager()\n        {\n            _agentBuffers[0] = new List&lt;VirtualAgent&gt;();\n            _agentBuffers[1] = new List&lt;VirtualAgent&gt;();\n            // Initialize with some agents\n            _agentBuffers[0].Add(new VirtualAgent { DefID = 1, Pos = new Vector2(10, 10), Health = 100, Hunger = 50 });\n            _agentBuffers[0].Add(new VirtualAgent { DefID = 2, Pos = new Vector2(20, 20), Health = 80, Hunger = 60 });\n        }\n\n        /// &lt;summary&gt;\n        /// Returns the current read-only list of virtual agents.\n        /// Jobs will read from this.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;VirtualAgent&gt; GetReadAgents()\n        {\n            return _agentBuffers[_readBufferIndex];\n        }\n\n        /// &lt;summary&gt;\n        /// Returns the list where jobs should write their modified agents.\n        /// &lt;/summary&gt;\n        public List&lt;VirtualAgent&gt; GetWriteAgents()\n        {\n            // Clear the write buffer before jobs start writing to it\n            _agentBuffers[_writeBufferIndex].Clear();\n            return _agentBuffers[_writeBufferIndex];\n        }\n\n        /// &lt;summary&gt;\n        /// Swaps the read and write buffers. Called on the main thread after all jobs complete.\n        /// &lt;/summary&gt;\n        public void SwapBuffers()\n        {\n            // Atomically swap indices to prevent race conditions if multiple threads were involved\n            // For simple List swapping, direct assignment is fine if called from main thread.\n            int temp = _readBufferIndex;\n            _readBufferIndex = _writeBufferIndex;\n            _writeBufferIndex = temp;\n            GD.Print($\"EcologyManager: Swapped buffers. New read index: {_readBufferIndex}\");\n        }\n\n        // --- Example Job for Ecology Update ---\n        public struct EcologyUpdateJob : IJob\n        {\n            public IReadOnlyList&lt;VirtualAgent&gt; ReadAgents; // Read from here\n            public List&lt;VirtualAgent&gt; WriteAgents;      // Write to here\n            public int StartIndex;\n            public int EndIndex;\n\n            public void Execute()\n            {\n                for (int i = StartIndex; i &lt; EndIndex; i++)\n                {\n                    VirtualAgent agent = ReadAgents[i];\n                    // Simulate agent logic: move, get hungry\n                    agent.Pos += new Vector2(1, 0); // Simple movement\n                    agent.Hunger = Math.Min(100, agent.Hunger + 5); // Get hungrier\n                    WriteAgents.Add(agent); // Add to the write buffer\n                }\n                GD.Print($\"EcologyUpdateJob: Processed agents {StartIndex}-{EndIndex-1}.\");\n            }\n        }\n    }\n}\n</code></pre> <p>Conceptual Integration into <code>GameManager._PhysicsProcess</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (Conceptual _PhysicsProcess)\n// ...\n    public EcologyManager Ecology { get; private set; } // Add EcologyManager property\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing calls) ...\n\n        // --- Ecology Double Buffer Process (Conceptual) ---\n        // 1. Get the write buffer and clear it\n        List&lt;VirtualAgent&gt; writeBuffer = Ecology.GetWriteAgents();\n        // 2. Get the read buffer (snapshot of current state)\n        IReadOnlyList&lt;VirtualAgent&gt; readBuffer = Ecology.GetReadAgents();\n\n        // 3. Schedule jobs to process agents\n        int agentsPerJob = readBuffer.Count / Environment.ProcessorCount; // Divide work\n        for (int i = 0; i &lt; readBuffer.Count; i += agentsPerJob)\n        {\n            int startIndex = i;\n            int endIndex = Math.Min(i + agentsPerJob, readBuffer.Count);\n            Jobs.Schedule(new EcologyManager.EcologyUpdateJob\n            {\n                ReadAgents = readBuffer,\n                WriteAgents = writeBuffer,\n                StartIndex = startIndex,\n                EndIndex = endIndex\n            },\n            // The last job to complete would trigger the buffer swap\n            // This requires more complex job completion tracking for multiple jobs.\n            // For simplicity, let's assume one job for now or a simpler swap logic.\n            null // No direct callback here; swap happens after ALL jobs are done.\n            );\n        }\n\n        // 4. After all jobs *complete* (this is the tricky part for multiple jobs), swap buffers.\n        // A robust solution would involve a countdown latch or similar mechanism.\n        // For now, we'll just demonstrate the swap, assuming jobs are fast enough.\n        // In reality, you'd track job completion and then call swap.\n        // For this chapter, we're focusing on the *concept* of the buffers.\n        // Ecology.SwapBuffers(); // This would be called AFTER all jobs finish and their results are written.\n        // ...\n</code></pre> <p>Key Takeaways for Double Buffering:</p> <ul> <li>Snapshot Consistency: Jobs always operate on a consistent snapshot of the data.</li> <li>No Concurrent Writes to Same Location: Jobs write to a separate buffer, preventing direct write conflicts.</li> <li>Synchronization Point: The buffer swap is a single, atomic operation on the main thread, making the new state authoritative.</li> </ul>"},{"location":"08-chapter-8/#4-summary","title":"4. Summary","text":"<p>You have solidified your understanding of thread safety in Sigilborne's hybrid architecture. By strictly adhering to the \"No-Node\" Rule and implementing Command Buffers via the <code>EventBus</code>, you've created a safe pipeline for background jobs to communicate changes to the main thread. Furthermore, you've grasped the conceptual framework of Double Buffering, a critical strategy for managing concurrent read/write operations on shared data, particularly for large simulation sets like ecology. These principles, as detailed in TDD 13.3, are fundamental for building a performant and stable game.</p>"},{"location":"08-chapter-8/#next-steps","title":"Next Steps","text":"<p>With our thread safety mechanisms in place, the next chapter will focus on standardizing how Godot Scenes are composed and how <code>EntityView.gd</code> acts as the crucial communication bridge between our C# Brain and GDScript Body, ensuring visual data is always reactive and decoupled from simulation logic.</p>"},{"location":"09-chapter-9/","title":"Chapter 1.9: Scene Composition - Standardizing Godot Scenes","text":""},{"location":"09-chapter-9/#chapter-19-scene-composition-standardizing-godot-scenes","title":"Chapter 1.9: Scene Composition - Standardizing Godot Scenes","text":"<p>With our C# Brain's architecture taking shape, it's time to formalize how the GDScript Body visualizes its data. This chapter focuses on standardizing Godot Scene composition, particularly for entities, as outlined in TDD 16. The goal is to create a predictable, maintainable, and efficient structure where <code>EntityView.gd</code> acts as the sole communication point between the Brain's data and the Body's visuals. This prevents \"Scene Spaghetti\" and ensures a clean separation of concerns.</p>"},{"location":"09-chapter-9/#1-the-view-vs-controller-philosophy","title":"1. The \"View\" vs. \"Controller\" Philosophy","text":"<p>In our Brain &amp; Body architecture:</p> <ul> <li>Brain (C#): Is the Controller (and Model). It dictates what should happen.</li> <li>Body (GDScript): Is the View. It displays what is happening.</li> </ul> <p>This means Godot scenes and their scripts should primarily focus on:</p> <ul> <li>Visuals: Sprites, animations, particles, UI.</li> <li>Audio: Sound effects, music.</li> <li>Input Capture: Forwarding raw input to the Brain.</li> <li>Interpolation: Smoothly animating between Brain states.</li> </ul> <p>Scenes should NOT contain logic for:</p> <ul> <li>Calculating damage.</li> <li>Determining AI decisions.</li> <li>Managing inventory data.</li> <li>Storing authoritative game state (e.g., actual health values).</li> </ul>"},{"location":"09-chapter-9/#2-the-canonical-entity-root-hierarchy","title":"2. The Canonical Entity Root Hierarchy","text":"<p>TDD 16.2 provides a strict template for every active entity scene. This consistency is vital for systems that need to generically interact with entity visuals (e.g., <code>EntityManager</code> spawning, <code>VFXManager</code> attaching particles).</p> <p>Let's create a generic <code>EntityRoot</code> scene that other entity types (Player, NPC, Projectile) will inherit from or instantiate.</p> <ol> <li>In Godot, go to <code>Scene &gt; New Scene</code>.</li> <li>Add a <code>CharacterBody2D</code> as the root node.<ul> <li>Rename this node to <code>EntityRoot</code>.</li> <li>Reasoning: <code>CharacterBody2D</code> is ideal for entities that move and collide in 2D space, providing built-in <code>move_and_slide()</code> functionality.</li> </ul> </li> <li>As a child of <code>EntityRoot</code>, add a <code>Node2D</code>.<ul> <li>Rename this node to <code>Visuals</code>.</li> <li>Reasoning: This node will contain all visual elements (sprites, animations). Rotating or flipping this node will affect all visuals without changing the <code>CharacterBody2D</code>'s collision or physics.</li> </ul> </li> <li>As a child of <code>Visuals</code>, add a <code>Sprite2D</code>.<ul> <li>Rename this node to <code>Sprite</code>.</li> <li>Reasoning: The main visual representation.</li> </ul> </li> <li>As a child of <code>Visuals</code>, add another <code>Node2D</code>.<ul> <li>Rename this node to <code>VFX</code>.</li> <li>Reasoning: A dedicated attachment point for particle effects, ensuring they move and rotate with the main visual.</li> </ul> </li> <li>As a child of <code>EntityRoot</code>, add a <code>CollisionShape2D</code>.<ul> <li>Rename this node to <code>Collision</code>.</li> <li>Reasoning: Defines the entity's physical collision bounds. You'll need to assign a <code>Shape2D</code> (e.g., <code>RectangleShape2D</code>, <code>CapsuleShape2D</code>) to it in the Inspector.</li> </ul> </li> <li>As a child of <code>EntityRoot</code>, add a <code>Node2D</code>.<ul> <li>Rename this node to <code>Audio</code>.</li> <li>Reasoning: A dedicated attachment point for <code>AudioStreamPlayer2D</code> nodes, allowing sounds to originate from the entity's position.</li> </ul> </li> <li>As a child of <code>EntityRoot</code>, add a <code>Control</code> node.<ul> <li>Rename this node to <code>UI</code>.</li> <li>Reasoning: An attachment point for UI elements like health bars, name tags, or interaction prompts, ensuring they stay positioned relative to the entity.</li> </ul> </li> </ol> <p>Your scene tree for <code>EntityRoot.tscn</code> should look like this:</p> <pre><code>EntityRoot (CharacterBody2D)\n\u251c\u2500\u2500 Visuals (Node2D)\n\u2502   \u251c\u2500\u2500 Sprite (Sprite2D)\n\u2502   \u2514\u2500\u2500 VFX (Node2D)\n\u251c\u2500\u2500 Collision (CollisionShape2D)\n\u251c\u2500\u2500 Audio (Node2D)\n\u2514\u2500\u2500 UI (Control)\n</code></pre> <p>Save this scene as <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</p>"},{"location":"09-chapter-9/#3-script-responsibilities-entityviewgd","title":"3. Script Responsibilities: <code>EntityView.gd</code>","text":"<p>TDD 16.2 explicitly states: \"<code>EntityView.gd</code>: The ONLY script that talks to the Brain.\" This script is the entity's \"puppet master\" in the Body, listening to C# signals and updating the visual scene.</p> <p>Create a new GDScript and attach it to the <code>EntityRoot</code> node in <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</p> <ol> <li>Select the <code>EntityRoot</code> node.</li> <li>Click the script icon in the Inspector.</li> <li>Create a new script:<ul> <li>Language: <code>GDScript</code>.</li> <li>Class Name: <code>EntityView</code>.</li> <li>Inherits: <code>CharacterBody2D</code> (this should be auto-filled).</li> <li>Path: <code>res://_Body/Scripts/Visuals/EntityView.gd</code> (create <code>Visuals</code> folder if it doesn't exist).</li> <li>Click <code>Create</code>.</li> </ul> </li> </ol> <p>Open <code>EntityView.gd</code> and modify it:</p> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# --- Public Properties ---\n# The EntityID from the C# Brain that this visual representation corresponds to.\nvar entity_id: int = -1 # Store as int for simplicity, but conceptually it's EntityID.Index\n\n# --- Node References ---\n@onready var visuals: Node2D = $Visuals\n@onready var sprite: Sprite2D = $Visuals/Sprite\n# @onready var animation_player: AnimationPlayer = $Visuals/AnimationPlayer # Add this if you have an AnimationPlayer\n@onready var vfx_attachment_point: Node2D = $Visuals/VFX\n@onready var audio_attachment_point: Node2D = $Audio\n@onready var ui_attachment_point: Control = $UI\n\n# --- Visual Interpolation Parameters (TDD 16.4) ---\n# The target position received from the Brain.\nvar brain_target_position: Vector2 = Vector2.ZERO\n# The smoothing speed for visual interpolation.\nconst SMOOTHING_SPEED: float = 10.0 # Adjust as needed\n\n# --- Signals ---\n# This signal is emitted when an animation event occurs.\n# It's caught by the Brain (C#) via GameEvents.\nsignal anim_event(type: String, payload: Dictionary)\n\n\n## Initializes this EntityView with its corresponding C# EntityID.\n## This function is called by the C# Brain via the EventBus when an entity is spawned.\n## (TDD 16.4: The \"Setup\" Function)\nfunc setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:\n    entity_id = id\n    global_position = initial_position\n    brain_target_position = initial_position\n    visuals.rotation_degrees = initial_rotation\n\n    # Example: Set sprite texture based on definition_id\n    # var texture_path = \"res://_Body/Art/Characters/%s.png\" % definition_id\n    # if ResourceLoader.exists(texture_path):\n    #     sprite.texture = load(texture_path)\n    # else:\n    #     push_warning(\"EntityView: No sprite found for definition_id: %s\" % definition_id)\n\n    GD.print(\"EntityView: Setup for C# EntityID %s (Def: %s) at %s\" % [entity_id, definition_id, global_position])\n\n    # --- Connect to Brain Signals (TDD 16.4) ---\n    # We will establish these connections more formally in Chapter 1.12 (Interop Layer).\n    # For now, conceptual connections:\n    # GameManager.Instance.Events.Connect(\"entity_moved\", Callable(self, \"_on_entity_moved\"))\n    # GameManager.Instance.Events.Connect(\"entity_health_changed\", Callable(self, \"_on_entity_health_changed\"))\n    pass\n\n## Called every physics frame (fixed rate) to update the visual position.\n## (TDD 16.4: Visual Interpolation)\nfunc _physics_process(delta: float) -&gt; void:\n    # Interpolate towards the Brain's authoritative target position.\n    # We use global_position here to affect the CharacterBody2D directly.\n    global_position = global_position.lerp(brain_target_position, delta * SMOOTHING_SPEED)\n\n    # If this entity needs to send input to the Brain, it would do so here.\n    # Example: if entity_id == GameManager.Instance.Player.PlayerEntityID:\n    #    InputManager.instance.send_player_input_to_brain()\n    pass\n\n## Placeholder for reacting to C# entity movement signals.\n## This method would be connected to an event from the C# Brain.\nfunc _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if entity_id == id:\n        brain_target_position = new_position\n        visuals.rotation_degrees = new_rotation\n        # GD.print(\"EntityView %s: Received new position %s\" % [entity_id, new_position])\n</code></pre> <p>Explanation of <code>EntityView.gd</code>:</p> <ul> <li><code>entity_id: int</code>: This <code>EntityView</code> stores the <code>Index</code> of its corresponding C# <code>EntityID</code>.</li> <li><code>@onready var ...</code>: Efficiently gets references to child nodes.</li> <li><code>brain_target_position</code>: This <code>Vector2</code> stores the last authoritative position received from the C# Brain.</li> <li><code>_physics_process(delta: float)</code>: This is where <code>Visual Interpolation</code> happens (TDD 16.4). The <code>EntityView</code> smoothly moves towards <code>brain_target_position</code>, providing fluid visuals even if the C# Brain updates at a lower tick rate.</li> <li><code>setup(id: int, ...)</code>: This is the \"Setup\" function (TDD 16.4). The C# Brain will call this via the <code>EventBus</code> when it spawns a new entity, passing its <code>EntityID</code> and initial state.</li> <li><code>_on_entity_moved(...)</code>: A placeholder for a signal handler. In Chapter 1.12, we'll connect this to a C# event that the <code>TransformSystem</code> will emit.</li> </ul>"},{"location":"09-chapter-9/#4-integrating-entityview-with-the-c-brain","title":"4. Integrating EntityView with the C# Brain","text":"<p>For the <code>EntityView</code> to be useful, the C# Brain needs to: 1.  Emit events when entities are spawned, moved, or destroyed. 2.  The GDScript <code>EntityView</code> needs to listen to these events.</p> <p>We already set up <code>EntityManager</code> to emit <code>EntitySpawnedEvent</code> and <code>EntityDespawnedEvent</code>. We will modify <code>TransformSystem</code> to emit <code>EntityMovedEvent</code>.</p> <p>First, let's define the <code>EntityMovedEvent</code> struct in <code>_Brain/Entities/EntityManager.cs</code> so our <code>EventBus</code> can handle it:</p> <pre><code>// _Brain/Entities/EntityManager.cs (inside Sigilborne.Entities namespace)\n// ...\n        // --- Helper Events for Body Sync (TDD 11.4) ---\n        public struct EntitySpawnedEvent { public EntityID ID; public EntityType Type; public string DefinitionID; public Vector2 InitialPosition; public float InitialRotation; }\n        public struct EntityDespawnedEvent { public EntityID ID; }\n        public struct EntityMovedEvent { public EntityID ID; public Vector2 NewPosition; public float NewRotation; } // Add this struct\n    }\n}\n</code></pre> <p>Note: We updated <code>EntitySpawnedEvent</code> to include initial position and rotation, as the <code>EntityView.gd</code> <code>setup</code> function now expects it.</p> <p>Now, modify <code>_Brain/Systems/TransformSystem.cs</code> to emit this event:</p> <pre><code>// _Brain/Systems/TransformSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\n\nnamespace Sigilborne.Systems\n{\n    public class TransformSystem\n    {\n        private Dictionary&lt;EntityID, TransformComponent&gt; _transforms = new Dictionary&lt;EntityID, TransformComponent&gt;();\n        private EntityManager _entityManager;\n        private EventBus _eventBus; // Store EventBus reference\n\n        public TransformSystem(EntityManager entityManager, EventBus eventBus)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus; // Store EventBus reference\n            eventBus.OnEntitySpawned += OnEntitySpawned;\n            eventBus.OnEntityDespawned += OnEntityDespawned;\n            GD.Print(\"TransformSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityManager.EntitySpawnedEvent e)\n        {\n            // All entities get a TransformComponent by default for simplicity in this example\n            _transforms.Add(e.ID, new TransformComponent(e.InitialPosition, e.InitialRotation)); // Use initial position from event\n            GD.Print($\"TransformSystem: Added transform for {e.ID}\");\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            if (_transforms.ContainsKey(e.ID))\n            {\n                _transforms.Remove(e.ID);\n                GD.Print($\"TransformSystem: Removed transform for {e.ID}\");\n            }\n        }\n\n        // ... (TryGetTransform, TrySetTransform, GetTransformRef methods) ...\n\n        public void Tick(double delta)\n        {\n            // Example: Simple movement for all entities with a transform\n            foreach (var kvp in _transforms)\n            {\n                EntityID id = kvp.Key;\n                ref TransformComponent transform = ref _transforms.GetValueRef(id);\n\n                // Simulate simple movement for testing: move right\n                transform.Position += new Vector2(10 * (float)delta, 0); // Move 10 units/sec to the right\n                transform.RotationDegrees += 50 * (float)delta; // Rotate 50 degrees/sec\n\n                // TDD 11.4: Emit OnEntityMoved for Body sync\n                _eventBus.Publish(new EntityManager.EntityMovedEvent { ID = id, NewPosition = transform.Position, NewRotation = transform.RotationDegrees });\n            }\n        }\n    }\n}\n</code></pre> <p>Now, we need to adjust <code>GameManager.CreateEntity</code> to pass initial position and rotation.</p> <pre><code>// _Brain/Core/GameManager.cs (inside CreateEntity and test section)\n// ...\n        public EntityID CreateEntity(EntityType type, string definitionID, Vector2 initialPosition = default, float initialRotation = 0f)\n        {\n            if (_freeIndices.Count == 0)\n            {\n                GD.PrintErr(\"EntityManager: No free entity slots available!\");\n                return EntityID.Invalid;\n            }\n\n            int index = _freeIndices[_freeIndices.Count - 1];\n            _freeIndices.RemoveAt(_freeIndices.Count - 1);\n\n            _entityMetas[index].Generation++;\n            _entityMetas[index].IsActive = true;\n            _entityMetas[index].Type = type;\n            _entityMetas[index].DefinitionID = definitionID;\n\n            EntityID newId = new EntityID(index, _entityMetas[index].Generation);\n            GD.Print($\"EntityManager: Created {type} entity {newId} (Def: {definitionID})\");\n\n            // Publish with initial position and rotation\n            _eventBus.Publish(new EntitySpawnedEvent { ID = newId, Type = type, DefinitionID = definitionID, InitialPosition = initialPosition, InitialRotation = initialRotation });\n\n            return newId;\n        }\n// ...\n// Inside GameManager._Ready():\n// ...\n        // --- Test Entity Management &amp; Components ---\n        GD.Print(\"\\n--- Testing Entity Management &amp; Components ---\");\n        // Pass initial position and rotation\n        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, \"player_default\", new Vector2(200, 200), 0f);\n        GD.Print($\"Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        // The TransformSystem will pick up this initial position from the EntitySpawnedEvent.\n        // No need to manually set it here, as Transforms.TrySetTransform will override.\n        // Let's remove the manual set/get for playerTransform here to show event-driven init.\n        // The TransformSystem.Tick will then immediately start moving it.\n\n        EntityID npcEntity = Entities.CreateEntity(EntityType.NPC, \"goblin_grunt\", new Vector2(100, 100), 90f);\n        GD.Print($\"Created NPC: {npcEntity}. IsValid: {Entities.IsValid(npcEntity)}\");\n\n        Entities.DestroyEntity(playerEntity);\n        GD.Print($\"Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        if (!Transforms.TryGetTransform(playerEntity, out TransformComponent destroyedTransform))\n        {\n            GD.Print($\"Attempted to get transform for destroyed entity {playerEntity}, it correctly failed.\");\n        }\n\n        GD.Print(\"--- End Testing Entity Management &amp; Components ---\\n\");\n// ...\n</code></pre> <p>Finally, we need to modify <code>EventBus.cs</code> to declare the new event types.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities; // Add this using directive for EntityID, EntityType, Vector2\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing OnGameStateChanged event) ...\n\n        // Declare events for entity lifecycle and movement\n        public event Action&lt;EntityManager.EntitySpawnedEvent&gt; OnEntitySpawned;\n        public event Action&lt;EntityManager.EntityDespawnedEvent&gt; OnEntityDespawned;\n        public event Action&lt;EntityManager.EntityMovedEvent&gt; OnEntityMoved; // New event\n\n        private ConcurrentQueue&lt;Action&gt; _commandBuffer = new ConcurrentQueue&lt;Action&gt;();\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // Use specific event types for publishing\n            if (eventData is EntityManager.EntitySpawnedEvent spawnedEvent)\n            {\n                OnEntitySpawned?.Invoke(spawnedEvent);\n            }\n            else if (eventData is EntityManager.EntityDespawnedEvent despawnedEvent)\n            {\n                OnEntityDespawned?.Invoke(despawnedEvent);\n            }\n            else if (eventData is EntityManager.EntityMovedEvent movedEvent) // New condition\n            {\n                OnEntityMoved?.Invoke(movedEvent);\n            }\n            else if (eventData is string gameState) // Existing example\n            {\n                OnGameStateChanged?.Invoke(gameState);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"09-chapter-9/#5-connecting-the-body-to-the-brains-events-conceptually","title":"5. Connecting the Body to the Brain's Events (Conceptually)","text":"<p>The actual connection between C# <code>Action</code> delegates and GDScript signals is handled by the Interop Layer (Chapter 1.12). For now, conceptually, <code>EntityView.gd</code> would connect to these events.</p> <p>We can illustrate this by adding a placeholder <code>EntityViewManager.gd</code> to manage the spawning and despawning of <code>EntityView</code> scenes.</p> <p>Create <code>res://_Body/Scripts/Visuals/EntityViewManager.gd</code>:</p> <pre><code># _Body/Scripts/Visuals/EntityViewManager.gd\nclass_name EntityViewManager extends Node\n\n# --- Singleton Instance ---\nstatic var instance: EntityViewManager\n\n# Dictionary to hold active EntityView instances, mapped by C# EntityID.Index\nvar _active_entity_views: Dictionary = {}\n\n# Preload our generic EntityRoot scene\nconst ENTITY_ROOT_SCENE: PackedScene = preload(\"res://_Body/Scenes/Entities/EntityRoot.tscn\")\n\nfunc _init():\n    if instance != null:\n        push_error(\"EntityViewManager: More than one instance detected!\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    # Connect to C# Events from GameManager.Instance.Events (will be done in Chapter 1.12)\n    # For now, we'll simulate the connection.\n    GD.print(\"EntityViewManager: Initialized. Waiting for C# entity events.\")\n    # This is a conceptual connection. In Chapter 1.12, we'll write the C# side to expose these.\n    # GameManager.Instance.Events.OnEntitySpawned += Callable(self, \"_on_entity_spawned\")\n    # GameManager.Instance.Events.OnEntityDespawned += Callable(self, \"_on_entity_despawned\")\n    # GameManager.Instance.Events.OnEntityMoved += Callable(self, \"_on_entity_moved\")\n    pass\n\n## Handler for C# EntitySpawnedEvent.\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if ENTITY_ROOT_SCENE == null:\n        push_error(\"EntityViewManager: ENTITY_ROOT_SCENE not loaded!\")\n        return\n\n    var entity_view: EntityView = ENTITY_ROOT_SCENE.instantiate()\n    add_child(entity_view) # Add to the scene tree\n\n    # Call the setup function on the EntityView\n    entity_view.setup(id, initial_position, initial_rotation, definition_id)\n\n    _active_entity_views[id] = entity_view\n    GD.print(\"EntityViewManager: Spawned visual for C# EntityID %s (Type: %s)\" % [id, type])\n\n## Handler for C# EntityDespawnedEvent.\nfunc _on_entity_despawned(id: int) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.queue_free() # Remove from scene tree\n        _active_entity_views.erase(id)\n        GD.print(\"EntityViewManager: Despawned visual for C# EntityID %s\" % id)\n    else:\n        push_warning(\"EntityViewManager: Attempted to despawn non-existent visual for C# EntityID %s\" % id)\n\n## Handler for C# EntityMovedEvent.\nfunc _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.brain_target_position = new_position\n        entity_view.visuals.rotation_degrees = new_rotation # Directly set rotation for now. Interpolation can be added later.\n    # else:\n        # push_warning(\"EntityViewManager: Received move event for non-existent visual for C# EntityID %s\" % id)\n</code></pre> <p>Now, add <code>EntityViewManager</code> to <code>Main.tscn</code> as a child of <code>Main</code>:</p> <pre><code>Main (Node)\n\u251c\u2500\u2500 GameManager (GameManager.cs)\n\u251c\u2500\u2500 SceneLoader (SceneLoader.gd)\n\u2514\u2500\u2500 EntityViewManager (EntityViewManager.gd)\n</code></pre> <p>Finally, let's test this.</p> <ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> </ol> <p>Expected Output:</p> <ul> <li>The game will load <code>Gameplay.tscn</code>.</li> <li>In the Output console, you'll see:<ul> <li><code>EntityViewManager: Spawned visual for C# EntityID 0 (Type: 0)</code> (Player)</li> <li><code>EntityViewManager: Spawned visual for C# EntityID 1 (Type: 1)</code> (NPC)</li> <li><code>EntityViewManager: Despawned visual for C# EntityID 0</code> (Player)</li> </ul> </li> <li>On the <code>Gameplay.tscn</code> scene, you should see one <code>EntityRoot</code> (the NPC) moving to the right and rotating. The player entity will briefly appear and then be removed.</li> </ul> <p>This confirms the <code>EntityViewManager</code> is correctly spawning and despawning <code>EntityView</code> instances based on C# events, and the <code>TransformSystem</code> is driving their movement.</p>"},{"location":"09-chapter-9/#summary","title":"Summary","text":"<p>You have successfully standardized Godot Scene composition for entities, defining a canonical <code>EntityRoot</code> hierarchy and implementing <code>EntityView.gd</code> as the dedicated communication interface for the Body. By integrating <code>EntityViewManager.gd</code> to dynamically spawn, manage, and despawn these visual representations based on C# events, you've established a robust, reactive presentation layer that adheres strictly to TDD 16's specifications. This setup ensures a clean separation between simulation logic and visual feedback, paving the way for efficient development and high performance.</p>"},{"location":"09-chapter-9/#next-steps","title":"Next Steps","text":"<p>In the next chapter, we will formalize our naming conventions across all project assets and scripts, ensuring consistency and readability, which are crucial for maintaining a large-scale project like Sigilborne.</p>"},{"location":"10-chapter-10/","title":"Chapter 1.10: Naming Conventions & Scene Interfaces","text":""},{"location":"10-chapter-10/#chapter-110-naming-conventions-scene-interfaces","title":"Chapter 1.10: Naming Conventions &amp; Scene Interfaces","text":"<p>Consistency in naming and structure is a hallmark of a professional, maintainable codebase. In Sigilborne, with its hybrid C# and GDScript architecture, strict adherence to conventions is even more critical to avoid confusion and streamline collaboration. This chapter formalizes the naming conventions for all files, classes, methods, variables, and nodes, as well as the basic interfaces for Godot Scenes, based on TDD 00 and TDD 16.</p>"},{"location":"10-chapter-10/#1-the-importance-of-naming-conventions","title":"1. The Importance of Naming Conventions","text":"<ul> <li>Readability: Code is read far more often than it's written. Clear, consistent names make it easier to understand intent.</li> <li>Maintainability: Reduces cognitive load when navigating a large project.</li> <li>Collaboration: Ensures all team members follow the same rules, preventing \"wild west\" naming.</li> <li>Tooling: Improves IDE autocompletion, search, and refactoring.</li> <li>Separation of Concerns: Naming helps reinforce which layer (Brain/Body) a file belongs to.</li> </ul>"},{"location":"10-chapter-10/#2-naming-conventions-the-canonical-rules","title":"2. Naming Conventions: The Canonical Rules","text":""},{"location":"10-chapter-10/#21-c-the-brain-tdd-00-tdd-011","title":"2.1. C# (The Brain) - TDD 00, TDD 01.1","text":"<ul> <li>Files/Classes (<code>.cs</code>): <code>PascalCase</code>.<ul> <li>Example: <code>GameManager.cs</code>, <code>TimeSystem.cs</code>, <code>SpellDefinition.cs</code>, <code>EntityID.cs</code>, <code>TransformComponent.cs</code>, <code>JobSystem.cs</code>.</li> </ul> </li> <li>Methods/Properties: <code>PascalCase</code>.<ul> <li>Example: <code>InitializeSystems()</code>, <code>CurrentGameTime</code>, <code>CreateEntity()</code>, <code>Execute()</code>.</li> </ul> </li> <li>Local Variables/Method Parameters: <code>camelCase</code>.<ul> <li>Example: <code>double delta</code>, <code>string definitionID</code>, <code>int index</code>.</li> </ul> </li> <li>Structs: <code>PascalCase</code>.<ul> <li>Example: <code>InputFrame</code>, <code>EntityMeta</code>, <code>TestJob</code>.</li> </ul> </li> <li>Enums: <code>PascalCase</code>.<ul> <li>Example: <code>GlyphType</code>, <code>CastState</code>, <code>EntityType</code>.</li> </ul> </li> <li>Interfaces: <code>IPascalCase</code> (starting with <code>I</code>).<ul> <li>Example: <code>IJob</code>.</li> </ul> </li> <li>Namespaces: <code>PascalCase</code>, typically <code>Sigilborne.Subsystem</code>.<ul> <li>Example: <code>Sigilborne.Core</code>, <code>Sigilborne.Entities</code>, <code>Sigilborne.Entities.Components</code>, <code>Sigilborne.Systems</code>, <code>Sigilborne.Utils</code>.</li> </ul> </li> </ul>"},{"location":"10-chapter-10/#22-gdscript-the-body-tdd-00-tdd-162","title":"2.2. GDScript (The Body) - TDD 00, TDD 16.2","text":"<ul> <li>Files/Classes (<code>.gd</code>) (custom types): <code>PascalCase</code> using <code>class_name</code>.<ul> <li>Example: <code>SceneLoader.gd</code>, <code>EntityView.gd</code>, <code>InputManager.gd</code>.</li> </ul> </li> <li>Variables/Functions: <code>snake_case</code>.<ul> <li>Example: <code>var current_health: float</code>, <code>func play_animation(anim_name: String)</code>.</li> </ul> </li> <li>Signals: <code>snake_case</code>.<ul> <li>Example: <code>signal scene_loaded</code>, <code>signal anim_event</code>.</li> </ul> </li> <li>Node Paths (in code): <code>PascalCase</code> matching the scene tree.<ul> <li>Example: <code>$Visuals/Sprite</code>, <code>get_node(\"MainCamera\")</code>.</li> </ul> </li> <li>Typing: ALWAYS use static typing (<code>var health: float = 100.0</code>). This is a hard rule.</li> <li>Constants: <code>SCREAMING_SNAKE_CASE</code>.<ul> <li>Example: <code>const SMOOTHING_SPEED: float = 10.0</code>, <code>const MAX_HEALTH: int = 100</code>.</li> </ul> </li> </ul>"},{"location":"10-chapter-10/#23-godot-assets-scenes-resources-art-tdd-161","title":"2.3. Godot Assets (Scenes, Resources, Art) - TDD 16.1","text":"<ul> <li>Scenes (<code>.tscn</code>): <code>PascalCase</code>.<ul> <li>Example: <code>PlayerCharacter.tscn</code>, <code>IronSword.tscn</code>, <code>MainMenu.tscn</code>, <code>Gameplay.tscn</code>, <code>EntityRoot.tscn</code>.</li> </ul> </li> <li>Resources (<code>.tres</code>, <code>.res</code>): <code>PascalCase</code>.<ul> <li>Example: <code>PlayerStats.tres</code>, <code>FireballEffect.tres</code>, <code>DefaultMaterial.tres</code>.</li> </ul> </li> <li>Art Assets (<code>.png</code>, <code>.wav</code>, <code>.ogg</code>, <code>.shader</code>, <code>.material</code>, etc.): <code>snake_case</code>.<ul> <li>Example: <code>icon_fire_ball.png</code>, <code>sfx_footstep_grass.wav</code>, <code>bgm_forest_loop.ogg</code>, <code>shader_water_flow.gdshader</code>.</li> </ul> </li> <li>Nodes in Scene Tree: <code>PascalCase</code>.<ul> <li>Functional/Generic Nodes: <code>Sprite</code>, <code>CollisionShape2D</code>, <code>AnimationPlayer</code>.</li> <li>Unique/Specific Nodes: <code>MainCamera</code>, <code>WorldEnvironment</code>, <code>PlayerCharacter</code>, <code>EnemyGoblin</code>.</li> <li>Our EntityRoot children: <code>Visuals</code>, <code>Sprite</code>, <code>VFX</code>, <code>Collision</code>, <code>Audio</code>, <code>UI</code>.</li> </ul> </li> </ul>"},{"location":"10-chapter-10/#3-scene-interfaces-the-setup-function","title":"3. Scene Interfaces: The \"Setup\" Function","text":"<p>TDD 16.4 introduces the concept of a \"Setup\" function for scenes. This is a standardized way for the C# Brain to initialize a newly spawned GDScript Body scene with its authoritative data.</p> <p>Rule: Every <code>EntityView.gd</code> (or similar top-level script on a visual entity scene) MUST have a <code>setup()</code> function.</p> <ul> <li>Purpose: This function is called by the <code>EntityViewManager.gd</code> (which is reacting to a C# <code>EntitySpawnedEvent</code>) immediately after <code>instantiate()</code> and <code>add_child()</code>.</li> <li>Parameters: It should accept the necessary C# data (<code>id</code>, <code>initial_position</code>, <code>initial_rotation</code>, <code>definition_id</code>) to initialize its visual state.</li> <li>Example from <code>EntityView.gd</code> (Chapter 1.9):</li> </ul> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# ... (properties and node references) ...\n\n## Initializes this EntityView with its corresponding C# EntityID.\n## This function is called by the C# Brain via the EventBus when an entity is spawned.\n## (TDD 16.4: The \"Setup\" Function)\nfunc setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:\n    entity_id = id\n    global_position = initial_position\n    brain_target_position = initial_position\n    visuals.rotation_degrees = initial_rotation\n    # ... (set sprite, etc.) ...\n</code></pre> <p>This <code>setup()</code> function acts as a formal contract between the Brain's data and the Body's visual initialization.</p>"},{"location":"10-chapter-10/#4-visual-interpolation-smoothness-in-the-body","title":"4. Visual Interpolation: Smoothness in the Body","text":"<p>TDD 16.4 also highlights visual interpolation. This is a core responsibility of the Body to ensure smooth animations even if the Brain updates at a lower tick rate.</p> <p>Rule: <code>EntityView.gd</code> (and similar scripts for moving visuals) MUST interpolate their <code>global_position</code> towards a <code>brain_target_position</code>.</p> <ul> <li>Mechanism: The <code>_physics_process()</code> (or <code>_process()</code> for non-physics-based movement) method is used to <code>lerp()</code> (linear interpolate) the current visual position towards the last authoritative position received from the Brain.</li> <li>Example from <code>EntityView.gd</code> (Chapter 1.9):</li> </ul> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# ... (properties) ...\nvar brain_target_position: Vector2 = Vector2.ZERO\nconst SMOOTHING_SPEED: float = 10.0\n\nfunc _physics_process(delta: float) -&gt; void:\n    global_position = global_position.lerp(brain_target_position, delta * SMOOTHING_SPEED)\n    # ...\n</code></pre> <p>This ensures that even if the C# Brain sends position updates at 20Hz, the GDScript Body renders smooth movement at 60Hz or higher.</p>"},{"location":"10-chapter-10/#5-reviewing-our-current-project-against-standards","title":"5. Reviewing Our Current Project Against Standards","text":"<p>Let's do a quick check of our existing files to ensure they meet these standards.</p> <ul> <li>Directory Structure: Fully created in Chapter 1.4.</li> <li>C# Naming:<ul> <li><code>GameManager.cs</code>, <code>TimeSystem.cs</code>, <code>EventBus.cs</code>, <code>WorldSimulation.cs</code> (classes): PascalCase.</li> <li><code>EntityManager.cs</code>, <code>EntityID.cs</code>, <code>TransformComponent.cs</code>, <code>StateComponent.cs</code> (classes/structs): PascalCase.</li> <li><code>IJob.cs</code>, <code>TestJob.cs</code>, <code>JobSystem.cs</code> (interface/struct/class): PascalCase, <code>IJob</code> starts with I.</li> <li>All internal methods/properties/variables follow PascalCase/camelCase.</li> <li>Namespaces <code>Sigilborne.Core</code>, <code>Sigilborne.Entities</code>, <code>Sigilborne.Entities.Components</code>, <code>Sigilborne.Systems</code>, <code>Sigilborne.Utils</code> are PascalCase. All good.</li> </ul> </li> <li>GDScript Naming:<ul> <li><code>SceneLoader.gd</code>, <code>EntityView.gd</code>, <code>EntityViewManager.gd</code> (class_name): PascalCase.</li> <li>Variables/functions like <code>_active_entity_views</code>, <code>_on_entity_spawned</code>, <code>brain_target_position</code>, <code>SMOOTHING_SPEED</code> (constants) follow snake_case/SCREAMING_SNAKE_CASE. All good.</li> <li>Static typing is used in <code>EntityView.gd</code> and <code>SceneLoader.gd</code>. All good.</li> </ul> </li> <li>Scene Naming:<ul> <li><code>Main.tscn</code>, <code>Gameplay.tscn</code>, <code>EntityRoot.tscn</code> are PascalCase. All good.</li> </ul> </li> <li>Node Naming in <code>EntityRoot.tscn</code>:<ul> <li><code>EntityRoot</code>, <code>Visuals</code>, <code>Sprite</code>, <code>VFX</code>, <code>Collision</code>, <code>Audio</code>, <code>UI</code> are PascalCase. All good.</li> </ul> </li> <li>Scene Interfaces:<ul> <li><code>EntityView.gd</code> has <code>func setup(...)</code>. All good.</li> <li><code>EntityView.gd</code> has <code>brain_target_position</code> and <code>_physics_process</code> for interpolation. All good.</li> </ul> </li> </ul> <p>Our current project perfectly adheres to the defined standards. This early commitment to consistency will greatly simplify future development.</p>"},{"location":"10-chapter-10/#summary","title":"Summary","text":"<p>You have thoroughly reviewed and committed to the comprehensive naming conventions and scene interface standards for Sigilborne, as defined in TDD 00 and TDD 16. By understanding the rationale behind these rules and verifying their application in your existing codebase, you've reinforced the clarity, maintainability, and scalability of your hybrid Godot/C# project. The <code>setup()</code> function and visual interpolation mechanisms in <code>EntityView.gd</code> now serve as formal contracts between the C# Brain's data and the GDScript Body's presentation.</p>"},{"location":"10-chapter-10/#next-steps","title":"Next Steps","text":"<p>The next chapter will delve into the Animation Event Protocol, a critical system for synchronizing complex animations in the GDScript Body with the precise logic in the C# Brain, ensuring that visual events (like a weapon's \"hit frame\") accurately trigger simulation events.</p>"},{"location":"11-chapter-11/","title":"Chapter 1.11: Animation Event Protocol - Syncing Brain & Body","text":""},{"location":"11-chapter-11/#chapter-111-animation-event-protocol-syncing-brain-body","title":"Chapter 1.11: Animation Event Protocol - Syncing Brain &amp; Body","text":"<p>In a game like Sigilborne, where combat is systemic and timing-sensitive, precise synchronization between visual animations (Body) and simulation logic (Brain) is crucial. A sword swing's \"hit frame\" must trigger damage calculation in the C# Brain at the exact moment the animation visually connects. This chapter implements the Animation Event Protocol, a strict standard for using Godot's <code>AnimationPlayer</code> to emit signals that the Brain can interpret, as detailed in TDD 16.5.</p>"},{"location":"11-chapter-11/#1-the-challenge-of-animation-synchronization","title":"1. The Challenge of Animation Synchronization","text":"<ul> <li>Decoupling: The Brain doesn't know about <code>AnimationPlayer</code> nodes. The Body plays animations.</li> <li>Precision: We need to trigger C# logic (e.g., \"activate hitbox,\" \"spawn projectile\") at specific frames of an animation.</li> <li>Reliability: The communication must be robust and thread-safe.</li> </ul> <p>Our solution is to use Godot's built-in <code>AnimationPlayer</code> functionality to emit custom signals, which our <code>EntityView.gd</code> script will then forward to the C# Brain via our <code>EventBus</code>.</p>"},{"location":"11-chapter-11/#2-the-signal-standard-anim_eventtype-string-payload-dictionary","title":"2. The Signal Standard: <code>anim_event(type: String, payload: Dictionary)</code>","text":"<p>TDD 16.5 specifies a standard signal format for animation events:</p> <ul> <li>Signal Name: <code>anim_event</code> (declared in <code>EntityView.gd</code>).</li> <li>Parameter 1 (<code>type: String</code>): A string identifying the type of event (e.g., <code>\"hit_frame\"</code>, <code>\"footstep\"</code>, <code>\"cast_release\"</code>).</li> <li>Parameter 2 (<code>payload: Dictionary</code>): A dictionary containing any additional data relevant to the event (e.g., <code>{\"hitbox_id\": \"sword_slash_01\"}</code>, <code>{\"socket\": \"right_hand\"}</code>).</li> </ul> <p>This generic format allows us to handle a wide range of animation-driven events with a single signal.</p>"},{"location":"11-chapter-11/#3-modifying-entityviewgd-to-emit-animation-events","title":"3. Modifying <code>EntityView.gd</code> to Emit Animation Events","text":"<p>Our <code>EntityView.gd</code> script, attached to <code>EntityRoot.tscn</code>, will be the intermediary. It will listen for a generic <code>animation_finished</code> signal from an <code>AnimationPlayer</code> (if present) or specific <code>AnimationPlayer</code> track events, and then re-emit them using our standardized <code>anim_event</code> signal.</p> <p>First, let's update <code>EntityView.gd</code> to declare the <code>anim_event</code> signal and prepare to handle animation events.</p> <p>Open <code>res://_Body/Scripts/Visuals/EntityView.gd</code>:</p> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# ... (existing properties) ...\n\n# --- Node References ---\n@onready var visuals: Node2D = $Visuals\n@onready var sprite: Sprite2D = $Visuals/Sprite\n@onready var animation_player: AnimationPlayer = null # Initialize as null, find in _ready if exists\n@onready var vfx_attachment_point: Node2D = $Visuals/VFX\n@onready var audio_attachment_point: Node2D = $Audio\n@onready var ui_attachment_point: Control = $UI\n\n# ... (existing interpolation parameters) ...\n\n# --- Signals (TDD 16.5) ---\n# This signal is emitted when an animation event occurs.\n# It's caught by the Brain (C#) via GameEvents.\nsignal anim_event(type: String, payload: Dictionary)\n\n\n## Initializes this EntityView with its corresponding C# EntityID.\nfunc setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:\n    entity_id = id\n    global_position = initial_position\n    brain_target_position = initial_position\n    visuals.rotation_degrees = initial_rotation\n\n    # Try to find an AnimationPlayer if it's a child of Visuals\n    # This assumes AnimationPlayer is a direct child of Visuals, which is a common pattern.\n    if visuals.has_node(\"AnimationPlayer\"):\n        animation_player = visuals.get_node(\"AnimationPlayer\")\n        # Connect to the AnimationPlayer's 'animation_changed' signal to react to new animations\n        # and 'animation_finished' for general animation completion.\n        # For specific frame events, we'll use AnimationPlayer's Call Method Track.\n        if animation_player != null:\n            animation_player.animation_finished.connect(Callable(self, \"_on_animation_finished\"))\n            GD.print(\"EntityView %s: Connected to AnimationPlayer.\" % entity_id)\n\n    GD.print(\"EntityView: Setup for C# EntityID %s (Def: %s) at %s\" % [entity_id, definition_id, global_position])\n    pass\n\n## Placeholder for reacting to C# entity movement signals.\nfunc _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if entity_id == id:\n        brain_target_position = new_position\n        visuals.rotation_degrees = new_rotation\n        # GD.print(\"EntityView %s: Received new position %s\" % [entity_id, new_position])\n\n# --- Animation Event Handlers ---\n\n## Generic handler for when any animation finishes playing.\nfunc _on_animation_finished(anim_name: String) -&gt; void:\n    # Example: Emit a generic 'animation_finished' event.\n    anim_event.emit(\"animation_finished\", {\"anim_name\": anim_name})\n    GD.print(\"EntityView %s: Animation '%s' finished.\" % [entity_id, anim_name])\n\n## This function will be called by an AnimationPlayer's Call Method Track.\n## (TDD 16.5: The Signal Standard)\n## @param type: String - The type of animation event (e.g., \"hit_frame\", \"footstep\").\n## @param payload: Dictionary - Additional data for the event.\nfunc _on_anim_track_event(type: String, payload: Dictionary) -&gt; void:\n    anim_event.emit(type, payload)\n    GD.print(\"EntityView %s: Emitted anim_event: Type '%s', Payload %s\" % [entity_id, type, payload])\n\n# --- Public Methods for Animation Control ---\n## Plays a specific animation on this entity's AnimationPlayer.\nfunc play_animation(anim_name: String, blend_time: float = -1, custom_speed: float = 1.0, from_end: bool = false) -&gt; void:\n    if animation_player != null and animation_player.has_animation(anim_name):\n        animation_player.play(anim_name, blend_time, custom_speed, from_end)\n        GD.print(\"EntityView %s: Playing animation '%s'.\" % [entity_id, anim_name])\n    else:\n        push_warning(\"EntityView %s: AnimationPlayer or animation '%s' not found.\" % [entity_id, anim_name])\n</code></pre> <p>Key Changes in <code>EntityView.gd</code>:</p> <ul> <li><code>@onready var animation_player</code>: Added to get a reference to the <code>AnimationPlayer</code> node.</li> <li><code>setup()</code>: Now checks for <code>AnimationPlayer</code> and connects its <code>animation_finished</code> signal.</li> <li><code>_on_animation_finished()</code>: A generic handler for when an animation completes.</li> <li><code>_on_anim_track_event(type: String, payload: Dictionary)</code>: This is the crucial method. It's designed to be called directly from an <code>AnimationPlayer</code> using a \"Call Method Track.\" It then emits our standardized <code>anim_event</code> signal.</li> <li><code>play_animation()</code>: A public method that other GDScript (or C# via interop) can call to trigger animations.</li> </ul>"},{"location":"11-chapter-11/#4-setting-up-animationplayer-tracks-in-entityroottscn","title":"4. Setting up <code>AnimationPlayer</code> Tracks in <code>EntityRoot.tscn</code>","text":"<p>Now, let's add an <code>AnimationPlayer</code> to our <code>EntityRoot.tscn</code> and configure it to emit events.</p> <ol> <li>Open <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</li> <li>Select the <code>Visuals</code> node.</li> <li>Add a child node: <code>AnimationPlayer</code>.<ul> <li>Rename it <code>AnimationPlayer</code>.</li> </ul> </li> <li>In the <code>AnimationPlayer</code> dock (usually at the bottom), click <code>Animation &gt; New</code>.<ul> <li>Name the new animation <code>test_attack</code>.</li> </ul> </li> <li>Set the animation <code>Length</code> to <code>1.0</code> seconds (or any duration).</li> <li>Click the \"Add Track\" button (the <code>+</code> icon).<ul> <li>Select <code>Call Method Track</code>.</li> <li>Click <code>Select Node</code> and choose <code>EntityRoot</code> (our <code>EntityView.gd</code> script is attached here).</li> <li>Click <code>Ok</code>.</li> </ul> </li> <li>In the <code>test_attack</code> animation timeline:<ul> <li>Move the timeline cursor to <code>0.5</code> seconds (this will be our \"hit frame\").</li> <li>Click the \"Add Key\" button (the diamond icon) on the <code>Call Method Track</code>.</li> <li>In the \"Insert Key\" dialog:<ul> <li>Method: Select <code>_on_anim_track_event</code>.</li> <li>Parameters: Click the <code>+</code> twice to add two parameters.<ul> <li>Parameter 0 (type <code>String</code>): Enter <code>\"hit_frame\"</code>.</li> <li>Parameter 1 (type <code>Dictionary</code>): Click <code>New Dictionary</code>. In the dictionary editor, add a key <code>hitbox_id</code> (String) with value <code>\"test_hitbox_01\"</code> (String).</li> </ul> </li> <li>Click <code>Ok</code>.</li> </ul> </li> </ul> </li> <li>Save <code>EntityRoot.tscn</code>.</li> </ol> <p>Now, when <code>test_attack</code> animation plays, at <code>0.5</code> seconds, it will call <code>EntityView._on_anim_track_event(\"hit_frame\", {\"hitbox_id\": \"test_hitbox_01\"})</code>, which then emits our <code>anim_event</code> signal.</p>"},{"location":"11-chapter-11/#5-conceptually-connecting-anim_event-to-the-c-brain","title":"5. Conceptually Connecting <code>anim_event</code> to the C# Brain","text":"<p>The <code>anim_event</code> signal is a GDScript signal. To reach the C# Brain, we need to connect it through our Interop Layer (Chapter 1.12). For now, we'll conceptually show how the C# side would subscribe.</p> <p>First, let's modify <code>_Brain/Entities/EntityManager.cs</code> to add a specific event struct for animation events.</p> <pre><code>// _Brain/Entities/EntityManager.cs (inside Sigilborne.Entities namespace)\n// ...\n        // --- Helper Events for Body Sync (TDD 11.4) ---\n        // ... (existing events) ...\n        public struct AnimationEvent { public EntityID ID; public string Type; public Dictionary&lt;string, Variant&gt; Payload; } // New event\n    }\n}\n</code></pre> <p>Note: <code>Variant</code> is Godot's universal type. Using <code>Dictionary&lt;string, Variant&gt;</code> here allows us to pass any GDScript dictionary payload.</p> <p>Now, modify <code>_Brain/Core/EventBus.cs</code> to publish this new event type:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing System.Collections.Generic; // For Dictionary&lt;string, Variant&gt;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing event Action definitions) ...\n        public event Action&lt;EntityManager.AnimationEvent&gt; OnAnimationEvent; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is EntityManager.AnimationEvent animEvent) // New condition\n            {\n                OnAnimationEvent?.Invoke(animEvent);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre> <p>Next, in our conceptual <code>EntityViewManager.gd</code> (which will eventually handle the actual <code>connect()</code> calls), we'd connect <code>EntityView.anim_event</code> to the C# <code>EventBus</code>.</p> <p>Conceptual <code>EntityViewManager.gd</code> (for context, no code change needed here yet):</p> <pre><code># _Body/Scripts/Visuals/EntityViewManager.gd (Conceptual)\n# ...\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    # ... (instantiate entity_view) ...\n    entity_view.setup(...)\n\n    # --- Conceptual Connection to C# Brain ---\n    # This connection will be handled in Chapter 1.12 (Interop Layer).\n    # For now, imagine GameManager.Instance.Events.Connect is the C# EventBus itself.\n    # The C# side will expose a method to connect to its Action&lt;AnimationEvent&gt; delegate.\n    # We would connect EntityView's anim_event to that C# method.\n    # entity_view.anim_event.connect(Callable(GameManager.Instance.Events, \"ReceiveAnimationEvent\"))\n\n    _active_entity_views[id] = entity_view\n# ...\n</code></pre>"},{"location":"11-chapter-11/#6-testing-the-animation-event-protocol","title":"6. Testing the Animation Event Protocol","text":"<p>To test this, we need to make <code>EntityViewManager.gd</code> play the <code>test_attack</code> animation.</p> <p>Modify <code>_Body/Scripts/Visuals/EntityViewManager.gd</code> to play an animation for the NPC shortly after it's spawned:</p> <pre><code># _Body/Scripts/Visuals/EntityViewManager.gd\nclass_name EntityViewManager extends Node\n\nstatic var instance: EntityViewManager\nvar _active_entity_views: Dictionary = {}\nconst ENTITY_ROOT_SCENE: PackedScene = preload(\"res://_Body/Scenes/Entities/EntityRoot.tscn\")\n\nfunc _init():\n    if instance != null:\n        push_error(\"EntityViewManager: More than one instance detected!\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    GD.print(\"EntityViewManager: Initialized. Waiting for C# entity events.\")\n    # For testing, we'll add a timer to play an animation after entities are spawned.\n    # This would normally be triggered by C# combat logic.\n    await get_tree().create_timer(3.0).timeout # Wait 3 seconds after scene loads\n\n    # Find an NPC entity view and play its attack animation\n    for id in _active_entity_views:\n        var entity_view: EntityView = _active_entity_views[id]\n        # Assuming we only have one NPC moving from previous chapter\n        if entity_view.entity_id == 1: # NPC entity has ID 1 from previous tests\n            entity_view.play_animation(\"test_attack\")\n            break\n    pass\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if ENTITY_ROOT_SCENE == null:\n        push_error(\"EntityViewManager: ENTITY_ROOT_SCENE not loaded!\")\n        return\n\n    var entity_view: EntityView = ENTITY_ROOT_SCENE.instantiate()\n    add_child(entity_view)\n\n    entity_view.setup(id, initial_position, initial_rotation, definition_id)\n\n    # Crucial: Connect the EntityView's anim_event signal to our manager's conceptual handler\n    # This allows EntityViewManager to \"catch\" events locally before forwarding to C#\n    entity_view.anim_event.connect(Callable(self, \"_on_entity_view_anim_event\"))\n\n    _active_entity_views[id] = entity_view\n    GD.print(\"EntityViewManager: Spawned visual for C# EntityID %s (Type: %s)\" % [id, type])\n\nfunc _on_entity_despawned(id: int) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.queue_free()\n        _active_entity_views.erase(id)\n        GD.print(\"EntityViewManager: Despawned visual for C# EntityID %s\" % id)\n    else:\n        push_warning(\"EntityViewManager: Attempted to despawn non-existent visual for C# EntityID %s\" % id)\n\nfunc _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.brain_target_position = new_position\n        entity_view.visuals.rotation_degrees = new_rotation\n\n## Conceptual handler for animation events from EntityView.\n## In Chapter 1.12, this is where we would forward the event to the C# EventBus.\nfunc _on_entity_view_anim_event(type: String, payload: Dictionary) -&gt; void:\n    GD.print(\"EntityViewManager: Caught anim_event from EntityView. Type: '%s', Payload: %s\" % [type, payload])\n    # Conceptual: GameManager.Instance.Events.Publish(new AnimationEvent { ID = entity_view.entity_id, Type = type, Payload = payload });\n    pass\n</code></pre> <p>Save all C# and GDScript files. Run <code>Main.tscn</code>.</p> <p>Expected Output:</p> <ol> <li>The game loads <code>Gameplay.tscn</code>.</li> <li>The NPC entity (ID 1) starts moving right and rotating.</li> <li>After ~3 seconds, you'll see in the Output console:<ul> <li><code>EntityView 1: Playing animation 'test_attack'.</code></li> <li>Then, shortly after (at the 0.5s mark of the animation):<ul> <li><code>EntityView 1: Emitted anim_event: Type 'hit_frame', Payload {hitbox_id:test_hitbox_01}</code></li> <li><code>EntityViewManager: Caught anim_event from EntityView. Type: 'hit_frame', Payload: {hitbox_id:test_hitbox_01}</code></li> </ul> </li> <li>Finally: <code>EntityView 1: Animation 'test_attack' finished.</code></li> <li><code>EntityViewManager: Caught anim_event from EntityView. Type: 'animation_finished', Payload: {anim_name:test_attack}</code></li> </ul> </li> </ol> <p>This confirms that: *   The <code>AnimationPlayer</code> is correctly configured to call <code>_on_anim_track_event</code>. *   <code>EntityView.gd</code> correctly emits its <code>anim_event</code> signal. *   <code>EntityViewManager.gd</code> correctly catches this signal.</p> <p>This pipeline is now ready for the formal C# to GDScript interop connection in the next chapter.</p>"},{"location":"11-chapter-11/#summary","title":"Summary","text":"<p>You have successfully implemented the Animation Event Protocol for Sigilborne, establishing a precise synchronization mechanism between visual animations in the GDScript Body and simulation logic in the C# Brain. By standardizing the <code>anim_event</code> signal and configuring <code>AnimationPlayer</code> tracks to call <code>EntityView.gd</code> methods, you've created a reliable pipeline for triggering simulation events (like \"hit frames\") at exact moments within animations, adhering to TDD 16.5's specifications.</p>"},{"location":"11-chapter-11/#next-steps","title":"Next Steps","text":"<p>The next crucial module will focus on the Interop Layer, where we will formalize the communication bridge between our C# Brain and GDScript Body, ensuring seamless and type-safe exchange of data and events.</p>"},{"location":"12-chapter-12/","title":"Chapter 1.12: Interop Layer - C# to GDScript Communication","text":""},{"location":"12-chapter-12/#chapter-112-interop-layer-c-to-gdscript-communication","title":"Chapter 1.12: Interop Layer - C# to GDScript Communication","text":"<p>The \"Interop Layer\" is the backbone of our hybrid architecture, enabling seamless communication between the C# Brain and the GDScript Body. TDD 01.3 specifies that the Brain does not call functions on the Body directly; instead, it emits Signals. This chapter will formalize how C# <code>Action&lt;T&gt;</code> delegates in our <code>EventBus</code> are exposed to GDScript, allowing GDScript to connect to them and react to state changes, strictly adhering to TDD 01.3's event bus contract.</p>"},{"location":"12-chapter-12/#1-understanding-the-interop-challenge","title":"1. Understanding the Interop Challenge","text":"<p>Godot's C# integration uses <code>P/Invoke</code> (Platform Invoke) to bridge the .NET runtime with the Godot engine's native C++ API. While C# can directly call GDScript methods using <code>Call()</code>, the TDD explicitly favors a signal-based approach for C# to GDScript communication.</p> <p>Why a Signal-Based Interop?</p> <ul> <li>Decoupling: The C# Brain doesn't need to know which GDScript node is listening or how it will react. It just broadcasts an event.</li> <li>Flexibility: Multiple GDScript nodes can listen to the same C# event, allowing for easy expansion (e.g., UI, VFX, Audio all react to <code>OnPlayerHealthChanged</code>).</li> <li>Thread Safety: Events emitted from the C# <code>EventBus</code> (which runs on the main thread during <code>FlushCommands()</code>) are safe for GDScript to receive and process.</li> <li>Maintainability: Clear separation of responsibilities.</li> </ul>"},{"location":"12-chapter-12/#2-exposing-c-events-to-gdscript","title":"2. Exposing C# Events to GDScript","text":"<p>Godot's C# binding allows GDScript to connect to C# delegates (events) that are exposed as <code>public event Action&lt;T&gt;</code>.</p> <p>Steps:</p> <ol> <li>Define C# <code>Action</code>s: Our <code>EventBus</code> already has these (e.g., <code>OnEntitySpawned</code>, <code>OnEntityMoved</code>).</li> <li>Make <code>EventBus</code> Accessible: The <code>GameManager</code> singleton makes <code>EventBus</code> globally accessible.</li> <li>GDScript Connection: GDScript uses <code>GameManager.Instance.Events.Connect(\"EventName\", Callable(self, \"_on_event_handler\"))</code>.</li> </ol> <p>Let's refine our <code>EventBus</code> and <code>GameManager</code> to make these connections as smooth as possible.</p>"},{"location":"12-chapter-12/#21-refine-eventbuscs-for-gdscript-compatibility","title":"2.1. Refine <code>EventBus.cs</code> for GDScript Compatibility","text":"<p>We need to ensure our <code>Action</code> parameters are simple types that Godot's C# binding can easily marshal to GDScript. <code>EntityID</code> is a struct, which works well. <code>Dictionary&lt;string, Variant&gt;</code> also works for payloads.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // --- C# to C# / C# to GDScript Events ---\n        // TDD 01.3: C# Action&lt;T&gt; delegates (Synchronous)\n        // These are public events that GDScript can connect to.\n\n        public event Action&lt;string&gt; OnGameStateChanged;\n\n        // Entity Lifecycle Events (TDD 11.4)\n        public event Action&lt;EntityID, EntityType, string, Vector2, float&gt; OnEntitySpawned; // Explicit parameters\n        public event Action&lt;EntityID&gt; OnEntityDespawned;\n        public event Action&lt;EntityID, Vector2, float&gt; OnEntityMoved;\n\n        // Animation Event (TDD 16.5)\n        public event Action&lt;EntityID, string, Dictionary&lt;string, Variant&gt;&gt; OnAnimationEvent; // Explicit parameters\n\n        // --- Command Buffer for Main Thread Execution (TDD 13.3) ---\n        private ConcurrentQueue&lt;Action&gt; _commandBuffer = new ConcurrentQueue&lt;Action&gt;();\n\n        /// &lt;summary&gt;\n        /// Publishes an event to all C# and GDScript subscribers.\n        /// GDScript connects to these events by name (e.g., \"OnEntitySpawned\").\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"TEvent\"&gt;The type of the event data struct.&lt;/typeparam&gt;\n        /// &lt;param name=\"eventData\"&gt;The event data struct.&lt;/param&gt;\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // The Publish method now explicitly unpacks event data structs\n            // and invokes the corresponding Action with individual parameters.\n            // This makes the GDScript connection cleaner (no need to unpack structs in GDScript).\n\n            if (eventData is EntityManager.EntitySpawnedEvent spawnedEvent)\n            {\n                OnEntitySpawned?.Invoke(spawnedEvent.ID, spawnedEvent.Type, spawnedEvent.DefinitionID, spawnedEvent.InitialPosition, spawnedEvent.InitialRotation);\n            }\n            else if (eventData is EntityManager.EntityDespawnedEvent despawnedEvent)\n            {\n                OnEntityDespawned?.Invoke(despawnedEvent.ID);\n            }\n            else if (eventData is EntityManager.EntityMovedEvent movedEvent)\n            {\n                OnEntityMoved?.Invoke(movedEvent.ID, movedEvent.NewPosition, movedEvent.NewRotation);\n            }\n            else if (eventData is EntityManager.AnimationEvent animEvent)\n            {\n                OnAnimationEvent?.Invoke(animEvent.ID, animEvent.Type, animEvent.Payload);\n            }\n            else if (eventData is string gameState)\n            {\n                OnGameStateChanged?.Invoke(gameState);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n\n        // ... (AddCommand and FlushCommands methods unchanged) ...\n    }\n}\n</code></pre> <p>Key Change: The <code>Publish&lt;TEvent&gt;</code> method now explicitly unpacks the event data structs (e.g., <code>EntityManager.EntitySpawnedEvent</code>) and invokes the corresponding <code>Action</code> with its individual parameters. This is crucial because Godot's <code>Connect</code> method for C# events maps to the parameters of the <code>Action</code>, not the struct itself.</p>"},{"location":"12-chapter-12/#22-update-entitymanagercs-to-reflect-entityspawnedevent-changes","title":"2.2. Update <code>EntityManager.cs</code> to reflect <code>EntitySpawnedEvent</code> changes","text":"<p>We made <code>EntitySpawnedEvent</code> include <code>InitialPosition</code> and <code>InitialRotation</code> in the previous chapter. The <code>EntityManager.CreateEntity</code> method needs to pass these values.</p> <p>Open <code>_Brain/Entities/EntityManager.cs</code> and ensure <code>CreateEntity</code> passes these:</p> <pre><code>// _Brain/Entities/EntityManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\n\nnamespace Sigilborne.Entities\n{\n    // ... (EntityID, EntityMeta, EntityType, EntityManager class) ...\n\n    public class EntityManager\n    {\n        // ... (MAX_ENTITIES, _entityMetas, _freeIndices, _eventBus) ...\n\n        public EntityManager(EventBus eventBus) { /* ... */ }\n\n        public EntityID CreateEntity(EntityType type, string definitionID, Vector2 initialPosition = default, float initialRotation = 0f)\n        {\n            // ... (slot allocation, generation increment, EntityMeta setup) ...\n\n            EntityID newId = new EntityID(index, _entityMetas[index].Generation);\n            GD.Print($\"EntityManager: Created {type} entity {newId} (Def: {definitionID})\");\n\n            // Publish with initial position and rotation\n            _eventBus.Publish(new EntitySpawnedEvent { ID = newId, Type = type, DefinitionID = definitionID, InitialPosition = initialPosition, InitialRotation = initialRotation });\n\n            return newId;\n        }\n\n        // ... (DestroyEntity, IsValid, GetEntityMeta methods) ...\n\n        // --- Helper Events for Body Sync (TDD 11.4) ---\n        // Note: These structs are just internal data carriers for the generic Publish method.\n        // The actual Action delegates in EventBus define the signature GDScript connects to.\n        public struct EntitySpawnedEvent { public EntityID ID; public EntityType Type; public string DefinitionID; public Vector2 InitialPosition; public float InitialRotation; }\n        public struct EntityDespawnedEvent { public EntityID ID; }\n        public struct EntityMovedEvent { public EntityID ID; public Vector2 NewPosition; public float NewRotation; }\n        public struct AnimationEvent { public EntityID ID; public string Type; public Dictionary&lt;string, Variant&gt; Payload; }\n    }\n}\n</code></pre> <p>This change ensures the <code>EntitySpawnedEvent</code> carries the necessary <code>Vector2</code> and <code>float</code> data for initialization.</p>"},{"location":"12-chapter-12/#3-gdscript-connecting-to-c-events","title":"3. GDScript Connecting to C# Events","text":"<p>Now, our <code>EntityViewManager.gd</code> will connect to these C# events.</p> <p>Open <code>res://_Body/Scripts/Visuals/EntityViewManager.gd</code>:</p> <pre><code># _Body/Scripts/Visuals/EntityViewManager.gd\nclass_name EntityViewManager extends Node\n\nstatic var instance: EntityViewManager\nvar _active_entity_views: Dictionary = {}\nconst ENTITY_ROOT_SCENE: PackedScene = preload(\"res://_Body/Scenes/Entities/EntityRoot.tscn\")\n\nfunc _init():\n    if instance != null:\n        push_error(\"EntityViewManager: More than one instance detected!\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    GD.print(\"EntityViewManager: Initialized. Connecting to C# events...\")\n\n    # --- Connect to C# Events from GameManager.Instance.Events (TDD 01.3) ---\n    # We use Callable(self, \"_on_...\") to bind the GDScript method.\n    # The string names (e.g., \"OnEntitySpawned\") must match the C# event names in EventBus.\n    # The parameters of the GDScript method must match the parameters of the C# Action delegate.\n\n    # Check if GameManager and its Events are ready before connecting\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnEntitySpawned.connect(Callable(self, \"_on_entity_spawned\"))\n        GameManager.Instance.Events.OnEntityDespawned.connect(Callable(self, \"_on_entity_despawned\"))\n        GameManager.Instance.Events.OnEntityMoved.connect(Callable(self, \"_on_entity_moved\"))\n        # Animation Events: EntityView's anim_event is local, then EntityViewManager forwards to C#\n        # We will connect EntityView's anim_event to a C# receiving method in the next step.\n        GD.print(\"EntityViewManager: Successfully connected to C# EventBus events.\")\n    else:\n        push_error(\"EntityViewManager: GameManager or EventBus not ready! Cannot connect C# events.\")\n\n    # For testing, we'll add a timer to play an animation after entities are spawned.\n    await get_tree().create_timer(3.0).timeout # Wait 3 seconds after scene loads\n\n    for id in _active_entity_views:\n        var entity_view: EntityView = _active_entity_views[id]\n        if entity_view.entity_id == 1: # NPC entity has ID 1 from previous tests\n            entity_view.play_animation(\"test_attack\")\n            break\n    pass\n\n## Handler for C# EntitySpawnedEvent.\n## Parameters must match Action&lt;EntityID, EntityType, string, Vector2, float&gt; OnEntitySpawned in C#.\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if ENTITY_ROOT_SCENE == null:\n        push_error(\"EntityViewManager: ENTITY_ROOT_SCENE not loaded!\")\n        return\n\n    var entity_view: EntityView = ENTITY_ROOT_SCENE.instantiate()\n    add_child(entity_view)\n\n    entity_view.setup(id, initial_position, initial_rotation, definition_id)\n\n    # Connect the EntityView's anim_event to our manager's conceptual handler\n    entity_view.anim_event.connect(Callable(self, \"_on_entity_view_anim_event\"))\n\n    _active_entity_views[id] = entity_view\n    GD.print(\"EntityViewManager: Spawned visual for C# EntityID %s (Type: %s, Def: %s) at %s\" % [id, type, definition_id, initial_position])\n\n## Handler for C# EntityDespawnedEvent.\n## Parameters must match Action&lt;EntityID&gt; OnEntityDespawned in C#.\nfunc _on_entity_despawned(id: int) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.queue_free()\n        _active_entity_views.erase(id)\n        GD.print(\"EntityViewManager: Despawned visual for C# EntityID %s\" % id)\n    else:\n        push_warning(\"EntityViewManager: Attempted to despawn non-existent visual for C# EntityID %s\" % id)\n\n## Handler for C# EntityMovedEvent.\n## Parameters must match Action&lt;EntityID, Vector2, float&gt; OnEntityMoved in C#.\nfunc _on_entity_moved(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if _active_entity_views.has(id):\n        var entity_view: EntityView = _active_entity_views[id]\n        entity_view.brain_target_position = new_position\n        entity_view.visuals.rotation_degrees = new_rotation # Directly set rotation for now. Interpolation can be added later.\n    # else:\n        # push_warning(\"EntityViewManager: Received move event for non-existent visual for C# EntityID %s\" % id)\n\n## Handler for animation events from EntityView.\n## This will forward the event to the C# EventBus.\nfunc _on_entity_view_anim_event(type: String, payload: Dictionary) -&gt; void:\n    GD.print(\"EntityViewManager: Caught anim_event from EntityView. Type: '%s', Payload: %s\" % [type, payload])\n    # This is where GDScript calls back into C#\n    # TDD 01.3: GDScript to C# (Method Calls)\n    # GameManager.Instance.Events.ReceiveAnimationEvent(entity_view.entity_id, type, payload)\n    # For now, we'll just print, the C# receiving method will be implemented next.\n    pass\n</code></pre> <p>Key Changes in <code>EntityViewManager.gd</code>:</p> <ul> <li><code>_ready()</code>: Now contains <code>GameManager.Instance.Events.OnEntitySpawned.connect(...)</code> calls. This is the core interop connection.</li> <li>GDScript Method Signatures: The parameters for <code>_on_entity_spawned</code>, <code>_on_entity_despawned</code>, <code>_on_entity_moved</code> now precisely match the parameters of their corresponding C# <code>Action</code> delegates in <code>EventBus</code>.</li> </ul>"},{"location":"12-chapter-12/#4-gdscript-calling-c-methods","title":"4. GDScript Calling C# Methods","text":"<p>While C# to GDScript uses signals, GDScript can directly call C# methods. This is useful for forwarding input or specific requests from the Body to the Brain. TDD 01.3 mentions this pattern.</p> <p>Let's implement a C# method in <code>EventBus</code> that <code>EntityViewManager.gd</code> can call to send animation events back to the Brain.</p> <p>Open <code>_Brain/Core/EventBus.cs</code> and add this method:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events and command buffer) ...\n\n        /// &lt;summary&gt;\n        /// GDScript calls this method to send animation events back to the C# Brain.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"entityIdIndex\"&gt;The EntityID.Index of the visual entity.&lt;/param&gt;\n        /// &lt;param name=\"type\"&gt;The type of animation event.&lt;/param&gt;\n        /// &lt;param name=\"payload\"&gt;Additional data as a Godot Dictionary.&lt;/param&gt;\n        public void ReceiveAnimationEvent(int entityIdIndex, string type, Dictionary&lt;string, Variant&gt; payload)\n        {\n            // We need to reconstruct the full EntityID for safety.\n            // This assumes EntityManager is available and entityIdIndex is valid.\n            // For now, let's just create a dummy EntityID for the event.\n            // In a real scenario, you'd use GameManager.Instance.Entities.GetEntityMeta(entityIdIndex).Generation\n            // to create a fully valid EntityID.\n            EntityID id = new EntityID(entityIdIndex, 1); // Placeholder generation\n\n            // Publish as an internal C# event\n            Publish(new EntityManager.AnimationEvent { ID = id, Type = type, Payload = payload });\n            GD.Print($\"EventBus: C# received animation event from GDScript: EntityID Index {entityIdIndex}, Type '{type}', Payload {payload}\");\n        }\n\n        // ... (Publish, AddCommand, FlushCommands methods) ...\n    }\n}\n</code></pre> <p>Now, modify <code>_Body/Scripts/Visuals/EntityViewManager.gd</code>'s <code>_on_entity_view_anim_event</code> to call this C# method:</p> <pre><code># _Body/Scripts/Visuals/EntityViewManager.gd\nclass_name EntityViewManager extends Node\n\n# ... (existing code) ...\n\nfunc _on_entity_view_anim_event(type: String, payload: Dictionary) -&gt; void:\n    # Get the EntityID.Index from the EntityView that emitted the signal\n    var entity_view: EntityView = get_tree().get_last_notified_signal_source()\n    if entity_view == null or not entity_view is EntityView:\n        push_error(\"EntityViewManager: Could not get source EntityView for anim_event.\")\n        return\n\n    GD.print(\"EntityViewManager: Caught anim_event from EntityView %s. Type: '%s', Payload: %s. Forwarding to C#.\" % [entity_view.entity_id, type, payload])\n\n    # --- GDScript Calling C# Method (TDD 01.3) ---\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        # Pass the entity's ID (index), event type, and payload.\n        # Note: Godot automatically converts GDScript Dictionary to C# Dictionary&lt;string, Variant&gt;.\n        GameManager.Instance.Events.ReceiveAnimationEvent(entity_view.entity_id, type, payload)\n    else:\n        push_error(\"EntityViewManager: GameManager or EventBus not ready! Cannot forward anim_event to C#.\")\n</code></pre>"},{"location":"12-chapter-12/#5-testing-the-full-interop-layer","title":"5. Testing the Full Interop Layer","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> </ol> <p>Expected Output:</p> <ul> <li>The scene loads.</li> <li>You'll see messages confirming C# and GDScript systems initialized and connected.</li> <li>The NPC will move and rotate.</li> <li>After ~3 seconds, the NPC's <code>test_attack</code> animation plays.</li> <li>When the \"hit_frame\" event triggers:<ul> <li><code>EntityView 1: Emitted anim_event: Type 'hit_frame', Payload {hitbox_id:test_hitbox_01}</code> (from <code>EntityView.gd</code>)</li> <li><code>EntityViewManager: Caught anim_event from EntityView 1. Type: 'hit_frame', Payload: {hitbox_id:test_hitbox_01}. Forwarding to C#.</code> (from <code>EntityViewManager.gd</code>)</li> <li><code>EventBus: C# received animation event from GDScript: EntityID Index 1, Type 'hit_frame', Payload {hitbox_id:test_hitbox_01}</code> (from <code>EventBus.cs</code>)</li> </ul> </li> </ul> <p>This confirms the complete bidirectional interop: C# events triggering GDScript visuals, and GDScript animation events calling C# logic.</p>"},{"location":"12-chapter-12/#summary","title":"Summary","text":"<p>You have successfully implemented Sigilborne's Interop Layer, formalizing the communication bridge between the C# Brain and GDScript Body. By leveraging C# <code>Action&lt;T&gt;</code> delegates in the <code>EventBus</code> for Brain-to-Body signals and direct method calls for Body-to-Brain requests, you've established a seamless, type-safe, and decoupled communication pipeline. This crucial step adheres strictly to TDD 01.3's specifications, ensuring that simulation logic and visual presentation can evolve independently while remaining perfectly synchronized.</p>"},{"location":"12-chapter-12/#next-steps","title":"Next Steps","text":"<p>The next module will focus on Global State Management, defining how the C# Brain maintains authoritative control over all game data, and how the GDScript Body consistently displays this data without owning it.</p>"},{"location":"13-chapter-13/","title":"Chapter 1.13: Global State Management - Data Ownership","text":""},{"location":"13-chapter-13/#chapter-113-global-state-management-data-ownership","title":"Chapter 1.13: Global State Management - Data Ownership","text":"<p>In Sigilborne's hybrid architecture, maintaining a consistent and authoritative game state is paramount. This chapter formalizes the principle of data ownership: the C# Brain is the sole owner of all authoritative game data, while the GDScript Body never \"owns\" data, it only displays it. This strict separation, as outlined in TDD 01.4, prevents data desynchronization, simplifies debugging, and reinforces the Brain &amp; Body paradigm.</p>"},{"location":"13-chapter-13/#1-the-principle-of-authoritative-state","title":"1. The Principle of Authoritative State","text":"<ul> <li>Brain (C#): Owns the Model (the data) and the Controller (the logic that changes the data).<ul> <li>Examples: Player's actual health, inventory contents, NPC positions, world time, faction relationships, quest states.</li> <li>Rule: All changes to the game state must originate from or be validated by the Brain.</li> </ul> </li> <li>Body (GDScript): Owns the View. It receives updates from the Brain and renders them.<ul> <li>Examples: Player's visual health bar, inventory UI, animated NPC sprite at an interpolated position, UI display of world time.</li> <li>Rule: The Body never modifies the authoritative game state directly. It only requests changes from the Brain (e.g., via GDScript-to-C# method calls for player input).</li> </ul> </li> </ul> <p>This single source of truth is crucial for determinism, especially if we were to introduce multiplayer.</p>"},{"location":"13-chapter-13/#2-global-state-examples-and-their-brain-owners","title":"2. Global State Examples and Their Brain Owners","text":"<p>Let's look at key game data and identify their authoritative owners within our C# Brain, as per TDD 01.4.</p> Data Type Owner (C# System) Example Data Player Stats <code>BiologicalSystem</code> (Soon) <code>Health: 100</code>, <code>Chakra: 50</code>, <code>Stamina: 75</code> Inventory <code>InventorySystem</code> (Soon) <code>[ItemID: \"iron_sword\", Qty: 1]</code> World Time <code>TimeSystem</code> (Implemented) <code>Day: 4</code>, <code>Hour: 14</code>, <code>Minute: 0</code> NPC Positions <code>TransformSystem</code> (Implemented) <code>EntityID(1).Position: (40, 20)</code> Weather <code>WeatherSystem</code> (Soon) <code>CurrentWeather: Rain</code>, <code>Temperature: 15</code> Quest State <code>QuestSystem</code> (Soon) <code>QuestID(\"main_01\").Status: Active</code> <p>The <code>GameManager.Instance</code> acts as the central hub to access these owning systems.</p>"},{"location":"13-chapter-13/#3-implementing-a-basic-player-stat-system-brain","title":"3. Implementing a Basic Player Stat System (Brain)","text":"<p>To demonstrate data ownership, let's create a very simple <code>PlayerStatSystem</code> in C# that manages the player's health. This will be an early step towards our <code>BiologicalSystem</code> (TDD 03.2).</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Biology/</code>.</li> <li>Create a new C# script <code>res://_Brain/Systems/Biology/PlayerStatSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Biology/PlayerStatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Biology\n{\n    /// &lt;summary&gt;\n    /// Stores the core stats for the player entity.\n    /// This is a component-like data structure managed by the PlayerStatSystem.\n    /// &lt;/summary&gt;\n    public struct PlayerStats\n    {\n        public EntityID PlayerID;\n        public float Health;\n        public float MaxHealth;\n        public float Chakra;\n        public float MaxChakra;\n        public float Stamina;\n        public float MaxStamina;\n\n        public PlayerStats(EntityID id, float maxHealth, float maxChakra, float maxStamina)\n        {\n            PlayerID = id;\n            MaxHealth = maxHealth;\n            Health = maxHealth;\n            MaxChakra = maxChakra;\n            Chakra = maxChakra;\n            MaxStamina = maxStamina;\n            Stamina = maxStamina;\n        }\n\n        public override string ToString()\n        {\n            return $\"Health: {Health}/{MaxHealth}, Chakra: {Chakra}/{MaxChakra}, Stamina: {Stamina}/{MaxStamina}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Manages the player's core biological stats.\n    /// This is the authoritative owner of the player's health, chakra, etc.\n    /// &lt;/summary&gt;\n    public class PlayerStatSystem\n    {\n        private PlayerStats _playerStats;\n        private EventBus _eventBus;\n        private EntityManager _entityManager;\n\n        public PlayerStatSystem(EventBus eventBus, EntityManager entityManager)\n        {\n            _eventBus = eventBus;\n            _entityManager = entityManager;\n            GD.Print(\"PlayerStatSystem: Initialized.\");\n\n            // Listen for when the player entity is actually spawned\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player)\n            {\n                // Initialize player stats when the player entity is created\n                _playerStats = new PlayerStats(id, 100f, 50f, 75f);\n                GD.Print($\"PlayerStatSystem: Initialized stats for player {id}: {_playerStats}\");\n\n                // Publish an event for the Body to display the initial health\n                _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = id, NewHealth = _playerStats.Health, MaxHealth = _playerStats.MaxHealth });\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a copy of the player's current stats.\n        /// &lt;/summary&gt;\n        public PlayerStats GetPlayerStats()\n        {\n            return _playerStats;\n        }\n\n        /// &lt;summary&gt;\n        /// Authoritatively applies damage to the player's health.\n        /// &lt;/summary&gt;\n        public void TakeDamage(float amount)\n        {\n            if (_playerStats.Health &lt;= 0) return; // Already dead\n\n            _playerStats.Health -= amount;\n            if (_playerStats.Health &lt; 0) _playerStats.Health = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerStats.PlayerID} took {amount} damage. New Health: {_playerStats.Health}\");\n\n            // Publish an event for the Body (UI) to update the health bar\n            _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = _playerStats.PlayerID, NewHealth = _playerStats.Health, MaxHealth = _playerStats.MaxHealth });\n\n            if (_playerStats.Health == 0)\n            {\n                GD.Print($\"PlayerStatSystem: Player {_playerStats.PlayerID} has died!\");\n                _eventBus.Publish(new PlayerDiedEvent { PlayerID = _playerStats.PlayerID });\n            }\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerHealthChangedEvent { public EntityID PlayerID; public float NewHealth; public float MaxHealth; }\n        public struct PlayerDiedEvent { public EntityID PlayerID; }\n    }\n}\n</code></pre>"},{"location":"13-chapter-13/#4-integrating-playerstatsystem-into-gamemanager","title":"4. Integrating <code>PlayerStatSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Biology;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>PlayerStatSystem</code> property.</li> <li>Initialize <code>PlayerStatSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology; // Add this using directive\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; }\n    public TransformSystem Transforms { get; private set; }\n    public JobSystem Jobs { get; private set; }\n    public PlayerStatSystem PlayerStats { get; private set; } // Add PlayerStatSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n\n        // --- Test Scene Loading ---\n        // ... (existing SceneLoader call) ...\n        // --- End Test Scene Loading ---\n\n        // --- Test Entity Management &amp; Components ---\n        GD.Print(\"\\n--- Testing Entity Management &amp; Components ---\");\n        // Create the player entity (this will trigger PlayerStatSystem to initialize stats)\n        EntityID playerEntity = Entities.CreateEntity(EntityType.Player, \"player_default\", new Vector2(200, 200), 0f);\n        GD.Print($\"Created Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        EntityID npcEntity = Entities.CreateEntity(EntityType.NPC, \"goblin_grunt\", new Vector2(100, 100), 90f);\n        GD.Print($\"Created NPC: {npcEntity}. IsValid: {Entities.IsValid(npcEntity)}\");\n\n        // Let's not destroy playerEntity immediately to test damage later\n        // Entities.DestroyEntity(playerEntity);\n        // GD.Print($\"Destroyed Player: {playerEntity}. IsValid: {Entities.IsValid(playerEntity)}\");\n\n        // if (!Transforms.TryGetTransform(playerEntity, out TransformComponent destroyedTransform))\n        // {\n        //     GD.Print($\"Attempted to get transform for destroyed entity {playerEntity}, it correctly failed.\");\n        // }\n\n        GD.Print(\"--- End Testing Entity Management &amp; Components ---\\n\");\n\n        // --- Test JobSystem ---\n        // ... (existing JobSystem tests) ...\n        // --- End Testing JobSystem ---\n\n        // --- Test PlayerStatSystem (Damage) ---\n        GD.Print(\"\\n--- Testing PlayerStatSystem ---\");\n        PlayerStats.TakeDamage(10f); // Player takes damage\n        PlayerStats.TakeDamage(20f);\n        PlayerStats.TakeDamage(70f); // Should kill the player\n        GD.Print(\"--- End Testing PlayerStatSystem ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Time.Tick(delta);\n        Events.FlushCommands();\n        World.Tick(delta);\n        Transforms.Tick(delta);\n        // PlayerStatSystem doesn't have a Tick method for now, its updates are event/command driven.\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities); // Initialize PlayerStatSystem here\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"13-chapter-13/#41-update-eventbuscs-for-playerstatsystem-events","title":"4.1. Update <code>EventBus.cs</code> for PlayerStatSystem Events","text":"<p>Our <code>PlayerStatSystem</code> publishes <code>PlayerHealthChangedEvent</code> and <code>PlayerDiedEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Player Stat Events (TDD 01.4)\n        public event Action&lt;EntityID, float, float&gt; OnPlayerHealthChanged;\n        public event Action&lt;EntityID&gt; OnPlayerDied;\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerStatSystem.PlayerHealthChangedEvent healthEvent) // New condition\n            {\n                OnPlayerHealthChanged?.Invoke(healthEvent.PlayerID, healthEvent.NewHealth, healthEvent.MaxHealth);\n            }\n            else if (eventData is PlayerStatSystem.PlayerDiedEvent diedEvent) // New condition\n            {\n                OnPlayerDied?.Invoke(diedEvent.PlayerID);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"13-chapter-13/#5-displaying-player-stats-in-the-body-gdscript-ui","title":"5. Displaying Player Stats in the Body (GDScript UI)","text":"<p>Now, let's create a simple UI (Body) to display the player's health, reacting to <code>OnPlayerHealthChanged</code> events.</p> <ol> <li>Create a new folder <code>res://_Body/Scenes/UI/</code>.</li> <li>Create a new scene <code>res://_Body/Scenes/UI/HUD.tscn</code>:<ul> <li>Root node: <code>CanvasLayer</code>. Rename it <code>HUD</code>.</li> <li>Child node: <code>HBoxContainer</code>. Rename it <code>HealthBarContainer</code>.<ul> <li>In Inspector, set <code>Anchor Preset</code> to <code>Top Wide</code> (or adjust layout as desired).</li> <li>Set <code>Position</code> (e.g., <code>x=10, y=10</code>).</li> </ul> </li> <li>Child of <code>HealthBarContainer</code>: <code>Label</code>. Rename it <code>HealthLabel</code>.<ul> <li>Set <code>Text</code> to <code>Health: 100/100</code>.</li> </ul> </li> </ul> </li> <li>Attach a new GDScript to the <code>HUD</code> node: <code>res://_Body/Scripts/UI/HUDController.gd</code>.</li> </ol> <pre><code># _Body/Scripts/UI/HUDController.gd\nclass_name HUDController extends CanvasLayer\n\n@onready var health_label: Label = $HealthBarContainer/HealthLabel\n\nvar player_entity_id: int = -1 # Store the player's EntityID.Index\n\nfunc _ready():\n    GD.print(\"HUDController: Initialized. Connecting to C# PlayerStatSystem events.\")\n    # Connect to C# PlayerStatSystem events\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnPlayerHealthChanged.connect(Callable(self, \"_on_player_health_changed\"))\n        GameManager.Instance.Events.OnPlayerDied.connect(Callable(self, \"_on_player_died\"))\n        # We also need to know the player's EntityID when it spawns\n        GameManager.Instance.Events.OnEntitySpawned.connect(Callable(self, \"_on_entity_spawned\"))\n        GD.print(\"HUDController: Successfully connected to C# PlayerStatSystem events.\")\n    else:\n        push_error(\"HUDController: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    # Only care about the Player entity here\n    # Godot's C# binding marshals EntityType enum as an int, so we compare to its integer value.\n    if type == 0: # EntityType.Player has value 0\n        player_entity_id = id\n        GD.print(\"HUDController: Detected player entity with ID: %s\" % player_entity_id)\n\n## Handler for C# PlayerHealthChangedEvent.\nfunc _on_player_health_changed(id: int, new_health: float, max_health: float) -&gt; void:\n    # Only update if it's our player's health\n    if id == player_entity_id:\n        health_label.text = \"Health: %s/%s\" % [int(new_health), int(max_health)]\n        GD.print(\"HUDController: Player %s Health Updated to %s/%s\" % [id, int(new_health), int(max_health)])\n\n## Handler for C# PlayerDiedEvent.\nfunc _on_player_died(id: int) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"Health: DEAD\"\n        GD.print(\"HUDController: Player %s has died visually!\" % id)\n</code></pre> <p>Now, instantiate the <code>HUD.tscn</code> scene into <code>res://Gameplay.tscn</code>:</p> <ol> <li>Open <code>res://Gameplay.tscn</code>.</li> <li>Add a new instance of <code>res://_Body/Scenes/UI/HUD.tscn</code> as a child of the <code>Gameplay</code> root node.</li> <li>Save <code>Gameplay.tscn</code>.</li> </ol>"},{"location":"13-chapter-13/#6-testing-global-state-management","title":"6. Testing Global State Management","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> </ol> <p>Expected Output:</p> <ul> <li>The game loads <code>Gameplay.tscn</code>.</li> <li>The <code>HUD</code> will appear with \"Health: 100/100\".</li> <li>In the Output console, you'll see the <code>PlayerStatSystem</code> messages about damage taken.</li> <li>The <code>HUD</code>'s health label will update <code>Health: 90/100</code>, then <code>Health: 70/100</code>, and finally <code>Health: DEAD</code>.</li> </ul> <p>This demonstrates:</p> <ul> <li>The C# Brain (<code>PlayerStatSystem</code>) authoritatively owns and modifies player health.</li> <li>The C# Brain publishes events when health changes.</li> <li>The GDScript Body (<code>HUDController</code>) listens to these events and reactively updates its UI.</li> <li>The Body does not directly modify player health; it only displays the state provided by the Brain.</li> </ul> <p>This is a perfect example of global state management and data ownership in action.</p>"},{"location":"13-chapter-13/#summary","title":"Summary","text":"<p>You have successfully implemented a core aspect of Global State Management, ensuring that the C# Brain authoritatively owns all game data, specifically demonstrated with a <code>PlayerStatSystem</code>. By designing <code>PlayerStats</code> and integrating the system with <code>GameManager</code> and <code>EventBus</code>, you've established a clear pipeline for modifying game state in C#. Furthermore, you've created a reactive GDScript <code>HUDController</code> that listens to C# events and displays this state without owning it, strictly adhering to TDD 01.4's principles of data ownership and separation of concerns.</p>"},{"location":"13-chapter-13/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Debugging Tools, implementing a console and state inspector to help visualize and manipulate our complex simulation data at runtime, which is essential for developing a large-scale, systemic game like Sigilborne.</p>"},{"location":"14-chapter-14/","title":"Chapter 1.14: Debugging Tools - Console & State Inspector","text":""},{"location":"14-chapter-14/#chapter-114-debugging-tools-console-state-inspector","title":"Chapter 1.14: Debugging Tools - Console &amp; State Inspector","text":"<p>Developing a complex, systemic game like Sigilborne, where thousands of entities interact and the world state is constantly evolving, demands powerful debugging tools. Without them, understanding and fixing issues in a hybrid C# Brain / GDScript Body architecture would be nearly impossible. This chapter implements a basic Debug Console and lays the conceptual groundwork for a State Inspector, as specified in TDD 01.5.</p>"},{"location":"14-chapter-14/#1-the-need-for-robust-debugging-tools","title":"1. The Need for Robust Debugging Tools","text":"<ul> <li>Visibility into the Brain: The C# Brain operates on pure data. We need ways to inspect and manipulate this data at runtime without stopping the game.</li> <li>Runtime Control: Quickly test game mechanics, spawn items, change time, or toggle debug flags without recompiling or restarting.</li> <li>Hybrid Complexity: Traditional debugger breakpoints might not be enough when issues span C# logic and GDScript visuals.</li> </ul>"},{"location":"14-chapter-14/#2-the-debug-console-quake-style-input","title":"2. The Debug Console: Quake-Style Input","text":"<p>A Quake-style console (activated by a key like <code>~</code>) allows players (and developers) to execute commands at runtime.</p> <p>Implementation Plan (GDScript UI + C# Backend):</p> <ol> <li>GDScript UI: A <code>Control</code> node with a <code>LineEdit</code> for input and <code>RichTextLabel</code> for output. It will capture input and forward commands to C#.</li> <li>C# Backend: A <code>DebugCommandSystem</code> that parses commands and executes corresponding actions on the Brain's systems.</li> </ol>"},{"location":"14-chapter-14/#21-c-debugcommandsystem-backend","title":"2.1. C# <code>DebugCommandSystem</code> (Backend)","text":"<p>This system will reside in our <code>_Brain/Utils</code> folder.</p> <ol> <li>Create a new C# script <code>res://_Brain/Utils/DebugCommandSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Utils/DebugCommandSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\n\nnamespace Sigilborne.Utils\n{\n    /// &lt;summary&gt;\n    /// Represents a debug command that can be executed.\n    /// &lt;/summary&gt;\n    public struct DebugCommand\n    {\n        public string Name; // e.g., \"give\"\n        public string Description; // e.g., \"Gives item to player: /give [item_id] [amount]\"\n        public Action&lt;string[]&gt; Action; // The method to execute, with arguments\n    }\n\n    /// &lt;summary&gt;\n    /// Manages and executes debug commands from the console.\n    /// This is the C# backend for our Quake-style debug console.\n    /// &lt;/summary&gt;\n    public class DebugCommandSystem\n    {\n        private Dictionary&lt;string, DebugCommand&gt; _commands = new Dictionary&lt;string, DebugCommand&gt;();\n        private GameManager _gameManager; // Reference to access other systems\n\n        public DebugCommandSystem(GameManager gameManager)\n        {\n            _gameManager = gameManager;\n            RegisterDefaultCommands();\n            GD.Print(\"DebugCommandSystem: Initialized.\");\n        }\n\n        private void RegisterCommand(string name, string description, Action&lt;string[]&gt; action)\n        {\n            _commands[name.ToLower()] = new DebugCommand { Name = name, Description = description, Action = action };\n        }\n\n        private void RegisterDefaultCommands()\n        {\n            // TDD 01.5: Example Commands\n            RegisterCommand(\"help\", \"Displays all available commands.\", (args) =&gt;\n            {\n                GD.Print(\"--- Available Commands ---\");\n                foreach (var cmd in _commands.Values.OrderBy(c =&gt; c.Name))\n                {\n                    GD.Print($\"/ {cmd.Name}: {cmd.Description}\");\n                }\n                GD.Print(\"--------------------------\");\n            });\n\n            RegisterCommand(\"time\", \"Sets the in-game hour: /time set [hour]\", (args) =&gt;\n            {\n                if (args.Length != 2 || args[0].ToLower() != \"set\" || !int.TryParse(args[1], out int hour))\n                {\n                    GD.PrintErr(\"Usage: /time set [hour (0-23)]\");\n                    return;\n                }\n                _gameManager.Time.SetCurrentHour(hour); // We'll add SetCurrentHour to TimeSystem\n                GD.Print($\"Time set to {hour}:00.\");\n            });\n\n            RegisterCommand(\"damage\", \"Damages the player: /damage [amount]\", (args) =&gt;\n            {\n                if (args.Length != 1 || !float.TryParse(args[0], out float amount))\n                {\n                    GD.PrintErr(\"Usage: /damage [amount]\");\n                    return;\n                }\n                _gameManager.PlayerStats.TakeDamage(amount);\n                GD.Print($\"Player took {amount} damage.\");\n            });\n\n            RegisterCommand(\"godmode\", \"Toggles god mode (placeholder).\", (args) =&gt;\n            {\n                // Implement actual god mode logic later (e.g., set player health to infinite, disable damage)\n                GD.Print(\"God mode toggled (placeholder).\");\n            });\n\n            RegisterCommand(\"spawn\", \"Spawns an entity: /spawn [type] [def_id] [x] [y]\", (args) =&gt;\n            {\n                if (args.Length != 4 || !Enum.TryParse(args[0], true, out EntityType type) ||\n                    !float.TryParse(args[2], out float x) || !float.TryParse(args[3], out float y))\n                {\n                    GD.PrintErr(\"Usage: /spawn [EntityType] [definition_id] [x] [y]\");\n                    GD.PrintErr($\"Available types: {string.Join(\", \", Enum.GetNames(typeof(EntityType)))}\");\n                    return;\n                }\n                string defId = args[1];\n                _gameManager.Entities.CreateEntity(type, defId, new Vector2(x, y));\n                GD.Print($\"Spawned {type} '{defId}' at ({x},{y}).\");\n            });\n        }\n\n        /// &lt;summary&gt;\n        /// Executes a command string received from the console UI.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"commandLine\"&gt;The full command string (e.g., \"/time set 12\").&lt;/param&gt;\n        public void ExecuteCommand(string commandLine)\n        {\n            commandLine = commandLine.Trim();\n            if (string.IsNullOrEmpty(commandLine) || !commandLine.StartsWith(\"/\"))\n            {\n                GD.Print(\"DebugCommandSystem: Commands must start with '/'.\");\n                return;\n            }\n\n            string[] parts = commandLine.Substring(1).Split(' ', StringSplitOptions.RemoveEmptyEntries);\n            if (parts.Length == 0) return;\n\n            string commandName = parts[0].ToLower();\n            string[] args = parts.Skip(1).ToArray();\n\n            if (_commands.TryGetValue(commandName, out DebugCommand cmd))\n            {\n                try\n                {\n                    cmd.Action.Invoke(args);\n                }\n                catch (Exception e)\n                {\n                    GD.PrintErr($\"Error executing command '{commandName}': {e.Message}\");\n                }\n            }\n            else\n            {\n                GD.Print($\"Unknown command: '{commandName}'. Type /help for a list of commands.\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"14-chapter-14/#22-integrate-debugcommandsystem-into-gamemanager","title":"2.2. Integrate <code>DebugCommandSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Utils;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>DebugCommandSystem</code> property.</li> <li>Initialize <code>DebugCommandSystem</code> in <code>InitializeSystems()</code>, passing <code>this</code> (the <code>GameManager</code> instance) so it can access other systems.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Utils; // Add this using directive\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; }\n    public TransformSystem Transforms { get; private set; }\n    public JobSystem Jobs { get; private set; }\n    public PlayerStatSystem PlayerStats { get; private set; }\n    public DebugCommandSystem DebugCommands { get; private set; } // Add DebugCommandSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n\n        // --- Test PlayerStatSystem (Damage) ---\n        // Let's remove the test damage from _Ready for now, so we can control it via console.\n        // GD.Print(\"\\n--- Testing PlayerStatSystem ---\");\n        // PlayerStats.TakeDamage(10f); // Player takes damage\n        // PlayerStats.TakeDamage(20f);\n        // PlayerStats.TakeDamage(70f); // Should kill the player\n        // GD.Print(\"--- End Testing PlayerStatSystem ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Time.Tick(delta);\n        Events.FlushCommands();\n        World.Tick(delta);\n        Transforms.Tick(delta);\n        // DebugCommandSystem doesn't have a Tick method, its operations are command driven.\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this); // Initialize DebugCommandSystem here, passing GameManager itself\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"14-chapter-14/#23-add-setcurrenthour-to-timesystemcs","title":"2.3. Add <code>SetCurrentHour</code> to <code>TimeSystem.cs</code>","text":"<p>The <code>DebugCommandSystem</code> needs a way to modify the game hour.</p> <p>Open <code>_Brain/Core/TimeSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Core/TimeSystem.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Core\n{\n    public class TimeSystem\n    {\n        // ... (existing properties and constants) ...\n\n        public TimeSystem() { /* ... */ }\n\n        public void Tick(double delta) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Sets the current in-game hour.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"hour\"&gt;The hour to set (0-23).&lt;/param&gt;\n        public void SetCurrentHour(int hour)\n        {\n            if (hour &lt; 0 || hour &gt; 23)\n            {\n                GD.PrintErr($\"TimeSystem: Invalid hour '{hour}'. Must be between 0 and 23.\");\n                return;\n            }\n            CurrentHour = hour;\n            CurrentMinute = 0; // Reset minutes for clean hour setting\n            GD.Print($\"TimeSystem: Hour manually set to {CurrentHour:D2}:00.\");\n            // Optionally, publish an event: _eventBus.Publish(new TimeChangedEvent { Hour = CurrentHour });\n        }\n    }\n}\n</code></pre>"},{"location":"14-chapter-14/#24-gdscript-debugconsole-ui","title":"2.4. GDScript <code>DebugConsole</code> (UI)","text":"<p>This is the visual part of the console. It will be a <code>CanvasLayer</code> that toggles visibility.</p> <ol> <li>Create a new folder <code>res://_Body/Scenes/UI/Debug/</code>.</li> <li>Create a new scene <code>res://_Body/Scenes/UI/Debug/DebugConsole.tscn</code>:<ul> <li>Root node: <code>CanvasLayer</code>. Rename it <code>DebugConsole</code>.</li> <li>Child node: <code>PanelContainer</code>. Rename it <code>ConsolePanel</code>.<ul> <li>In Inspector, set <code>Layout &gt; Anchors Presets</code> to <code>Full Rect</code>.</li> <li>Set <code>Margin &gt; Top</code> to <code>0</code>, <code>Bottom</code> to <code>50%</code> (covers top half of screen).</li> <li>Set <code>Theme Overrides &gt; StyleBoxes &gt; Panel</code> to <code>New StyleBoxFlat</code>.<ul> <li>Set <code>Bg Color</code> to <code>rgba(0, 0, 0, 0.8)</code>.</li> </ul> </li> </ul> </li> <li>Child of <code>ConsolePanel</code>: <code>VBoxContainer</code>. Rename it <code>ConsoleVBox</code>.<ul> <li><code>Layout &gt; Anchors Presets</code> to <code>Full Rect</code>.</li> <li><code>Margin &gt; All</code> to <code>5</code>.</li> </ul> </li> <li>Child of <code>ConsoleVBox</code>: <code>RichTextLabel</code>. Rename it <code>OutputLabel</code>.<ul> <li><code>Size Flags &gt; Vertical</code> to <code>Expand</code>.</li> <li><code>Scroll Fit Content</code> to <code>true</code>.</li> <li><code>Selection Enabled</code> to <code>true</code>.</li> <li><code>Autowrap Mode</code> to <code>Word</code>.</li> </ul> </li> <li>Child of <code>ConsoleVBox</code>: <code>LineEdit</code>. Rename it <code>InputLine</code>.<ul> <li><code>Placeholder Text</code> to <code>Type /help for commands...</code>.</li> <li><code>Release Focus on Echo</code> to <code>false</code> (so it stays focused).</li> <li><code>Context Menu Enabled</code> to <code>true</code>.</li> </ul> </li> </ul> </li> <li>Attach a new GDScript to the <code>DebugConsole</code> node: <code>res://_Body/Scripts/UI/Debug/DebugConsoleController.gd</code>.</li> </ol> <pre><code># _Body/Scripts/UI/Debug/DebugConsoleController.gd\nclass_name DebugConsoleController extends CanvasLayer\n\n@onready var console_panel: PanelContainer = $ConsolePanel\n@onready var output_label: RichTextLabel = $ConsolePanel/ConsoleVBox/OutputLabel\n@onready var input_line: LineEdit = $ConsolePanel/ConsoleVBox/InputLine\n\nvar is_open: bool = false:\n    set(value):\n        is_open = value\n        console_panel.visible = is_open\n        if is_open:\n            input_line.grab_focus()\n        else:\n            input_line.release_focus()\n\nfunc _ready():\n    is_open = false # Start closed\n    console_panel.visible = false # Ensure it's hidden initially\n    input_line.text_submitted.connect(Callable(self, \"_on_input_line_text_submitted\"))\n\n    # Redirect Godot's GD.print output to our console\n    # This captures all GD.print calls, including C# ones.\n    # Note: For production, you might want to filter this.\n    GD.push_error(\"DebugConsoleController: Capturing GD.print output. Use GD.print_raw for unfiltered output.\")\n\n    # Capture existing output (if any)\n    for i in range(OS.get_stdout_line_count()):\n        _append_output(OS.get_stdout_line(i))\n\nfunc _notification(what: int):\n    # This is a hacky way to capture GD.print, as there's no direct signal.\n    # In a real game, you might use a custom Logger that prints to both console and UI.\n    if what == NOTIFICATION_WM_SIZE_CHANGED or what == NOTIFICATION_VISIBILITY_CHANGED:\n        output_label.scroll_to_line(output_label.get_line_count() - 1)\n\nfunc _append_output(text: String):\n    output_label.append_text(text + \"\\n\")\n    output_label.scroll_to_line(output_label.get_line_count() - 1)\n\nfunc _input(event: InputEvent):\n    # TDD 01.5: Quake-style console (tilde key)\n    if event.is_action_pressed(\"toggle_console\"): # Map \"toggle_console\" to '~' in Project Settings\n        is_open = not is_open\n        get_viewport().set_input_as_handled() # Prevent input from going to game\n\nfunc _on_input_line_text_submitted(text: String) -&gt; void:\n    _append_output(\"&gt; \" + text) # Echo command to output\n    input_line.clear()\n\n    if text.is_empty():\n        return\n\n    # Forward command to C# DebugCommandSystem\n    if GameManager.Instance != null and GameManager.Instance.DebugCommands != null:\n        GameManager.Instance.DebugCommands.ExecuteCommand(text)\n    else:\n        _append_output(\"Error: C# DebugCommandSystem not ready.\")\n</code></pre>"},{"location":"14-chapter-14/#25-integrate-debugconsole-into-maintscn","title":"2.5. Integrate <code>DebugConsole</code> into <code>Main.tscn</code>","text":"<ol> <li>Open <code>res://Main.tscn</code>.</li> <li>Add an instance of <code>res://_Body/Scenes/UI/Debug/DebugConsole.tscn</code> as a child of the <code>Main</code> root node.</li> <li>Save <code>Main.tscn</code>.</li> </ol>"},{"location":"14-chapter-14/#26-map-the-toggle-console-input-action","title":"2.6. Map the Toggle Console Input Action","text":"<ol> <li>Go to <code>Project &gt; Project Settings... &gt; Input Map</code> tab.</li> <li>In the \"Action\" field, type <code>toggle_console</code>.</li> <li>Click <code>Add</code>.</li> <li>Click the <code>+</code> icon next to <code>toggle_console</code>.</li> <li>Press the <code>~</code> (tilde) key.</li> <li>Close Project Settings.</li> </ol>"},{"location":"14-chapter-14/#3-testing-the-debug-console","title":"3. Testing the Debug Console","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>The game loads <code>Gameplay.tscn</code>.</li> <li>Press the <code>~</code> key. The console should appear.</li> <li>Type <code>/help</code> and press Enter. You should see the list of commands.</li> <li>Type <code>/time set 12</code> and press Enter. You should see \"Time set to 12:00.\"</li> <li>Type <code>/damage 50</code> and press Enter. The HUD health bar should update.</li> <li>Type <code>/spawn Animal deer 300 300</code> and press Enter. A new entity should be spawned visually (though it won't move yet, as it lacks a movement component).</li> <li>Press <code>~</code> again to close the console.</li> </ol> <p>This confirms our Debug Console is functional, allowing us to interact with the C# Brain's systems at runtime.</p>"},{"location":"14-chapter-14/#4-state-inspector-conceptual","title":"4. State Inspector (Conceptual)","text":"<p>TDD 01.5 also mentions a State Inspector. This tool would allow inspecting the raw data of an entity (its components) by hovering the mouse over its visual representation.</p> <p>Conceptual Implementation:</p> <ol> <li>Body (GDScript):<ul> <li>A <code>Control</code> UI element for displaying data.</li> <li>A <code>_Process()</code> method in a <code>DebugInputHandler.gd</code> script that performs a <code>raycast</code> from the mouse position.</li> <li>If the raycast hits an <code>EntityView.gd</code>, it gets its <code>entity_id</code>.</li> <li>It then calls a C# method: <code>GameManager.Instance.DebugCommands.GetEntityDebugInfo(entity_id)</code>.</li> </ul> </li> <li>Brain (C#):<ul> <li><code>DebugCommandSystem.GetEntityDebugInfo(EntityID id)</code>: This method would query the <code>EntityManager</code> and all other relevant systems (e.g., <code>Transforms</code>, <code>PlayerStats</code>) for all components associated with that <code>EntityID</code>.</li> <li>It would serialize this data into a <code>Dictionary&lt;string, string&gt;</code> or a custom debug struct.</li> <li>It would then emit a C# event: <code>OnEntityDebugInfoReceived(EntityID id, Dictionary&lt;string, string&gt; info)</code>.</li> </ul> </li> <li>Body (GDScript UI):<ul> <li>The <code>State Inspector</code> UI listens to <code>OnEntityDebugInfoReceived</code> and populates its fields.</li> </ul> </li> </ol> <p>This would provide invaluable insight into the live state of any entity in the simulation. We won't implement this fully in this course, but understanding its architecture is key.</p>"},{"location":"14-chapter-14/#summary","title":"Summary","text":"<p>You have successfully implemented a functional Debug Console, providing a Quake-style interface to execute commands and interact with the C# Brain's systems at runtime. By creating a C# <code>DebugCommandSystem</code> and a reactive GDScript <code>DebugConsoleController</code>, you've established a vital tool for inspecting and manipulating game state, adhering to TDD 01.5's specifications. This significantly enhances your ability to develop and troubleshoot Sigilborne's complex simulation.</p>"},{"location":"14-chapter-14/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on refining the Main Loop Execution Order, detailing how <code>_Process</code> (GDScript) and <code>_PhysicsProcess</code> (C#) are synchronized, and how input processing, simulation ticks, and visual interpolation work together to maintain game integrity and performance.</p>"},{"location":"15-chapter-15/","title":"Chapter 1.15: Main Loop Execution Order - Tick vs. Frame","text":""},{"location":"15-chapter-15/#chapter-115-main-loop-execution-order-tick-vs-frame","title":"Chapter 1.15: Main Loop Execution Order - Tick vs. Frame","text":"<p>Understanding the main loop is fundamental to developing a high-performance, deterministic game like Sigilborne, especially with our hybrid C# Brain / GDScript Body architecture. This chapter details the precise execution order of Godot's <code>_Process</code> and <code>_PhysicsProcess</code> methods, and how we leverage them to synchronize input, advance the simulation tick, and perform visual interpolation, as specified in TDD 01.6.</p>"},{"location":"15-chapter-15/#1-the-tick-vs-frame-distinction","title":"1. The \"Tick\" vs. \"Frame\" Distinction","text":"<ul> <li>Simulation Tick (Brain):<ul> <li>Fixed Timestep: Occurs at a consistent rate (e.g., 20Hz, or every 0.05 seconds), regardless of frame rate.</li> <li>Deterministic: Ideal for all game logic, physics calculations, and AI decisions. Ensures consistent results across different machines.</li> <li>Owner: C# Brain (<code>GameManager._PhysicsProcess</code>).</li> </ul> </li> <li>Render Frame (Body):<ul> <li>Variable Timestep: Occurs as fast as the hardware can render (e.g., 60Hz, 144Hz, or more), tied to the monitor's refresh rate.</li> <li>Non-Deterministic: Used for visual updates, animations, and smooth interpolation.</li> <li>Owner: GDScript Body (<code>_Process</code> method in visual scripts).</li> </ul> </li> </ul> <p>The challenge is to connect these two distinct loops seamlessly.</p>"},{"location":"15-chapter-15/#2-main-loop-execution-order-tdd-016","title":"2. Main Loop Execution Order (TDD 01.6)","text":"<p>Godot's engine processes its main loop in a specific order. We're fitting our Brain and Body logic into this.</p> <ol> <li> <p><code>_Process(delta)</code> (GDScript Body):</p> <ul> <li>Input Capture: Captures raw player input (keyboard, mouse, gamepad).</li> <li>Input Buffering: Sends a snapshot of this input to the C# Brain's input buffer.</li> <li>Visual Interpolation: Smoothly moves visual elements (like <code>EntityView</code> sprites) between known simulation states.</li> <li>UI Updates: Updates UI elements based on the current visual state.</li> <li>Audio/VFX: Triggers non-gameplay-critical visual/audio effects.</li> </ul> </li> <li> <p><code>_PhysicsProcess(delta)</code> (C# Brain):</p> <ul> <li>Phase 1: Process Input Buffer: Reads the latest input snapshots from the buffer.</li> <li>Phase 2: Run Simulation Systems: This is the \"Tick\" where all core game logic runs (AI, Biology, Combat, Magic, WorldSimulation).</li> <li>Phase 3: Resolve Collisions/Events: Handles collision responses and processes any pending commands from the Job System's buffer.</li> <li>Phase 4: Emit State Update Signals: Broadcasts the new authoritative game state to the GDScript Body via the <code>EventBus</code>.</li> </ul> </li> </ol>"},{"location":"15-chapter-15/#3-implementing-the-input-buffer-body-brain","title":"3. Implementing the Input Buffer (Body -&gt; Brain)","text":"<p>To pass input from GDScript (<code>_Process</code>) to C# (<code>_PhysicsProcess</code>), we need an input buffer. TDD 02.1 specifies <code>InputBuffer</code> in C#, and TDD 12.2 defines <code>PlayerInputFrame</code>.</p>"},{"location":"15-chapter-15/#31-c-playerinputframe-and-inputbuffer","title":"3.1. C# <code>PlayerInputFrame</code> and <code>InputBuffer</code>","text":"<ol> <li>Create a new folder <code>res://_Brain/Systems/Input/</code>.</li> <li>Create <code>res://_Brain/Systems/Input/PlayerInputFrame.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Input/PlayerInputFrame.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Systems.Input\n{\n    /// &lt;summary&gt;\n    /// Represents a snapshot of player input at a specific moment.\n    /// This is sent from the GDScript Body to the C# Brain.\n    /// &lt;/summary&gt;\n    public struct PlayerInputFrame\n    {\n        public Vector2 MoveVector;      // X,Y (-1 to 1)\n        public Vector2 LookVector;      // Mouse position or Stick (e.g., normalized direction or screen coords)\n        public bool IsSprintHeld;\n        public bool IsShiftHeld;        // For \"Sliding\" mechanic\n        public bool[] HotbarKeys;       // 1-0 (array of 10 booleans)\n        public bool InteractPressed;\n        public double Timestamp;        // When this input was captured (real time)\n\n        public PlayerInputFrame(Vector2 moveVector, Vector2 lookVector, bool isSprintHeld, bool isShiftHeld, bool[] hotbarKeys, bool interactPressed, double timestamp)\n        {\n            MoveVector = moveVector;\n            LookVector = lookVector;\n            IsSprintHeld = isSprintHeld;\n            IsShiftHeld = isShiftHeld;\n            HotbarKeys = hotbarKeys ?? new bool[10]; // Ensure it's not null\n            InteractPressed = interactPressed;\n            Timestamp = timestamp;\n        }\n\n        public override string ToString()\n        {\n            return $\"Move: {MoveVector}, Sprint: {IsSprintHeld}, Shift: {IsShiftHeld}, Interact: {InteractPressed}, T: {Timestamp:F3}\";\n        }\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/Input/InputSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Input/InputSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent; // For ConcurrentQueue\nusing Sigilborne.Core;\n\nnamespace Sigilborne.Systems.Input\n{\n    /// &lt;summary&gt;\n    /// Manages player input, receiving frames from the GDScript Body and providing\n    /// the latest input to other Brain systems.\n    /// &lt;/summary&gt;\n    public class InputSystem\n    {\n        // TDD 02.1: InputBuffer - A ConcurrentQueue to safely receive input frames from GDScript.\n        private ConcurrentQueue&lt;PlayerInputFrame&gt; _inputQueue = new ConcurrentQueue&lt;PlayerInputFrame&gt;();\n        private PlayerInputFrame _latestInput; // The input frame processed in the current tick\n\n        public InputSystem()\n        {\n            // Initialize with a default (empty) input frame\n            _latestInput = new PlayerInputFrame(Vector2.Zero, Vector2.Zero, false, false, new bool[10], false, 0);\n            GD.Print(\"InputSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Receives an input frame from the GDScript Body and adds it to the queue.\n        /// This method is called from GDScript on the main thread.\n        /// &lt;/summary&gt;\n        public void EnqueueInput(PlayerInputFrame inputFrame)\n        {\n            _inputQueue.Enqueue(inputFrame);\n        }\n\n        /// &lt;summary&gt;\n        /// Processes the input queue, updating the latest input for the current simulation tick.\n        /// Called during GameManager._PhysicsProcess (Phase 1).\n        /// &lt;/summary&gt;\n        public void ProcessInputBuffer()\n        {\n            // Always take the latest input available in the queue for the current tick.\n            // If multiple inputs arrived since the last tick, we only care about the most recent one.\n            PlayerInputFrame newLatest = _latestInput;\n            bool updated = false;\n            while (_inputQueue.TryDequeue(out PlayerInputFrame inputFrame))\n            {\n                newLatest = inputFrame;\n                updated = true;\n            }\n\n            if (updated)\n            {\n                _latestInput = newLatest;\n                // GD.Print($\"InputSystem: Processed latest input: {_latestInput}\");\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Returns the latest processed input frame for other systems to read.\n        /// &lt;/summary&gt;\n        public PlayerInputFrame GetLatestInput()\n        {\n            return _latestInput;\n        }\n    }\n}\n</code></pre>"},{"location":"15-chapter-15/#32-integrate-inputsystem-into-gamemanager","title":"3.2. Integrate <code>InputSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Input;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add an <code>InputSystem</code> property.</li> <li>Initialize <code>InputSystem</code> in <code>InitializeSystems()</code>.</li> <li>Call <code>InputSystem.ProcessInputBuffer()</code> in <code>_PhysicsProcess</code> (Phase 1).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input; // Add this using directive\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    public TimeSystem Time { get; private set; }\n    public EventBus Events { get; private set; }\n    public WorldSimulation World { get; private set; }\n    public EntityManager Entities { get; private set; }\n    public TransformSystem Transforms { get; private set; }\n    public JobSystem Jobs { get; private set; }\n    public PlayerStatSystem PlayerStats { get; private set; }\n    public DebugCommandSystem DebugCommands { get; private set; }\n    public InputSystem Input { get; private set; } // Add InputSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // TDD 01.6: Phase 1: Process Input Buffer.\n        Input.ProcessInputBuffer(); \n\n        // TDD 01.6: Phase 2: Run Simulation Systems.\n        Time.Tick(delta);\n        World.Tick(delta); // WorldSimulation might contain AI, Biology, Combat, Magic updates\n        Transforms.Tick(delta); // Transforms are updated by simulation logic (e.g., movement system)\n\n        // TDD 01.6: Phase 3: Resolve Collisions/Events.\n        Events.FlushCommands(); // Process any batched events from background jobs and deferred commands.\n\n        // TDD 01.6: Phase 4: Emit State Update Signals.\n        // These are implicitly handled by systems calling Events.Publish within their Tick methods.\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem(); // Initialize InputSystem here\n        GD.Print(\"  - InputSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"15-chapter-15/#33-gdscript-inputmanager-body","title":"3.3. GDScript <code>InputManager</code> (Body)","text":"<p>This script will capture input in <code>_Process</code> and send it to the C# <code>InputSystem</code>.</p> <ol> <li>Create <code>res://_Body/Scripts/Core/InputManager.gd</code>:</li> </ol> <pre><code># _Body/Scripts/Core/InputManager.gd\nclass_name InputManager extends Node\n\n# --- Singleton Instance ---\nstatic var instance: InputManager\n\n# --- Hotbar Key Mapping ---\nconst HOTBAR_KEYS: Array[int] = [\n    KEY_1, KEY_2, KEY_3, KEY_4, KEY_5,\n    KEY_6, KEY_7, KEY_8, KEY_9, KEY_0\n]\n\nfunc _init():\n    if instance != null:\n        push_error(\"InputManager: More than one instance detected!\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    GD.print(\"InputManager: Initialized. Capturing input for C# Brain.\")\n    pass # No connections needed here, we poll input in _process\n\n## Captures raw input events and sends a snapshot to the C# InputSystem.\n## (TDD 01.6: _Process (GDScript) - Capture Input -&gt; Send to C# Buffer)\nfunc _process(delta: float) -&gt; void:\n    # Only send input if GameManager and InputSystem are ready\n    if GameManager.Instance == null or GameManager.Instance.Input == null:\n        return\n\n    # Check if console is open; if so, consume input\n    if DebugConsoleController.instance != null and DebugConsoleController.instance.is_open:\n        # Input is handled by the console, don't send to game\n        return\n\n    var move_vector: Vector2 = Input.get_vector(\"move_left\", \"move_right\", \"move_up\", \"move_down\")\n    var look_vector: Vector2 = Vector2.ZERO # Placeholder for mouse/stick look\n    var is_sprint_held: bool = Input.is_action_pressed(\"sprint\")\n    var is_shift_held: bool = Input.is_action_pressed(\"shift\") # Placeholder for shift-slide\n    var interact_pressed: bool = Input.is_action_just_pressed(\"interact\")\n\n    var hotbar_keys_pressed: Array[bool] = []\n    for i in range(HOTBAR_KEYS.size()):\n        hotbar_keys_pressed.append(Input.is_key_pressed(HOTBAR_KEYS[i]))\n\n    var input_frame = PlayerInputFrame.new() # Create a new C# struct instance via Godot's binding\n    input_frame.MoveVector = move_vector\n    input_frame.LookVector = look_vector\n    input_frame.IsSprintHeld = is_sprint_held\n    input_frame.IsShiftHeld = is_shift_held\n    input_frame.HotbarKeys = hotbar_keys_pressed.to_array() # Convert GDScript Array to C# Array\n    input_frame.InteractPressed = interact_pressed\n    input_frame.Timestamp = Time.get_ticks_msec() / 1000.0 # Real-time timestamp\n\n    GameManager.Instance.Input.EnqueueInput(input_frame)\n    # GD.print(\"InputManager: Sent input frame: %s\" % input_frame.to_string()) # Excessive printing, use for debug\n</code></pre>"},{"location":"15-chapter-15/#34-update-maintscn","title":"3.4. Update <code>Main.tscn</code>","text":"<ol> <li>Open <code>res://Main.tscn</code>.</li> <li>Add an instance of <code>res://_Body/Scripts/Core/InputManager.gd</code> as a child of the <code>Main</code> root node.</li> <li>Save <code>Main.tscn</code>.</li> </ol>"},{"location":"15-chapter-15/#35-map-movement-input-actions","title":"3.5. Map Movement Input Actions","text":"<ol> <li>Go to <code>Project &gt; Project Settings... &gt; Input Map</code> tab.</li> <li>Add the following actions and map keys:<ul> <li><code>move_up</code>: <code>W</code></li> <li><code>move_down</code>: <code>S</code></li> <li><code>move_left</code>: <code>A</code></li> <li><code>move_right</code>: <code>D</code></li> <li><code>sprint</code>: <code>Shift</code> (Left)</li> <li><code>shift</code>: <code>Alt</code> (Left) (for our shift-slide mechanic, distinct from sprint)</li> <li><code>interact</code>: <code>E</code></li> </ul> </li> <li>Close Project Settings.</li> </ol>"},{"location":"15-chapter-15/#4-visual-interpolation-body","title":"4. Visual Interpolation (Body)","text":"<p>Our <code>EntityView.gd</code> already handles this (Chapter 1.9). The <code>_physics_process</code> method in <code>EntityView.gd</code> <code>lerps</code> the visual position towards <code>brain_target_position</code>, which is updated by C# <code>OnEntityMoved</code> events. This ensures smooth movement regardless of the Brain's fixed tick rate.</p>"},{"location":"15-chapter-15/#5-testing-the-main-loop-integration","title":"5. Testing the Main Loop Integration","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>You should see the NPC moving and rotating as before.</li> <li>Now, the console output will be flooded with <code>InputManager: Sent input frame...</code> if you uncommented the print statement.</li> <li>Press WASD. You won't see any immediate movement from the player yet, because we haven't implemented a <code>MovementSystem</code> in C# that uses the input. However, the input frames are correctly being sent to the C# Brain.</li> </ol> <p>To confirm the input is reaching the C# Brain, you can temporarily add a print statement to <code>InputSystem.ProcessInputBuffer()</code>:</p> <pre><code>// _Brain/Systems/Input/InputSystem.cs (inside ProcessInputBuffer)\n// ...\n            if (updated)\n            {\n                _latestInput = newLatest;\n                GD.Print($\"InputSystem: Processed latest input: {_latestInput}\"); // Temp debug print\n            }\n// ...\n</code></pre> <p>Run again, and you'll see the input frames being processed by the C# Brain.</p>"},{"location":"15-chapter-15/#summary","title":"Summary","text":"<p>You have successfully established the Main Loop Execution Order for Sigilborne, clearly distinguishing between the fixed-timestep simulation tick (C# Brain in <code>_PhysicsProcess</code>) and the variable-timestep render frame (GDScript Body in <code>_Process</code>). By implementing a C# <code>InputSystem</code> to receive <code>PlayerInputFrame</code> snapshots from the GDScript <code>InputManager</code>, and confirming <code>EntityView.gd</code>'s role in visual interpolation, you've created a robust pipeline for handling input, advancing simulation, and maintaining smooth visuals, strictly adhering to TDD 01.6's specifications.</p>"},{"location":"15-chapter-15/#next-steps","title":"Next Steps","text":"<p>This concludes Module 1: Core Architecture - The Brain &amp; Body Paradigm. You now have a fully functional architectural backbone for Sigilborne. We will now move on to Module 2: Player Input &amp; Core Movement, where we will implement the actual movement logic in the C# Brain, using the input frames we just set up.</p>"},{"location":"16-chapter-16/","title":"Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)","text":""},{"location":"16-chapter-16/#chapter-21-input-manager-capturing-raw-input-gdscript","title":"Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)","text":"<p>Welcome to Module 2: Player Input &amp; Core Movement! In our hybrid architecture, the GDScript Body is the primary interface for player interaction. This chapter focuses on the <code>InputManager.gd</code> script, which is solely responsible for capturing raw hardware input events (keyboard, mouse, gamepad) from Godot's <code>_Process</code> loop, normalizing them, and forwarding them as a concise snapshot to the C# Brain. This adheres to TDD 12.2's <code>PlayerInputFrame</code> and <code>InputManager</code> specifications.</p>"},{"location":"16-chapter-16/#1-the-role-of-inputmanagergd","title":"1. The Role of <code>InputManager.gd</code>","text":"<ul> <li>Capture: Listens to Godot's input events.</li> <li>Normalize: Translates various hardware inputs (e.g., \"W\" key, \"Up Arrow\", Left Stick Up) into unified game actions (e.g., <code>move_up</code>).</li> <li>Snapshot: Collects all relevant input states into a single <code>PlayerInputFrame</code> struct.</li> <li>Forward: Sends this <code>PlayerInputFrame</code> to the C# <code>InputSystem</code> for processing by the Brain.</li> <li>Filter: Prevents game input from being sent when UI (like the Debug Console) is active.</li> </ul> <p>It does NOT interpret what the input means for game logic (e.g., \"move character,\" \"cast spell\"). That's the Brain's job.</p>"},{"location":"16-chapter-16/#2-reviewing-and-enhancing-inputmanagergd","title":"2. Reviewing and Enhancing <code>InputManager.gd</code>","text":"<p>We've already created a basic <code>InputManager.gd</code> in Chapter 1.15. Let's review its structure and enhance it to fully meet the requirements for capturing raw input.</p> <p>Open <code>res://_Body/Scripts/Core/InputManager.gd</code>:</p> <pre><code># _Body/Scripts/Core/InputManager.gd\nclass_name InputManager extends Node\n\n# --- Singleton Instance (TDD 12.1) ---\nstatic var instance: InputManager\n\n# --- Hotbar Key Mapping (TDD 12.5) ---\n# Maps Godot key codes to hotbar slots 0-9.\n# The C# PlayerInputFrame.HotbarKeys expects an array of 10 booleans.\nconst HOTBAR_KEYS: Array[int] = [\n    KEY_1, KEY_2, KEY_3, KEY_4, KEY_5,\n    KEY_6, KEY_7, KEY_8, KEY_9, KEY_0\n]\n\nfunc _init():\n    if instance != null:\n        push_error(\"InputManager: More than one instance detected! This should not happen.\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    GD.print(\"InputManager: Initialized. Capturing input for C# Brain.\")\n    # No explicit connections here, as we poll input state in _process.\n    # Input actions are defined in Project Settings -&gt; Input Map.\n    pass\n\n## Captures raw input events and sends a snapshot to the C# InputSystem.\n## This runs every render frame (variable timestep).\n## (TDD 01.6: _Process (GDScript) - Capture Input -&gt; Send to C# Buffer)\nfunc _process(delta: float) -&gt; void:\n    # Ensure GameManager and its InputSystem are initialized before sending input.\n    if GameManager.Instance == null or GameManager.Instance.Input == null:\n        return\n\n    # TDD 12.4: Action Routing &amp; Priority - If UI (Debug Console) is open, consume input.\n    if DebugConsoleController.instance != null and DebugConsoleController.instance.is_open:\n        # Input is handled by the console, don't send to game.\n        return\n\n    # --- Capture Movement Input (TDD 12.2: PlayerInputFrame.MoveVector) ---\n    var move_vector: Vector2 = Input.get_vector(\"move_left\", \"move_right\", \"move_up\", \"move_down\")\n\n    # --- Capture Look Input (TDD 12.2: PlayerInputFrame.LookVector) ---\n    # For a 2D game, LookVector might be mouse position, or a normalized direction from a gamepad stick.\n    # For now, let's capture mouse position relative to the viewport center.\n    var look_vector: Vector2 = Vector2.ZERO\n    if get_viewport() != null:\n        var mouse_pos: Vector2 = get_viewport().get_mouse_position()\n        var viewport_center: Vector2 = get_viewport().size / 2.0\n        look_vector = (mouse_pos - viewport_center).normalized() # Normalized direction from center\n\n    # --- Capture Action Inputs (TDD 12.2: PlayerInputFrame flags) ---\n    var is_sprint_held: bool = Input.is_action_pressed(\"sprint\")\n    var is_shift_held: bool = Input.is_action_pressed(\"shift\")\n    var interact_pressed: bool = Input.is_action_just_pressed(\"interact\") # Use just_pressed for single-trigger actions\n\n    # --- Capture Hotbar Inputs (TDD 12.2: PlayerInputFrame.HotbarKeys) ---\n    var hotbar_keys_pressed: Array[bool] = []\n    # Ensure the array is always 10 elements long to match C# struct\n    hotbar_keys_pressed.resize(HOTBAR_KEYS.size()) \n    for i in range(HOTBAR_KEYS.size()):\n        hotbar_keys_pressed[i] = Input.is_key_pressed(HOTBAR_KEYS[i])\n\n    # --- Create PlayerInputFrame Snapshot (TDD 12.2) ---\n    # PlayerInputFrame is a C# struct, so we instantiate it using `new()`.\n    var input_frame = PlayerInputFrame.new() \n    input_frame.MoveVector = move_vector\n    input_frame.LookVector = look_vector\n    input_frame.IsSprintHeld = is_sprint_held\n    input_frame.IsShiftHeld = is_shift_held\n    input_frame.HotbarKeys = hotbar_keys_pressed.to_array() # Convert GDScript Array to C# Array\n    input_frame.InteractPressed = interact_pressed\n    input_frame.Timestamp = Time.get_ticks_msec() / 1000.0 # Real-time timestamp (TDD 12.2)\n\n    # --- Enqueue Input to C# Brain (TDD 12.2) ---\n    GameManager.Instance.Input.EnqueueInput(input_frame)\n    # GD.print(\"InputManager: Sent input frame: %s\" % input_frame.to_string()) # Keep commented for performance\n</code></pre> <p>Key Enhancements:</p> <ul> <li><code>look_vector</code>: Now captures a normalized direction from the mouse position relative to the viewport center. This is a common pattern for 2D games where the player \"looks\" in the direction of the mouse.</li> <li><code>interact_pressed</code>: Uses <code>is_action_just_pressed</code> to ensure it only triggers once per press, not every frame the button is held.</li> <li><code>hotbar_keys_pressed.resize(HOTBAR_KEYS.size())</code>: Explicitly resizes the array to 10 elements, matching the C# <code>PlayerInputFrame.HotbarKeys</code> array size expectation.</li> <li><code>PlayerInputFrame.new()</code>: Correctly instantiates the C# struct via Godot's binding.</li> <li><code>hotbar_keys_pressed.to_array()</code>: Converts the GDScript <code>Array[bool]</code> to a C# compatible array.</li> </ul>"},{"location":"16-chapter-16/#3-defining-input-actions-in-project-settings","title":"3. Defining Input Actions in Project Settings","text":"<p>For <code>Input.get_vector()</code> and <code>Input.is_action_pressed()</code>, we rely on Godot's Input Map. We started this in Chapter 1.15. Let's ensure all necessary actions are defined.</p> <ol> <li>Go to <code>Project &gt; Project Settings... &gt; Input Map</code> tab.</li> <li> <p>Verify/Add Actions and Map Keys:</p> <ul> <li><code>move_up</code>: <code>W</code></li> <li><code>move_down</code>: <code>S</code></li> <li><code>move_left</code>: <code>A</code></li> <li><code>move_right</code>: <code>D</code></li> <li><code>sprint</code>: <code>Shift</code> (Left)</li> <li><code>shift</code>: <code>Alt</code> (Left) (for our shift-slide mechanic)</li> <li><code>interact</code>: <code>E</code></li> <li><code>toggle_console</code>: <code>~</code> (tilde)</li> <li><code>hotbar_1</code>: <code>1</code> (Key 1)</li> <li><code>hotbar_2</code>: <code>2</code> (Key 2)</li> <li>...</li> <li><code>hotbar_0</code>: <code>0</code> (Key 0)<ul> <li>Note: For <code>hotbar_X</code> actions, you'll need to add each individually and map the corresponding key. <code>Input.is_key_pressed(KEY_1)</code> in GDScript directly checks the key, so defining these actions isn't strictly necessary for <code>InputManager.gd</code>'s <code>HOTBAR_KEYS</code> array, but it's good practice for consistency and potential UI binding. <code>Input.get_vector</code> and <code>is_action_pressed</code> do require actions.</li> </ul> </li> </ul> </li> <li> <p>Close Project Settings.</p> </li> </ol>"},{"location":"16-chapter-16/#4-testing-raw-input-capture","title":"4. Testing Raw Input Capture","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Interact with movement keys (WASD), sprint (Left Shift), and our custom shift key (Left Alt).</li> <li>Open the debug console (<code>~</code>) and type <code>/help</code> to ensure console input is still isolated.</li> <li>Close the console and move the mouse around.</li> </ol> <p>Expected Output (in the Godot Output console, if you temporarily uncomment the <code>GD.print</code> in <code>InputManager.gd</code>):</p> <p>You should see <code>InputManager: Sent input frame...</code> messages, with <code>MoveVector</code>, <code>LookVector</code>, <code>IsSprintHeld</code>, <code>IsShiftHeld</code>, <code>InteractPressed</code>, and <code>HotbarKeys</code> accurately reflecting your inputs. This confirms that <code>InputManager.gd</code> is correctly capturing and formatting all raw player input.</p>"},{"location":"16-chapter-16/#summary","title":"Summary","text":"<p>You have successfully implemented and enhanced <code>InputManager.gd</code> to reliably capture and normalize raw hardware input events from Godot's <code>_Process</code> loop. By collecting all relevant input states into a <code>PlayerInputFrame</code> snapshot and forwarding it to the C# <code>InputSystem</code>, you've established the foundational pipeline for player control, strictly adhering to TDD 12.2's specifications. This ensures that the C# Brain receives consistent and timely player commands, decoupled from the Body's rendering.</p>"},{"location":"16-chapter-16/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Movement Logic (Brain), where we will use the <code>PlayerInputFrame</code> data in the C# <code>InputSystem</code> to implement standard character movement and our unique \"Shift-Sliding\" mechanic, bringing our player entity to life in the simulation.</p>"},{"location":"17-chapter-17/","title":"Chapter 2.2: Standard Movement Logic - Velocity & Friction (C#)","text":""},{"location":"17-chapter-17/#chapter-22-standard-movement-logic-velocity-friction-c","title":"Chapter 2.2: Standard Movement Logic - Velocity &amp; Friction (C#)","text":"<p>Now that our GDScript <code>InputManager</code> is reliably sending player input snapshots to the C# Brain's <code>InputSystem</code>, it's time to translate that input into actual character movement within our simulation. This chapter focuses on implementing the standard movement logic in C#, defining how <code>MoveVector</code> from the <code>PlayerInputFrame</code> is converted into a <code>Velocity</code>, and how friction is applied for a snappy, responsive feel, as specified in TDD 12.3.</p>"},{"location":"17-chapter-17/#1-the-movement-systems-role-in-the-brain","title":"1. The Movement System's Role in the Brain","text":"<p>Our movement logic resides entirely in the C# Brain. This ensures:</p> <ul> <li>Authoritative Movement: The Brain dictates the character's true position and velocity.</li> <li>Determinism: Movement calculations are consistent across all runs.</li> <li>Decoupling: The visual movement (interpolation in <code>EntityView.gd</code>) is separate from the logical movement.</li> </ul> <p>We will create a new <code>MovementSystem</code> in C# that processes the <code>PlayerInputFrame</code> and updates the <code>TransformComponent</code> of the player entity.</p>"},{"location":"17-chapter-17/#2-implementing-movementsystemcs","title":"2. Implementing <code>MovementSystem.cs</code>","text":"<p>This system will manage <code>TransformComponent</code> (position, rotation) and potentially a new <code>VelocityComponent</code> (current speed and direction).</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Movement/</code>.</li> <li>Create <code>res://_Brain/Systems/Movement/MovementSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Movement/MovementSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Input; // To read PlayerInputFrame\n\nnamespace Sigilborne.Systems.Movement\n{\n    /// &lt;summary&gt;\n    /// Component to store an entity's current velocity.\n    /// &lt;/summary&gt;\n    public struct VelocityComponent\n    {\n        public Vector2 Velocity;\n\n        public VelocityComponent(Vector2 velocity)\n        {\n            Velocity = velocity;\n        }\n\n        public override string ToString()\n        {\n            return $\"Vel: {Velocity}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Component to store an entity's movement parameters.\n    /// &lt;/summary&gt;\n    public struct MovementParametersComponent\n    {\n        public float BaseSpeed;\n        public float SprintMultiplier;\n        public float Friction; // For snappy stops\n        public float Acceleration; // How fast to reach max speed\n\n        public MovementParametersComponent(float baseSpeed, float sprintMultiplier, float friction, float acceleration)\n        {\n            BaseSpeed = baseSpeed;\n            SprintMultiplier = sprintMultiplier;\n            Friction = friction;\n            Acceleration = acceleration;\n        }\n    }\n\n\n    /// &lt;summary&gt;\n    /// Manages the movement logic for entities.\n    /// Reads input, calculates velocity, and updates TransformComponents.\n    /// &lt;/summary&gt;\n    public class MovementSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem; // To get player input\n        private EventBus _eventBus;\n\n        // Store VelocityComponents and MovementParametersComponents for entities that move.\n        private Dictionary&lt;EntityID, VelocityComponent&gt; _velocities = new Dictionary&lt;EntityID, VelocityComponent&gt;();\n        private Dictionary&lt;EntityID, MovementParametersComponent&gt; _movementParams = new Dictionary&lt;EntityID, MovementParametersComponent&gt;();\n\n        // Reference to the TransformSystem to update positions\n        private TransformSystem _transformSystem; \n\n        public MovementSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus, TransformSystem transformSystem)\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem; // Get reference to TransformSystem\n\n            // Subscribe to entity lifecycle events to manage components\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"MovementSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player) // Only player gets movement for now\n            {\n                _velocities.Add(id, new VelocityComponent(Vector2.Zero));\n                _movementParams.Add(id, new MovementParametersComponent(150f, 1.5f, 0.8f, 10f)); // BaseSpeed 150, Sprint 1.5x, Friction 0.8, Accel 10\n                GD.Print($\"MovementSystem: Added movement components for Player {id}\");\n            }\n            // NPCs/Animals will have their own AI-driven movement, handled later.\n        }\n\n        private void OnEntityDespawned(EntityID id)\n        {\n            _velocities.Remove(id);\n            _movementParams.Remove(id);\n            GD.Print($\"MovementSystem: Removed movement components for {id}\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the MovementSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            // Get the latest input from the InputSystem\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n\n            // Iterate over all entities that have movement components (currently just player)\n            foreach (var kvp in _velocities)\n            {\n                EntityID id = kvp.Key;\n\n                // Ensure entity is valid and has movement parameters\n                if (!_entityManager.IsValid(id) || !_movementParams.TryGetValue(id, out MovementParametersComponent moveParams))\n                {\n                    continue;\n                }\n\n                // Get current velocity (mutable reference)\n                ref VelocityComponent currentVelocity = ref _velocities.GetValueRef(id);\n\n                // --- Standard Movement Logic (TDD 12.3) ---\n                Vector2 targetMoveVector = currentInput.MoveVector;\n                float currentSpeed = moveParams.BaseSpeed;\n\n                if (currentInput.IsSprintHeld)\n                {\n                    currentSpeed *= moveParams.SprintMultiplier;\n                }\n\n                Vector2 desiredVelocity = targetMoveVector * currentSpeed;\n\n                // Apply acceleration to smoothly reach desired velocity\n                currentVelocity.Velocity = currentVelocity.Velocity.Lerp(desiredVelocity, moveParams.Acceleration * (float)delta);\n\n                // If no input, apply friction for snappy stops (TDD 12.3)\n                if (targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &gt; 0.1f)\n                {\n                    currentVelocity.Velocity = currentVelocity.Velocity.Lerp(Vector2.Zero, moveParams.Friction * (float)delta);\n                }\n                else if (targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &lt;= 0.1f)\n                {\n                    currentVelocity.Velocity = Vector2.Zero; // Snap to zero to prevent tiny residual movement\n                }\n\n                // --- Update TransformComponent ---\n                if (_transformSystem.TryGetTransform(id, out TransformComponent transform))\n                {\n                    // ProposedPosition = CurrentPosition + (Velocity * Delta) (TDD 17.2.1)\n                    transform.Position += currentVelocity.Velocity * (float)delta;\n                    // For player, rotation should follow LookVector or MoveVector if no LookVector.\n                    // For now, let's make it follow MoveVector if moving.\n                    if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                    {\n                        transform.RotationDegrees = targetMoveVector.Angle() * (180f / Mathf.Pi); // Convert radians to degrees\n                    }\n                    _transformSystem.TrySetTransform(id, transform);\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Explanation of <code>MovementSystem.cs</code>:</p> <ul> <li><code>VelocityComponent</code>: A new struct to hold the entity's current velocity.</li> <li><code>MovementParametersComponent</code>: A new struct to define an entity's speed, sprint multiplier, friction, and acceleration.</li> <li><code>_velocities</code> / <code>_movementParams</code>: Dictionaries to store these components, mapped by <code>EntityID</code>.</li> <li><code>OnEntitySpawned</code> / <code>OnEntityDespawned</code>: Event handlers to add/remove movement components when entities (currently just the player) are created/destroyed.</li> <li><code>Tick(double delta)</code>:<ul> <li>Retrieves the <code>PlayerInputFrame</code> from <code>_inputSystem</code>.</li> <li>Iterates over entities with movement components.</li> <li>Calculates <code>desiredVelocity</code> based on <code>MoveVector</code> and <code>sprint</code>.</li> <li>Applies <code>acceleration</code> for smooth start/stop.</li> <li>Applies <code>friction</code> when <code>MoveVector</code> is zero (TDD 12.3).</li> <li>Updates the <code>TransformComponent.Position</code> by adding <code>currentVelocity * delta</code>.</li> <li>Updates <code>TransformComponent.RotationDegrees</code> to face the movement direction.</li> </ul> </li> </ul>"},{"location":"17-chapter-17/#3-integrating-movementsystem-into-gamemanager","title":"3. Integrating <code>MovementSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Movement;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>MovementSystem</code> property.</li> <li>Initialize <code>MovementSystem</code> in <code>InitializeSystems()</code>.</li> <li>Call <code>MovementSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement; // Add this using directive\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public InputSystem Input { get; private set; }\n    public MovementSystem Movement { get; private set; } // Add MovementSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // TDD 01.6: Phase 1: Process Input Buffer.\n        Input.ProcessInputBuffer(); \n\n        // TDD 01.6: Phase 2: Run Simulation Systems.\n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta); // Call MovementSystem's tick method\n        Transforms.Tick(delta); // Transforms are updated by MovementSystem, but also other systems, so it ticks.\n\n        // TDD 01.6: Phase 3: Resolve Collisions/Events.\n        Events.FlushCommands();\n\n        // TDD 01.6: Phase 4: Emit State Update Signals. (Implicitly handled)\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        // Initialize MovementSystem, passing all necessary dependencies\n        Movement = new MovementSystem(Entities, Input, Events, Transforms); // Initialize MovementSystem here\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"17-chapter-17/#4-testing-standard-movement","title":"4. Testing Standard Movement","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Use WASD keys to move the player entity.<ul> <li>You should see the player sprite (the one that briefly appears and then doesn't get destroyed if you commented out <code>Entities.DestroyEntity(playerEntity)</code> in <code>GameManager._Ready()</code>) moving and rotating.</li> <li>The movement should feel responsive, accelerating and decelerating smoothly due to <code>acceleration</code> and <code>friction</code>.</li> <li>Press Left Shift to sprint, and the movement speed should increase.</li> </ul> </li> </ol> <p>Important Note on Visuals: The player entity (<code>EntityID 0</code>) is still the generic <code>EntityRoot.tscn</code>. It doesn't have a specific player sprite yet. It's just a placeholder circle. In a later chapter (e.g., in Module 1.9 or Module 6), we'd swap this to a proper player character scene. For now, observe its movement behavior.</p> <p>Also, remember the NPC (<code>EntityID 1</code>) is still moving right and rotating as per our <code>TransformSystem.Tick</code> test from Chapter 1.9. Its movement is independent of player input.</p>"},{"location":"17-chapter-17/#summary","title":"Summary","text":"<p>You have successfully implemented the Standard Movement Logic in the C# Brain, translating player input from the <code>InputSystem</code> into authoritative <code>Velocity</code> and <code>TransformComponent</code> updates. By creating a <code>MovementSystem</code> that incorporates <code>MovementParametersComponent</code> and applies <code>acceleration</code> and <code>friction</code>, you've achieved responsive and smooth character movement, strictly adhering to TDD 12.3's specifications. This is a crucial step in bringing our player entity to life within Sigilborne's simulation.</p>"},{"location":"17-chapter-17/#next-steps","title":"Next Steps","text":"<p>The next chapter will build on this by implementing the Shift-Sliding Mechanic, a unique movement ability that allows the player to lock their last movement direction, adding a tactical layer to traversal.</p>"},{"location":"18-chapter-18/","title":"Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)","text":""},{"location":"18-chapter-18/#chapter-23-shift-sliding-mechanic-direction-lock-c","title":"Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)","text":"<p>Building on our standard movement, this chapter introduces Sigilborne's unique \"Shift-Sliding\" mechanic. This mechanic allows the player to \"lock\" their last movement direction by holding a specific key (e.g., <code>Alt</code>), causing the character to continue moving in that direction even if the directional input is released. This adds a tactical layer to movement, allowing for precise positioning while maintaining focus on other actions. This feature is directly specified in TDD 12.3.</p>"},{"location":"18-chapter-18/#1-understanding-the-shift-sliding-mechanic","title":"1. Understanding the Shift-Sliding Mechanic","text":"<ul> <li>Core Idea: When the \"Shift\" key (our <code>IsShiftHeld</code> input) is pressed, the player's movement direction becomes \"locked\" to the last non-zero <code>MoveVector</code>.</li> <li>Behavior:<ul> <li>If <code>Shift</code> is held and directional input is active, the player moves normally, and the locked direction updates.</li> <li>If <code>Shift</code> is held and directional input is released, the player continues moving in the last locked direction at their current speed, rather than stopping or decelerating due to friction.</li> <li>If <code>Shift</code> is released, movement reverts to normal (friction applies, player stops if no directional input).</li> </ul> </li> <li>Benefit: Allows players to maintain momentum or precise positioning while freeing up their directional input for other complex actions (e.g., casting glyphs without needing to hold WASD).</li> </ul>"},{"location":"18-chapter-18/#2-enhancing-movementsystemcs-for-shift-sliding","title":"2. Enhancing <code>MovementSystem.cs</code> for Shift-Sliding","text":"<p>We will modify our <code>MovementSystem</code> to incorporate this new logic. We'll need a way to store the <code>LastMoveVector</code> when the <code>IsShiftHeld</code> flag is active.</p> <p>Open <code>res://_Brain/Systems/Movement/MovementSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Movement/MovementSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Movement\n{\n    // ... (VelocityComponent and MovementParametersComponent structs) ...\n\n    /// &lt;summary&gt;\n    /// Component to store specific player movement states like the last locked direction for shift-sliding.\n    /// &lt;/summary&gt;\n    public struct PlayerMovementStateComponent\n    {\n        public Vector2 LastLockedMoveVector; // Stores the last non-zero move vector when shift is held\n        public bool IsShiftSliding; // True if currently in shift-sliding mode (shift is held and moving)\n\n        public PlayerMovementStateComponent(Vector2 lastLockedMoveVector = default, bool isShiftSliding = false)\n        {\n            LastLockedMoveVector = lastLockedMoveVector;\n            IsShiftSliding = isShiftSliding;\n        }\n    }\n\n\n    /// &lt;summary&gt;\n    /// Manages the movement logic for entities.\n    /// Reads input, calculates velocity, and updates TransformComponents.\n    /// &lt;/summary&gt;\n    public class MovementSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem; \n\n        private Dictionary&lt;EntityID, VelocityComponent&gt; _velocities = new Dictionary&lt;EntityID, VelocityComponent&gt;();\n        private Dictionary&lt;EntityID, MovementParametersComponent&gt; _movementParams = new Dictionary&lt;EntityID, MovementParametersComponent&gt;();\n        private Dictionary&lt;EntityID, PlayerMovementStateComponent&gt; _playerMovementStates = new Dictionary&lt;EntityID, PlayerMovementStateComponent&gt;(); // New: For player-specific movement states\n\n        public MovementSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus, TransformSystem transformSystem)\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"MovementSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player) // Only player gets movement for now\n            {\n                _velocities.Add(id, new VelocityComponent(Vector2.Zero));\n                _movementParams.Add(id, new MovementParametersComponent(150f, 1.5f, 0.8f, 10f));\n                _playerMovementStates.Add(id, new PlayerMovementStateComponent()); // Add player-specific state\n                GD.Print($\"MovementSystem: Added movement components for Player {id}\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityID id)\n        {\n            _velocities.Remove(id);\n            _movementParams.Remove(id);\n            _playerMovementStates.Remove(id); // Remove player-specific state\n            GD.Print($\"MovementSystem: Removed movement components for {id}\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the MovementSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n\n            foreach (var kvp in _velocities)\n            {\n                EntityID id = kvp.Key;\n\n                if (!_entityManager.IsValid(id) || !_movementParams.TryGetValue(id, out MovementParametersComponent moveParams))\n                {\n                    continue;\n                }\n\n                ref VelocityComponent currentVelocity = ref _velocities.GetValueRef(id);\n                Vector2 targetMoveVector = currentInput.MoveVector;\n                float currentSpeed = moveParams.BaseSpeed;\n\n                // --- Player-specific Movement Logic (Shift-Sliding) ---\n                if (id == _entityManager.GetPlayerEntityID()) // Assuming we have a way to get player's ID\n                {\n                    ref PlayerMovementStateComponent playerMoveState = ref _playerMovementStates.GetValueRef(id);\n\n                    // TDD 12.3: Shift-Sliding Logic\n                    if (currentInput.IsShiftHeld)\n                    {\n                        if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                        {\n                            // If shift is held AND directional input is active, update the locked vector\n                            playerMoveState.LastLockedMoveVector = targetMoveVector;\n                            playerMoveState.IsShiftSliding = true;\n                        }\n                        // If shift is held but directional input is released, continue with LastLockedMoveVector\n                        targetMoveVector = playerMoveState.LastLockedMoveVector;\n                        playerMoveState.IsShiftSliding = (targetMoveVector.LengthSquared() &gt; 0.1f); // Only sliding if there's a locked direction\n                    }\n                    else\n                    {\n                        // Shift is not held, reset sliding state\n                        playerMoveState.IsShiftSliding = false;\n                        playerMoveState.LastLockedMoveVector = Vector2.Zero; // Clear locked vector\n                    }\n                }\n                // --- End Player-specific Movement Logic ---\n\n\n                if (currentInput.IsSprintHeld &amp;&amp; !(_playerMovementStates.TryGetValue(id, out var state) &amp;&amp; state.IsShiftSliding)) // Cannot sprint while shift-sliding\n                {\n                    currentSpeed *= moveParams.SprintMultiplier;\n                }\n\n                Vector2 desiredVelocity = targetMoveVector * currentSpeed;\n\n                currentVelocity.Velocity = currentVelocity.Velocity.Lerp(desiredVelocity, moveParams.Acceleration * (float)delta);\n\n                // Apply friction only if not shift-sliding and no input\n                if (!(_playerMovementStates.TryGetValue(id, out var state2) &amp;&amp; state2.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &gt; 0.1f)\n                {\n                    currentVelocity.Velocity = currentVelocity.Velocity.Lerp(Vector2.Zero, moveParams.Friction * (float)delta);\n                }\n                else if (!(_playerMovementStates.TryGetValue(id, out var state3) &amp;&amp; state3.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &lt;= 0.1f)\n                {\n                    currentVelocity.Velocity = Vector2.Zero;\n                }\n\n                // --- Update TransformComponent ---\n                if (_transformSystem.TryGetTransform(id, out TransformComponent transform))\n                {\n                    transform.Position += currentVelocity.Velocity * (float)delta;\n                    // Rotation follows MoveVector or LastLockedMoveVector if sliding\n                    if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                    {\n                        transform.RotationDegrees = targetMoveVector.Angle() * (180f / Mathf.Pi);\n                    }\n                    _transformSystem.TrySetTransform(id, transform);\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Key Changes in <code>MovementSystem.cs</code>:</p> <ul> <li><code>PlayerMovementStateComponent</code>: A new struct to store <code>LastLockedMoveVector</code> and <code>IsShiftSliding</code> specifically for the player.</li> <li><code>_playerMovementStates</code>: A dictionary to hold <code>PlayerMovementStateComponent</code> instances.</li> <li><code>OnEntitySpawned</code> / <code>OnEntityDespawned</code>: Updated to add/remove <code>PlayerMovementStateComponent</code> for the player entity.</li> <li>Shift-Sliding Logic:<ul> <li>If <code>currentInput.IsShiftHeld</code> is true:<ul> <li>If <code>MoveVector</code> is active, <code>LastLockedMoveVector</code> is updated.</li> <li><code>targetMoveVector</code> is then set to <code>LastLockedMoveVector</code>, effectively continuing movement in the locked direction even if <code>currentInput.MoveVector</code> is zero.</li> <li><code>IsShiftSliding</code> is set.</li> </ul> </li> <li>If <code>IsShiftHeld</code> is false, <code>IsShiftSliding</code> is reset, and <code>LastLockedMoveVector</code> is cleared.</li> </ul> </li> <li>Friction and Sprinting Conditional: Friction is only applied if the player is not currently shift-sliding. Sprinting is also conditionally applied, preventing sprinting while shift-sliding for a balanced mechanic.</li> </ul>"},{"location":"18-chapter-18/#21-update-entitymanagercs-to-get-player-id","title":"2.1. Update <code>EntityManager.cs</code> to Get Player ID","text":"<p>The <code>MovementSystem</code> needs to know which <code>EntityID</code> belongs to the player. We can add a simple property to <code>EntityManager</code> for this.</p> <p>Open <code>_Brain/Entities/EntityManager.cs</code> and add this property:</p> <pre><code>// _Brain/Entities/EntityManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\n\nnamespace Sigilborne.Entities\n{\n    // ... (EntityID, EntityMeta, EntityType structs/enums) ...\n\n    public class EntityManager\n    {\n        // ... (MAX_ENTITIES, _entityMetas, _freeIndices, _eventBus) ...\n        private EntityID _playerEntityID = EntityID.Invalid; // New: Store player's EntityID\n\n        public EntityManager(EventBus eventBus) { /* ... */ }\n\n        public EntityID CreateEntity(EntityType type, string definitionID, Vector2 initialPosition = default, float initialRotation = 0f)\n        {\n            // ... (slot allocation, generation increment, EntityMeta setup) ...\n\n            EntityID newId = new EntityID(index, _entityMetas[index].Generation);\n            GD.Print($\"EntityManager: Created {type} entity {newId} (Def: {definitionID})\");\n\n            if (type == EntityType.Player) // Store player's ID when created\n            {\n                _playerEntityID = newId;\n            }\n\n            _eventBus.Publish(new EntitySpawnedEvent { ID = newId, Type = type, DefinitionID = definitionID, InitialPosition = initialPosition, InitialRotation = initialRotation });\n\n            return newId;\n        }\n\n        public void DestroyEntity(EntityID id)\n        {\n            // ... (existing destruction logic) ...\n            if (id == _playerEntityID) // Clear player's ID if destroyed\n            {\n                _playerEntityID = EntityID.Invalid;\n            }\n        }\n\n        public bool IsValid(EntityID id) { /* ... */ }\n        public ref EntityMeta GetEntityMeta(EntityID id) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Returns the EntityID of the player character.\n        /// &lt;/summary&gt;\n        public EntityID GetPlayerEntityID()\n        {\n            return _playerEntityID;\n        }\n\n        // ... (Helper Events for Body Sync) ...\n    }\n}\n</code></pre>"},{"location":"18-chapter-18/#3-testing-the-shift-sliding-mechanic","title":"3. Testing the Shift-Sliding Mechanic","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Test 1 (Normal Movement): Press WASD. The player moves. Release WASD. The player stops due to friction.</li> <li>Test 2 (Shift-Sliding):<ul> <li>Hold <code>Alt</code> (our <code>shift</code> key).</li> <li>Press <code>W</code> (move up). The player moves up.</li> <li>While still holding <code>Alt</code>, release <code>W</code>. The player should continue moving up without friction applying.</li> <li>Press <code>A</code> (move left) while holding <code>Alt</code>. The player's direction should change to left, and they continue moving left when <code>A</code> is released (as long as <code>Alt</code> is held).</li> <li>Release <code>Alt</code>. The player should stop if no directional input is held, or revert to normal movement if directional input is held.</li> </ul> </li> <li>Test 3 (Sprint vs. Shift-Slide):<ul> <li>Hold <code>Alt</code> and move (shift-sliding).</li> <li>Try to press <code>Shift</code> (sprint). The player should not sprint faster, as we've added a condition to prevent sprinting while shift-sliding.</li> </ul> </li> </ol> <p>This confirms the Shift-Sliding mechanic is working as intended, providing the player with a directional lock based on input.</p>"},{"location":"18-chapter-18/#summary","title":"Summary","text":"<p>You have successfully implemented the Shift-Sliding Mechanic in the C# Brain, allowing the player to lock their last movement direction for tactical precision. By introducing the <code>PlayerMovementStateComponent</code> and integrating its logic into the <code>MovementSystem</code>, you've created a unique traversal ability that dynamically responds to player input, strictly adhering to TDD 12.3's specifications. This enhances player agency and adds depth to movement, which is crucial for Sigilborne's systemic gameplay.</p>"},{"location":"18-chapter-18/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on the Physics Layer, detailing how our hybrid physics architecture leverages Godot's <code>CharacterBody2D</code> for collision detection and resolution while the C# Brain maintains authoritative control over velocity and position.</p>"},{"location":"19-chapter-19/","title":"Chapter 2.4: Physics Layer - Hybrid Movement Pipeline","text":""},{"location":"19-chapter-19/#chapter-24-physics-layer-hybrid-movement-pipeline","title":"Chapter 2.4: Physics Layer - Hybrid Movement Pipeline","text":"<p>In Sigilborne, accurate and responsive physics are crucial for combat, environmental interaction, and satisfying movement. However, directly managing complex physics simulations in our C# Brain for thousands of entities would be an immense undertaking. This chapter details our Hybrid Physics Architecture, where Godot's <code>CharacterBody2D</code> (Body) is authoritative for collision detection and separation, while the C# Brain maintains authoritative control over velocity and position. This approach, outlined in TDD 17.1, balances performance with reliable collision resolution.</p>"},{"location":"19-chapter-19/#1-the-hybrid-physics-architecture-philosophy","title":"1. The Hybrid Physics Architecture Philosophy","text":"<ul> <li>C# Brain:<ul> <li>Authoritative for Logic: Calculates <code>TargetVelocity</code>, <code>ProposedPosition</code>, and applies all game-specific forces (e.g., knockback, movement input).</li> <li>\"Wishes\" a Position: It computes where an entity should be if there were no obstacles.</li> </ul> </li> <li>GDScript Body:<ul> <li>Authoritative for Collision Resolution: Takes the Brain's \"wish\" (velocity) and uses Godot's built-in physics engine (<code>move_and_slide()</code>) to resolve actual collisions with walls, terrain, and other entities.</li> <li>\"Reports\" Actual Position: After <code>move_and_slide()</code> completes, it reports the final, collision-resolved position back to the Brain.</li> </ul> </li> <li>Reconciliation: The Brain then reconciles its <code>CurrentPosition</code> with the Body's <code>FinalPosition</code>.</li> </ul> <p>This way, we get Godot's optimized and robust physics engine for collision handling, while keeping our core game logic and state deterministic in C#.</p>"},{"location":"19-chapter-19/#2-the-movement-pipeline-tdd-172","title":"2. The Movement Pipeline (TDD 17.2)","text":"<p>Let's formalize the steps involved in each physics frame:</p> <ol> <li>Brain Calculates Proposed Movement:<ul> <li><code>MovementSystem</code> (C#) calculates the <code>TargetVelocity</code> based on input, speed, friction, etc.</li> <li>It then calculates <code>ProposedPosition = CurrentPosition + (TargetVelocity * Delta)</code>.</li> <li>Crucially: The Brain does not apply this <code>ProposedPosition</code> directly as the new <code>CurrentPosition</code> yet. It just generates the <code>TargetVelocity</code> and emits it.</li> </ul> </li> <li>Brain Emits <code>EntityPhysicsUpdate</code>: The <code>TransformSystem</code> (C#) will emit a specific event containing the <code>EntityID</code> and the <code>TargetVelocity</code> for the Body.</li> <li>Body Receives and Resolves Collisions:<ul> <li><code>EntityView.gd</code> (Body) receives <code>EntityPhysicsUpdate</code>.</li> <li>It calls <code>CharacterBody2D.move_and_slide()</code> using the <code>TargetVelocity</code> received from the Brain.</li> <li>Godot's physics engine handles all collisions, sliding along walls, pushing other <code>CharacterBody2D</code>s, etc.</li> </ul> </li> <li>Body Reports Actual Position Back to Brain:<ul> <li>After <code>move_and_slide()</code> completes, <code>EntityView.gd</code> gets its new <code>global_position</code>.</li> <li>It calls a C# method (e.g., <code>GameManager.Instance.Physics.ReportFinalPosition()</code>) to send this <code>FinalPosition</code> back.</li> </ul> </li> <li>Brain Reconciles:<ul> <li>A <code>PhysicsSystem</code> (C#) receives <code>FinalPosition</code>.</li> <li>It overwrites the entity's <code>TransformComponent.Position</code> with this <code>FinalPosition</code>.</li> </ul> </li> </ol>"},{"location":"19-chapter-19/#3-implementing-the-c-physicssystem-brain","title":"3. Implementing the C# <code>PhysicsSystem</code> (Brain)","text":"<p>This system will handle the reconciliation step.</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Physics/</code>.</li> <li>Create <code>res://_Brain/Systems/Physics/PhysicsSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Physics/PhysicsSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Movement; // To get VelocityComponent\n\nnamespace Sigilborne.Systems.Physics\n{\n    /// &lt;summary&gt;\n    /// Manages the reconciliation of physics positions between the Godot Body and C# Brain.\n    /// It receives the final, collision-resolved position from the Body and updates the Brain's authoritative TransformComponent.\n    /// &lt;/summary&gt;\n    public class PhysicsSystem\n    {\n        private EntityManager _entityManager;\n        private TransformSystem _transformSystem;\n        private EventBus _eventBus;\n\n        public PhysicsSystem(EntityManager entityManager, TransformSystem transformSystem, EventBus eventBus)\n        {\n            _entityManager = entityManager;\n            _transformSystem = transformSystem;\n            _eventBus = eventBus;\n            GD.Print(\"PhysicsSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Receives the final, collision-resolved position from the GDScript Body\n        /// and updates the Brain's authoritative TransformComponent.\n        /// (TDD 17.2.2: Body Reports Actual Position Back to Brain)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"idIndex\"&gt;The index of the entity.&lt;/param&gt;\n        /// &lt;param name=\"generation\"&gt;The generation of the entity (for validation).&lt;/param&gt;\n        /// &lt;param name=\"finalPosition\"&gt;The actual position after Godot's physics resolution.&lt;/param&gt;\n        /// &lt;param name=\"finalRotation\"&gt;The actual rotation after Godot's physics resolution.&lt;/param&gt;\n        public void ReportFinalPosition(int idIndex, int generation, Vector2 finalPosition, float finalRotation)\n        {\n            EntityID id = new EntityID(idIndex, generation);\n\n            if (!_entityManager.IsValid(id))\n            {\n                // GD.PrintErr($\"PhysicsSystem: Received final position for invalid or stale entity {id}. Ignoring.\");\n                return;\n            }\n\n            // TDD 17.2.3: Reconciliation - Overwrite Brain's internal CurrentPosition\n            if (_transformSystem.TryGetTransform(id, out TransformComponent transform))\n            {\n                transform.Position = finalPosition;\n                transform.RotationDegrees = finalRotation;\n                _transformSystem.TrySetTransform(id, transform);\n                // GD.Print($\"PhysicsSystem: Reconciled {id} to {finalPosition}\");\n            }\n            else\n            {\n                GD.PrintErr($\"PhysicsSystem: Entity {id} has no TransformComponent to reconcile.\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"19-chapter-19/#4-integrating-physicssystem-into-gamemanager","title":"4. Integrating <code>PhysicsSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Physics;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>PhysicsSystem</code> property.</li> <li>Initialize <code>PhysicsSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics; // Add this using directive\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public MovementSystem Movement { get; private set; }\n    public PhysicsSystem Physics { get; private set; } // Add PhysicsSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // TDD 01.6: Phase 1: Process Input Buffer.\n        Input.ProcessInputBuffer(); \n\n        // TDD 01.6: Phase 2: Run Simulation Systems.\n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta); // Calculates target velocities and updates transforms (proposed positions)\n        // Transforms.Tick(delta); // This is no longer needed here. TransformSystem only manages data, doesn't 'tick' in this context.\n                                // Its data is updated by MovementSystem, and then reconciled by PhysicsSystem.\n\n        // TDD 01.6: Phase 3: Resolve Collisions/Events.\n        Events.FlushCommands();\n\n        // TDD 01.6: Phase 4: Emit State Update Signals. (Implicitly handled)\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events); // Keep TransformSystem initialized\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        // Initialize PhysicsSystem, passing dependencies\n        Physics = new PhysicsSystem(Entities, Transforms, Events); // Initialize PhysicsSystem here\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre> <p>Important Correction: <code>TransformSystem.Tick(delta)</code> was previously updating transforms based on simulated velocity and emitting <code>EntityMovedEvent</code>. This is fine for testing simple movement, but for a full physics pipeline, <code>TransformSystem</code> should not be directly ticking movement after <code>MovementSystem</code> calculates the velocity. Instead, <code>MovementSystem</code> should calculate the velocity, and <code>EntityView.gd</code> should apply it via <code>move_and_slide()</code>, then report back. The <code>TransformSystem</code>'s <code>Tick</code> method can be removed or repurposed for other transform-related logic (e.g., updating children transforms if we had a hierarchy).</p> <p>Let's adjust <code>TransformSystem.cs</code> to remove its internal movement logic, as movement is now owned by <code>MovementSystem</code> and resolved by <code>EntityView</code>'s <code>move_and_slide</code>. <code>TransformSystem</code>'s <code>Tick</code> will be empty for now.</p> <pre><code>// _Brain/Systems/TransformSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\n\nnamespace Sigilborne.Systems\n{\n    public class TransformSystem\n    {\n        private Dictionary&lt;EntityID, TransformComponent&gt; _transforms = new Dictionary&lt;EntityID, TransformComponent&gt;();\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n\n        public TransformSystem(EntityManager entityManager, EventBus eventBus)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            eventBus.OnEntitySpawned += OnEntitySpawned;\n            eventBus.OnEntityDespawned += OnEntityDespawned;\n            GD.Print(\"TransformSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityManager.EntitySpawnedEvent e)\n        {\n            _transforms.Add(e.ID, new TransformComponent(e.InitialPosition, e.InitialRotation));\n            GD.Print($\"TransformSystem: Added transform for {e.ID}\");\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            if (_transforms.ContainsKey(e.ID))\n            {\n                _transforms.Remove(e.ID);\n                GD.Print($\"TransformSystem: Removed transform for {e.ID}\");\n            }\n        }\n\n        // ... (TryGetTransform, TrySetTransform, GetTransformRef methods) ...\n\n        public void Tick(double delta)\n        {\n            // TDD 17.2: TransformSystem no longer directly updates positions or rotations based on its own tick.\n            // Movement is now handled by MovementSystem calculating velocity, and EntityView resolving collisions.\n            // TransformSystem's job is to store and provide the authoritative transform data,\n            // and emit events when that data is externally changed (e.g., by PhysicsSystem after collision).\n            // For now, this method will be empty.\n        }\n    }\n}\n</code></pre>"},{"location":"19-chapter-19/#5-modifying-movementsystem-to-emit-entityphysicsupdate","title":"5. Modifying <code>MovementSystem</code> to Emit <code>EntityPhysicsUpdate</code>","text":"<p>Instead of directly modifying <code>TransformComponent.Position</code>, <code>MovementSystem</code> should now calculate the <code>TargetVelocity</code> and emit it. The <code>TransformSystem</code> will then publish <code>EntityMovedEvent</code> when its data is set (e.g., by <code>PhysicsSystem</code>).</p> <p>Let's introduce a new event for the Body to receive the velocity.</p> <ol> <li>Add <code>EntityVelocityUpdateEvent</code> struct to <code>_Brain/Entities/EntityManager.cs</code>:</li> </ol> <pre><code>// _Brain/Entities/EntityManager.cs (inside Sigilborne.Entities namespace)\n// ...\n        // --- Helper Events for Body Sync (TDD 11.4) ---\n        // ... (existing events) ...\n        public struct EntityVelocityUpdateEvent { public EntityID ID; public Vector2 TargetVelocity; public float TargetRotationDegrees; } // New event\n    }\n}\n</code></pre> <ol> <li>Add <code>OnEntityVelocityUpdate</code> delegate to <code>_Brain/Core/EventBus.cs</code>:</li> </ol> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n        public event Action&lt;EntityID, Vector2, float&gt; OnEntityVelocityUpdate; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is EntityManager.EntityVelocityUpdateEvent velUpdateEvent) // New condition\n            {\n                OnEntityVelocityUpdate?.Invoke(velUpdateEvent.ID, velUpdateEvent.TargetVelocity, velUpdateEvent.TargetRotationDegrees);\n            }\n            else if (eventData is EntityManager.EntityMovedEvent movedEvent) // Existing, but now published by PhysicsSystem\n            {\n                OnEntityMoved?.Invoke(movedEvent.ID, movedEvent.NewPosition, movedEvent.NewRotation);\n            }\n            // ... (rest of conditions) ...\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre> <ol> <li>Modify <code>_Brain/Systems/Movement/MovementSystem.cs</code>:<ul> <li>Remove the <code>transform.Position</code> and <code>transform.RotationDegrees</code> updates.</li> <li>Instead, publish <code>EntityVelocityUpdateEvent</code>.</li> </ul> </li> </ol> <pre><code>// _Brain/Systems/Movement/MovementSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Movement\n{\n    // ... (VelocityComponent, MovementParametersComponent, PlayerMovementStateComponent structs) ...\n\n    public class MovementSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem; // Still needed for TryGetTransform etc.\n\n        // ... (dictionaries, constructor) ...\n\n        public void Tick(double delta)\n        {\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n\n            foreach (var kvp in _velocities)\n            {\n                EntityID id = kvp.Key;\n\n                if (!_entityManager.IsValid(id) || !_movementParams.TryGetValue(id, out MovementParametersComponent moveParams))\n                {\n                    continue;\n                }\n\n                ref VelocityComponent currentVelocity = ref _velocities.GetValueRef(id);\n                Vector2 targetMoveVector = currentInput.MoveVector;\n                float currentSpeed = moveParams.BaseSpeed;\n                float targetRotationDegrees = _transformSystem.GetTransformRef(id).RotationDegrees; // Keep current rotation\n\n                // --- Player-specific Movement Logic (Shift-Sliding) ---\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    ref PlayerMovementStateComponent playerMoveState = ref _playerMovementStates.GetValueRef(id);\n\n                    if (currentInput.IsShiftHeld)\n                    {\n                        if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                        {\n                            playerMoveState.LastLockedMoveVector = targetMoveVector;\n                            playerMoveState.IsShiftSliding = true;\n                        }\n                        targetMoveVector = playerMoveState.LastLockedMoveVector;\n                        playerMoveState.IsShiftSliding = (targetMoveVector.LengthSquared() &gt; 0.1f);\n                    }\n                    else\n                    {\n                        playerMoveState.IsShiftSliding = false;\n                        playerMoveState.LastLockedMoveVector = Vector2.Zero;\n                    }\n                }\n                // --- End Player-specific Movement Logic ---\n\n                if (currentInput.IsSprintHeld &amp;&amp; !(_playerMovementStates.TryGetValue(id, out var state) &amp;&amp; state.IsShiftSliding))\n                {\n                    currentSpeed *= moveParams.SprintMultiplier;\n                }\n\n                Vector2 desiredVelocity = targetMoveVector * currentSpeed;\n\n                currentVelocity.Velocity = currentVelocity.Velocity.Lerp(desiredVelocity, moveParams.Acceleration * (float)delta);\n\n                if (!(_playerMovementStates.TryGetValue(id, out var state2) &amp;&amp; state2.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &gt; 0.1f)\n                {\n                    currentVelocity.Velocity = currentVelocity.Velocity.Lerp(Vector2.Zero, moveParams.Friction * (float)delta);\n                }\n                else if (!(_playerMovementStates.TryGetValue(id, out var state3) &amp;&amp; state3.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &lt;= 0.1f)\n                {\n                    currentVelocity.Velocity = Vector2.Zero;\n                }\n\n                // --- Determine Target Rotation ---\n                if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                {\n                    targetRotationDegrees = targetMoveVector.Angle() * (180f / Mathf.Pi);\n                }\n\n\n                // TDD 17.2.1: Brain calculates TargetVelocity and emits it.\n                // It does NOT modify TransformComponent.Position directly here anymore.\n                _eventBus.Publish(new EntityManager.EntityVelocityUpdateEvent { ID = id, TargetVelocity = currentVelocity.Velocity, TargetRotationDegrees = targetRotationDegrees });\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"19-chapter-19/#6-modifying-entityviewgd-to-use-move_and_slide-and-report-back","title":"6. Modifying <code>EntityView.gd</code> to use <code>move_and_slide()</code> and Report Back","text":"<p>Now, <code>EntityView.gd</code> needs to: 1.  Connect to <code>OnEntityVelocityUpdate</code>. 2.  Store the <code>TargetVelocity</code> from C#. 3.  In <code>_physics_process</code>, call <code>move_and_slide()</code> with this velocity. 4.  After <code>move_and_slide()</code>, call <code>GameManager.Instance.Physics.ReportFinalPosition()</code> to send the actual, collision-resolved position back to the C# Brain.</p> <p>Open <code>res://_Body/Scripts/Visuals/EntityView.gd</code>:</p> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# ... (existing properties and node references) ...\n\n# --- Visual Interpolation Parameters (TDD 16.4) ---\nvar brain_target_position: Vector2 = Vector2.ZERO # For visual interpolation\nvar brain_target_velocity: Vector2 = Vector2.ZERO # New: Velocity received from Brain\nvar brain_target_rotation_degrees: float = 0.0 # New: Rotation received from Brain\nconst SMOOTHING_SPEED: float = 10.0\n\n# ... (existing signals) ...\n\nfunc setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:\n    entity_id = id\n    global_position = initial_position\n    brain_target_position = initial_position\n    brain_target_rotation_degrees = initial_rotation\n    visuals.rotation_degrees = initial_rotation # Set initial visual rotation\n\n    # ... (animation_player setup) ...\n\n    GD.print(\"EntityView: Setup for C# EntityID %s (Def: %s) at %s\" % [entity_id, definition_id, global_position])\n\n    # --- Connect to Brain Signals ---\n    # Connect to the new velocity update event\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnEntityVelocityUpdate.connect(Callable(self, \"_on_entity_velocity_update\"))\n        # We also need to connect to the OnEntityMoved for reconciliation to get the final authoritative position\n        GameManager.Instance.Events.OnEntityMoved.connect(Callable(self, \"_on_entity_moved_reconciliation\"))\n    pass\n\n## Called every physics frame (fixed rate) to update the visual position.\n## (TDD 17.2.2: Body Receives and Resolves Collisions)\nfunc _physics_process(delta: float) -&gt; void:\n    # Interpolate visual position towards the Brain's authoritative position for smoothness\n    # (This is separate from the physics movement, just for visual lag compensation)\n    global_position = global_position.lerp(brain_target_position, delta * SMOOTHING_SPEED)\n    visuals.rotation_degrees = lerp_angle(visuals.rotation_degrees, brain_target_rotation_degrees, delta * SMOOTHING_SPEED)\n\n\n    # TDD 17.2.2: Body calls CharacterBody2D.move_and_slide() using Brain's velocity.\n    # Note: CharacterBody2D.velocity is implicitly used by move_and_slide().\n    # We set this CharacterBody2D's velocity to the one received from the Brain.\n    velocity = brain_target_velocity\n    move_and_slide()\n\n    # TDD 17.2.2: Body Reports Actual Position Back to Brain.\n    # After move_and_slide, global_position is the actual, collision-resolved position.\n    if GameManager.Instance != null and GameManager.Instance.Physics != null:\n        # We need the EntityID's generation for validation in C#\n        var entity_id_struct = GameManager.Instance.Entities.GetEntityMeta(entity_id).Generation\n        # This assumes entity_id is the index.\n        GameManager.Instance.Physics.ReportFinalPosition(entity_id, GameManager.Instance.Entities.GetEntityMeta(entity_id).Generation, global_position, visuals.rotation_degrees)\n    # else:\n        # push_error(\"EntityView: GameManager or PhysicsSystem not ready to report final position.\")\n\n\n## Handler for C# EntityMovedEvent. This is for reconciliation.\n## (TDD 17.2.3: Brain Reconciles)\nfunc _on_entity_moved_reconciliation(id: int, new_position: Vector2, new_rotation: float) -&gt; void:\n    if entity_id == id:\n        # This is the authoritative position from the Brain after reconciliation.\n        # We set our visual interpolation target to this.\n        brain_target_position = new_position\n        brain_target_rotation_degrees = new_rotation\n        # GD.print(\"EntityView %s: Reconciled to Brain position %s\" % [entity_id, new_position])\n\n## Handler for C# EntityVelocityUpdateEvent.\n## Parameters must match Action&lt;EntityID, Vector2, float&gt; OnEntityVelocityUpdate in C#.\nfunc _on_entity_velocity_update(id: int, target_velocity: Vector2, target_rotation_degrees: float) -&gt; void:\n    if entity_id == id:\n        # Store the target velocity and rotation from the Brain.\n        # move_and_slide() will use this in the next _physics_process call.\n        brain_target_velocity = target_velocity\n        brain_target_rotation_degrees = target_rotation_degrees\n        # GD.print(\"EntityView %s: Received target velocity %s\" % [entity_id, target_velocity])\n</code></pre> <p>Key Changes in <code>EntityView.gd</code>:</p> <ul> <li><code>brain_target_velocity</code>: New property to store the velocity received from the Brain.</li> <li><code>_physics_process</code>:<ul> <li>Now sets <code>velocity = brain_target_velocity</code>.</li> <li>Calls <code>move_and_slide()</code>.</li> <li>Calls <code>GameManager.Instance.Physics.ReportFinalPosition()</code> after <code>move_and_slide()</code> to report the actual position.</li> </ul> </li> <li><code>_on_entity_velocity_update</code>: Connects to the new C# event and stores the <code>target_velocity</code>.</li> <li><code>_on_entity_moved_reconciliation</code>: Renamed the old <code>_on_entity_moved</code> to clarify its role in reconciliation.</li> </ul>"},{"location":"19-chapter-19/#7-creating-a-collision-layer-body","title":"7. Creating a Collision Layer (Body)","text":"<p>For <code>move_and_slide()</code> to work, we need a simple collision object. Let's add a <code>StaticBody2D</code> with a <code>CollisionShape2D</code> to <code>Gameplay.tscn</code>.</p> <ol> <li>Open <code>res://Gameplay.tscn</code>.</li> <li>Add a <code>StaticBody2D</code> node. Rename it <code>Wall</code>.</li> <li>Add a <code>CollisionShape2D</code> as a child of <code>Wall</code>.</li> <li>In the <code>CollisionShape2D</code>'s Inspector, set its <code>Shape</code> to <code>New RectangleShape2D</code>.</li> <li>Select the <code>RectangleShape2D</code> resource. Set its <code>Size</code> to <code>Vector2(20, 200)</code> (or any size for a vertical wall).</li> <li>Position the <code>Wall</code> (e.g., <code>x=400, y=300</code>) so the player can collide with it.</li> <li>Save <code>Gameplay.tscn</code>.</li> </ol>"},{"location":"19-chapter-19/#8-testing-the-hybrid-physics-pipeline","title":"8. Testing the Hybrid Physics Pipeline","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Move the player (WASD).<ul> <li>Observe the player moving smoothly.</li> <li>Try to move the player into the <code>Wall</code> you created. The player should slide along the wall, not pass through it.</li> <li>Use Shift-Sliding (<code>Alt</code> + WASD, then release WASD while holding <code>Alt</code>). The player should continue sliding in the locked direction, even against the wall.</li> </ul> </li> </ol> <p>Expected Output (in debug console, if you print <code>_latestInput</code> in <code>InputSystem</code>):</p> <p>You'll see <code>InputSystem: Processed latest input...</code> showing your WASD and Shift/Alt states. You should also see many <code>PhysicsSystem: Reconciled...</code> messages, confirming the Body is reporting back to the Brain.</p> <p>This confirms the hybrid physics pipeline is functional: the C# Brain dictates the intent (velocity), Godot's Body resolves the actual collisions, and the Body reports the final position back to the Brain for reconciliation.</p>"},{"location":"19-chapter-19/#summary","title":"Summary","text":"<p>You have successfully implemented Sigilborne's Hybrid Physics Architecture, leveraging Godot's <code>CharacterBody2D</code> for collision detection and resolution while the C# Brain maintains authoritative control over velocity and position. By designing a <code>PhysicsSystem</code> for reconciliation and modifying <code>MovementSystem</code> and <code>EntityView.gd</code> to work in concert, you've established a robust pipeline where the Brain calculates intent, the Body resolves physical interactions via <code>move_and_slide()</code>, and the final position is reported back to the Brain, strictly adhering to TDD 17's specifications.</p>"},{"location":"19-chapter-19/#next-steps","title":"Next Steps","text":"<p>This concludes Module 2: Player Input &amp; Core Movement. We will now move on to Module 3: The Glyph System - Language of Ninjutsu, where we will begin to design and implement the procedural generation of glyph meanings and the player's discovery mechanics.</p>"},{"location":"20-chapter-20/","title":"Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)","text":""},{"location":"20-chapter-20/#chapter-31-glyph-database-concepts-vs-symbols-c","title":"Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)","text":"<p>Welcome to Module 3: The Glyph System - Language of Ninjutsu! This module dives into Sigilborne's core magic system. Unlike traditional RPGs with fixed spell lists, Sigilborne's magic is dynamic: the meaning of a \"hand sign\" (glyph symbol) is randomized per world. This chapter lays the groundwork by separating abstract <code>Concepts</code> (the mechanical effects like Fire, Water) from <code>Symbols</code> (the visual hand signs like Triangle, Circle) and establishing a database to manage them in the C# Brain, as specified in TDD 15.2.</p>"},{"location":"20-chapter-20/#1-the-philosophical-core-dynamic-magic","title":"1. The Philosophical Core: Dynamic Magic","text":"<p>The GDD (B01.3) states that each glyph's actual effect (its \"meaning\") is generated uniquely per world. This is achieved by decoupling the visual representation from its mechanical function.</p> <ul> <li>Concepts: These are the underlying, stable magical archetypes (e.g., Bloom, Veil, Pulse, Bind). They are universal across all worlds.</li> <li>Symbols: These are the visual hand signs the player sees and performs (e.g., a specific hand gesture, a rune-like graphic). They are also universal in their visual form, but their meaning changes.</li> </ul> <p>The \"magic\" happens when a <code>Symbol</code> is mapped to a <code>Concept</code> for a specific world.</p>"},{"location":"20-chapter-20/#2-defining-glyph-concepts-enums","title":"2. Defining Glyph <code>Concepts</code> (Enums)","text":"<p><code>Concepts</code> represent the fundamental magical archetypes. They are stable and unchanging, providing long-term player intuition.</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Magic/</code>.</li> <li>Create <code>res://_Brain/Systems/Magic/GlyphConcepts.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphConcepts.cs\nusing System;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents the fundamental, stable magical archetypes (mechanical categories).\n    /// These concepts are universal across all worlds.\n    /// (GDD B01.2, TDD 15.2)\n    /// &lt;/summary&gt;\n    public enum GlyphConcept\n    {\n        None,       // Default or invalid concept\n        Bloom,      // Growth, expansion, healing\n        Veil,       // Concealment, distortion, illusion\n        Pulse,      // Shock, bursts, force\n        Bind,       // Control, restraint, entanglement\n        Consume,    // Drain, corruption, decay\n        Fracture,   // Division, instability, breaking\n        Echo,       // Duplication, resonance, memory\n        Project,    // Beams, projectiles, focused energy\n        Conjure,    // Materialization, summoning\n        Shape,      // Form manipulation, alteration\n        Flux,       // Transformation, chaotic change\n        Chain,      // Propagation, linking, spreading\n        // Add more concepts as defined in GDD B01.2 if needed\n    }\n}\n</code></pre>"},{"location":"20-chapter-20/#3-defining-glyph-symbols-ids","title":"3. Defining Glyph <code>Symbols</code> (IDs)","text":"<p><code>Symbols</code> are the visual hand signs. They are unique and fixed in their visual appearance across the global database, but their assigned meaning (to a <code>GlyphConcept</code>) changes per world.</p> <p>We'll define these as simple string IDs for now, representing distinct visual assets.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/GlyphSymbols.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphSymbols.cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents the static, visual hand-sign symbols available in the global pool.\n    /// Each symbol has a unique string ID corresponding to a visual asset.\n    /// (GDD B01.1, TDD 15.2)\n    /// &lt;/summary&gt;\n    public static class GlyphSymbols\n    {\n        // Example static list of all available glyph symbol IDs.\n        // In a real game, these might be loaded from a config file or asset manifest.\n        public static readonly IReadOnlyList&lt;string&gt; AllSymbols = new List&lt;string&gt;\n        {\n            \"symbol_triangle\",\n            \"symbol_circle\",\n            \"symbol_square\",\n            \"symbol_spiral\",\n            \"symbol_dot\",\n            \"symbol_cross\",\n            \"symbol_wave\",\n            \"symbol_star\",\n            \"symbol_moon\",\n            \"symbol_sun\",\n            // Add more symbols to reach the GDD's 100+ global pool\n            \"symbol_diamond\", \"symbol_pentagon\", \"symbol_hexagon\", \"symbol_infinity\",\n            \"symbol_lightning\", \"symbol_leaf\", \"symbol_drop\", \"symbol_fire\",\n            \"symbol_eye\", \"symbol_mouth\", \"symbol_hand\", \"symbol_foot\",\n            \"symbol_mountain\", \"symbol_river\", \"symbol_cloud\", \"symbol_tree\",\n            // ... and so on, up to 100+ unique visual identifiers.\n        };\n\n        /// &lt;summary&gt;\n        /// Returns a subset of all available symbols, simulating a world drawing 50-80 glyphs\n        /// from the global pool (GDD B01.2).\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"worldSeed\"&gt;The seed for world generation.&lt;/param&gt;\n        /// &lt;param name=\"count\"&gt;The number of symbols to select.&lt;/param&gt;\n        /// &lt;returns&gt;A list of selected symbol IDs for a specific world.&lt;/returns&gt;\n        public static List&lt;string&gt; SelectWorldSymbols(int worldSeed, int count)\n        {\n            if (count &gt; AllSymbols.Count) count = AllSymbols.Count;\n            if (count &lt; 0) count = 0;\n\n            Random rand = new Random(worldSeed);\n            List&lt;string&gt; selected = new List&lt;string&gt;(AllSymbols);\n\n            // Shuffle and take the first 'count' elements\n            for (int i = selected.Count - 1; i &gt; 0; i--)\n            {\n                int j = rand.Next(i + 1);\n                string temp = selected[i];\n                selected[i] = selected[j];\n                selected[j] = temp;\n            }\n\n            return selected.Take(count).ToList();\n        }\n    }\n}\n</code></pre>"},{"location":"20-chapter-20/#4-the-glyph-database-worldglyphmap","title":"4. The Glyph Database: <code>WorldGlyphMap</code>","text":"<p>This is the core data structure that stores the unique <code>Symbol</code> to <code>Concept</code> mapping for a given world. TDD 15.2 specifies that this mapping is stored in <code>WorldData.GlyphMap</code>. For now, we'll implement it as a standalone class.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/WorldGlyphMap.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/WorldGlyphMap.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents a single glyph definition for a specific world, mapping a visual symbol to a mechanical concept.\n    /// (TDD 15.2)\n    /// &lt;/summary&gt;\n    public struct WorldGlyphDefinition\n    {\n        public string SymbolID;     // e.g., \"symbol_triangle\"\n        public GlyphConcept Concept; // e.g., GlyphConcept.Fire\n        // Subtype information will be added in a later chapter (GDD B01.3, TDD 15.4)\n\n        public WorldGlyphDefinition(string symbolId, GlyphConcept concept)\n        {\n            SymbolID = symbolId;\n            Concept = concept;\n        }\n\n        public override string ToString()\n        {\n            return $\"Symbol: '{SymbolID}' -&gt; Concept: {Concept}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// The authoritative database for a world's unique Glyph Symbol to Concept mapping.\n    /// This is generated once per world seed.\n    /// (TDD 15.2)\n    /// &lt;/summary&gt;\n    public class WorldGlyphMap\n    {\n        private Dictionary&lt;string, WorldGlyphDefinition&gt; _symbolToDefinition = new Dictionary&lt;string, WorldGlyphDefinition&gt;();\n        private Dictionary&lt;GlyphConcept, WorldGlyphDefinition&gt; _conceptToDefinition = new Dictionary&lt;GlyphConcept, WorldGlyphDefinition&gt;(); // Optional reverse lookup\n\n        // Expose the definitions as a read-only list for iteration or UI display\n        public IReadOnlyList&lt;WorldGlyphDefinition&gt; AllWorldGlyphs =&gt; _symbolToDefinition.Values.ToList().AsReadOnly();\n\n        public WorldGlyphMap(int worldSeed, int glyphCount)\n        {\n            GenerateWorldGlyphMap(worldSeed, glyphCount);\n            GD.Print($\"WorldGlyphMap: Generated {AllWorldGlyphs.Count} glyph definitions for world seed {worldSeed}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Generates the unique Symbol to Concept mapping for a new world.\n        /// (TDD 15.2: Generation Logic)\n        /// &lt;/summary&gt;\n        private void GenerateWorldGlyphMap(int worldSeed, int glyphCount)\n        {\n            Random rand = new Random(worldSeed);\n\n            // 1. Select a subset of symbols for this world (GDD B01.2)\n            List&lt;string&gt; selectedSymbols = GlyphSymbols.SelectWorldSymbols(worldSeed, glyphCount);\n\n            // 2. Get all available concepts (excluding 'None')\n            List&lt;GlyphConcept&gt; availableConcepts = Enum.GetValues(typeof(GlyphConcept))\n                                                        .Cast&lt;GlyphConcept&gt;()\n                                                        .Where(c =&gt; c != GlyphConcept.None)\n                                                        .ToList();\n\n            // Ensure we don't try to map more symbols than concepts available\n            if (selectedSymbols.Count &gt; availableConcepts.Count)\n            {\n                GD.PrintErr($\"WorldGlyphMap: Not enough unique concepts ({availableConcepts.Count}) for {selectedSymbols.Count} symbols. Some symbols will share concepts.\");\n                // For now, we'll allow sharing concepts, or just map fewer symbols.\n                // A more robust system might disallow this or add \"minor\" concepts.\n            }\n\n            // Shuffle concepts to ensure random assignment\n            for (int i = availableConcepts.Count - 1; i &gt; 0; i--)\n            {\n                int j = rand.Next(i + 1);\n                GlyphConcept temp = availableConcepts[i];\n                availableConcepts[i] = availableConcepts[j];\n                availableConcepts[j] = temp;\n            }\n\n            // 3. Assign each selected symbol to a unique concept (or reuse if concepts run out)\n            for (int i = 0; i &lt; selectedSymbols.Count; i++)\n            {\n                string symbol = selectedSymbols[i];\n                GlyphConcept concept = availableConcepts[i % availableConcepts.Count]; // Cycle through concepts if more symbols than unique concepts\n\n                WorldGlyphDefinition def = new WorldGlyphDefinition(symbol, concept);\n                _symbolToDefinition.Add(symbol, def);\n                // For reverse lookup, store only if concept isn't already mapped (i.e., unique concept mapping)\n                if (!_conceptToDefinition.ContainsKey(concept))\n                {\n                    _conceptToDefinition.Add(concept, def);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the WorldGlyphDefinition for a given SymbolID.\n        /// &lt;/summary&gt;\n        public WorldGlyphDefinition GetDefinitionBySymbol(string symbolID)\n        {\n            if (_symbolToDefinition.TryGetValue(symbolID, out WorldGlyphDefinition def))\n            {\n                return def;\n            }\n            GD.PrintErr($\"WorldGlyphMap: No definition found for symbol '{symbolID}'.\");\n            return new WorldGlyphDefinition(symbolID, GlyphConcept.None);\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the WorldGlyphDefinition for a given GlyphConcept.\n        /// (Useful for AI or systems that know the concept but need the symbol)\n        /// &lt;/summary&gt;\n        public WorldGlyphDefinition GetDefinitionByConcept(GlyphConcept concept)\n        {\n            if (_conceptToDefinition.TryGetValue(concept, out WorldGlyphDefinition def))\n            {\n                return def;\n            }\n            GD.PrintErr($\"WorldGlyphMap: No definition found for concept '{concept}'.\");\n            return new WorldGlyphDefinition(\"unknown_symbol\", GlyphConcept.None);\n        }\n    }\n}\n</code></pre>"},{"location":"20-chapter-20/#5-integrating-worldglyphmap-into-gamemanager","title":"5. Integrating <code>WorldGlyphMap</code> into <code>GameManager</code>","text":"<p>Now, let's make <code>WorldGlyphMap</code> a core system of our <code>GameManager</code>.</p> <ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>WorldGlyphMap</code> property.</li> <li>Initialize <code>WorldGlyphMap</code> in <code>InitializeSystems()</code>. We'll pass a <code>worldSeed</code> (e.g., from a future <code>WorldGenerationSystem</code>) and a <code>glyphCount</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic; // Add this using directive\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PhysicsSystem Physics { get; private set; }\n    public WorldGlyphMap GlyphMap { get; private set; } // Add WorldGlyphMap property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        Physics = new PhysicsSystem(Entities, Transforms, Events);\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        // Initialize WorldGlyphMap (TDD 15.2)\n        // For now, use a fixed seed and glyph count. These will come from world generation later.\n        int currentWorldSeed = 12345;\n        int numGlyphsForWorld = 10; // GDD B01.2: Player typically learns 8-12 early, 20-30 late.\n                                   // This is the number available in *this* world.\n        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);\n        GD.Print(\"  - WorldGlyphMap initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"20-chapter-20/#6-testing-glyph-database-generation","title":"6. Testing Glyph Database Generation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>In the Output console, you should see messages indicating the <code>WorldGlyphMap</code> initialization.</li> </ol> <pre><code>...\n  - PhysicsSystem initialized.\nWorldGlyphMap: Generated 10 glyph definitions for world seed 12345.\n  - WorldGlyphMap initialized.\n  - WorldSimulation initialized.\n...\n</code></pre> <p>You can also use the debug console to inspect the generated map (we'll add a command for this later). For now, you can temporarily add a print loop in <code>GameManager._Ready()</code> to see the generated definitions:</p> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready, after GlyphMap initialization)\n        GD.Print(\"\\n--- Generated World Glyphs ---\");\n        foreach (var glyphDef in GlyphMap.AllWorldGlyphs)\n        {\n            GD.Print(glyphDef.ToString());\n        }\n        GD.Print(\"------------------------------\\n\");\n</code></pre> <p>Run again, and you'll see a list like:</p> <pre><code>--- Generated World Glyphs ---\nSymbol: 'symbol_leaf' -&gt; Concept: Bloom\nSymbol: 'symbol_cross' -&gt; Concept: Consume\nSymbol: 'symbol_spiral' -&gt; Concept: Pulse\nSymbol: 'symbol_pentagon' -&gt; Concept: Veil\nSymbol: 'symbol_hand' -&gt; Concept: Chain\nSymbol: 'symbol_triangle' -&gt; Concept: Echo\nSymbol: 'symbol_sun' -&gt; Concept: Fracture\nSymbol: 'symbol_river' -&gt; Concept: Shape\nSymbol: 'symbol_dot' -&gt; Concept: Project\nSymbol: 'symbol_wave' -&gt; Concept: Bind\n------------------------------\n</code></pre> <p>The specific mappings will vary if you change <code>currentWorldSeed</code>. This demonstrates the procedural generation of glyph meanings for each world.</p>"},{"location":"20-chapter-20/#summary","title":"Summary","text":"<p>You have successfully implemented the foundational Glyph Database for Sigilborne, clearly separating <code>GlyphConcept</code> (mechanical archetypes) from <code>GlyphSymbol</code> (visual hand signs). By designing <code>WorldGlyphMap</code> to procedurally generate a unique <code>Symbol</code> to <code>Concept</code> mapping for each world seed, you've established the core mechanism for dynamic magic, strictly adhering to TDD 15.2's specifications. This crucial step enables infinite replayability and ensures every playthrough feels like a coherent, yet unique, magical language.</p>"},{"location":"20-chapter-20/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on the Glyph Discovery System, implementing how players learn these randomized glyph meanings through experimentation, observation, and reading scrolls, and how their <code>KnowledgeState</code> progresses over time.</p>"},{"location":"21-chapter-21/","title":"Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)","text":""},{"location":"21-chapter-21/#chapter-32-glyph-discovery-system-player-knowledge-state-c","title":"Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)","text":"<p>With our <code>WorldGlyphMap</code> creating unique glyph meanings per world, the next critical step is to implement the Glyph Discovery System. Players don't start knowing these meanings; they must learn them. This chapter focuses on tracking the player's <code>KnowledgeState</code> for each glyph (Hidden, Seen, Known) and implementing the feedback loop for revealing glyph meanings, as outlined in TDD 15.3.</p>"},{"location":"21-chapter-21/#1-the-discovery-philosophy-mystery-and-experimentation","title":"1. The Discovery Philosophy: Mystery and Experimentation","text":"<p>The GDD (B01.4) emphasizes that players learn glyphs through teachers, observation, scrolls, and experimentation. This means the system must:</p> <ul> <li>Hide Information: Initially, glyph meanings are unknown.</li> <li>Progressive Revelation: Knowledge is gained in stages.</li> <li>Feedback: The game must clearly communicate when a player gains new knowledge.</li> </ul>"},{"location":"21-chapter-21/#2-defining-glyphknowledgestate","title":"2. Defining <code>GlyphKnowledgeState</code>","text":"<p>We need an enum to represent the different levels of knowledge a player has about a specific glyph symbol.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/GlyphConcepts.cs</code> and add the <code>GlyphKnowledgeState</code> enum:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphConcepts.cs\nusing System;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (GlyphConcept enum) ...\n\n    /// &lt;summary&gt;\n    /// Represents the player's knowledge state about a specific glyph symbol.\n    /// (TDD 15.3)\n    /// &lt;/summary&gt;\n    public enum GlyphKnowledgeState\n    {\n        Hidden, // Player sees \"???\" or a blurred rune. Has no idea what it is.\n        Seen,   // Player has seen the symbol (e.g., an NPC cast it). Knows the visual but not the meaning.\n        Known   // Player knows the symbol's concept (e.g., \"Triangle is Fire\"). Can attempt to cast.\n    }\n}\n</code></pre>"},{"location":"21-chapter-21/#3-implementing-playerglyphknowledgesystemcs","title":"3. Implementing <code>PlayerGlyphKnowledgeSystem.cs</code>","text":"<p>This system will manage the player's knowledge state for all glyphs in the current world.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/PlayerGlyphKnowledgeSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/PlayerGlyphKnowledgeSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Manages the player's knowledge state for each glyph symbol in the current world.\n    /// (TDD 15.3)\n    /// &lt;/summary&gt;\n    public class PlayerGlyphKnowledgeSystem\n    {\n        private EntityID _playerEntityID;\n        private WorldGlyphMap _worldGlyphMap; // Reference to the world's glyph definitions\n        private EventBus _eventBus;\n\n        // Dictionary to store the player's knowledge state for each glyph symbol ID.\n        private Dictionary&lt;string, GlyphKnowledgeState&gt; _playerGlyphKnowledge = new Dictionary&lt;string, GlyphKnowledgeState&gt;();\n\n        public PlayerGlyphKnowledgeSystem(EntityID playerEntityID, WorldGlyphMap worldGlyphMap, EventBus eventBus)\n        {\n            _playerEntityID = playerEntityID;\n            _worldGlyphMap = worldGlyphMap;\n            _eventBus = eventBus;\n\n            // Initialize all glyphs in the world map as Hidden for the player.\n            foreach (var glyphDef in _worldGlyphMap.AllWorldGlyphs)\n            {\n                _playerGlyphKnowledge.Add(glyphDef.SymbolID, GlyphKnowledgeState.Hidden);\n            }\n            GD.Print($\"PlayerGlyphKnowledgeSystem: Initialized for player {_playerEntityID} with all glyphs as Hidden.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Updates the player's knowledge state for a specific glyph symbol.\n        /// (TDD 15.3: Knowledge State)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"symbolID\"&gt;The ID of the glyph symbol.&lt;/param&gt;\n        /// &lt;param name=\"newState\"&gt;The new knowledge state.&lt;/param&gt;\n        /// &lt;param name=\"forceUpdate\"&gt;If true, updates even if new state is lower than current.&lt;/param&gt;\n        /// &lt;returns&gt;True if the knowledge state was updated, false otherwise.&lt;/returns&gt;\n        public bool UpdateGlyphKnowledge(string symbolID, GlyphKnowledgeState newState, bool forceUpdate = false)\n        {\n            if (!_playerGlyphKnowledge.ContainsKey(symbolID))\n            {\n                GD.PrintErr($\"PlayerGlyphKnowledgeSystem: Attempted to update knowledge for unknown symbol '{symbolID}'.\");\n                return false;\n            }\n\n            GlyphKnowledgeState currentState = _playerGlyphKnowledge[symbolID];\n\n            // Only update if the new state is higher or forceUpdate is true.\n            if (forceUpdate || newState &gt; currentState)\n            {\n                _playerGlyphKnowledge[symbolID] = newState;\n                GD.Print($\"PlayerGlyphKnowledgeSystem: Player {_playerEntityID} knowledge of '{symbolID}' updated from {currentState} to {newState}.\");\n\n                // Publish an event for the Body (UI) to update its display\n                _eventBus.Publish(new GlyphKnowledgeUpdatedEvent { PlayerID = _playerEntityID, SymbolID = symbolID, NewState = newState });\n\n                // If the glyph became Known, also publish its meaning for UI hints (TDD 15.3: Feedback)\n                if (newState == GlyphKnowledgeState.Known)\n                {\n                    WorldGlyphDefinition def = _worldGlyphMap.GetDefinitionBySymbol(symbolID);\n                    _eventBus.Publish(new GlyphMeaningDiscoveredEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = def.Concept });\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the player's current knowledge state for a glyph symbol.\n        /// &lt;/summary&gt;\n        public GlyphKnowledgeState GetGlyphKnowledge(string symbolID)\n        {\n            if (_playerGlyphKnowledge.TryGetValue(symbolID, out GlyphKnowledgeState state))\n            {\n                return state;\n            }\n            return GlyphKnowledgeState.Hidden; // Default to hidden if not in map (shouldn't happen with proper init)\n        }\n\n        /// &lt;summary&gt;\n        /// Returns all glyph symbols the player knows (state &gt;= Known).\n        /// &lt;/summary&gt;\n        public IEnumerable&lt;string&gt; GetKnownGlyphSymbols()\n        {\n            return _playerGlyphKnowledge.Where(kv =&gt; kv.Value &gt;= GlyphKnowledgeState.Known).Select(kv =&gt; kv.Key);\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct GlyphKnowledgeUpdatedEvent { public EntityID PlayerID; public string SymbolID; public GlyphKnowledgeState NewState; }\n        public struct GlyphMeaningDiscoveredEvent { public EntityID PlayerID; public string SymbolID; public GlyphConcept Concept; }\n    }\n}\n</code></pre>"},{"location":"21-chapter-21/#4-integrating-playerglyphknowledgesystem-into-gamemanager","title":"4. Integrating <code>PlayerGlyphKnowledgeSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>PlayerGlyphKnowledgeSystem</code> property.</li> <li>Initialize <code>PlayerGlyphKnowledgeSystem</code> in <code>InitializeSystems()</code>, passing the player's <code>EntityID</code>, <code>WorldGlyphMap</code>, and <code>EventBus</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public WorldGlyphMap GlyphMap { get; private set; }\n    public PlayerGlyphKnowledgeSystem PlayerGlyphKnowledge { get; private set; } // Add PlayerGlyphKnowledgeSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test PlayerStatSystem (Damage) ---\n        // ... (existing test damage code) ...\n        // --- End Testing PlayerStatSystem ---\n\n        // --- Test Glyph Discovery System ---\n        GD.Print(\"\\n--- Testing Glyph Discovery System ---\");\n        // Get a symbol from the generated map for testing\n        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID; // e.g., \"symbol_leaf\"\n        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s)); // Get a symbol not in this world\n\n        GD.Print($\"Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Seen);\n        GD.Print($\"Knowledge of '{testSymbol}' after 'Seen': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Known);\n        GD.Print($\"Knowledge of '{testSymbol}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n\n        GD.Print($\"Attempt to update unknown symbol '{unknownSymbol}':\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known); // Should print an error\n\n        GD.Print(\"--- End Testing Glyph Discovery System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        Physics = new PhysicsSystem(Entities, Transforms, Events);\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        int currentWorldSeed = 12345;\n        int numGlyphsForWorld = 10;\n        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);\n        GD.Print(\"  - WorldGlyphMap initialized.\");\n\n        // Initialize PlayerGlyphKnowledgeSystem (TDD 15.3)\n        // We need the player's EntityID, which is created earlier in _Ready().\n        // For now, let's create a temporary player ID for initialization.\n        // In a proper game flow, this would happen AFTER the player entity is confirmed.\n        // We'll rely on EntityManager.GetPlayerEntityID() for now, assuming it's set.\n        // To be safe, we'll initialize this AFTER the player entity is created in _Ready.\n        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);\n        GD.Print(\"  - PlayerGlyphKnowledgeSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre> <p>Important Note: The <code>PlayerGlyphKnowledgeSystem</code> needs the player's <code>EntityID</code>. In our current <code>GameManager._Ready()</code> test setup, the player entity is created before <code>InitializeSystems()</code> is fully done. A more robust solution for the full game would be to: 1.  Spawn the player entity. 2.  Then, in a callback or a later <code>_Ready</code> phase, initialize <code>PlayerGlyphKnowledgeSystem</code> using <code>GameManager.Instance.Entities.GetPlayerEntityID()</code>. For this chapter's testing, <code>Entities.GetPlayerEntityID()</code> should work because the player entity is indeed created before <code>InitializeSystems()</code> finishes in <code>_Ready</code>.</p>"},{"location":"21-chapter-21/#41-update-eventbuscs-for-glyph-knowledge-events","title":"4.1. Update <code>EventBus.cs</code> for Glyph Knowledge Events","text":"<p>Our <code>PlayerGlyphKnowledgeSystem</code> publishes <code>GlyphKnowledgeUpdatedEvent</code> and <code>GlyphMeaningDiscoveredEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Glyph Knowledge Events (TDD 15.3)\n        public event Action&lt;EntityID, string, GlyphKnowledgeState&gt; OnGlyphKnowledgeUpdated;\n        public event Action&lt;EntityID, string, GlyphConcept&gt; OnGlyphMeaningDiscovered;\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerGlyphKnowledgeSystem.GlyphKnowledgeUpdatedEvent knowledgeEvent) // New condition\n            {\n                OnGlyphKnowledgeUpdated?.Invoke(knowledgeEvent.PlayerID, knowledgeEvent.SymbolID, knowledgeEvent.NewState);\n            }\n            else if (eventData is PlayerGlyphKnowledgeSystem.GlyphMeaningDiscoveredEvent meaningEvent) // New condition\n            {\n                OnGlyphMeaningDiscovered?.Invoke(meaningEvent.PlayerID, meaningEvent.SymbolID, meaningEvent.Concept);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"21-chapter-21/#5-testing-glyph-discovery","title":"5. Testing Glyph Discovery","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>In the Output console, you should see the <code>PlayerGlyphKnowledgeSystem</code> initialization and test messages.</li> </ol> <pre><code>...\nPlayerStatSystem: Initialized stats for player EntityID(0, Gen:1): Health: 100/100, Chakra: 50/50, Stamina: 75/75\n  - PlayerStatSystem initialized.\n  - DebugCommandSystem initialized.\n  - InputSystem initialized.\n  - MovementSystem initialized.\n  - PhysicsSystem initialized.\nWorldGlyphMap: Generated 10 glyph definitions for world seed 12345.\n  - WorldGlyphMap initialized.\nPlayerGlyphKnowledgeSystem: Initialized for player EntityID(0, Gen:1) with all glyphs as Hidden.\n  - PlayerGlyphKnowledgeSystem initialized.\n  - WorldSimulation initialized.\n...\n--- Testing Glyph Discovery System ---\nInitial knowledge of 'symbol_leaf': Hidden\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Hidden to Seen.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Seen to Known.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Seen to Known.\nAttempt to update unknown symbol 'symbol_triangle_alt':\nPlayerGlyphKnowledgeSystem: Attempted to update knowledge for unknown symbol 'symbol_triangle_alt'.\n--- End Testing Glyph Discovery System ---\n...\n</code></pre> <p>This output confirms that: *   The player's glyph knowledge is correctly initialized to <code>Hidden</code>. *   <code>UpdateGlyphKnowledge</code> successfully transitions the state from <code>Hidden</code> to <code>Seen</code> to <code>Known</code>. *   An error is logged when trying to update an unknown symbol. *   <code>GlyphKnowledgeUpdatedEvent</code> and <code>GlyphMeaningDiscoveredEvent</code> are published when the state reaches <code>Known</code>.</p>"},{"location":"21-chapter-21/#summary","title":"Summary","text":"<p>You have successfully implemented the Glyph Discovery System for Sigilborne, allowing players to progressively learn the randomized meanings of glyph symbols. By defining <code>GlyphKnowledgeState</code> and creating <code>PlayerGlyphKnowledgeSystem</code> to manage this state, you've established a core mechanism for progressive revelation. The system correctly initializes glyphs as <code>Hidden</code>, updates knowledge through stages, and publishes events for UI feedback, strictly adhering to TDD 15.3's specifications. This sets the stage for experimentation and a unique learning journey in each world.</p>"},{"location":"21-chapter-21/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Glyph Experimentation, implementing how players attempt to combine glyphs, process the results (success, fizzle, discovery), and handle the crucial feedback loop that reveals glyph meanings or hints at new combos.</p>"},{"location":"22-chapter-22/","title":"Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)","text":""},{"location":"22-chapter-22/#chapter-33-glyph-experimentation-trial-error-casting-c","title":"Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)","text":"<p>With glyph meanings defined and player knowledge tracked, it's time for the player to actually use (or attempt to use) these glyphs. This chapter implements the core Glyph Experimentation loop, where players input sequences of glyphs. The system will process these inputs, determine if they form a valid known combo, a new plausible technique, or simply fizzle, and provide appropriate feedback, including revealing glyph meanings, as specified in TDD 15.3.</p> <p>This is where the magic (or the misfire) truly happens!</p>"},{"location":"22-chapter-22/#1-the-experimentation-loop-input-interpretation-outcome","title":"1. The Experimentation Loop: Input -&gt; Interpretation -&gt; Outcome","text":"<p>The GDD (B01.4, B02.2) emphasizes freeform combos and interpretation by world logic. This requires:</p> <ul> <li>Input Capture: We already have this via <code>InputSystem</code> and <code>PlayerInputFrame</code>.</li> <li>Glyph Mapping: The player presses a hotbar key, which maps to a <code>GlyphSymbolID</code>. This symbol is then looked up in the <code>WorldGlyphMap</code> to get its <code>GlyphConcept</code>.</li> <li>Sequence Interpretation: The sequence of <code>GlyphConcept</code>s is analyzed to determine the outcome.</li> <li>Outcome &amp; Feedback: Based on the interpretation, a <code>SpellDefinition</code> is either found/created, or a fizzle/miscast occurs, and knowledge is updated.</li> </ul>"},{"location":"22-chapter-22/#2-mapping-hotbar-input-to-glyph-symbols","title":"2. Mapping Hotbar Input to Glyph Symbols","text":"<p>First, we need a way to map hotbar key presses to specific <code>GlyphSymbolID</code>s. This mapping will be dynamic and tied to the player's learned glyphs.</p> <p>We'll create a <code>PlayerHotbarSystem</code> to manage what glyphs are currently \"equipped\" to the hotbar.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/PlayerHotbarSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/PlayerHotbarSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Manages the glyphs (symbols) currently assigned to the player's hotbar slots.\n    /// (GDD B05.2: The Recursive Mastery Deck)\n    /// &lt;/summary&gt;\n    public class PlayerHotbarSystem\n    {\n        private EntityID _playerEntityID;\n        private EventBus _eventBus;\n        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;\n        private WorldGlyphMap _worldGlyphMap;\n\n        // The hotbar slots. Max 10 slots (TDD 12.5).\n        // Stores the SymbolID assigned to each slot. Null if slot is empty.\n        private string[] _hotbarSlots = new string[10];\n\n        public PlayerHotbarSystem(EntityID playerEntityID, EventBus eventBus, PlayerGlyphKnowledgeSystem playerGlyphKnowledge, WorldGlyphMap worldGlyphMap)\n        {\n            _playerEntityID = playerEntityID;\n            _eventBus = eventBus;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n\n            // Initially, hotbar is empty.\n            // For testing, let's assign the first few known glyphs to the hotbar.\n            // In a real game, players would equip these via UI.\n            GD.Print($\"PlayerHotbarSystem: Initialized for player {_playerEntityID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Assigns a glyph symbol to a specific hotbar slot.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"slotIndex\"&gt;The 0-9 index of the hotbar slot.&lt;/param&gt;\n        /// &lt;param name=\"symbolID\"&gt;The ID of the glyph symbol. Null/empty to unequip.&lt;/param&gt;\n        /// &lt;returns&gt;True if assignment was successful, false otherwise (e.g., unknown symbol, invalid slot).&lt;/returns&gt;\n        public bool AssignGlyphToSlot(int slotIndex, string symbolID)\n        {\n            if (slotIndex &lt; 0 || slotIndex &gt;= _hotbarSlots.Length)\n            {\n                GD.PrintErr($\"PlayerHotbarSystem: Invalid hotbar slot index: {slotIndex}.\");\n                return false;\n            }\n\n            if (string.IsNullOrEmpty(symbolID))\n            {\n                _hotbarSlots[slotIndex] = null; // Unequip\n                GD.Print($\"PlayerHotbarSystem: Unequipped slot {slotIndex}.\");\n                _eventBus.Publish(new HotbarSlotUpdatedEvent { PlayerID = _playerEntityID, SlotIndex = slotIndex, SymbolID = null });\n                return true;\n            }\n\n            // Check if the player knows this glyph and if it's a valid symbol for this world\n            if (_playerGlyphKnowledge.GetGlyphKnowledge(symbolID) &lt; GlyphKnowledgeState.Known)\n            {\n                GD.PrintErr($\"PlayerHotbarSystem: Player does not know glyph '{symbolID}'. Cannot assign to hotbar.\");\n                return false;\n            }\n            if (!_worldGlyphMap.GetDefinitionBySymbol(symbolID).Concept.IsValidConcept()) // Check if symbol maps to a valid concept in this world\n            {\n                GD.PrintErr($\"PlayerHotbarSystem: Symbol '{symbolID}' is not a valid glyph in this world. Cannot assign to hotbar.\");\n                return false;\n            }\n\n            _hotbarSlots[slotIndex] = symbolID;\n            GD.Print($\"PlayerHotbarSystem: Assigned '{symbolID}' to slot {slotIndex}.\");\n            _eventBus.Publish(new HotbarSlotUpdatedEvent { PlayerID = _playerEntityID, SlotIndex = slotIndex, SymbolID = symbolID });\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the glyph symbol ID assigned to a hotbar slot.\n        /// &lt;/summary&gt;\n        public string GetGlyphSymbolInSlot(int slotIndex)\n        {\n            if (slotIndex &gt;= 0 &amp;&amp; slotIndex &lt; _hotbarSlots.Length)\n            {\n                return _hotbarSlots[slotIndex];\n            }\n            return null;\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct HotbarSlotUpdatedEvent { public EntityID PlayerID; public int SlotIndex; public string SymbolID; }\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#21-update-glyphconceptscs-with-isvalidconcept","title":"2.1. Update <code>GlyphConcepts.cs</code> with <code>IsValidConcept</code>","text":"<p>We need a helper method to check if a <code>GlyphConcept</code> is valid (i.e., not <code>None</code>).</p> <p>Open <code>res://_Brain/Systems/Magic/GlyphConcepts.cs</code> and add this extension method:</p> <pre><code>// _Brain/Systems/Magic/GlyphConcepts.cs\nusing System;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (GlyphConcept enum) ...\n    // ... (GlyphKnowledgeState enum) ...\n\n    public static class GlyphConceptExtensions\n    {\n        public static bool IsValidConcept(this GlyphConcept concept)\n        {\n            return concept != GlyphConcept.None;\n        }\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#3-integrating-playerhotbarsystem-into-gamemanager","title":"3. Integrating <code>PlayerHotbarSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>PlayerHotbarSystem</code> property.</li> <li>Initialize <code>PlayerHotbarSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq; // For .First() in test\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PlayerGlyphKnowledgeSystem PlayerGlyphKnowledge { get; private set; }\n    public PlayerHotbarSystem PlayerHotbar { get; private set; } // Add PlayerHotbarSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test Glyph Discovery System ---\n        GD.Print(\"\\n--- Testing Glyph Discovery System ---\");\n        // Get a symbol from the generated map for testing\n        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID; // e.g., \"symbol_leaf\"\n        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID; // e.g., \"symbol_cross\"\n        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s));\n\n        GD.Print($\"Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Seen);\n        GD.Print($\"Knowledge of '{testSymbol}' after 'Seen': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Known);\n        GD.Print($\"Knowledge of '{testSymbol}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known); // Make second symbol known for hotbar test\n        GD.Print($\"Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}\");\n\n        GD.Print($\"Attempt to update unknown symbol '{unknownSymbol}':\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known);\n\n        GD.Print(\"--- End Testing Glyph Discovery System ---\\n\");\n\n        // --- Test PlayerHotbarSystem ---\n        GD.Print(\"\\n--- Testing PlayerHotbarSystem ---\");\n        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign known symbol\n        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign another known symbol\n        PlayerHotbar.AssignGlyphToSlot(2, unknownSymbol); // Attempt to assign unknown symbol (should fail)\n        PlayerHotbar.AssignGlyphToSlot(9, testSymbol); // Assign to last slot\n        PlayerHotbar.AssignGlyphToSlot(0, null); // Unequip slot 0\n        GD.Print($\"Glyph in slot 1: {PlayerHotbar.GetGlyphSymbolInSlot(1)}\");\n        GD.Print(\"--- End Testing PlayerHotbarSystem ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        Events = new EventBus();\n        GD.Print(\"  - EventBus initialized.\");\n\n        Time = new TimeSystem();\n        GD.Print(\"  - TimeSystem initialized.\");\n\n        Entities = new EntityManager(Events);\n        GD.Print(\"  - EntityManager initialized.\");\n\n        Transforms = new TransformSystem(Entities, Events);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        Jobs = new JobSystem(Events);\n        GD.Print(\"  - JobSystem initialized.\");\n\n        PlayerStats = new PlayerStatSystem(Events, Entities);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        Physics = new PhysicsSystem(Entities, Transforms, Events);\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        int currentWorldSeed = 12345;\n        int numGlyphsForWorld = 10;\n        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);\n        GD.Print(\"  - WorldGlyphMap initialized.\");\n\n        // Player entity is created in _Ready(), so its ID is available when InitializeSystems() is called.\n        // This is safe because _Ready() runs before InitializeSystems() in Godot's execution order.\n        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);\n        GD.Print(\"  - PlayerGlyphKnowledgeSystem initialized.\");\n\n        // Initialize PlayerHotbarSystem\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#31-update-eventbuscs-for-hotbar-events","title":"3.1. Update <code>EventBus.cs</code> for Hotbar Events","text":"<p>Our <code>PlayerHotbarSystem</code> publishes <code>HotbarSlotUpdatedEvent</code>. We need to define this <code>Action</code> delegate in <code>EventBus</code>.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Hotbar Events (TDD 12.5)\n        public event Action&lt;EntityID, int, string&gt; OnHotbarSlotUpdated;\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerHotbarSystem.HotbarSlotUpdatedEvent hotbarEvent) // New condition\n            {\n                OnHotbarSlotUpdated?.Invoke(hotbarEvent.PlayerID, hotbarEvent.SlotIndex, hotbarEvent.SymbolID);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#4-implementing-the-magicsystem-core-logic","title":"4. Implementing the <code>MagicSystem</code> (Core Logic)","text":"<p>This system will take hotbar inputs, resolve them into glyph concepts, and then (in later chapters) trigger spell casting. For now, it will focus on processing the input sequence and providing feedback.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/MagicSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Input; // To get hotbar input\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents a single glyph input by the player as part of a sequence.\n    /// (TDD 02.1)\n    /// &lt;/summary&gt;\n    public struct GlyphInputFrame\n    {\n        public string SymbolID;     // The visual symbol ID (e.g., \"symbol_triangle\")\n        public GlyphConcept Concept; // The resolved mechanical concept (e.g., GlyphConcept.Fire)\n        public double Timestamp;    // When this input occurred (real time)\n        public bool Consumed;       // Whether this input has been part of a successfully resolved combo\n\n        public GlyphInputFrame(string symbolID, GlyphConcept concept, double timestamp)\n        {\n            SymbolID = symbolID;\n            Concept = concept;\n            Timestamp = timestamp;\n            Consumed = false;\n        }\n\n        public override string ToString()\n        {\n            return $\"'{SymbolID}' ({Concept}) @ {Timestamp:F3}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Manages the core magic system: processing glyph input sequences,\n    /// resolving combos, and triggering spell effects.\n    /// (TDD 02.1: InputBuffer, TDD 02.2: Combo Resolver)\n    /// &lt;/summary&gt;\n    public class MagicSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private PlayerHotbarSystem _playerHotbar;\n        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;\n        private WorldGlyphMap _worldGlyphMap;\n\n        private EntityID _playerEntityID;\n\n        // TDD 02.1: InputBuffer - We'll use a List as a circular buffer for simplicity in C#.\n        private List&lt;GlyphInputFrame&gt; _glyphInputBuffer = new List&lt;GlyphInputFrame&gt;();\n        private const int MAX_GLYPH_BUFFER_SIZE = 10; // Max glyphs in a sequence\n        private const float MAX_COMBO_DELAY = 1.5f; // Max time between glyph inputs for a combo (GDD B05.6)\n\n        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,\n                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,\n                           WorldGlyphMap worldGlyphMap)\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _playerHotbar = playerHotbar;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID(); // Get player's ID\n\n            GD.Print(\"MagicSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the MagicSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n            double currentTime = _gameManager.Time.CurrentGameTime; // Assuming GameManager is accessible\n\n            // Process hotbar inputs for glyphs\n            for (int i = 0; i &lt; currentInput.HotbarKeys.Length; i++)\n            {\n                if (currentInput.HotbarKeys[i]) // If hotbar key is pressed\n                {\n                    string symbolID = _playerHotbar.GetGlyphSymbolInSlot(i);\n                    if (symbolID != null)\n                    {\n                        ProcessGlyphInput(symbolID, currentTime);\n                    }\n                }\n            }\n\n            // Clean up old inputs from the buffer (GDD B05.6: Combo Timing Window)\n            _glyphInputBuffer.RemoveAll(f =&gt; (currentTime - f.Timestamp) &gt; MAX_COMBO_DELAY * 2); // Keep for a bit longer than max combo delay\n        }\n\n        /// &lt;summary&gt;\n        /// Processes a single glyph input (from hotbar press).\n        /// Adds it to the buffer and attempts to resolve a combo.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"symbolID\"&gt;The symbol ID of the glyph that was input.&lt;/param&gt;\n        /// &lt;param name=\"timestamp\"&gt;The real-time timestamp of the input.&lt;/param&gt;\n        private void ProcessGlyphInput(string symbolID, double timestamp)\n        {\n            // Check if this glyph was already input very recently (debounce)\n            if (_glyphInputBuffer.Any(f =&gt; f.SymbolID == symbolID &amp;&amp; (timestamp - f.Timestamp) &lt; 0.1f)) // 0.1s debounce\n            {\n                return;\n            }\n\n            // Get player's knowledge of this glyph (TDD 15.3)\n            GlyphKnowledgeState knowledge = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);\n            if (knowledge == GlyphKnowledgeState.Hidden)\n            {\n                // If player doesn't even know the symbol, just mark as seen.\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, GlyphKnowledgeState.Seen);\n                GD.Print($\"MagicSystem: Player saw symbol '{symbolID}'.\");\n                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = false });\n                return;\n            }\n\n            // If player knows the symbol, get its concept\n            WorldGlyphDefinition glyphDef = _worldGlyphMap.GetDefinitionBySymbol(symbolID);\n            if (!glyphDef.Concept.IsValidConcept())\n            {\n                GD.PrintErr($\"MagicSystem: Glyph symbol '{symbolID}' has no valid concept in this world. Cannot process.\");\n                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = true, IsValid = false });\n                return;\n            }\n\n            // Add to input buffer (TDD 02.1)\n            _glyphInputBuffer.Add(new GlyphInputFrame(symbolID, glyphDef.Concept, timestamp));\n            if (_glyphInputBuffer.Count &gt; MAX_GLYPH_BUFFER_SIZE)\n            {\n                _glyphInputBuffer.RemoveAt(0); // Maintain max size\n            }\n\n            GD.Print($\"MagicSystem: Player input glyph: {glyphDef}. Buffer size: {_glyphInputBuffer.Count}\");\n            _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = glyphDef.Concept, KnowledgeState = knowledge, IsKnown = true, IsValid = true });\n\n            // Attempt to resolve combo (TDD 02.2)\n            ResolveCombo();\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to resolve a combo from the current glyph input buffer.\n        /// (TDD 02.2: Combo Resolver)\n        /// &lt;/summary&gt;\n        private void ResolveCombo()\n        {\n            if (_glyphInputBuffer.Count == 0) return;\n\n            // Get recent inputs within the combo delay window (GDD B05.6)\n            List&lt;GlyphInputFrame&gt; recentInputs = _glyphInputBuffer\n                .Where(f =&gt; (GameManager.Instance.Time.CurrentGameTime - f.Timestamp) &lt;= MAX_COMBO_DELAY)\n                .OrderBy(f =&gt; f.Timestamp) // Ensure correct order\n                .ToList();\n\n            if (recentInputs.Count == 0) return;\n\n            GD.Print($\"MagicSystem: Attempting to resolve combo with {recentInputs.Count} recent inputs.\");\n\n            // --- Combo Resolution Logic (Placeholder for now) ---\n            // In later chapters, this is where a Trie structure (TDD 02.2)\n            // or complex interpretation model (GDD B02.2) would go.\n            // For now, we'll simulate a simple \"known\" combo if it's a single known glyph.\n\n            // TDD 15.3: Feedback - If player inputs a known glyph, mark it as known.\n            if (recentInputs.Count == 1 &amp;&amp; recentInputs[0].KnowledgeState &lt; GlyphKnowledgeState.Known)\n            {\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputs[0].SymbolID, GlyphKnowledgeState.Known);\n                GD.Print($\"MagicSystem: Player successfully experimented with '{recentInputs[0].SymbolID}' and now KNOWS its concept: {recentInputs[0].Concept}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Discovered {recentInputs[0].Concept}!\", ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputs[0].Concept } });\n                MarkInputsConsumed(recentInputs);\n                return;\n            }\n\n            // Simple check: if two known glyphs are pressed, it's a plausible experiment (GDD B05.7)\n            if (recentInputs.Count &gt;= 2 &amp;&amp; recentInputs.All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))\n            {\n                List&lt;GlyphConcept&gt; conceptSequence = recentInputs.Select(f =&gt; f.Concept).ToList();\n                GD.Print($\"MagicSystem: Player experimented with a plausible sequence: {string.Join(\" -&gt; \", conceptSequence)}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Plausible experiment! {string.Join(\" \", conceptSequence)}\", ConceptSequence = conceptSequence });\n                MarkInputsConsumed(recentInputs);\n                return;\n            }\n\n            // If buffer is full and no combo resolved, or oldest input expired, it's a fizzle (GDD B05.7)\n            if (_glyphInputBuffer.Count == MAX_GLYPH_BUFFER_SIZE &amp;&amp; recentInputs.Count == 0)\n            {\n                GD.Print($\"MagicSystem: Combo fizzled (inputs too slow or no valid sequence).\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = false, IsDiscovery = false, ResultText = \"Fizzle!\", ConceptSequence = new List&lt;GlyphConcept&gt;() });\n                _glyphInputBuffer.Clear(); // Clear buffer on fizzle\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Marks glyph inputs as consumed after a combo is resolved.\n        /// (TDD 02.1)\n        /// &lt;/summary&gt;\n        private void MarkInputsConsumed(List&lt;GlyphInputFrame&gt; inputs)\n        {\n            foreach (var input in inputs)\n            {\n                int index = _glyphInputBuffer.IndexOf(input);\n                if (index != -1)\n                {\n                    _glyphInputBuffer[index] = new GlyphInputFrame(input.SymbolID, input.Concept, input.Timestamp) { Consumed = true };\n                }\n            }\n            _glyphInputBuffer.RemoveAll(f =&gt; f.Consumed); // Remove consumed inputs\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct GlyphInputEvent { public EntityID PlayerID; public string SymbolID; public GlyphConcept Concept; public GlyphKnowledgeState KnowledgeState; public bool IsKnown; public bool IsValid; }\n        public struct ComboResolvedEvent { public EntityID PlayerID; public bool IsSuccess; public bool IsDiscovery; public string ResultText; public List&lt;GlyphConcept&gt; ConceptSequence; }\n    }\n}\n</code></pre> <p>Explanation of <code>MagicSystem.cs</code>:</p> <ul> <li><code>GlyphInputFrame</code>: A struct to store each individual glyph input (symbol, concept, timestamp, consumed status).</li> <li><code>_glyphInputBuffer</code>: A <code>List&lt;GlyphInputFrame&gt;</code> acting as our circular input buffer (TDD 02.1).</li> <li><code>MAX_COMBO_DELAY</code>: Defines the maximum time between glyphs for them to be considered part of the same combo (GDD B05.6).</li> <li><code>Tick(double delta)</code>:<ul> <li>Iterates through the <code>PlayerInputFrame.HotbarKeys</code>.</li> <li>If a hotbar key is pressed, it calls <code>ProcessGlyphInput()</code>.</li> <li>Cleans up old, expired inputs from the buffer.</li> </ul> </li> <li><code>ProcessGlyphInput()</code>:<ul> <li>Debounces: Prevents multiple inputs from a single key press.</li> <li>Knowledge Check: If the glyph is <code>Hidden</code>, it updates to <code>Seen</code> (GDD B01.4.C).</li> <li>Resolves <code>GlyphConcept</code> from <code>WorldGlyphMap</code>.</li> <li>Adds the <code>GlyphInputFrame</code> to <code>_glyphInputBuffer</code>.</li> <li>Publishes a <code>GlyphInputEvent</code> for UI feedback.</li> <li>Calls <code>ResolveCombo()</code>.</li> </ul> </li> <li><code>ResolveCombo()</code>:<ul> <li>Filters <code>_glyphInputBuffer</code> for recent inputs within <code>MAX_COMBO_DELAY</code>.</li> <li>Placeholder Logic:<ul> <li>If a single <code>Seen</code> glyph is input, it's marked as <code>Known</code> (TDD 15.3: Feedback).</li> <li>If two or more <code>Known</code> glyphs are input, it's a \"plausible experiment\" (GDD B05.7).</li> <li>If the buffer fills up and no combo is resolved, it's a \"fizzle.\"</li> </ul> </li> <li>Publishes a <code>ComboResolvedEvent</code> with the outcome.</li> <li>Calls <code>MarkInputsConsumed()</code> on successful combos.</li> </ul> </li> <li><code>MarkInputsConsumed()</code>: Clears inputs that were part of a successful combo.</li> </ul>"},{"location":"22-chapter-22/#5-integrating-magicsystem-into-gamemanager","title":"5. Integrating <code>MagicSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>MagicSystem</code> property.</li> <li>Initialize <code>MagicSystem</code> in <code>InitializeSystems()</code>.</li> <li>Call <code>MagicSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PlayerHotbarSystem PlayerHotbar { get; private set; }\n    public MagicSystem Magic { get; private set; } // Add MagicSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test Glyph Discovery System ---\n        GD.Print(\"\\n--- Testing Glyph Discovery System ---\");\n        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID;\n        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID;\n        // Make sure testSymbol is only Seen initially for experimentation\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Hidden, true); // Force reset to Hidden\n        GD.Print($\"Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        // PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Seen); // Will be handled by MagicSystem\n        // PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Known); // Will be handled by MagicSystem\n\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known); // Make second symbol known for hotbar test\n        GD.Print($\"Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}\");\n\n        // ... (existing unknown symbol test) ...\n        GD.Print(\"--- End Testing Glyph Discovery System ---\\n\");\n\n        // --- Test PlayerHotbarSystem ---\n        GD.Print(\"\\n--- Testing PlayerHotbarSystem ---\");\n        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign potentially unknown symbol\n        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign known symbol\n        // ... (existing hotbar tests) ...\n        GD.Print(\"--- End Testing PlayerHotbarSystem ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta); // Call MagicSystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations) ...\n\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        // Initialize MagicSystem\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - MagicSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#51-update-eventbuscs-for-magicsystem-events","title":"5.1. Update <code>EventBus.cs</code> for MagicSystem Events","text":"<p>Our <code>MagicSystem</code> publishes <code>GlyphInputEvent</code> and <code>ComboResolvedEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Magic System Events (TDD 15.3, TDD 02.1)\n        public event Action&lt;EntityID, string, GlyphConcept, GlyphKnowledgeState, bool, bool&gt; OnGlyphInput; // PlayerID, SymbolID, Concept, KnowledgeState, IsKnown, IsValid\n        public event Action&lt;EntityID, bool, bool, string, List&lt;GlyphConcept&gt;&gt; OnComboResolved; // PlayerID, IsSuccess, IsDiscovery, ResultText, ConceptSequence\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is MagicSystem.GlyphInputEvent glyphInputEvent) // New condition\n            {\n                OnGlyphInput?.Invoke(glyphInputEvent.PlayerID, glyphInputEvent.SymbolID, glyphInputEvent.Concept, glyphInputEvent.KnowledgeState, glyphInputEvent.IsKnown, glyphInputEvent.IsValid);\n            }\n            else if (eventData is MagicSystem.ComboResolvedEvent comboResolvedEvent) // New condition\n            {\n                OnComboResolved?.Invoke(comboResolvedEvent.PlayerID, comboResolvedEvent.IsSuccess, comboResolvedEvent.IsDiscovery, comboResolvedEvent.ResultText, comboResolvedEvent.ConceptSequence);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"22-chapter-22/#6-testing-glyph-experimentation","title":"6. Testing Glyph Experimentation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>In the Output console, observe the initial glyph knowledge and hotbar setup. The <code>testSymbol</code> (e.g., <code>symbol_leaf</code>) should be <code>Hidden</code>. The <code>testSymbol2</code> (e.g., <code>symbol_cross</code>) should be <code>Known</code>.</li> <li>Test 1 (Single Unknown Glyph): Press <code>1</code> (hotbar slot 0). This is our <code>testSymbol</code>.<ul> <li>You should see <code>MagicSystem: Player saw symbol 'symbol_leaf'.</code></li> <li>Then <code>PlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Hidden to Seen.</code></li> <li>Then <code>MagicSystem: Player input glyph: 'symbol_leaf' (Bloom) @ X.XX. Buffer size: 1</code></li> <li>Then <code>MagicSystem: Player successfully experimented with 'symbol_leaf' and now KNOWS its concept: Bloom.</code></li> <li>And <code>PlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Seen to Known.</code></li> <li>This sequence demonstrates the discovery of a glyph's meaning through solo experimentation.</li> </ul> </li> <li>Test 2 (Two Known Glyphs - Plausible Experiment):<ul> <li>Quickly press <code>0</code> (hotbar slot 0, which is <code>testSymbol</code>, now <code>Known</code>).</li> <li>Then quickly press <code>1</code> (hotbar slot 1, which is <code>testSymbol2</code>, <code>Known</code>).</li> <li>You should see <code>MagicSystem: Player input glyph...</code> for both.</li> <li>Then <code>MagicSystem: Player experimented with a plausible sequence: Bloom -&gt; Consume.</code> (or whatever your concepts are). This simulates a new combo discovery.</li> </ul> </li> <li>Test 3 (Fizzle):<ul> <li>Press <code>0</code>. Wait for more than <code>MAX_COMBO_DELAY</code> (1.5 seconds).</li> <li>Press <code>0</code> again.</li> <li>You should see a <code>MagicSystem: Combo fizzled...</code> message. The buffer cleared.</li> </ul> </li> </ol> <p>This confirms the basic glyph experimentation loop, including knowledge progression and combo resolution, is working.</p>"},{"location":"22-chapter-22/#summary","title":"Summary","text":"<p>You have successfully implemented the core Glyph Experimentation loop for Sigilborne, allowing players to input glyph sequences, process their hotbar choices, and interpret the outcomes. By creating <code>PlayerHotbarSystem</code> to manage equipped glyphs and enhancing <code>MagicSystem</code> to process inputs, track knowledge, and resolve rudimentary combos (or fizzles), you've established the foundation for dynamic spellcasting and discovery. This system correctly handles knowledge progression from <code>Hidden</code> to <code>Known</code> and provides feedback for plausible experiments, strictly adhering to TDD 15.3's specifications.</p>"},{"location":"22-chapter-22/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Subtypes &amp; Modifiers, expanding our <code>WorldGlyphDefinition</code> to include procedural subtypes that add nuance and variety to each glyph's actual effect based on world-specific conditions, further enhancing replayability.</p>"},{"location":"23-chapter-23/","title":"Chapter 3.4: Subtypes & Modifiers - Procedural Nuance for Glyphs (C#)","text":""},{"location":"23-chapter-23/#chapter-34-subtypes-modifiers-procedural-nuance-for-glyphs-c","title":"Chapter 3.4: Subtypes &amp; Modifiers - Procedural Nuance for Glyphs (C#)","text":"<p>Our glyph system currently maps a <code>GlyphSymbol</code> to a <code>GlyphConcept</code>. However, the GDD (B01.3) specifies that \"each glyph's actual effect \u00e2\u20ac\u201d its \u00e2\u20ac\u0153meaning\u00e2\u20ac  \u00e2\u20ac\u201d is generated uniquely per world.\" This means a <code>Bloom</code> concept might be \"toxic bloom\" in one world and \"healing growth\" in another. This chapter implements Subtypes &amp; Modifiers, adding procedural nuance to each <code>WorldGlyphDefinition</code> to define these world-specific behaviors, as outlined in TDD 15.4.</p>"},{"location":"23-chapter-23/#1-the-role-of-subtypes-in-dynamic-magic","title":"1. The Role of Subtypes in Dynamic Magic","text":"<p>Subtypes are crucial for Sigilborne's infinite replayability and emergent world identity. They provide the \"flavor and nuance\" (GDD B02.4) to a glyph's core mechanical archetype.</p> <ul> <li>Core Concept: <code>Bloom</code> (stable, universal mechanical archetype).</li> <li>World-Specific Subtype: <code>Toxic Bloom</code> vs. <code>Healing Bloom</code> vs. <code>Spore Cloud</code>.</li> <li>Modifiers: Numerical parameters that define the subtype's behavior (e.g., <code>damage_multiplier</code>, <code>healing_amount</code>, <code>duration</code>).</li> </ul> <p>These subtypes depend on world history, biomes, anomalies, and clan traditions, ensuring every world feels like a coherent magical language.</p>"},{"location":"23-chapter-23/#2-defining-glyphsubtype-and-glyphmodifiers","title":"2. Defining <code>GlyphSubtype</code> and <code>GlyphModifiers</code>","text":"<p>We need a way to define the specific behavior of a glyph's subtype. This will involve a unique ID for the subtype and a collection of numerical modifiers.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/GlyphConcepts.cs</code> and add <code>GlyphSubtype</code> and <code>GlyphModifierType</code> enums:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphConcepts.cs\nusing System;\nusing System.Collections.Generic; // For Dictionary&lt;TKey, TValue&gt;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (GlyphConcept enum) ...\n    // ... (GlyphKnowledgeState enum) ...\n    // ... (GlyphConceptExtensions class) ...\n\n    /// &lt;summary&gt;\n    /// Represents the world-specific behavior variant of a GlyphConcept.\n    /// (GDD B01.3, TDD 15.4)\n    /// &lt;/summary&gt;\n    public enum GlyphSubtype\n    {\n        None,           // Default or invalid subtype\n        Basic,          // A generic, balanced version of the concept (fallback)\n\n        // Bloom Subtypes\n        ToxicBloom,     // Damages, spreads poison\n        HealingGrowth,  // Heals, grows protective flora\n        SporeCloud,     // Creates a cloud, obscures vision\n\n        // Veil Subtypes\n        HeatMirage,     // Creates heat haze, blurs vision\n        ColdMistVeil,   // Creates cold fog, slows movement\n        ShadowBlend,    // Deepens shadows, enhances stealth\n\n        // Pulse Subtypes\n        Shockwave,      // Pushes entities, stuns briefly\n        VibrationBurst, // Damages in area, disorients\n        ChakraBeam,     // Focused damage, high penetration\n\n        // ... Add more subtypes for other concepts as needed ...\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the types of numerical modifiers that a glyph subtype can have.\n    /// (TDD 15.4)\n    /// &lt;/summary&gt;\n    public enum GlyphModifierType\n    {\n        None,\n        DamageMultiplier,\n        HealingAmount,\n        Range,\n        Duration,\n        Radius,\n        Speed,\n        StabilityCost,\n        ResidueGeneration,\n        // Add more as needed for specific effects\n    }\n}\n</code></pre>"},{"location":"23-chapter-23/#3-enhancing-worldglyphdefinition-with-subtypes-and-modifiers","title":"3. Enhancing <code>WorldGlyphDefinition</code> with Subtypes and Modifiers","text":"<p>Now, we'll update our <code>WorldGlyphDefinition</code> struct to include a <code>GlyphSubtype</code> and a dictionary of <code>GlyphModifiers</code>.</p> <p>Open <code>res://_Brain/Systems/Magic/WorldGlyphMap.cs</code> and modify <code>WorldGlyphDefinition</code> and its constructor:</p> <pre><code>// _Brain/Systems/Magic/WorldGlyphMap.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents a single glyph definition for a specific world, mapping a visual symbol to a mechanical concept.\n    /// Now includes world-specific subtype and modifiers.\n    /// (GDD B01.3, TDD 15.4)\n    /// &lt;/summary&gt;\n    public struct WorldGlyphDefinition\n    {\n        public string SymbolID;\n        public GlyphConcept Concept;\n        public GlyphSubtype Subtype; // New: World-specific behavior variant\n        public Dictionary&lt;GlyphModifierType, float&gt; Modifiers; // New: Numerical parameters for the subtype\n\n        public WorldGlyphDefinition(string symbolId, GlyphConcept concept, GlyphSubtype subtype = GlyphSubtype.Basic, Dictionary&lt;GlyphModifierType, float&gt; modifiers = null)\n        {\n            SymbolID = symbolId;\n            Concept = concept;\n            Subtype = subtype;\n            Modifiers = modifiers ?? new Dictionary&lt;GlyphModifierType, float&gt;(); // Initialize if null\n        }\n\n        public override string ToString()\n        {\n            // Include Subtype and Modifiers in the string representation\n            string modifierString = string.Join(\", \", Modifiers.Select(kv =&gt; $\"{kv.Key}: {kv.Value:F1}\"));\n            return $\"Symbol: '{SymbolID}' -&gt; Concept: {Concept}, Subtype: {Subtype} (Mods: {modifierString})\";\n        }\n    }\n\n    // ... (WorldGlyphMap class) ...\n}\n</code></pre>"},{"location":"23-chapter-23/#4-enhancing-worldglyphmap-to-generate-subtypes-and-modifiers","title":"4. Enhancing <code>WorldGlyphMap</code> to Generate Subtypes and Modifiers","text":"<p>The <code>GenerateWorldGlyphMap</code> method needs to be updated to: 1.  Assign a random <code>GlyphSubtype</code> to each <code>WorldGlyphDefinition</code> based on its <code>GlyphConcept</code>. 2.  Generate <code>GlyphModifiers</code> for that subtype.</p> <p>This will involve creating a helper method to get possible subtypes and their base modifiers for each concept.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/WorldGlyphMap.cs</code> and add a new helper class for Subtype Data (within the <code>Sigilborne.Systems.Magic</code> namespace, perhaps in a new file <code>GlyphSubtypeData.cs</code> or at the bottom of <code>WorldGlyphMap.cs</code>). For now, let's keep it in <code>WorldGlyphMap.cs</code> for simplicity.</li> </ol> <pre><code>// _Brain/Systems/Magic/WorldGlyphMap.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (WorldGlyphDefinition struct) ...\n\n    /// &lt;summary&gt;\n    /// Helper class to store static definitions of GlyphSubtypes and their base modifiers.\n    /// This is a static lookup, not procedurally generated. The *assignment* is procedural.\n    /// &lt;/summary&gt;\n    public static class GlyphSubtypeData\n    {\n        private static Dictionary&lt;GlyphConcept, List&lt;GlyphSubtype&gt;&gt; _conceptToSubtypes = new Dictionary&lt;GlyphConcept, List&lt;GlyphSubtype&gt;&gt;();\n        private static Dictionary&lt;GlyphSubtype, Dictionary&lt;GlyphModifierType, float&gt;&gt; _subtypeBaseModifiers = new Dictionary&lt;GlyphSubtype, Dictionary&lt;GlyphModifierType, float&gt;&gt;();\n\n        static GlyphSubtypeData() // Static constructor to initialize data once\n        {\n            // --- Map Concepts to Possible Subtypes ---\n            _conceptToSubtypes.Add(GlyphConcept.Bloom, new List&lt;GlyphSubtype&gt; { GlyphSubtype.ToxicBloom, GlyphSubtype.HealingGrowth, GlyphSubtype.SporeCloud });\n            _conceptToSubtypes.Add(GlyphConcept.Veil, new List&lt;GlyphSubtype&gt; { GlyphSubtype.HeatMirage, GlyphSubtype.ColdMistVeil, GlyphSubtype.ShadowBlend });\n            _conceptToSubtypes.Add(GlyphConcept.Pulse, new List&lt;GlyphSubtype&gt; { GlyphSubtype.Shockwave, GlyphSubtype.VibrationBurst, GlyphSubtype.ChakraBeam });\n            // Add mappings for other concepts as they get subtypes\n\n            // --- Define Base Modifiers for Each Subtype ---\n            _subtypeBaseModifiers.Add(GlyphSubtype.Basic, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.DamageMultiplier, 1.0f }, { GlyphModifierType.Range, 100f } });\n\n            _subtypeBaseModifiers.Add(GlyphSubtype.ToxicBloom, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.DamageMultiplier, 1.2f }, { GlyphModifierType.Duration, 5.0f }, { GlyphModifierType.Radius, 50f } });\n            _subtypeBaseModifiers.Add(GlyphSubtype.HealingGrowth, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.HealingAmount, 15.0f }, { GlyphModifierType.Duration, 3.0f }, { GlyphModifierType.Radius, 40f } });\n            _subtypeBaseModifiers.Add(GlyphSubtype.SporeCloud, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.Duration, 8.0f }, { GlyphModifierType.Radius, 70f } });\n\n            _subtypeBaseModifiers.Add(GlyphSubtype.HeatMirage, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.Duration, 10.0f }, { GlyphModifierType.StabilityCost, 0.1f } });\n            _subtypeBaseModifiers.Add(GlyphSubtype.ColdMistVeil, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.Duration, 7.0f }, { GlyphModifierType.Speed, 0.7f } }); // Speed modifier for affected entities\n            _subtypeBaseModifiers.Add(GlyphSubtype.ShadowBlend, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.Duration, 12.0f }, { GlyphModifierType.StabilityCost, 0.05f } });\n\n            _subtypeBaseModifiers.Add(GlyphSubtype.Shockwave, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.DamageMultiplier, 0.8f }, { GlyphModifierType.Radius, 80f }, { GlyphModifierType.Speed, 0.5f } }); // Pushes, slows\n            _subtypeBaseModifiers.Add(GlyphSubtype.VibrationBurst, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.DamageMultiplier, 1.1f }, { GlyphModifierType.Radius, 40f }, { GlyphModifierType.Duration, 2.0f } }); // Disorient duration\n            _subtypeBaseModifiers.Add(GlyphSubtype.ChakraBeam, new Dictionary&lt;GlyphModifierType, float&gt; { { GlyphModifierType.DamageMultiplier, 1.5f }, { GlyphModifierType.Range, 200f }, { GlyphModifierType.StabilityCost, 0.2f } });\n        }\n\n        public static List&lt;GlyphSubtype&gt; GetSubtypesForConcept(GlyphConcept concept)\n        {\n            if (_conceptToSubtypes.TryGetValue(concept, out List&lt;GlyphSubtype&gt; subtypes))\n            {\n                return new List&lt;GlyphSubtype&gt;(subtypes); // Return a copy\n            }\n            return new List&lt;GlyphSubtype&gt; { GlyphSubtype.Basic }; // Fallback\n        }\n\n        public static Dictionary&lt;GlyphModifierType, float&gt; GetBaseModifiersForSubtype(GlyphSubtype subtype)\n        {\n            if (_subtypeBaseModifiers.TryGetValue(subtype, out Dictionary&lt;GlyphModifierType, float&gt; modifiers))\n            {\n                // Return a new dictionary to prevent external modification of static data\n                return new Dictionary&lt;GlyphModifierType, float&gt;(modifiers);\n            }\n            return new Dictionary&lt;GlyphModifierType, float&gt;(); // Empty if no specific modifiers\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// The authoritative database for a world's unique Glyph Symbol to Concept mapping.\n    /// This is generated once per world seed.\n    /// (TDD 15.2)\n    /// &lt;/summary&gt;\n    public class WorldGlyphMap\n    {\n        // ... (existing fields) ...\n\n        public WorldGlyphMap(int worldSeed, int glyphCount)\n        {\n            GenerateWorldGlyphMap(worldSeed, glyphCount);\n            GD.Print($\"WorldGlyphMap: Generated {AllWorldGlyphs.Count} glyph definitions for world seed {worldSeed}.\");\n        }\n\n        private void GenerateWorldGlyphMap(int worldSeed, int glyphCount)\n        {\n            Random rand = new Random(worldSeed);\n\n            List&lt;string&gt; selectedSymbols = GlyphSymbols.SelectWorldSymbols(worldSeed, glyphCount);\n            List&lt;GlyphConcept&gt; availableConcepts = Enum.GetValues(typeof(GlyphConcept))\n                                                        .Cast&lt;GlyphConcept&gt;()\n                                                        .Where(c =&gt; c != GlyphConcept.None)\n                                                        .ToList();\n\n            // ... (shuffle concepts) ...\n\n            for (int i = 0; i &lt; selectedSymbols.Count; i++)\n            {\n                string symbol = selectedSymbols[i];\n                GlyphConcept concept = availableConcepts[i % availableConcepts.Count];\n\n                // --- NEW: Procedurally assign subtype and modifiers (TDD 15.4) ---\n                List&lt;GlyphSubtype&gt; possibleSubtypes = GlyphSubtypeData.GetSubtypesForConcept(concept);\n                GlyphSubtype assignedSubtype = possibleSubtypes.Count &gt; 0 ? possibleSubtypes[rand.Next(possibleSubtypes.Count)] : GlyphSubtype.Basic;\n\n                Dictionary&lt;GlyphModifierType, float&gt; baseModifiers = GlyphSubtypeData.GetBaseModifiersForSubtype(assignedSubtype);\n\n                // Further randomize modifiers slightly (e.g., +/- 10%)\n                Dictionary&lt;GlyphModifierType, float&gt; finalModifiers = new Dictionary&lt;GlyphModifierType, float&gt;();\n                foreach (var kvp in baseModifiers)\n                {\n                    float variance = (float)(rand.NextDouble() * 0.2 - 0.1); // -0.1 to +0.1\n                    finalModifiers.Add(kvp.Key, kvp.Value * (1.0f + variance));\n                }\n                // --- END NEW ---\n\n                WorldGlyphDefinition def = new WorldGlyphDefinition(symbol, concept, assignedSubtype, finalModifiers); // Pass new data\n                _symbolToDefinition.Add(symbol, def);\n                if (!_conceptToDefinition.ContainsKey(concept))\n                {\n                    _conceptToDefinition.Add(concept, def);\n                }\n            }\n        }\n\n        // ... (GetDefinitionBySymbol, GetDefinitionByConcept methods) ...\n    }\n}\n</code></pre> <p>Explanation of Changes:</p> <ul> <li><code>GlyphSubtypeData</code>: A new static class that acts as a lookup table for:<ul> <li>Which <code>GlyphSubtype</code>s are possible for each <code>GlyphConcept</code>.</li> <li>The base numerical <code>Modifiers</code> for each <code>GlyphSubtype</code>. This data is static and pre-defined, not procedurally generated.</li> </ul> </li> <li><code>GenerateWorldGlyphMap()</code>:<ul> <li>Now, after assigning a <code>Concept</code> to a <code>Symbol</code>, it retrieves the <code>possibleSubtypes</code> for that <code>Concept</code> from <code>GlyphSubtypeData</code>.</li> <li>It randomly selects one <code>assignedSubtype</code> from the possibilities.</li> <li>It gets the <code>baseModifiers</code> for that <code>assignedSubtype</code>.</li> <li>It then applies a small random <code>variance</code> to these modifiers, ensuring even more uniqueness per world.</li> <li>Finally, it creates the <code>WorldGlyphDefinition</code> with the <code>assignedSubtype</code> and <code>finalModifiers</code>.</li> </ul> </li> </ul>"},{"location":"23-chapter-23/#5-testing-subtype-generation","title":"5. Testing Subtype Generation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>In the Output console, you should now see the <code>WorldGlyphMap</code> initialization printing the generated glyphs with their assigned subtypes and modified values.</li> </ol> <pre><code>...\n--- Generated World Glyphs ---\nSymbol: 'symbol_leaf' -&gt; Concept: Bloom, Subtype: HealingGrowth (Mods: HealingAmount: 15.4, Duration: 3.3, Radius: 43.1)\nSymbol: 'symbol_cross' -&gt; Concept: Consume, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\nSymbol: 'symbol_spiral' -&gt; Concept: Pulse, Subtype: Shockwave (Mods: DamageMultiplier: 0.8, Radius: 79.9, Speed: 0.5)\nSymbol: 'symbol_pentagon' -&gt; Concept: Veil, Subtype: ShadowBlend (Mods: Duration: 12.5, StabilityCost: 0.0)\nSymbol: 'symbol_hand' -&gt; Concept: Chain, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\nSymbol: 'symbol_triangle' -&gt; Concept: Echo, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\nSymbol: 'symbol_sun' -&gt; Concept: Fracture, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\nSymbol: 'symbol_river' -&gt; Concept: Shape, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\nSymbol: 'symbol_dot' -&gt; Concept: Project, Subtype: ChakraBeam (Mods: DamageMultiplier: 1.4, Range: 181.9, StabilityCost: 0.2)\nSymbol: 'symbol_wave' -&gt; Concept: Bind, Subtype: Basic (Mods: DamageMultiplier: 1.0, Range: 100.0)\n------------------------------\n...\n</code></pre> <p>Notice how <code>symbol_leaf</code> (Bloom) got <code>HealingGrowth</code> with slightly varied modifiers, <code>symbol_spiral</code> (Pulse) got <code>Shockwave</code>, etc. This demonstrates the procedural assignment of subtypes and modifiers, bringing the GDD's vision of unique magic per world to life.</p>"},{"location":"23-chapter-23/#summary","title":"Summary","text":"<p>You have successfully implemented Subtypes &amp; Modifiers for Sigilborne's glyph system, expanding <code>WorldGlyphDefinition</code> to include procedural subtypes and numerical modifiers. By defining <code>GlyphSubtypeData</code> and enhancing <code>WorldGlyphMap</code> to randomly assign subtypes and vary their parameters based on the world seed, you've introduced deep nuance and replayability to each glyph's effect, strictly adhering to TDD 15.4's specifications. This crucial step ensures that every <code>Bloom</code> is not just <code>Bloom</code>, but a unique <code>Toxic Bloom</code> or <code>Healing Growth</code> with distinct properties, making each world's magic truly unique.</p>"},{"location":"23-chapter-23/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Glyph Acquisition, detailing how players learn new glyphs through various in-world methods like interacting with teachers, finding scrolls, and observing NPCs, and how these actions update their <code>PlayerGlyphKnowledgeSystem</code>.</p>"},{"location":"24-chapter-24/","title":"Chapter 3.5: Glyph Acquisition - Teachers & Scrolls (C#)","text":""},{"location":"24-chapter-24/#chapter-35-glyph-acquisition-teachers-scrolls-c","title":"Chapter 3.5: Glyph Acquisition - Teachers &amp; Scrolls (C#)","text":"<p>Players in Sigilborne don't just know glyphs; they acquire them through active engagement with the world. This chapter implements the core mechanisms for Glyph Acquisition, focusing on two primary methods: learning from NPC teachers and discovering scrolls. These actions will update the player's <code>GlyphKnowledgeState</code> in the <code>PlayerGlyphKnowledgeSystem</code>, reflecting their journey of discovery, as specified in TDD 15.4 and GDD B01.4.</p>"},{"location":"24-chapter-24/#1-the-acquisition-philosophy-in-world-discovery","title":"1. The Acquisition Philosophy: In-World Discovery","text":"<p>The GDD (B01.4) outlines several ways players learn glyphs: *   NPC Teachers: Structured or informal teaching. *   Scrolls &amp; Fragments: Diagrams, partial combos, lore. *   Observation: Seeing an NPC use a sign. *   Solo-Cast Discovery: Experimentation (already covered). *   Bloodline Resonance: Innate intuition (covered later). *   Anomaly Revelation: Dangerous flashes (covered later).</p> <p>This chapter will focus on the first two, building a foundation for explicit knowledge transfer.</p>"},{"location":"24-chapter-24/#2-implementing-glyphacquisitionsystemcs","title":"2. Implementing <code>GlyphAcquisitionSystem.cs</code>","text":"<p>This system will provide methods for other systems (e.g., <code>InteractionSystem</code> for talking to teachers, <code>InventorySystem</code> for using scrolls) to trigger glyph learning.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/GlyphAcquisitionSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphAcquisitionSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Manages the acquisition of new glyph knowledge for the player.\n    /// Provides methods for learning via teachers, scrolls, and observation.\n    /// (GDD B01.4, TDD 15.4)\n    /// &lt;/summary&gt;\n    public class GlyphAcquisitionSystem\n    {\n        private EntityID _playerEntityID;\n        private EventBus _eventBus;\n        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;\n        private WorldGlyphMap _worldGlyphMap;\n\n        public GlyphAcquisitionSystem(EntityID playerEntityID, EventBus eventBus, PlayerGlyphKnowledgeSystem playerGlyphKnowledge, WorldGlyphMap worldGlyphMap)\n        {\n            _playerEntityID = playerEntityID;\n            _eventBus = eventBus;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n            GD.Print($\"GlyphAcquisitionSystem: Initialized for player {_playerEntityID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Simulates learning a glyph from an NPC teacher.\n        /// (GDD B01.4.A: NPC Teachers)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"symbolID\"&gt;The ID of the glyph symbol being taught.&lt;/param&gt;\n        /// &lt;returns&gt;True if knowledge was updated to Known, false otherwise.&lt;/returns&gt;\n        public bool LearnFromTeacher(string symbolID)\n        {\n            if (!_worldGlyphMap.GetDefinitionBySymbol(symbolID).Concept.IsValidConcept())\n            {\n                GD.PrintErr($\"GlyphAcquisitionSystem: Teacher attempted to teach unknown symbol '{symbolID}'.\");\n                return false;\n            }\n\n            GlyphKnowledgeState currentState = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);\n            if (currentState == GlyphKnowledgeState.Known)\n            {\n                GD.Print($\"GlyphAcquisitionSystem: Player already knows '{symbolID}'. Teacher offers practice instead.\");\n                // In a real game, this might trigger a training mini-game or quest.\n                return false;\n            }\n\n            GD.Print($\"GlyphAcquisitionSystem: Player learned symbol '{symbolID}' from a teacher.\");\n            // Teachers typically grant 'Known' status immediately for the symbol and its concept.\n            return _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, GlyphKnowledgeState.Known);\n        }\n\n        /// &lt;summary&gt;\n        /// Simulates learning a glyph from a scroll or fragment.\n        /// (GDD B01.4.B: Scrolls &amp; Fragments)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"symbolID\"&gt;The ID of the glyph symbol detailed in the scroll.&lt;/param&gt;\n        /// &lt;param name=\"fullMeaning\"&gt;If true, scroll grants Known. If false, grants Seen (fragment).&lt;/param&gt;\n        /// &lt;returns&gt;True if knowledge was updated, false otherwise.&lt;/returns&gt;\n        public bool LearnFromScroll(string symbolID, bool fullMeaning)\n        {\n            if (!_worldGlyphMap.GetDefinitionBySymbol(symbolID).Concept.IsValidConcept())\n            {\n                GD.PrintErr($\"GlyphAcquisitionSystem: Scroll details unknown symbol '{symbolID}'.\");\n                return false;\n            }\n\n            GlyphKnowledgeState currentState = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);\n            GlyphKnowledgeState newState = fullMeaning ? GlyphKnowledgeState.Known : GlyphKnowledgeState.Seen;\n\n            if (currentState &gt;= newState)\n            {\n                GD.Print($\"GlyphAcquisitionSystem: Player already knows '{symbolID}' at state {currentState}. Scroll provides no new info.\");\n                // In a real game, a scroll might provide lore or combo hints even if the glyph is known.\n                return false;\n            }\n\n            GD.Print($\"GlyphAcquisitionSystem: Player learned symbol '{symbolID}' from a scroll (State: {newState}).\");\n            return _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, newState);\n        }\n\n        /// &lt;summary&gt;\n        /// Simulates observing an NPC use a glyph.\n        /// (GDD B01.4.C: Observation)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"symbolID\"&gt;The ID of the glyph symbol observed.&lt;/param&gt;\n        /// &lt;returns&gt;True if knowledge was updated to Seen (or higher), false otherwise.&lt;/returns&gt;\n        public bool ObserveGlyph(string symbolID)\n        {\n            if (!_worldGlyphMap.GetDefinitionBySymbol(symbolID).Concept.IsValidConcept())\n            {\n                GD.PrintErr($\"GlyphAcquisitionSystem: Observed unknown symbol '{symbolID}'.\");\n                return false;\n            }\n\n            GlyphKnowledgeState currentState = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);\n            if (currentState &gt;= GlyphKnowledgeState.Seen)\n            {\n                // Already seen or known, no update needed for 'Seen' status.\n                return false;\n            }\n\n            GD.Print($\"GlyphAcquisitionSystem: Player observed symbol '{symbolID}'.\");\n            return _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, GlyphKnowledgeState.Seen);\n        }\n    }\n}\n</code></pre>"},{"location":"24-chapter-24/#3-integrating-glyphacquisitionsystem-into-gamemanager","title":"3. Integrating <code>GlyphAcquisitionSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>GlyphAcquisitionSystem</code> property.</li> <li>Initialize <code>GlyphAcquisitionSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq; // For .First() in test\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PlayerHotbarSystem PlayerHotbar { get; private set; }\n    public MagicSystem Magic { get; private set; }\n    public GlyphAcquisitionSystem GlyphAcquisition { get; private set; } // Add GlyphAcquisitionSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test Glyph Discovery System ---\n        GD.Print(\"\\n--- Testing Glyph Discovery System ---\");\n        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID;\n        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID;\n        string testSymbol3 = GlyphMap.AllWorldGlyphs[2].SymbolID; // New symbol for acquisition tests\n        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s));\n\n        // Reset knowledge for acquisition tests\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Hidden, true);\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Hidden, true);\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol3, GlyphKnowledgeState.Hidden, true);\n\n        GD.Print($\"Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        GD.Print($\"Initial knowledge of '{testSymbol2}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}\");\n        GD.Print($\"Initial knowledge of '{testSymbol3}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol3)}\");\n\n        // Let MagicSystem handle discovery for testSymbol via hotbar input\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known, true); // Still make testSymbol2 known for hotbar test\n\n        GD.Print($\"Attempt to update unknown symbol '{unknownSymbol}':\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known);\n\n        GD.Print(\"--- End Testing Glyph Discovery System ---\\n\");\n\n        // --- Test PlayerHotbarSystem ---\n        GD.Print(\"\\n--- Testing PlayerHotbarSystem ---\");\n        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign potentially unknown symbol\n        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign known symbol\n        PlayerHotbar.AssignGlyphToSlot(2, testSymbol3); // Assign unknown symbol for observation test\n        // ... (existing hotbar tests) ...\n        GD.Print(\"--- End Testing PlayerHotbarSystem ---\\n\");\n\n        // --- Test Glyph Acquisition System ---\n        GD.Print(\"\\n--- Testing Glyph Acquisition System ---\");\n        GD.Print($\"Knowledge of '{testSymbol3}' before acquisition: {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol3)}\");\n\n        // Test LearnFromTeacher\n        GlyphAcquisition.LearnFromTeacher(testSymbol3);\n        GD.Print($\"Knowledge of '{testSymbol3}' after teacher: {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol3)}\");\n        GlyphAcquisition.LearnFromTeacher(testSymbol3); // Should say already known\n\n        // Test LearnFromScroll (fragment)\n        string scrollSymbol = GlyphMap.AllWorldGlyphs[3].SymbolID; // Get another symbol\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(scrollSymbol, GlyphKnowledgeState.Hidden, true); // Ensure it's hidden\n        GD.Print($\"Knowledge of '{scrollSymbol}' before scroll: {PlayerGlyphKnowledge.GetGlyphKnowledge(scrollSymbol)}\");\n        GlyphAcquisition.LearnFromScroll(scrollSymbol, false); // Fragment -&gt; Seen\n        GD.Print($\"Knowledge of '{scrollSymbol}' after fragment scroll: {PlayerGlyphKnowledge.GetGlyphKnowledge(scrollSymbol)}\");\n        GlyphAcquisition.LearnFromScroll(scrollSymbol, false); // No update needed\n        GlyphAcquisition.LearnFromScroll(scrollSymbol, true); // Full scroll -&gt; Known\n        GD.Print($\"Knowledge of '{scrollSymbol}' after full scroll: {PlayerGlyphKnowledge.GetGlyphKnowledge(scrollSymbol)}\");\n\n        // Test ObserveGlyph\n        string observedSymbol = GlyphMap.AllWorldGlyphs[4].SymbolID; // Yet another symbol\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(observedSymbol, GlyphKnowledgeState.Hidden, true); // Ensure hidden\n        GD.Print($\"Knowledge of '{observedSymbol}' before observation: {PlayerGlyphKnowledge.GetGlyphKnowledge(observedSymbol)}\");\n        GlyphAcquisition.ObserveGlyph(observedSymbol);\n        GD.Print($\"Knowledge of '{observedSymbol}' after observation: {PlayerGlyphKnowledge.GetGlyphKnowledge(observedSymbol)}\");\n        GlyphAcquisition.ObserveGlyph(observedSymbol); // No update needed\n\n        GD.Print(\"--- End Testing Glyph Acquisition System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations) ...\n\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - MagicSystem initialized.\");\n\n        // Initialize GlyphAcquisitionSystem\n        GlyphAcquisition = new GlyphAcquisitionSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - GlyphAcquisitionSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"24-chapter-24/#4-testing-glyph-acquisition","title":"4. Testing Glyph Acquisition","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>In the Output console, you should see the <code>GlyphAcquisitionSystem</code> initialization and test messages.</li> </ol> <pre><code>...\nPlayerGlyphKnowledgeSystem: Initialized for player EntityID(0, Gen:1) with all glyphs as Hidden.\n  - PlayerGlyphKnowledgeSystem initialized.\n  - PlayerHotbarSystem initialized.\n  - MagicSystem initialized.\nGlyphAcquisitionSystem: Initialized for player EntityID(0, Gen:1).\n  - GlyphAcquisitionSystem initialized.\n  - WorldSimulation initialized.\n\n--- Testing Glyph Discovery System ---\nInitial knowledge of 'symbol_leaf': Hidden\nInitial knowledge of 'symbol_cross': Hidden\nInitial knowledge of 'symbol_diamond': Hidden\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_cross' updated from Hidden to Known.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_cross' updated from Hidden to Known.\nAttempt to update unknown symbol 'symbol_triangle_alt':\nPlayerGlyphKnowledgeSystem: Attempted to update knowledge for unknown symbol 'symbol_triangle_alt'.\n--- End Testing Glyph Discovery System ---\n\n--- Testing PlayerHotbarSystem ---\nPlayerHotbarSystem: Assigned 'symbol_leaf' to slot 0.\nPlayerHotbarSystem: Assigned 'symbol_cross' to slot 1.\nPlayerGlyphKnowledgeSystem: Player does not know glyph 'symbol_diamond'. Cannot assign to hotbar.\nPlayerHotbarSystem: Assigned 'symbol_leaf' to slot 9.\nPlayerHotbarSystem: Unequipped slot 0.\nGlyph in slot 1: symbol_cross\n--- End Testing PlayerHotbarSystem ---\n\n--- Testing Glyph Acquisition System ---\nKnowledge of 'symbol_diamond' before acquisition: Hidden\nGlyphAcquisitionSystem: Player learned symbol 'symbol_diamond' from a teacher.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_diamond' updated from Hidden to Known.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_diamond' updated from Hidden to Known.\nGlyphAcquisitionSystem: Player already knows 'symbol_diamond'. Teacher offers practice instead.\nKnowledge of 'symbol_diamond' after teacher: Known\nKnowledge of 'symbol_pentagon' before scroll: Hidden\nGlyphAcquisitionSystem: Player learned symbol 'symbol_pentagon' from a scroll (State: Seen).\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_pentagon' updated from Hidden to Seen.\nGlyphAcquisitionSystem: Player already knows 'symbol_pentagon' at state Seen. Scroll provides no new info.\nGlyphAcquisitionSystem: Player learned symbol 'symbol_pentagon' from a scroll (State: Known).\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_pentagon' updated from Seen to Known.\nKnowledge of 'symbol_pentagon' after full scroll: Known\nKnowledge of 'symbol_hexagon' before observation: Hidden\nGlyphAcquisitionSystem: Player observed symbol 'symbol_hexagon'.\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_hexagon' updated from Hidden to Seen.\nGlyphAcquisitionSystem: Player observed symbol 'symbol_hexagon'.\nKnowledge of 'symbol_hexagon' after observation: Seen\n--- End Testing Glyph Acquisition System ---\n</code></pre> <p>This output confirms: *   <code>LearnFromTeacher</code> correctly grants <code>Known</code> status. *   <code>LearnFromScroll</code> correctly grants <code>Seen</code> (for fragments) and then <code>Known</code> (for full meaning). *   <code>ObserveGlyph</code> correctly grants <code>Seen</code> status. *   The system gracefully handles attempts to acquire already known glyphs or unknown symbols.</p>"},{"location":"24-chapter-24/#summary","title":"Summary","text":"<p>You have successfully implemented the Glyph Acquisition System for Sigilborne, enabling players to learn new glyphs through structured methods like NPC teachers and scrolls, as well as through passive observation. By creating <code>GlyphAcquisitionSystem</code> and integrating it with <code>PlayerGlyphKnowledgeSystem</code>, you've established a clear pipeline for updating the player's knowledge state based on in-world discovery actions, strictly adhering to GDD B01.4 and TDD 15.4's specifications. This crucial step enriches the player's journey of mastering ninjutsu through active engagement with the game world.</p>"},{"location":"24-chapter-24/#next-steps","title":"Next Steps","text":"<p>This concludes Module 3: The Glyph System - Language of Ninjutsu. We will now move on to Module 4: Combos &amp; Casting - The Art of Ninjutsu, starting with Input Buffer - Storing Glyph Sequences (C#). This will refine our glyph input processing for more complex combo detection.</p>"},{"location":"25-chapter-25/","title":"Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)","text":""},{"location":"25-chapter-25/#chapter-41-input-buffer-storing-glyph-sequences-c","title":"Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)","text":"<p>Welcome to Module 4: Combos &amp; Casting - The Art of Ninjutsu! This module focuses on how glyphs combine into powerful techniques. The foundation of any combo system is a robust way to store and retrieve a sequence of player inputs. This chapter refines our <code>MagicSystem</code> by implementing a dedicated Input Buffer to store <code>GlyphInputFrame</code> structs, allowing for efficient detection of glyph sequences within a time window, as specified in TDD 02.1.</p>"},{"location":"25-chapter-25/#1-the-need-for-a-dedicated-glyph-input-buffer","title":"1. The Need for a Dedicated Glyph Input Buffer","text":"<p>Our <code>MagicSystem</code> currently uses a <code>List&lt;GlyphInputFrame&gt;</code> to store recent glyph inputs. While functional, we need to formalize this into a proper circular buffer (or a <code>List</code> managed like one) for clarity and to adhere to TDD 02.1's specification.</p> <p>Key Requirements for the Input Buffer:</p> <ul> <li>Order Preservation: Inputs must be stored in the order they occurred.</li> <li>Timestamping: Each input needs a precise timestamp to determine if it's within a combo window.</li> <li>Fixed Size / Max Count: We only care about the most recent inputs relevant for combos.</li> <li>Efficient Retrieval: Quickly get a <code>ReadOnlySpan&lt;GlyphInputFrame&gt;</code> of recent inputs.</li> </ul>"},{"location":"25-chapter-25/#2-refining-glyphinputframe","title":"2. Refining <code>GlyphInputFrame</code>","text":"<p>We already defined <code>GlyphInputFrame</code> in <code>MagicSystem.cs</code> in Chapter 3.3. Let's move it to its own file (<code>GlyphInputFrame.cs</code>) for better modularity and ensure it includes the <code>Consumed</code> flag as per TDD 02.1.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/GlyphInputFrame.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphInputFrame.cs\nusing System;\nusing Godot; // For Vector2 if needed, though not directly in this struct\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents a single glyph input by the player as part of a sequence.\n    /// This struct is stored in the MagicSystem's input buffer.\n    /// (TDD 02.1)\n    /// &lt;/summary&gt;\n    public struct GlyphInputFrame : IEquatable&lt;GlyphInputFrame&gt;\n    {\n        public string SymbolID;     // The visual symbol ID (e.g., \"symbol_triangle\")\n        public GlyphConcept Concept; // The resolved mechanical concept (e.g., GlyphConcept.Fire)\n        public double Timestamp;    // When this input occurred (real time)\n        public bool Consumed;       // Whether this input has been part of a successfully resolved combo (TDD 02.1)\n\n        public GlyphInputFrame(string symbolID, GlyphConcept concept, double timestamp, bool consumed = false)\n        {\n            SymbolID = symbolID;\n            Concept = concept;\n            Timestamp = timestamp;\n            Consumed = consumed;\n        }\n\n        public override string ToString()\n        {\n            return $\"'{SymbolID}' ({Concept}) @ {Timestamp:F3} (Consumed: {Consumed})\";\n        }\n\n        // --- IEquatable Implementation ---\n        public bool Equals(GlyphInputFrame other)\n        {\n            // For equality, we typically check all fields, or just the unique identifier if one exists.\n            // For the purpose of tracking inputs, all fields should match for true equality.\n            return SymbolID == other.SymbolID &amp;&amp;\n                   Concept == other.Concept &amp;&amp;\n                   Timestamp == other.Timestamp &amp;&amp;\n                   Consumed == other.Consumed;\n        }\n\n        public override bool Equals(object obj)\n        {\n            return obj is GlyphInputFrame other &amp;&amp; Equals(other);\n        }\n\n        public override int GetHashCode()\n        {\n            return HashCode.Combine(SymbolID, Concept, Timestamp, Consumed);\n        }\n    }\n}\n</code></pre> <ol> <li>Now, open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code> and remove the <code>GlyphInputFrame</code> struct definition from it. Add <code>using Sigilborne.Systems.Magic;</code> at the top if it's not already there.</li> </ol>"},{"location":"25-chapter-25/#3-implementing-the-glyphinputbuffer-class","title":"3. Implementing the <code>GlyphInputBuffer</code> Class","text":"<p>TDD 02.1 suggests a circular buffer. While a <code>List</code> with <code>RemoveAt(0)</code> can simulate this, a dedicated <code>GlyphInputBuffer</code> class (or even a <code>Queue</code> or <code>LinkedList</code>) provides clearer semantics and better control. For efficiency with <code>ReadOnlySpan&lt;T&gt;</code>, a raw array or a <code>List</code> managed carefully is often preferred. We'll stick with a <code>List</code> and manage its size, as it's flexible for <code>ReadOnlySpan&lt;T&gt;</code> conversion.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/GlyphInputBuffer.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/GlyphInputBuffer.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq; // For debugging output\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// A circular buffer that stores recent GlyphInputFrames with precise timestamps.\n    /// (TDD 02.1)\n    /// &lt;/summary&gt;\n    public class GlyphInputBuffer\n    {\n        private List&lt;GlyphInputFrame&gt; _buffer;\n        private int _maxSize;\n\n        public GlyphInputBuffer(int maxSize)\n        {\n            _maxSize = maxSize;\n            _buffer = new List&lt;GlyphInputFrame&gt;(maxSize);\n        }\n\n        /// &lt;summary&gt;\n        /// Pushes a new GlyphInputFrame into the buffer.\n        /// If the buffer is full, the oldest unconsumed input is removed.\n        /// &lt;/summary&gt;\n        public void Push(GlyphInputFrame frame)\n        {\n            _buffer.Add(frame);\n            if (_buffer.Count &gt; _maxSize)\n            {\n                // Remove the oldest unconsumed input, or just the oldest if all are consumed/no unconsumed\n                // This logic might need refinement based on exact combo rules (e.g., if consumed inputs are needed for historical context)\n                int oldestUnconsumedIndex = _buffer.FindIndex(f =&gt; !f.Consumed);\n                if (oldestUnconsumedIndex != -1 &amp;&amp; _buffer.Count &gt; _maxSize)\n                {\n                    _buffer.RemoveAt(oldestUnconsumedIndex);\n                }\n                else if (_buffer.Count &gt; _maxSize) // If all are consumed or no unconsumed, just remove the oldest\n                {\n                    _buffer.RemoveAt(0);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a ReadOnlySpan of recent, unconsumed glyph inputs within a specified time window.\n        /// (TDD 02.1)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"windowStartTime\"&gt;The minimum timestamp for inputs to be considered.&lt;/param&gt;\n        public ReadOnlySpan&lt;GlyphInputFrame&gt; GetRecentUnconsumed(double windowStartTime)\n        {\n            // Filter and order inputs from the current buffer\n            // For performance, avoid Linq in hot paths. This is a simple example.\n            var recent = _buffer.Where(f =&gt; !f.Consumed &amp;&amp; f.Timestamp &gt;= windowStartTime).OrderBy(f =&gt; f.Timestamp).ToList();\n\n            // To return a ReadOnlySpan, we need to ensure the underlying data is contiguous.\n            // Converting to an array is the safest way for a List&lt;T&gt;.\n            return new ReadOnlySpan&lt;GlyphInputFrame&gt;(recent.ToArray());\n        }\n\n        /// &lt;summary&gt;\n        /// Marks a set of inputs as consumed.\n        /// &lt;/summary&gt;\n        public void MarkConsumed(IEnumerable&lt;GlyphInputFrame&gt; inputsToConsume)\n        {\n            foreach (var inputToConsume in inputsToConsume)\n            {\n                for (int i = 0; i &lt; _buffer.Count; i++)\n                {\n                    if (_buffer[i].Equals(inputToConsume)) // Use struct equality\n                    {\n                        _buffer[i] = new GlyphInputFrame(inputToConsume.SymbolID, inputToConsume.Concept, inputToConsume.Timestamp, true);\n                        break; // Found and updated\n                    }\n                }\n            }\n            // After marking, optionally remove consumed inputs to keep buffer clean\n            _buffer.RemoveAll(f =&gt; f.Consumed);\n        }\n\n        /// &lt;summary&gt;\n        /// Clears all inputs from the buffer.\n        /// &lt;/summary&gt;\n        public void Clear()\n        {\n            _buffer.Clear();\n        }\n\n        public int Count =&gt; _buffer.Count;\n\n        public override string ToString()\n        {\n            return $\"Buffer ({_buffer.Count}/{_maxSize}): [{string.Join(\", \", _buffer.Select(f =&gt; f.ToString()))}]\";\n        }\n    }\n}\n</code></pre>"},{"location":"25-chapter-25/#4-integrating-glyphinputbuffer-into-magicsystem","title":"4. Integrating <code>GlyphInputBuffer</code> into <code>MagicSystem</code>","text":"<p>Now, <code>MagicSystem</code> will use this dedicated <code>GlyphInputBuffer</code> class.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>.</li> <li>Replace <code>private List&lt;GlyphInputFrame&gt; _glyphInputBuffer = new List&lt;GlyphInputFrame&gt;();</code> with:     <code>private GlyphInputBuffer _glyphInputBuffer;</code></li> <li>Modify the <code>MagicSystem</code> constructor to initialize <code>_glyphInputBuffer</code>.</li> <li>Update <code>ProcessGlyphInput</code> and <code>ResolveCombo</code> to use the <code>GlyphInputBuffer</code>'s <code>Push</code>, <code>GetRecentUnconsumed</code>, <code>MarkConsumed</code>, and <code>Clear</code> methods.</li> </ol> <pre><code>// _Brain/Systems/Magic/MagicSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (removed GlyphInputFrame struct definition) ...\n\n    /// &lt;summary&gt;\n    /// Manages the core magic system: processing glyph input sequences,\n    /// resolving combos, and triggering spell effects.\n    /// (TDD 02.1: InputBuffer, TDD 02.2: Combo Resolver)\n    /// &lt;/summary&gt;\n    public class MagicSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private PlayerHotbarSystem _playerHotbar;\n        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;\n        private WorldGlyphMap _worldGlyphMap;\n        private GameManager _gameManager; // Reference to GameManager for CurrentGameTime\n\n        private EntityID _playerEntityID;\n\n        // TDD 02.1: InputBuffer - Now using our dedicated GlyphInputBuffer class.\n        private GlyphInputBuffer _glyphInputBuffer;\n        private const int MAX_GLYPH_BUFFER_SIZE = 10; // Max glyphs in a sequence (GDD B02.3)\n        private const float MAX_COMBO_DELAY = 1.5f; // Max time between glyph inputs for a combo (GDD B05.6)\n        private const float GLYPH_DEBOUNCE_TIME = 0.1f; // Prevents multiple inputs from a single key press\n\n        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,\n                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,\n                           WorldGlyphMap worldGlyphMap, GameManager gameManager) // Add GameManager\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _playerHotbar = playerHotbar;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n            _gameManager = gameManager; // Store GameManager reference\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n\n            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE); // Initialize the new buffer\n            GD.Print(\"MagicSystem: Initialized.\");\n        }\n\n        public void Tick(double delta)\n        {\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n            double currentTime = _gameManager.Time.CurrentGameTime;\n\n            // Process hotbar inputs for glyphs\n            for (int i = 0; i &lt; currentInput.HotbarKeys.Length; i++)\n            {\n                if (currentInput.HotbarKeys[i]) // If hotbar key is pressed\n                {\n                    string symbolID = _playerHotbar.GetGlyphSymbolInSlot(i);\n                    if (symbolID != null)\n                    {\n                        ProcessGlyphInput(symbolID, currentTime);\n                    }\n                }\n            }\n\n            // No longer need to manually remove old inputs here, GlyphInputBuffer manages its size\n            // However, we might still want to trigger a fizzle if the oldest input is too old and no combo has resolved.\n            // This is part of the combo timing window logic.\n            if (_glyphInputBuffer.Count &gt; 0 &amp;&amp; (currentTime - _glyphInputBuffer.GetRecentUnconsumed(0).ToArray().First().Timestamp) &gt; MAX_COMBO_DELAY)\n            {\n                // Oldest input expired, and no combo resolved. Fizzle.\n                GD.Print($\"MagicSystem: Combo fizzled (inputs too slow). Buffer cleared.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = false, IsDiscovery = false, ResultText = \"Fizzle!\", ConceptSequence = new List&lt;GlyphConcept&gt;() });\n                _glyphInputBuffer.Clear();\n            }\n        }\n\n        private void ProcessGlyphInput(string symbolID, double timestamp)\n        {\n            // Debounce (GDD B05.6) - Check if this glyph was already input very recently\n            if (_glyphInputBuffer.GetRecentUnconsumed(timestamp - GLYPH_DEBOUNCE_TIME).Any(f =&gt; f.SymbolID == symbolID))\n            {\n                return;\n            }\n\n            GlyphKnowledgeState knowledge = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);\n            if (knowledge == GlyphKnowledgeState.Hidden)\n            {\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, GlyphKnowledgeState.Seen);\n                GD.Print($\"MagicSystem: Player saw symbol '{symbolID}'.\");\n                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = false, IsValid = false });\n                return;\n            }\n\n            WorldGlyphDefinition glyphDef = _worldGlyphMap.GetDefinitionBySymbol(symbolID);\n            if (!glyphDef.Concept.IsValidConcept())\n            {\n                GD.PrintErr($\"MagicSystem: Glyph symbol '{symbolID}' has no valid concept in this world. Cannot process.\");\n                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = true, IsValid = false });\n                return;\n            }\n\n            // Add to input buffer (TDD 02.1)\n            _glyphInputBuffer.Push(new GlyphInputFrame(symbolID, glyphDef.Concept, timestamp));\n\n            GD.Print($\"MagicSystem: Player input glyph: {glyphDef}. Buffer size: {_glyphInputBuffer.Count}\");\n            _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = glyphDef.Concept, KnowledgeState = knowledge, IsKnown = true, IsValid = true });\n\n            // Attempt to resolve combo (TDD 02.2)\n            ResolveCombo();\n        }\n\n        private void ResolveCombo()\n        {\n            // TDD 02.1: Get recent inputs within the combo delay window.\n            // ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(GameManager.Instance.Time.CurrentGameTime - MAX_COMBO_DELAY);\n            // Convert to List for easier manipulation in this simple combo resolver.\n            List&lt;GlyphInputFrame&gt; recentInputs = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY).ToList();\n\n            if (recentInputs.Count == 0) return;\n\n            GD.Print($\"MagicSystem: Attempting to resolve combo with {recentInputs.Count} recent inputs.\");\n\n            // --- Combo Resolution Logic (Placeholder for now) ---\n            // Simplified logic from previous chapter.\n            // TDD 15.3: Feedback - If player inputs a single known glyph, mark it as known.\n            if (recentInputs.Count == 1 &amp;&amp; recentInputs[0].KnowledgeState &lt; GlyphKnowledgeState.Known)\n            {\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputs[0].SymbolID, GlyphKnowledgeState.Known);\n                GD.Print($\"MagicSystem: Player successfully experimented with '{recentInputs[0].SymbolID}' and now KNOWS its concept: {recentInputs[0].Concept}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Discovered {recentInputs[0].Concept}!\", ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputs[0].Concept } });\n                _glyphInputBuffer.MarkConsumed(recentInputs);\n                return;\n            }\n\n            // Simple check: if two known glyphs are pressed, it's a plausible experiment (GDD B05.7)\n            if (recentInputs.Count &gt;= 2 &amp;&amp; recentInputs.All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))\n            {\n                List&lt;GlyphConcept&gt; conceptSequence = recentInputs.Select(f =&gt; f.Concept).ToList();\n                GD.Print($\"MagicSystem: Player experimented with a plausible sequence: {string.Join(\" -&gt; \", conceptSequence)}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Plausible experiment! {string.Join(\" \", conceptSequence)}\", ConceptSequence = conceptSequence });\n                _glyphInputBuffer.MarkConsumed(recentInputs);\n                return;\n            }\n\n            // Fizzle logic is now primarily handled in Tick() if inputs expire, or if explicit invalid combo.\n            // This placeholder resolver does not handle complex invalid combos yet.\n        }\n\n        // Removed MarkInputsConsumed, it's now part of GlyphInputBuffer.MarkConsumed\n        // Removed Clear, it's now part of GlyphInputBuffer.Clear\n    }\n}\n</code></pre> <p>Key Changes in <code>MagicSystem.cs</code>:</p> <ul> <li>Now uses <code>GlyphInputBuffer _glyphInputBuffer</code> instead of a raw <code>List</code>.</li> <li>Constructor now takes <code>GameManager</code> to access <code>Time.CurrentGameTime</code>.</li> <li><code>Push</code> and <code>MarkConsumed</code> are delegated to the <code>_glyphInputBuffer</code> instance.</li> <li>The <code>Tick</code> method now includes logic to fizzle combos if the oldest input expires due to <code>MAX_COMBO_DELAY</code>.</li> <li><code>ProcessGlyphInput</code> includes <code>GLYPH_DEBOUNCE_TIME</code> to prevent accidental double-inputs.</li> </ul>"},{"location":"25-chapter-25/#5-update-gamemanager-to-pass-gamemanager-to-magicsystem","title":"5. Update <code>GameManager</code> to Pass <code>GameManager</code> to <code>MagicSystem</code>","text":"<ol> <li>Open <code>res://_Brain/Core/GameManager.cs</code>.</li> <li>Modify the <code>MagicSystem</code> initialization in <code>InitializeSystems()</code> to pass <code>this</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        // Initialize MagicSystem, passing GameManager itself for CurrentGameTime access\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this); // Pass 'this'\n        GD.Print(\"  - MagicSystem initialized.\");\n// ...\n</code></pre>"},{"location":"25-chapter-25/#6-testing-the-input-buffer","title":"6. Testing the Input Buffer","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Perform the same tests as in Chapter 3.3:<ul> <li>Test 1 (Single Unknown Glyph): Press <code>1</code> (hotbar slot 0). This is our <code>testSymbol</code> (initially <code>Hidden</code>). You should see it become <code>Seen</code>, then <code>Known</code>, and a \"Discovered Concept!\" message.</li> <li>Test 2 (Two Known Glyphs - Plausible Experiment): Quickly press <code>0</code> then <code>1</code>. You should see a \"Plausible experiment!\" message.</li> <li>Test 3 (Fizzle): Press <code>0</code>. Wait for more than <code>MAX_COMBO_DELAY</code> (1.5 seconds). Press <code>0</code> again. You should see a <code>MagicSystem: Combo fizzled (inputs too slow)...</code> message.</li> </ul> </li> </ol> <p>The output and behavior should be consistent with the previous chapter, but now the underlying <code>GlyphInputBuffer</code> is handling the sequence storage more robustly. The explicit <code>_glyphInputBuffer.ToString()</code> can be used in debug to see the buffer's state.</p>"},{"location":"25-chapter-25/#summary","title":"Summary","text":"<p>You have successfully implemented a dedicated Input Buffer for storing <code>GlyphInputFrame</code> sequences, enhancing the <code>MagicSystem</code>'s ability to process player input for combos. By creating the <code>GlyphInputBuffer</code> class and integrating it into <code>MagicSystem</code>, you've established a robust mechanism for managing glyph input order, timestamps, and consumption, strictly adhering to TDD 02.1's specifications. This refined input pipeline is crucial for the efficient and accurate detection of complex glyph combos.</p>"},{"location":"25-chapter-25/#next-steps","title":"Next Steps","text":"<p>The next chapter will implement the Combo Resolver using a Trie structure (TDD 02.2) to efficiently detect known spell sequences from the glyph input buffer, moving us closer to a fully functional magic system.</p>"},{"location":"26-chapter-26/","title":"Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)","text":""},{"location":"26-chapter-26/#chapter-42-combo-resolver-trie-structure-for-spell-detection-c","title":"Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)","text":"<p>With our <code>GlyphInputBuffer</code> accurately storing glyph sequences, the next challenge is efficiently detecting if these sequences correspond to known spells or combo patterns. This chapter implements the Combo Resolver using a Prefix Tree (Trie) structure, as specified in TDD 02.2. This data structure is ideal for quickly matching input sequences and is fundamental for Sigilborne's dynamic combo system.</p>"},{"location":"26-chapter-26/#1-the-need-for-a-trie-based-combo-resolver","title":"1. The Need for a Trie-Based Combo Resolver","text":"<p>The GDD (B02.2) emphasizes that \"any sequence can be attempted\" and \"the world's logic interprets them.\" A Trie allows for:</p> <ul> <li>Efficient Prefix Matching: Quickly determine if a partial input sequence could lead to a valid combo.</li> <li>Dynamic Combo Registration: Easily add or remove new combos (spells) to the system.</li> <li>Hierarchical Structure: Naturally represents sequences of glyphs.</li> </ul>"},{"location":"26-chapter-26/#2-defining-spelldefinition","title":"2. Defining <code>SpellDefinition</code>","text":"<p>Before we build the Trie, we need a way to define what a \"spell\" or \"combo\" actually is. TDD 02.3 specifies <code>SpellDefinition</code> as data, not code.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/SpellDefinition.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/SpellDefinition.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Vector2, though not directly used in this struct yet\nusing Sigilborne.Entities; // For EntityID if spell targets an entity\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents the static data defining a single spell or combo technique.\n    /// Spells are data-driven to allow for thousands of variations and mythic evolution.\n    /// (TDD 02.3)\n    /// &lt;/summary&gt;\n    public class SpellDefinition\n    {\n        public string ID { get; private set; } // Unique ID (e.g., \"fireball_01\", \"bloom_veil_healing_mist\")\n        public List&lt;GlyphConcept&gt; Sequence { get; private set; } // The required sequence of GlyphConcepts\n        public float BaseDamage { get; private set; }\n        public float ChakraCost { get; private set; } // TDD 02.3: ManaCost renamed to ChakraCost\n        public float CastTime { get; private set; }\n        public float StabilityCost { get; private set; } // GDD B03.2: Strain Accumulation Model\n        public float ResidueGeneration { get; private set; } // GDD B03.7: Chaos Residue System\n        public bool IsMythic { get; private set; } // TDD 02.3: For Mythic Evolution (C01)\n        public bool IsForbidden { get; private set; } // GDD B01.10: Forbidden Glyphs (C04)\n\n        // Components (ECS-lite) - TDD 02.3\n        // These will be actual structs or classes in later chapters.\n        public ProjectileData Projectile { get; private set; } // Speed, Size, Pierce\n        public AoEData Explosion { get; private set; } // Radius, Falloff\n        public List&lt;StatusEffectData&gt; Effects { get; private set; } // Burn, Stun\n\n        public SpellDefinition(string id, List&lt;GlyphConcept&gt; sequence, float baseDamage, float chakraCost, float castTime, float stabilityCost, float residueGeneration, bool isMythic, bool isForbidden, ProjectileData projectile = null, AoEData explosion = null, List&lt;StatusEffectData&gt; effects = null)\n        {\n            ID = id;\n            Sequence = sequence ?? new List&lt;GlyphConcept&gt;();\n            BaseDamage = baseDamage;\n            ChakraCost = chakraCost;\n            CastTime = castTime;\n            StabilityCost = stabilityCost;\n            ResidueGeneration = residueGeneration;\n            IsMythic = isMythic;\n            IsForbidden = isForbidden;\n            Projectile = projectile;\n            Explosion = explosion;\n            Effects = effects ?? new List&lt;StatusEffectData&gt;();\n        }\n\n        public override string ToString()\n        {\n            string seq = string.Join(\"-&gt;\", Sequence.Select(c =&gt; c.ToString()));\n            return $\"Spell: '{ID}' ({seq}) | Dmg: {BaseDamage}, Chakra: {ChakraCost}, StabCost: {StabilityCost}\";\n        }\n\n        // --- Placeholder Component Data Structs (TDD 02.3) ---\n        public class ProjectileData { public float Speed; public float Size; public int Pierce; public override string ToString() =&gt; $\"Proj(Spd:{Speed},Sz:{Size})\"; }\n        public class AoEData { public float Radius; public float Falloff; public override string ToString() =&gt; $\"AoE(Rad:{Radius})\"; }\n        public class StatusEffectData { public string EffectID; public float Duration; public override string ToString() =&gt; $\"Effect({EffectID})\"; }\n    }\n}\n</code></pre>"},{"location":"26-chapter-26/#3-the-comboresolver-trie-structure","title":"3. The <code>ComboResolver</code> (Trie Structure)","text":"<p>Now, let's implement the Trie. Each node in the Trie will represent a <code>GlyphConcept</code>. Leaf nodes will store the <code>SpellDefinition</code> that corresponds to the completed sequence.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/ComboResolver.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/ComboResolver.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Godot;\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents a node in the Trie structure for combo resolution.\n    /// (TDD 02.2)\n    /// &lt;/summary&gt;\n    public class TrieNode\n    {\n        public Dictionary&lt;GlyphConcept, TrieNode&gt; Children { get; } = new Dictionary&lt;GlyphConcept, TrieNode&gt;();\n        public SpellDefinition Spell { get; set; } // Null if not a complete spell, otherwise the SpellDefinition\n\n        public override string ToString()\n        {\n            return $\"Node (Children: {Children.Count}) {(Spell != null ? $\"[Spell: {Spell.ID}]\" : \"\")}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Uses a Prefix Tree (Trie) to efficiently detect spells from glyph input sequences.\n    /// (TDD 02.2)\n    /// &lt;/summary&gt;\n    public class ComboResolver\n    {\n        private TrieNode _root = new TrieNode();\n\n        public ComboResolver()\n        {\n            GD.Print(\"ComboResolver: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new SpellDefinition into the Trie structure.\n        /// &lt;/summary&gt;\n        public void RegisterSpell(SpellDefinition spell)\n        {\n            if (spell.Sequence == null || spell.Sequence.Count == 0)\n            {\n                GD.PrintErr($\"ComboResolver: Cannot register spell '{spell.ID}' with empty sequence.\");\n                return;\n            }\n\n            TrieNode currentNode = _root;\n            foreach (GlyphConcept concept in spell.Sequence)\n            {\n                if (!currentNode.Children.ContainsKey(concept))\n                {\n                    currentNode.Children[concept] = new TrieNode();\n                }\n                currentNode = currentNode.Children[concept];\n            }\n            // If a spell already exists at this node, it means a shorter sequence\n            // has the same effect, or we're overwriting. Log a warning.\n            if (currentNode.Spell != null)\n            {\n                GD.PrintWarning($\"ComboResolver: Overwriting spell '{currentNode.Spell.ID}' with '{spell.ID}' for sequence '{string.Join(\"-&gt;\", spell.Sequence)}'.\");\n            }\n            currentNode.Spell = spell;\n            GD.Print($\"ComboResolver: Registered spell '{spell.ID}' with sequence '{string.Join(\"-&gt;\", spell.Sequence)}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to find the longest matching spell in the Trie for a given sequence of glyph inputs.\n        /// (TDD 02.2: Algorithm)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"glyphInputs\"&gt;The sequence of glyph inputs to check.&lt;/param&gt;\n        /// &lt;returns&gt;The longest matching SpellDefinition, or null if no spell is found.&lt;/returns&gt;\n        public SpellDefinition ResolveCombo(ReadOnlySpan&lt;GlyphInputFrame&gt; glyphInputs)\n        {\n            if (glyphInputs.IsEmpty) return null;\n\n            SpellDefinition bestMatch = null;\n            TrieNode currentNode = _root;\n            int longestMatchLength = 0;\n\n            for (int i = 0; i &lt; glyphInputs.Length; i++)\n            {\n                GlyphConcept concept = glyphInputs[i].Concept;\n\n                if (currentNode.Children.TryGetValue(concept, out TrieNode nextNode))\n                {\n                    currentNode = nextNode;\n                    // If this node completes a spell, it's a potential match.\n                    // We keep searching for a longer match.\n                    if (currentNode.Spell != null)\n                    {\n                        bestMatch = currentNode.Spell;\n                        longestMatchLength = i + 1; // Length of the sequence that matched\n                    }\n                }\n                else\n                {\n                    // No further match for this sequence, break.\n                    break;\n                }\n            }\n            return bestMatch;\n        }\n\n        // --- Debugging / Utility ---\n        public void PrintTrie(TrieNode node = null, string prefix = \"\")\n        {\n            if (node == null) node = _root;\n\n            foreach (var childEntry in node.Children)\n            {\n                string newPrefix = prefix + childEntry.Key.ToString() + \"-&gt;\";\n                GD.Print($\"{newPrefix}{(childEntry.Value.Spell != null ? $\" [Spell: {childEntry.Value.Spell.ID}]\" : \"\")}\");\n                PrintTrie(childEntry.Value, newPrefix);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"26-chapter-26/#4-integrating-comboresolver-into-magicsystem","title":"4. Integrating <code>ComboResolver</code> into <code>MagicSystem</code>","text":"<p>Now, <code>MagicSystem</code> will use <code>ComboResolver</code> to detect actual spells.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>.</li> <li>Add a <code>ComboResolver</code> property.</li> <li>Modify the <code>MagicSystem</code> constructor to initialize <code>_comboResolver</code>.</li> <li>Update <code>ResolveCombo</code> to use <code>_comboResolver.ResolveCombo()</code>.</li> </ol> <pre><code>// _Brain/Systems/Magic/MagicSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Magic\n{\n    // ... (GlyphInputFrame struct) ...\n\n    public class MagicSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private PlayerHotbarSystem _playerHotbar;\n        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;\n        private WorldGlyphMap _worldGlyphMap;\n        private GameManager _gameManager;\n\n        private EntityID _playerEntityID;\n\n        private GlyphInputBuffer _glyphInputBuffer;\n        private ComboResolver _comboResolver; // New: ComboResolver instance\n\n        private const int MAX_GLYPH_BUFFER_SIZE = 10;\n        private const float MAX_COMBO_DELAY = 1.5f;\n        private const float GLYPH_DEBOUNCE_TIME = 0.1f;\n\n        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,\n                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,\n                           WorldGlyphMap worldGlyphMap, GameManager gameManager, ComboResolver comboResolver) // Add ComboResolver\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _playerHotbar = playerHotbar;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n            _gameManager = gameManager;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n\n            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE);\n            _comboResolver = comboResolver; // Initialize ComboResolver\n            GD.Print(\"MagicSystem: Initialized.\");\n        }\n\n        // ... (Tick, ProcessGlyphInput methods) ...\n\n        private void ResolveCombo()\n        {\n            // TDD 02.1: Get recent inputs within the combo delay window.\n            ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY);\n\n            if (recentInputsSpan.IsEmpty) return;\n\n            GD.Print($\"MagicSystem: Attempting to resolve combo with {recentInputsSpan.Length} recent inputs.\");\n\n            // --- NEW: Use ComboResolver to find a known spell (TDD 02.2) ---\n            SpellDefinition resolvedSpell = _comboResolver.ResolveCombo(recentInputsSpan);\n\n            if (resolvedSpell != null)\n            {\n                // Found a known spell!\n                GD.Print($\"MagicSystem: Resolved known spell: '{resolvedSpell.ID}'!\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = false, ResultText = $\"Cast {resolvedSpell.ID}!\", ConceptSequence = resolvedSpell.Sequence });\n                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray()); // Mark inputs as consumed\n                return;\n            }\n            // --- END NEW ---\n\n            // --- Existing Placeholder Combo Resolution Logic ---\n            // Simplified logic from previous chapter.\n            // If player inputs a single unknown glyph, mark it as known.\n            if (recentInputsSpan.Length == 1 &amp;&amp; recentInputsSpan[0].KnowledgeState &lt; GlyphKnowledgeState.Known)\n            {\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputsSpan[0].SymbolID, GlyphKnowledgeState.Known);\n                GD.Print($\"MagicSystem: Player successfully experimented with '{recentInputsSpan[0].SymbolID}' and now KNOWS its concept: {recentInputsSpan[0].Concept}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Discovered {recentInputsSpan[0].Concept}!\", ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputsSpan[0].Concept } });\n                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                return;\n            }\n\n            // Simple check: if two known glyphs are pressed, it's a plausible experiment (GDD B00.7)\n            if (recentInputsSpan.Length &gt;= 2 &amp;&amp; recentInputsSpan.ToArray().All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))\n            {\n                List&lt;GlyphConcept&gt; conceptSequence = recentInputsSpan.ToArray().Select(f =&gt; f.Concept).ToList();\n                GD.Print($\"MagicSystem: Player experimented with a plausible sequence: {string.Join(\" -&gt; \", conceptSequence)}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Plausible experiment! {string.Join(\" \", conceptSequence)}\", ConceptSequence = conceptSequence });\n                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                return;\n            }\n\n            // Fizzle logic is now primarily handled in Tick() if inputs expire, or if explicit invalid combo.\n        }\n    }\n}\n</code></pre>"},{"location":"26-chapter-26/#5-integrating-comboresolver-into-gamemanager","title":"5. Integrating <code>ComboResolver</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>ComboResolver</code> property.</li> <li>Initialize <code>ComboResolver</code> in <code>InitializeSystems()</code> before <code>MagicSystem</code>.</li> <li>Pass <code>ComboResolver</code> to <code>MagicSystem</code>'s constructor.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public MagicSystem Magic { get; private set; }\n    public ComboResolver ComboResolver { get; private set; } // Add ComboResolver property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test Glyph Discovery System ---\n        GD.Print(\"\\n--- Testing Glyph Discovery System ---\");\n        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID;\n        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID;\n        string testSymbol3 = GlyphMap.AllWorldGlyphs[2].SymbolID;\n        string testSymbol4 = GlyphMap.AllWorldGlyphs[3].SymbolID; // New for multi-glyph combo\n        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s));\n\n        // Reset knowledge for acquisition tests\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Hidden, true);\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Hidden, true);\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol3, GlyphKnowledgeState.Hidden, true);\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol4, GlyphKnowledgeState.Hidden, true); // Reset\n\n        GD.Print($\"Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}\");\n        // Let MagicSystem handle discovery for testSymbol via hotbar input\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known, true); // Still make testSymbol2 known for hotbar test\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol3, GlyphKnowledgeState.Known, true); // Make testSymbol3 known\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol4, GlyphKnowledgeState.Known, true); // Make testSymbol4 known\n\n        GD.Print($\"Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}\");\n        GD.Print($\"Knowledge of '{testSymbol3}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol3)}\");\n        GD.Print($\"Knowledge of '{testSymbol4}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol4)}\");\n\n        GD.Print($\"Attempt to update unknown symbol '{unknownSymbol}':\");\n        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known);\n\n        GD.Print(\"--- End Testing Glyph Discovery System ---\\n\");\n\n        // --- Test PlayerHotbarSystem ---\n        GD.Print(\"\\n--- Testing PlayerHotbarSystem ---\");\n        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign potentially unknown symbol\n        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign known symbol\n        PlayerHotbar.AssignGlyphToSlot(2, testSymbol3); // Assign known symbol\n        PlayerHotbar.AssignGlyphToSlot(3, testSymbol4); // Assign known symbol\n        // ... (existing hotbar tests) ...\n        GD.Print(\"--- End Testing PlayerHotbarSystem ---\\n\");\n\n        // --- Test Glyph Acquisition System ---\n        // ... (existing acquisition tests) ...\n        GD.Print(\"--- End Testing Glyph Acquisition System ---\\n\");\n\n        // --- Test Combo Resolver and Spell Definitions ---\n        GD.Print(\"\\n--- Testing Combo Resolver and Spell Definitions ---\");\n        // Register some dummy spells for testing the Trie\n        // Spell 1: Bloom -&gt; Consume\n        List&lt;GlyphConcept&gt; spell1Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol2).Concept };\n        SpellDefinition spell1 = new SpellDefinition(\"Test_BloomConsume\", spell1Sequence, 10f, 5f, 0.5f, 0.1f, 0.05f, false, false,\n                                                    projectile: new SpellDefinition.ProjectileData { Speed = 200, Size = 10 });\n        ComboResolver.RegisterSpell(spell1);\n\n        // Spell 2: Bloom -&gt; Consume -&gt; Pulse (longer version)\n        List&lt;GlyphConcept&gt; spell2Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol2).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol3).Concept };\n        SpellDefinition spell2 = new SpellDefinition(\"Test_BloomConsumePulse\", spell2Sequence, 25f, 15f, 1.0f, 0.3f, 0.1f, false, false,\n                                                    explosion: new SpellDefinition.AoEData { Radius = 50 });\n        ComboResolver.RegisterSpell(spell2);\n\n        // Spell 3: Pulse -&gt; Bloom\n        List&lt;GlyphConcept&gt; spell3Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol3).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol).Concept };\n        SpellDefinition spell3 = new SpellDefinition(\"Test_PulseBloom\", spell3Sequence, 15f, 8f, 0.7f, 0.2f, 0.0f, false, false,\n                                                    effects: new List&lt;SpellDefinition.StatusEffectData&gt; { new SpellDefinition.StatusEffectData { EffectID = \"slow\", Duration = 3f } });\n        ComboResolver.RegisterSpell(spell3);\n\n        GD.Print(\"\\n--- Combo Resolver Trie Structure ---\");\n        ComboResolver.PrintTrie();\n        GD.Print(\"-------------------------------------\\n\");\n\n        GD.Print(\"--- End Testing Combo Resolver and Spell Definitions ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to GlyphMap) ...\n\n        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);\n        GD.Print(\"  - PlayerGlyphKnowledgeSystem initialized.\");\n\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        // Initialize ComboResolver BEFORE MagicSystem\n        ComboResolver = new ComboResolver(); // Initialize ComboResolver here\n        GD.Print(\"  - ComboResolver initialized.\");\n\n        // Initialize MagicSystem, passing GameManager and ComboResolver\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver); // Pass 'this' and ComboResolver\n        GD.Print(\"  - MagicSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"26-chapter-26/#6-testing-combo-resolution","title":"6. Testing Combo Resolution","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for <code>ComboResolver</code> initialization and spell registration. The <code>PrintTrie()</code> output will show the structure.</li> <li>Test 1 (Single Unknown Glyph): Press <code>0</code> (hotbar slot 0, <code>testSymbol</code>, initially <code>Hidden</code>).<ul> <li>This will still trigger the glyph discovery logic: <code>MagicSystem: Player successfully experimented with 'symbol_leaf' and now KNOWS its concept: Bloom.</code></li> </ul> </li> <li>Test 2 (Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code>):<ul> <li>Quickly press <code>0</code> (for <code>testSymbol</code>, which is <code>Bloom</code> in our seed)</li> <li>Then quickly press <code>1</code> (for <code>testSymbol2</code>, which is <code>Consume</code> in our seed)</li> <li>This sequence should match <code>Test_BloomConsume</code>.</li> <li>You should see: <code>MagicSystem: Resolved known spell: 'Test_BloomConsume'!</code></li> <li><code>MagicSystem: Combo fizzled...</code> should NOT appear for these resolved combos.</li> </ul> </li> <li>Test 3 (Longer Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code> -&gt; <code>testSymbol3</code>):<ul> <li>Quickly press <code>0</code> (Bloom)</li> <li>Then <code>1</code> (Consume)</li> <li>Then <code>2</code> (Pulse)</li> <li>This sequence should match <code>Test_BloomConsumePulse</code>.</li> <li>You should see: <code>MagicSystem: Resolved known spell: 'Test_BloomConsumePulse'!</code> (The Trie correctly finds the longest match, even if a shorter prefix also matches a spell).</li> </ul> </li> <li>Test 4 (Fizzle):<ul> <li>Press <code>0</code>. Wait for more than <code>MAX_COMBO_DELAY</code> (1.5 seconds).</li> <li>Press <code>0</code> again. You should see a <code>MagicSystem: Combo fizzled...</code> message.</li> </ul> </li> <li>Test 5 (Different Order - <code>testSymbol3</code> -&gt; <code>testSymbol</code>):<ul> <li>Quickly press <code>2</code> (Pulse)</li> <li>Then <code>0</code> (Bloom)</li> <li>This should match <code>Test_PulseBloom</code>.</li> <li>You should see: <code>MagicSystem: Resolved known spell: 'Test_PulseBloom'!</code></li> </ul> </li> </ol> <p>This confirms the <code>ComboResolver</code> (Trie) is correctly identifying known spell sequences, respecting order, and finding the longest match.</p>"},{"location":"26-chapter-26/#summary","title":"Summary","text":"<p>You have successfully implemented the Combo Resolver using a Prefix Tree (Trie) structure, efficiently detecting known spell sequences from the glyph input buffer. By defining <code>SpellDefinition</code> as data and integrating <code>ComboResolver</code> into <code>MagicSystem</code>, you've established a robust and flexible system for matching glyph input patterns, strictly adhering to TDD 02.2's specifications. This crucial component is the brain of Sigilborne's dynamic combo system, enabling complex spellcasting and emergent technique discovery.</p>"},{"location":"26-chapter-26/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Spell Data Architecture, expanding our <code>SpellDefinition</code> with more detailed data for projectiles, AoE, and status effects, and laying the groundwork for how these definitions will support <code>Mythic Evolution</code>.</p>"},{"location":"27-chapter-27/","title":"Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)","text":""},{"location":"27-chapter-27/#chapter-43-spell-data-architecture-data-driven-definitions-c","title":"Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)","text":"<p>Our <code>ComboResolver</code> can now identify known <code>SpellDefinition</code>s. This chapter focuses on expanding the <code>SpellDefinition</code> itself to be truly data-driven, encompassing detailed parameters for projectiles, AoE effects, and status effects, as specified in TDD 02.3. This data-first approach is crucial for supporting thousands of unique spell variations, dynamic <code>Mythic Evolution</code> (C01), and <code>Forbidden Arts</code> (C04) without extensive code changes.</p>"},{"location":"27-chapter-27/#1-the-power-of-data-driven-spells","title":"1. The Power of Data-Driven Spells","text":"<ul> <li>Flexibility: New spells can be created, modified, or evolved simply by changing data, not code.</li> <li>Scalability: Supports a vast number of unique techniques, from simple glyphs to legendary combos.</li> <li>Moddability: Easier for future content creators or modders to add new magic.</li> <li>GDD Alignment: Directly supports the GDD's vision of emergent, world-specific techniques and mythic transformations.</li> </ul>"},{"location":"27-chapter-27/#2-refining-spelldefinition-with-component-data-structs","title":"2. Refining <code>SpellDefinition</code> with Component Data Structs","text":"<p>We briefly defined placeholder <code>ProjectileData</code>, <code>AoEData</code>, and <code>StatusEffectData</code> as nested classes in <code>SpellDefinition.cs</code>. While this works, for a truly ECS-lite approach, these should ideally be separate <code>structs</code> or <code>classes</code> that <code>SpellDefinition</code> references. This allows for cleaner data and potential reusability.</p> <p>Let's move these into their own files in <code>res://_Brain/Systems/Magic/Components/</code> and refine their structure.</p>"},{"location":"27-chapter-27/#21-projectiledatacs","title":"2.1. <code>ProjectileData.cs</code>","text":"<ol> <li>Create <code>res://_Brain/Systems/Magic/Components/ProjectileData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/Components/ProjectileData.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.Magic.Components\n{\n    /// &lt;summary&gt;\n    /// Data for a spell that spawns a projectile.\n    /// (TDD 02.3)\n    /// &lt;/summary&gt;\n    public struct ProjectileData\n    {\n        public float Speed;         // Speed of the projectile\n        public float Size;          // Visual size/radius for collision\n        public int Pierce;          // Number of enemies it can pierce through\n        public string VisualID;     // ID for the Body to know which visual to spawn (e.g., \"fireball_vfx\")\n        public Vector2 Offset;      // Offset from caster's position\n\n        public ProjectileData(float speed, float size, int pierce, string visualId, Vector2 offset)\n        {\n            Speed = speed;\n            Size = size;\n            Pierce = pierce;\n            VisualID = visualId;\n            Offset = offset;\n        }\n\n        public override string ToString() =&gt; $\"Proj(Spd:{Speed},Sz:{Size},Vis:{VisualID})\";\n    }\n}\n</code></pre>"},{"location":"27-chapter-27/#22-aoedatacs","title":"2.2. <code>AoEData.cs</code>","text":"<ol> <li>Create <code>res://_Brain/Systems/Magic/Components/AoEData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/Components/AoEData.cs\nusing System;\n\nnamespace Sigilborne.Systems.Magic.Components\n{\n    /// &lt;summary&gt;\n    /// Data for a spell that creates an Area of Effect (AoE).\n    /// (TDD 02.3)\n    /// &lt;/summary&gt;\n    public struct AoEData\n    {\n        public float Radius;        // Radius of the AoE\n        public float Falloff;       // How damage/effect diminishes with distance from center (0-1)\n        public string VisualID;     // ID for the Body to know which visual to spawn (e.g., \"explosion_vfx\")\n        public float Duration;      // How long the AoE persists (if not instantaneous)\n\n        public AoEData(float radius, float falloff, string visualId, float duration = 0f)\n        {\n            Radius = radius;\n            Falloff = falloff;\n            VisualID = visualId;\n            Duration = duration;\n        }\n\n        public override string ToString() =&gt; $\"AoE(Rad:{Radius},Vis:{VisualID})\";\n    }\n}\n</code></pre>"},{"location":"27-chapter-27/#23-statuseffectdatacs","title":"2.3. <code>StatusEffectData.cs</code>","text":"<ol> <li>Create <code>res://_Brain/Systems/Magic/Components/StatusEffectData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/Components/StatusEffectData.cs\nusing System;\n\nnamespace Sigilborne.Systems.Magic.Components\n{\n    /// &lt;summary&gt;\n    /// Data for a status effect applied by a spell.\n    /// (TDD 02.3)\n    /// &lt;/summary&gt;\n    public struct StatusEffectData\n    {\n        public string EffectID;     // Unique ID of the status effect (e.g., \"burn_t1\", \"stun_short\")\n        public float Duration;      // How long the effect lasts\n        public float Strength;      // Magnitude of the effect (e.g., damage per tick, slow amount)\n\n        public StatusEffectData(string effectId, float duration, float strength)\n        {\n            EffectID = effectId;\n            Duration = duration;\n            Strength = strength;\n        }\n\n        public override string ToString() =&gt; $\"Effect({EffectID},Dur:{Duration},Str:{Strength})\";\n    }\n}\n</code></pre>"},{"location":"27-chapter-27/#24-update-spelldefinitioncs-to-reference-new-structs","title":"2.4. Update <code>SpellDefinition.cs</code> to Reference New Structs","text":"<p>Now, modify <code>res://_Brain/Systems/Magic/SpellDefinition.cs</code> to use these new structs and remove the nested class definitions.</p> <pre><code>// _Brain/Systems/Magic/SpellDefinition.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components; // Add this using directive\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Represents the static data defining a single spell or combo technique.\n    /// Spells are data-driven to allow for thousands of variations and mythic evolution.\n    /// (TDD 02.3)\n    /// &lt;/summary&gt;\n    public class SpellDefinition\n    {\n        public string ID { get; private set; }\n        public List&lt;GlyphConcept&gt; Sequence { get; private set; }\n        public float BaseDamage { get; private set; }\n        public float ChakraCost { get; private set; }\n        public float CastTime { get; private set; }\n        public float StabilityCost { get; private set; }\n        public float ResidueGeneration { get; private set; }\n        public bool IsMythic { get; private set; }\n        public bool IsForbidden { get; private set; }\n\n        // Components (ECS-lite) - Now using our dedicated structs (TDD 02.3)\n        // Use nullable types or default values if a spell doesn't always have these.\n        public ProjectileData? Projectile { get; private set; } // Nullable struct\n        public AoEData? Explosion { get; private set; } // Nullable struct\n        public List&lt;StatusEffectData&gt; Effects { get; private set; }\n\n        public SpellDefinition(string id, List&lt;GlyphConcept&gt; sequence, float baseDamage, float chakraCost, float castTime, float stabilityCost, float residueGeneration, bool isMythic, bool isForbidden, ProjectileData? projectile = null, AoEData? explosion = null, List&lt;StatusEffectData&gt; effects = null)\n        {\n            ID = id;\n            Sequence = sequence ?? new List&lt;GlyphConcept&gt;();\n            BaseDamage = baseDamage;\n            ChakraCost = chakraCost;\n            CastTime = castTime;\n            StabilityCost = stabilityCost;\n            ResidueGeneration = residueGeneration;\n            IsMythic = isMythic;\n            IsForbidden = isForbidden;\n            Projectile = projectile;\n            Explosion = explosion;\n            Effects = effects ?? new List&lt;StatusEffectData&gt;();\n        }\n\n        public override string ToString()\n        {\n            string seq = string.Join(\"-&gt;\", Sequence.Select(c =&gt; c.ToString()));\n            string components = \"\";\n            if (Projectile.HasValue) components += $\" {Projectile.Value}\";\n            if (Explosion.HasValue) components += $\" {Explosion.Value}\";\n            if (Effects.Any()) components += $\" {string.Join(\", \", Effects.Select(e =&gt; e.ToString()))}\";\n\n            return $\"Spell: '{ID}' ({seq}) | Dmg: {BaseDamage}, Chakra: {ChakraCost}, StabCost: {StabilityCost}{components}\";\n        }\n    }\n}\n</code></pre>"},{"location":"27-chapter-27/#3-populating-spelldefinitions-with-procedural-subtype-modifiers","title":"3. Populating <code>SpellDefinition</code>s with Procedural Subtype Modifiers","text":"<p>Now that <code>WorldGlyphDefinition</code> has subtypes and modifiers, and <code>SpellDefinition</code> has component data, we can leverage this to create more dynamic spells.</p> <p>When we register a spell, its <code>BaseDamage</code>, <code>ChakraCost</code>, etc., and the parameters for <code>ProjectileData</code>, <code>AoEData</code>, <code>StatusEffectData</code> can be influenced by the <code>WorldGlyphDefinition</code>s that make up its sequence. This is the \"emergent behavior\" the GDD (B02.1) talks about.</p> <p>Let's modify <code>GameManager._Ready()</code> to register spells that incorporate these modifiers.</p> <p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the \"Test Combo Resolver and Spell Definitions\" section:</p> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method)\n// ...\n        // --- Test Combo Resolver and Spell Definitions ---\n        GD.Print(\"\\n--- Testing Combo Resolver and Spell Definitions ---\");\n\n        // Get WorldGlyphDefinitions for our test symbols\n        WorldGlyphDefinition def0 = GlyphMap.GetDefinitionBySymbol(testSymbol); // Bloom\n        WorldGlyphDefinition def1 = GlyphMap.GetDefinitionBySymbol(testSymbol2); // Consume\n        WorldGlyphDefinition def2 = GlyphMap.GetDefinitionBySymbol(testSymbol3); // Pulse\n        WorldGlyphDefinition def3 = GlyphMap.GetDefinitionBySymbol(testSymbol4); // e.g., Bind\n\n        // Helper to get modifier value safely\n        Func&lt;WorldGlyphDefinition, GlyphModifierType, float, float&gt; getMod = (def, type, defaultValue) =&gt; \n            def.Modifiers.TryGetValue(type, out float val) ? val : defaultValue;\n\n        // --- Spell 1: Bloom -&gt; Consume (Example: Toxic Projectile) ---\n        // Base stats for the spell\n        float baseDmg1 = 10f * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def1, GlyphModifierType.DamageMultiplier, 1.0f);\n        float chakraCost1 = 5f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost1 = 0.1f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f);\n\n        // Projectile data influenced by glyphs\n        ProjectileData projData1 = new ProjectileData(\n            speed: 200f * getMod(def0, GlyphModifierType.Speed, 1.0f),\n            size: 10f * getMod(def1, GlyphModifierType.Radius, 1.0f), // Consume might make it smaller/denser\n            pierce: 1,\n            visualId: \"projectile_basic\",\n            offset: Vector2.Zero\n        );\n        List&lt;StatusEffectData&gt; effects1 = new List&lt;StatusEffectData&gt;();\n        if (def0.Subtype == GlyphSubtype.ToxicBloom) effects1.Add(new StatusEffectData(\"poison_t1\", getMod(def0, GlyphModifierType.Duration, 3f), getMod(def0, GlyphModifierType.DamageMultiplier, 1f)));\n\n        List&lt;GlyphConcept&gt; spell1Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept };\n        SpellDefinition spell1 = new SpellDefinition(\"Test_BloomConsume\", spell1Sequence, baseDmg1, chakraCost1, 0.5f, stabilityCost1, 0.05f, false, false,\n                                                    projectile: projData1,\n                                                    effects: effects1);\n        ComboResolver.RegisterSpell(spell1);\n\n        // --- Spell 2: Bloom -&gt; Consume -&gt; Pulse (Example: Healing AoE) ---\n        float baseHeal2 = 15f * getMod(def0, GlyphModifierType.HealingAmount, 1.0f) + getMod(def2, GlyphModifierType.HealingAmount, 0f); // Pulse could add healing\n        float chakraCost2 = 15f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f) + getMod(def2, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost2 = 0.3f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f) + getMod(def2, GlyphModifierType.ResidueGeneration, 0f);\n\n        AoEData aoeData2 = new AoEData(\n            radius: 50f * getMod(def0, GlyphModifierType.Radius, 1.0f) * getMod(def2, GlyphModifierType.Radius, 1.0f),\n            falloff: 0.5f,\n            visualId: \"aoe_healing_pulse\",\n            duration: getMod(def0, GlyphModifierType.Duration, 0f) + getMod(def2, GlyphModifierType.Duration, 0f) // If pulse has duration\n        );\n        List&lt;StatusEffectData&gt; effects2 = new List&lt;StatusEffectData&gt;();\n        if (def0.Subtype == GlyphSubtype.HealingGrowth) effects2.Add(new StatusEffectData(\"regen_t1\", aoeData2.Duration, getMod(def0, GlyphModifierType.HealingAmount, 1f)));\n\n        List&lt;GlyphConcept&gt; spell2Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept, def2.Concept };\n        SpellDefinition spell2 = new SpellDefinition(\"Test_BloomConsumePulse\", spell2Sequence, baseHeal2, chakraCost2, 1.0f, stabilityCost2, 0.1f, false, false,\n                                                    explosion: aoeData2, // AoE for healing\n                                                    effects: effects2);\n        ComboResolver.RegisterSpell(spell2);\n\n        // --- Spell 3: Pulse -&gt; Bloom (Example: Stun/Slow) ---\n        float baseDmg3 = 15f * getMod(def2, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f);\n        float chakraCost3 = 8f + getMod(def2, GlyphModifierType.StabilityCost, 0f) + getMod(def0, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost3 = 0.2f + getMod(def2, GlyphModifierType.ResidueGeneration, 0f) + getMod(def0, GlyphModifierType.ResidueGeneration, 0f);\n\n        List&lt;StatusEffectData&gt; effects3 = new List&lt;StatusEffectData&gt; { new StatusEffectData(\"stun_short\", 1.0f, 1.0f) };\n        if (def2.Subtype == GlyphSubtype.Shockwave) effects3.Add(new StatusEffectData(\"slow_t1\", getMod(def2, GlyphModifierType.Duration, 3f), getMod(def2, GlyphModifierType.Speed, 1f)));\n\n        List&lt;GlyphConcept&gt; spell3Sequence = new List&lt;GlyphConcept&gt; { def2.Concept, def0.Concept };\n        SpellDefinition spell3 = new SpellDefinition(\"Test_PulseBloom\", spell3Sequence, baseDmg3, chakraCost3, 0.7f, stabilityCost3, 0.0f, false, false,\n                                                    effects: effects3);\n        ComboResolver.RegisterSpell(spell3);\n\n        GD.Print(\"\\n--- Combo Resolver Trie Structure ---\");\n        ComboResolver.PrintTrie();\n        GD.Print(\"-------------------------------------\\n\");\n\n        GD.Print(\"--- End Testing Combo Resolver and Spell Definitions ---\\n\");\n// ...\n</code></pre> <p>Key Changes in <code>GameManager._Ready()</code>:</p> <ul> <li><code>getMod</code> Helper: A lambda function <code>getMod</code> is used to safely retrieve modifier values from <code>WorldGlyphDefinition.Modifiers</code>, providing a default if the modifier isn't present.</li> <li>Dynamic Spell Stats: <code>baseDmg</code>, <code>chakraCost</code>, <code>stabilityCost</code>, and the parameters for <code>ProjectileData</code>, <code>AoEData</code>, and <code>StatusEffectData</code> are now calculated by multiplying or adding values from the <code>WorldGlyphDefinition</code>'s <code>Modifiers</code>. This makes each spell's numerical properties unique to the current world's glyph definitions.</li> <li><code>ProjectileData</code>, <code>AoEData</code>, <code>StatusEffectData</code> Instantiation: Now correctly uses the new struct constructors.</li> </ul>"},{"location":"27-chapter-27/#4-testing-data-driven-spells","title":"4. Testing Data-Driven Spells","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for \"Testing Combo Resolver and Spell Definitions\".<ul> <li>The <code>Spell: 'ID' (...)</code> string representation will now include the details of the <code>Projectile</code>, <code>AoE</code>, and <code>StatusEffect</code> data.</li> <li>Crucially, the <code>Dmg</code>, <code>Chakra</code>, <code>StabCost</code>, and parameters within the component data (e.g., <code>Proj(Spd:X,Sz:Y)</code>) will reflect the values influenced by the <code>GlyphModifierType</code>s of the specific <code>WorldGlyphDefinition</code>s in your current world seed. These numbers will change if you change the <code>worldSeed</code> in <code>GameManager.InitializeSystems()</code>.</li> </ul> </li> </ol> <p>This output demonstrates that your <code>SpellDefinition</code>s are truly data-driven, with their properties dynamically influenced by the world's unique glyph mappings and their associated subtypes and modifiers.</p>"},{"location":"27-chapter-27/#summary","title":"Summary","text":"<p>You have successfully expanded Sigilborne's <code>SpellDefinition</code> to be truly data-driven, incorporating detailed parameters for projectiles, AoE effects, and status effects using dedicated structs. By leveraging the procedural <code>GlyphSubtype</code>s and <code>Modifiers</code> from <code>WorldGlyphMap</code> to dynamically calculate spell properties during registration, you've established a powerful mechanism for creating thousands of unique technique variations. This crucial step strictly adheres to TDD 02.3's specifications, laying the groundwork for <code>Mythic Evolution</code> and <code>Forbidden Arts</code> through flexible, data-centric spell definitions.</p>"},{"location":"27-chapter-27/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on the Casting State Machine, implementing the player's casting flow (Idle, Channeling, Casting, Recovery) in the C# Brain, which will govern when spells can be input and executed, and how chakra costs and stability are managed.</p>"},{"location":"28-chapter-28/","title":"Chapter 4.4: Casting State Machine - Player Casting Flow (C#)","text":""},{"location":"28-chapter-28/#chapter-44-casting-state-machine-player-casting-flow-c","title":"Chapter 4.4: Casting State Machine - Player Casting Flow (C#)","text":"<p>Our <code>ComboResolver</code> can now identify a <code>SpellDefinition</code> from player input. However, casting a spell isn't instantaneous; it involves a sequence of states: preparing the glyphs, channeling energy, and then executing the technique. This chapter implements a Casting State Machine in the C# Brain to manage the player's casting flow (Idle, Channeling, Casting, Recovery), governing when spells can be input, executed, and how chakra costs and stability are managed, as specified in TDD 02.4.</p>"},{"location":"28-chapter-28/#1-the-importance-of-a-casting-state-machine","title":"1. The Importance of a Casting State Machine","text":"<p>The GDD (B05.6) describes dynamic timing windows, and (B03.2) details chakra strain. A state machine provides:</p> <ul> <li>Clear State Management: Precisely define what the player can do in each phase of casting.</li> <li>Timing Control: Enforce <code>CastTime</code> and <code>Recovery</code> periods.</li> <li>Resource Management: Deduct <code>ChakraCost</code> and <code>StabilityCost</code> at the appropriate time.</li> <li>Feedback: Emit events for the Body (UI, animations) to react to casting states.</li> <li>Interruptibility: Define when a cast can be interrupted (covered later).</li> </ul>"},{"location":"28-chapter-28/#2-defining-caststate-and-playercastingstate","title":"2. Defining <code>CastState</code> and <code>PlayerCastingState</code>","text":"<p>We need an enum for the casting states and a component-like struct to hold the player's current casting data.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/PlayerCastingState.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/PlayerCastingState.cs\nusing System;\nusing Godot; // For Vector2 if needed\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Defines the possible states of a player's spellcasting flow.\n    /// (TDD 02.4)\n    /// &lt;/summary&gt;\n    public enum CastState\n    {\n        Idle,           // Not casting, ready for new input.\n        Channeling,     // Glyph sequence started, waiting for more inputs within combo window.\n        CastStart,      // Sequence complete, spell identified, resources deducted, preparing to execute.\n        Casting,        // Spell is actively being cast (e.g., projectile traveling, AoE active).\n        Recovery,       // Post-cast delay, player is briefly unable to act.\n        Interrupted     // Cast was interrupted (e.g., by damage, status effect).\n    }\n\n    /// &lt;summary&gt;\n    /// Stores the player's current casting state and related data.\n    /// This is a component-like data structure managed by the CastingSystem.\n    /// &lt;/summary&gt;\n    public struct PlayerCastingState\n    {\n        public CastState CurrentState;\n        public SpellDefinition CurrentSpell; // The spell being cast.\n        public double StateTimer;           // How long we've been in the current state.\n        public EntityID CasterID;           // The entity performing the cast.\n\n        public PlayerCastingState(EntityID casterID)\n        {\n            CasterID = casterID;\n            CurrentState = CastState.Idle;\n            CurrentSpell = null;\n            StateTimer = 0;\n        }\n\n        public override string ToString()\n        {\n            return $\"State: {CurrentState}, Spell: {CurrentSpell?.ID ?? \"None\"}, Timer: {StateTimer:F2}\";\n        }\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#3-implementing-castingsystemcs","title":"3. Implementing <code>CastingSystem.cs</code>","text":"<p>This system will manage the <code>PlayerCastingState</code> struct, process state transitions, deduct resources, and interact with other systems.</p> <ol> <li>Create <code>res://_Brain/Systems/Magic/CastingSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Magic/CastingSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology; // For PlayerStatSystem\nusing Sigilborne.Systems.Magic.Components; // For ProjectileData, AoEData etc.\n\nnamespace Sigilborne.Systems.Magic\n{\n    /// &lt;summary&gt;\n    /// Manages the player's spellcasting state machine and executes spell effects.\n    /// (TDD 02.4)\n    /// &lt;/summary&gt;\n    public class CastingSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private PlayerStatSystem _playerStatSystem; // To deduct chakra/stability\n        private TransformSystem _transformSystem;   // To get caster position for effects\n\n        private EntityID _playerEntityID;\n        private PlayerCastingState _playerCastingState; // The player's casting state machine\n\n        // Recovery time after a spell cast (GDD B05.5)\n        private const float DEFAULT_RECOVERY_TIME = 0.3f; // Small default recovery\n\n        public CastingSystem(EntityManager entityManager, EventBus eventBus, PlayerStatSystem playerStatSystem, TransformSystem transformSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _playerStatSystem = playerStatSystem;\n            _transformSystem = transformSystem;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n            _playerCastingState = new PlayerCastingState(_playerEntityID); // Initialize casting state\n\n            GD.Print(\"CastingSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the CastingSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// (TDD 02.4: Update(double delta) logic)\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _playerCastingState.StateTimer += delta; // Increment timer for current state\n\n            switch (_playerCastingState.CurrentState)\n            {\n                case CastState.Idle:\n                    // Do nothing, waiting for MagicSystem to initiate Channeling\n                    break;\n\n                case CastState.Channeling:\n                    // Channeling is managed by MagicSystem (combo delay window)\n                    // If MagicSystem doesn't transition to CastStart, it will fizzle.\n                    break;\n\n                case CastState.CastStart:\n                    // Resources deducted, now waiting for CastTime to elapse\n                    if (_playerCastingState.StateTimer &gt;= _playerCastingState.CurrentSpell.CastTime)\n                    {\n                        ExecuteSpellEffect(_playerCastingState.CurrentSpell);\n                        TransitionToState(CastState.Recovery, DEFAULT_RECOVERY_TIME); // Enter recovery after execution\n                    }\n                    break;\n\n                case CastState.Casting:\n                    // For instant spells, this state might be very short or skipped.\n                    // For sustained spells (e.g., beam), this state would persist.\n                    // For now, most spells are instant or have effects triggered in CastStart.\n                    break;\n\n                case CastState.Recovery:\n                    // TDD 02.4: The \"End Lag\". Player cannot move/act.\n                    if (_playerCastingState.StateTimer &gt;= DEFAULT_RECOVERY_TIME)\n                    {\n                        TransitionToState(CastState.Idle); // Back to idle after recovery\n                    }\n                    break;\n\n                case CastState.Interrupted:\n                    // Stays in interrupted state until reset (e.g., player input, timer).\n                    // For now, it will transition to Idle after a short delay.\n                    if (_playerCastingState.StateTimer &gt;= 0.5f) // Short interruption recovery\n                    {\n                        TransitionToState(CastState.Idle);\n                    }\n                    break;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Initiates a spell cast. Called by MagicSystem when a combo is resolved.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"spell\"&gt;The resolved spell to cast.&lt;/param&gt;\n        /// &lt;returns&gt;True if cast initiated, false if resources insufficient or not in Idle state.&lt;/returns&gt;\n        public bool InitiateCast(SpellDefinition spell)\n        {\n            if (_playerCastingState.CurrentState != CastState.Idle)\n            {\n                GD.Print($\"CastingSystem: Cannot cast spell '{spell.ID}', not in Idle state ({_playerCastingState.CurrentState}).\");\n                return false;\n            }\n\n            PlayerStats currentStats = _playerStatSystem.GetPlayerStats();\n            if (currentStats.Chakra &lt; spell.ChakraCost)\n            {\n                GD.Print($\"CastingSystem: Insufficient Chakra to cast '{spell.ID}'. (Need: {spell.ChakraCost}, Have: {currentStats.Chakra})\");\n                // Emit event for UI feedback (e.g., \"Not enough Chakra\")\n                _eventBus.Publish(new CastFailedEvent { PlayerID = _playerEntityID, Reason = \"Insufficient Chakra\" });\n                return false;\n            }\n            // Add stability check here (GDD B03.2)\n            // If currentStats.Stability &lt; spell.StabilityCost... fail or miscast.\n\n            // Deduct resources immediately (TDD 02.4: Mana deducted)\n            _playerStatSystem.TakeChakra(spell.ChakraCost); // We'll add TakeChakra to PlayerStatSystem\n            // Deduct stability (GDD B03.2)\n            // _playerStatSystem.TakeStability(spell.StabilityCost);\n\n            _playerCastingState.CurrentSpell = spell;\n            TransitionToState(CastState.CastStart, spell.CastTime); // Transition to CastStart, timer is CastTime\n\n            GD.Print($\"CastingSystem: Initiated cast for '{spell.ID}'. Chakra cost: {spell.ChakraCost}.\");\n            _eventBus.Publish(new CastStateChangedEvent { PlayerID = _playerEntityID, NewState = CastState.CastStart, SpellID = spell.ID });\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Transitions the casting state machine to a new state.\n        /// &lt;/summary&gt;\n        private void TransitionToState(CastState newState, double timerDuration = 0)\n        {\n            _playerCastingState.CurrentState = newState;\n            _playerCastingState.StateTimer = 0; // Reset timer for the new state\n            GD.Print($\"CastingSystem: Player {_playerEntityID} transitioned to state: {newState}.\");\n            _eventBus.Publish(new CastStateChangedEvent { PlayerID = _playerEntityID, NewState = newState, SpellID = _playerCastingState.CurrentSpell?.ID });\n        }\n\n        /// &lt;summary&gt;\n        /// Executes the actual effects of the spell.\n        /// (TDD 02.4: Casting: The \"Active Frames\". Projectile spawns or effect applies.)\n        /// &lt;/summary&gt;\n        private void ExecuteSpellEffect(SpellDefinition spell)\n        {\n            GD.Print($\"CastingSystem: Executing effect for spell '{spell.ID}'!\");\n            _eventBus.Publish(new SpellEffectExecutedEvent { PlayerID = _playerEntityID, Spell = spell });\n\n            // --- Placeholder for actual effect logic ---\n            // In later chapters, this would interact with other systems:\n            // - Spawn projectile entities (ProjectileSystem)\n            // - Apply AoE effects (AoESystem)\n            // - Apply status effects (StatusEffectSystem)\n            // - Play specific VFX/Audio (Body via EventBus)\n\n            // For now, let's just use the TransformSystem to get the caster's position for context.\n            if (_transformSystem.TryGetTransform(_playerEntityID, out TransformComponent casterTransform))\n            {\n                GD.Print($\"  Caster Position: {casterTransform.Position}\");\n                if (spell.Projectile.HasValue)\n                {\n                    GD.Print($\"  Spawn Projectile: {spell.Projectile.Value}\");\n                    // _eventBus.Publish(new SpawnProjectileEvent { CasterID = _playerEntityID, ProjectileData = spell.Projectile.Value, SpawnPosition = casterTransform.Position });\n                }\n                if (spell.Explosion.HasValue)\n                {\n                    GD.Print($\"  Apply AoE: {spell.Explosion.Value}\");\n                    // _eventBus.Publish(new ApplyAoEEvent { CasterID = _playerEntityID, AoEData = spell.Explosion.Value, CenterPosition = casterTransform.Position });\n                }\n                if (spell.Effects.Any())\n                {\n                    GD.Print($\"  Apply Effects: {string.Join(\", \", spell.Effects)}\");\n                    // _eventBus.Publish(new ApplyStatusEffectsEvent { CasterID = _playerEntityID, TargetID = ..., Effects = spell.Effects });\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the player's current casting state.\n        /// &lt;/summary&gt;\n        public PlayerCastingState GetPlayerCastingState()\n        {\n            return _playerCastingState;\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct CastStateChangedEvent { public EntityID PlayerID; public CastState NewState; public string SpellID; }\n        public struct SpellEffectExecutedEvent { public EntityID PlayerID; public SpellDefinition Spell; }\n        public struct CastFailedEvent { public EntityID PlayerID; public string Reason; }\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#31-update-playerstatsystemcs-with-takechakra","title":"3.1. Update <code>PlayerStatSystem.cs</code> with <code>TakeChakra</code>","text":"<p>The <code>CastingSystem</code> needs to deduct chakra.</p> <p>Open <code>res://_Brain/Systems/Biology/PlayerStatSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Biology/PlayerStatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Biology\n{\n    // ... (PlayerStats struct) ...\n\n    public class PlayerStatSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        public PlayerStats GetPlayerStats() { return _playerStats; }\n\n        public void TakeDamage(float amount) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Authoritatively deducts chakra from the player.\n        /// &lt;/summary&gt;\n        public void TakeChakra(float amount)\n        {\n            if (amount &lt; 0) return;\n\n            _playerStats.Chakra -= amount;\n            if (_playerStats.Chakra &lt; 0) _playerStats.Chakra = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerStats.PlayerID} used {amount} chakra. New Chakra: {_playerStats.Chakra}\");\n\n            // Publish an event for the Body (UI) to update chakra display\n            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerStats.PlayerID, NewChakra = _playerStats.Chakra, MaxChakra = _playerStats.MaxChakra });\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerHealthChangedEvent { public EntityID PlayerID; public float NewHealth; public float MaxHealth; }\n        public struct PlayerDiedEvent { public EntityID PlayerID; }\n        public struct PlayerChakraChangedEvent { public EntityID PlayerID; public float NewChakra; public float MaxChakra; } // New event\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#4-integrating-castingsystem-into-gamemanager","title":"4. Integrating <code>CastingSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>CastingSystem</code> property.</li> <li>Initialize <code>CastingSystem</code> in <code>InitializeSystems()</code> before <code>MagicSystem</code>.</li> <li>Call <code>CastingSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> <li>Pass <code>CastingSystem</code> to <code>MagicSystem</code>'s constructor.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components; // Needed for ProjectileData etc.\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public ComboResolver ComboResolver { get; private set; }\n    public CastingSystem Casting { get; private set; } // Add CastingSystem property\n    public MagicSystem Magic { get; private set; }\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n\n        // --- Test PlayerStatSystem (Damage) ---\n        // ... (existing test damage code) ...\n        // --- End Testing PlayerStatSystem ---\n\n        // --- Test Glyph Discovery System ---\n        // ... (existing glyph discovery tests) ...\n\n        // --- Test PlayerHotbarSystem ---\n        // ... (existing hotbar tests) ...\n\n        // --- Test Glyph Acquisition System ---\n        // ... (existing acquisition tests) ...\n\n        // --- Test Combo Resolver and Spell Definitions ---\n        GD.Print(\"\\n--- Testing Combo Resolver and Spell Definitions ---\");\n\n        WorldGlyphDefinition def0 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[0].SymbolID); // Bloom\n        WorldGlyphDefinition def1 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[1].SymbolID); // Consume\n        WorldGlyphDefinition def2 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[2].SymbolID); // Pulse\n        WorldGlyphDefinition def3 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[3].SymbolID); // e.g., Bind\n\n        Func&lt;WorldGlyphDefinition, GlyphModifierType, float, float&gt; getMod = (def, type, defaultValue) =&gt; \n            def.Modifiers.TryGetValue(type, out float val) ? val : defaultValue;\n\n        // Spell 1: Bloom -&gt; Consume (Example: Toxic Projectile)\n        float baseDmg1 = 10f * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def1, GlyphModifierType.DamageMultiplier, 1.0f);\n        float chakraCost1 = 5f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost1 = 0.1f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f);\n        ProjectileData projData1 = new ProjectileData(speed: 200f * getMod(def0, GlyphModifierType.Speed, 1.0f), size: 10f * getMod(def1, GlyphModifierType.Radius, 1.0f), pierce: 1, visualId: \"projectile_basic\", offset: Vector2.Zero);\n        List&lt;StatusEffectData&gt; effects1 = new List&lt;StatusEffectData&gt;();\n        if (def0.Subtype == GlyphSubtype.ToxicBloom) effects1.Add(new StatusEffectData(\"poison_t1\", getMod(def0, GlyphModifierType.Duration, 3f), getMod(def0, GlyphModifierType.DamageMultiplier, 1f)));\n        List&lt;GlyphConcept&gt; spell1Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept };\n        SpellDefinition spell1 = new SpellDefinition(\"Test_BloomConsume\", spell1Sequence, baseDmg1, chakraCost1, 0.5f, stabilityCost1, 0.05f, false, false,\n                                                    projectile: projData1, effects: effects1);\n        ComboResolver.RegisterSpell(spell1);\n\n        // Spell 2: Bloom -&gt; Consume -&gt; Pulse (Example: Healing AoE)\n        float baseHeal2 = 15f * getMod(def0, GlyphModifierType.HealingAmount, 1.0f) + getMod(def2, GlyphModifierType.HealingAmount, 0f);\n        float chakraCost2 = 15f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f) + getMod(def2, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost2 = 0.3f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f) + getMod(def2, GlyphModifierType.ResidueGeneration, 0f);\n        AoEData aoeData2 = new AoEData(radius: 50f * getMod(def0, GlyphModifierType.Radius, 1.0f) * getMod(def2, GlyphModifierType.Radius, 1.0f), falloff: 0.5f, visualId: \"aoe_healing_pulse\", duration: getMod(def0, GlyphModifierType.Duration, 0f) + getMod(def2, GlyphModifierType.Duration, 0f));\n        List&lt;StatusEffectData&gt; effects2 = new List&lt;StatusEffectData&gt;();\n        if (def0.Subtype == GlyphSubtype.HealingGrowth) effects2.Add(new StatusEffectData(\"regen_t1\", aoeData2.Duration, getMod(def0, GlyphModifierType.HealingAmount, 1f)));\n        List&lt;GlyphConcept&gt; spell2Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept, def2.Concept };\n        SpellDefinition spell2 = new SpellDefinition(\"Test_BloomConsumePulse\", spell2Sequence, baseHeal2, chakraCost2, 1.0f, stabilityCost2, 0.1f, false, false,\n                                                    explosion: aoeData2, effects: effects2);\n        ComboResolver.RegisterSpell(spell2);\n\n        // Spell 3: Pulse -&gt; Bloom (Example: Stun/Slow)\n        float baseDmg3 = 15f * getMod(def2, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f);\n        float chakraCost3 = 8f + getMod(def2, GlyphModifierType.StabilityCost, 0f) + getMod(def0, GlyphModifierType.StabilityCost, 0f);\n        float stabilityCost3 = 0.2f + getMod(def2, GlyphModifierType.ResidueGeneration, 0f) + getMod(def0, GlyphModifierType.ResidueGeneration, 0f);\n        List&lt;StatusEffectData&gt; effects3 = new List&lt;StatusEffectData&gt; { new StatusEffectData(\"stun_short\", 1.0f, 1.0f) };\n        if (def2.Subtype == GlyphSubtype.Shockwave) effects3.Add(new StatusEffectData(\"slow_t1\", getMod(def2, GlyphModifierType.Duration, 3f), getMod(def2, GlyphModifierType.Speed, 1f)));\n        List&lt;GlyphConcept&gt; spell3Sequence = new List&lt;GlyphConcept&gt; { def2.Concept, def0.Concept };\n        SpellDefinition spell3 = new SpellDefinition(\"Test_PulseBloom\", spell3Sequence, baseDmg3, chakraCost3, 0.7f, stabilityCost3, 0.0f, false, false,\n                                                    effects: effects3);\n        ComboResolver.RegisterSpell(spell3);\n\n        GD.Print(\"\\n--- Combo Resolver Trie Structure ---\");\n        ComboResolver.PrintTrie();\n        GD.Print(\"-------------------------------------\\n\");\n\n        GD.Print(\"--- End Testing Combo Resolver and Spell Definitions ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Casting.Tick(delta); // Call CastingSystem's tick method\n        Magic.Tick(delta); // MagicSystem is called after CastingSystem to allow it to initiate casts\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to PlayerStatSystem) ...\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        Physics = new PhysicsSystem(Entities, Transforms, Events);\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        int currentWorldSeed = 12345;\n        int numGlyphsForWorld = 10;\n        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);\n        GD.Print(\"  - WorldGlyphMap initialized.\");\n\n        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);\n        GD.Print(\"  - PlayerGlyphKnowledgeSystem initialized.\");\n\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        ComboResolver = new ComboResolver();\n        GD.Print(\"  - ComboResolver initialized.\");\n\n        // Initialize CastingSystem BEFORE MagicSystem\n        Casting = new CastingSystem(Entities, Events, PlayerStats, Transforms); // Initialize CastingSystem here\n        GD.Print(\"  - CastingSystem initialized.\");\n\n        // Initialize MagicSystem, passing CastingSystem\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver, Casting); // Pass CastingSystem\n        GD.Print(\"  - MagicSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#41-update-magicsystemcs-to-pass-castingsystem","title":"4.1. Update <code>MagicSystem.cs</code> to Pass <code>CastingSystem</code>","text":"<p>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code> and modify its constructor and <code>ResolveCombo</code> to interact with <code>CastingSystem</code>.</p> <pre><code>// _Brain/Systems/Magic/MagicSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Magic\n{\n    public class MagicSystem\n    {\n        // ... (existing fields) ...\n        private CastingSystem _castingSystem; // New: Reference to CastingSystem\n\n        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,\n                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,\n                           WorldGlyphMap worldGlyphMap, GameManager gameManager, ComboResolver comboResolver,\n                           CastingSystem castingSystem) // Add CastingSystem parameter\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _playerHotbar = playerHotbar;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n            _gameManager = gameManager;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n\n            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE);\n            _comboResolver = comboResolver;\n            _castingSystem = castingSystem; // Store CastingSystem reference\n            GD.Print(\"MagicSystem: Initialized.\");\n        }\n\n        // ... (Tick, ProcessGlyphInput methods) ...\n\n        private void ResolveCombo()\n        {\n            ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY);\n\n            if (recentInputsSpan.IsEmpty) return;\n\n            // Check if player is currently in a state that prevents new casts (TDD 02.4)\n            if (_castingSystem.GetPlayerCastingState().CurrentState != CastState.Idle)\n            {\n                GD.Print($\"MagicSystem: Player is not Idle ({_castingSystem.GetPlayerCastingState().CurrentState}), cannot initiate new cast.\");\n                return; // Cannot initiate a new cast if not idle\n            }\n\n            GD.Print($\"MagicSystem: Attempting to resolve combo with {recentInputsSpan.Length} recent inputs.\");\n\n            SpellDefinition resolvedSpell = _comboResolver.ResolveCombo(recentInputsSpan);\n\n            if (resolvedSpell != null)\n            {\n                // Found a known spell! Now initiate the cast via CastingSystem.\n                if (_castingSystem.InitiateCast(resolvedSpell))\n                {\n                    GD.Print($\"MagicSystem: Resolved and initiated cast for known spell: '{resolvedSpell.ID}'!\");\n                    _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = false, ResultText = $\"Cast {resolvedSpell.ID}!\", ConceptSequence = resolvedSpell.Sequence });\n                    _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                }\n                else\n                {\n                    GD.Print($\"MagicSystem: Failed to initiate cast for '{resolvedSpell.ID}' (e.g., insufficient resources).\");\n                    // CastingSystem already published a CastFailedEvent.\n                }\n                return;\n            }\n            // ... (existing placeholder resolution logic) ...\n            // Simplified logic for single unknown glyph discovery\n            if (recentInputsSpan.Length == 1 &amp;&amp; recentInputsSpan[0].KnowledgeState &lt; GlyphKnowledgeState.Known)\n            {\n                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputsSpan[0].SymbolID, GlyphKnowledgeState.Known);\n                GD.Print($\"MagicSystem: Player successfully experimented with '{recentInputsSpan[0].SymbolID}' and now KNOWS its concept: {recentInputsSpan[0].Concept}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Discovered {recentInputsSpan[0].Concept}!\", ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputsSpan[0].Concept } });\n                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                return;\n            }\n\n            // Plausible experiment for 2+ known glyphs\n            if (recentInputsSpan.Length &gt;= 2 &amp;&amp; recentInputsSpan.ToArray().All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))\n            {\n                List&lt;GlyphConcept&gt; conceptSequence = recentInputsSpan.ToArray().Select(f =&gt; f.Concept).ToList();\n                GD.Print($\"MagicSystem: Player experimented with a plausible sequence: {string.Join(\" -&gt; \", conceptSequence)}.\");\n                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $\"Plausible experiment! {string.Join(\" \", conceptSequence)}\", ConceptSequence = conceptSequence });\n                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                return;\n            }\n        }\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#42-update-eventbuscs-for-castingsystem-events","title":"4.2. Update <code>EventBus.cs</code> for CastingSystem Events","text":"<p>Our <code>CastingSystem</code> publishes <code>CastStateChangedEvent</code>, <code>SpellEffectExecutedEvent</code>, and <code>CastFailedEvent</code>. Our <code>PlayerStatSystem</code> also now publishes <code>PlayerChakraChangedEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p> <p>Open <code>_Brain/Core/EventBus.cs</code>:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Player Stat Events (TDD 01.4) - updated with Chakra\n        public event Action&lt;EntityID, float, float&gt; OnPlayerHealthChanged;\n        public event Action&lt;EntityID&gt; OnPlayerDied;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerChakraChanged; // New event\n\n        // Casting System Events (TDD 02.4)\n        public event Action&lt;EntityID, CastState, string&gt; OnCastStateChanged; // PlayerID, NewState, SpellID\n        public event Action&lt;EntityID, SpellDefinition&gt; OnSpellEffectExecuted; // PlayerID, Spell\n        public event Action&lt;EntityID, string&gt; OnCastFailed; // PlayerID, Reason\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerStatSystem.PlayerChakraChangedEvent chakraEvent) // New condition\n            {\n                OnPlayerChakraChanged?.Invoke(chakraEvent.PlayerID, chakraEvent.NewChakra, chakraEvent.MaxChakra);\n            }\n            else if (eventData is CastingSystem.CastStateChangedEvent castStateEvent) // New condition\n            {\n                OnCastStateChanged?.Invoke(castStateEvent.PlayerID, castStateEvent.NewState, castStateEvent.SpellID);\n            }\n            else if (eventData is CastingSystem.SpellEffectExecutedEvent spellEffectEvent) // New condition\n            {\n                OnSpellEffectExecuted?.Invoke(spellEffectEvent.PlayerID, spellEffectEvent.Spell);\n            }\n            else if (eventData is CastingSystem.CastFailedEvent castFailedEvent) // New condition\n            {\n                OnCastFailed?.Invoke(castFailedEvent.PlayerID, castFailedEvent.Reason);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"28-chapter-28/#5-testing-the-casting-state-machine","title":"5. Testing the Casting State Machine","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>The player should have 50 Chakra initially.</li> <li>Test 1 (Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code>):<ul> <li>Quickly press <code>0</code> (for <code>testSymbol</code>, which is <code>Bloom</code>)</li> <li>Then quickly press <code>1</code> (for <code>testSymbol2</code>, which is <code>Consume</code>)</li> <li>This sequence should match <code>Test_BloomConsume</code> (Chakra Cost: <code>chakraCost1</code> from <code>GameManager._Ready()</code>, e.g., 5).</li> <li>You should see:<ul> <li><code>MagicSystem: Resolved and initiated cast for known spell: 'Test_BloomConsume'!</code></li> <li><code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: CastStart.</code></li> <li><code>PlayerStatSystem: Player EntityID(0, Gen:1) used X chakra. New Chakra: Y</code> (Chakra deducted)</li> <li>After <code>CastTime</code> (0.5s): <code>CastingSystem: Executing effect for spell 'Test_BloomConsume'!</code></li> <li><code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: Recovery.</code></li> <li>After <code>Recovery</code> (0.3s): <code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: Idle.</code></li> </ul> </li> </ul> </li> <li>Test 2 (Insufficient Chakra):<ul> <li>Repeatedly cast <code>Test_BloomConsume</code> until your Chakra is below its <code>chakraCost1</code>.</li> <li>The next attempt should result in: <code>CastingSystem: Insufficient Chakra to cast 'Test_BloomConsume'. (Need: X, Have: Y)</code> and <code>MagicSystem: Failed to initiate cast...</code></li> </ul> </li> <li>Test 3 (Casting While Not Idle):<ul> <li>Quickly press <code>0</code> then <code>1</code> (initiates cast).</li> <li>While in <code>CastStart</code> or <code>Recovery</code> states, quickly press <code>0</code> then <code>1</code> again.</li> <li>You should see: <code>CastingSystem: Cannot cast spell 'Test_BloomConsume', not in Idle state (CastStart/Recovery).</code></li> </ul> </li> </ol> <p>This confirms the Casting State Machine is correctly managing the player's casting flow, deducting resources, and enforcing state transitions.</p>"},{"location":"28-chapter-28/#summary","title":"Summary","text":"<p>You have successfully implemented the Casting State Machine in the C# Brain, managing the player's spellcasting flow through <code>Idle</code>, <code>Channeling</code>, <code>CastStart</code>, <code>Casting</code>, and <code>Recovery</code> states. By creating <code>CastingSystem</code> to handle state transitions, enforce <code>CastTime</code> and <code>Recovery</code> periods, and deduct <code>ChakraCost</code> (via <code>PlayerStatSystem</code>), you've established precise control over spell execution. This crucial system strictly adheres to TDD 02.4's specifications, providing a robust foundation for Sigilborne's dynamic magic.</p>"},{"location":"28-chapter-28/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Visual Feedback - Particles &amp; Animations, where we will create a <code>ParticleManager</code> and <code>AnimationController</code> in GDScript to react to the C# Brain's casting state changes and spell effect execution events, bringing our spells to life visually.</p>"},{"location":"29-chapter-29/","title":"Chapter 4.5: Visual Feedback - Particles & Animations (GDScript)","text":""},{"location":"29-chapter-29/#chapter-45-visual-feedback-particles-animations-gdscript","title":"Chapter 4.5: Visual Feedback - Particles &amp; Animations (GDScript)","text":"<p>With the C# Brain's <code>CastingSystem</code> now managing the player's casting flow and executing spell effects, it's time for the GDScript Body to bring these actions to life visually. This chapter focuses on implementing a <code>ParticleManager</code> and <code>AnimationController</code> in GDScript to react to the Brain's casting state changes and spell effect execution events, providing essential visual feedback for glyph inputs, cast states, and spell effects, as specified in TDD 02.5.</p>"},{"location":"29-chapter-29/#1-the-role-of-visual-feedback-in-the-body","title":"1. The Role of Visual Feedback in the Body","text":"<ul> <li>Immersion: Visuals make the magic feel real and impactful.</li> <li>Clarity: Players need clear feedback on their inputs, casting progress, and spell outcomes.</li> <li>Responsiveness: The Body must react immediately to Brain events to maintain a smooth player experience.</li> <li>Decoupling: Visuals are completely separate from game logic. The Body doesn't decide to cast; it shows a cast.</li> </ul>"},{"location":"29-chapter-29/#2-implementing-a-particlemanagergd","title":"2. Implementing a <code>ParticleManager.gd</code>","text":"<p>This manager will handle spawning and pooling <code>GPUParticles2D</code> for glyph inputs and spell effects.</p> <ol> <li>Create a new folder <code>res://_Body/Scenes/VFX/</code>.</li> <li>Create a simple <code>GPUParticles2D</code> scene for a generic glyph input effect: <code>res://_Body/Scenes/VFX/GlyphInputFX.tscn</code>.<ul> <li>Root node: <code>GPUParticles2D</code>.</li> <li>In Inspector, set <code>Amount</code> to <code>10-20</code>.</li> <li>Set <code>Lifetime</code> to <code>0.5-1.0</code>.</li> <li>Set <code>Process Material</code> to <code>New ParticlesMaterial</code>.<ul> <li>In <code>ParticlesMaterial</code>, set <code>Direction &gt; Spread</code> to <code>180</code>.</li> <li>Set <code>Initial Velocity &gt; Min/Max</code> to <code>50-100</code>.</li> <li>Set <code>Color</code> to a generic white or light blue.</li> <li>Set <code>Emission Shape</code> to <code>Sphere</code> (radius <code>5-10</code>).</li> <li>Set <code>Scale &gt; Scale Curve</code> to fade out.</li> </ul> </li> <li>Set <code>Texture</code> to a simple circle or square (you can create a <code>res://_Body/Art/VFX/circle_particle.png</code> or use a default Godot texture).</li> <li>Set <code>One Shot</code> to <code>true</code>.</li> <li>Set <code>Autostart</code> to <code>false</code>.</li> <li>Set <code>Emitting</code> to <code>false</code>.</li> <li>Crucially: Set <code>Process Mode</code> to <code>One Shot</code> (in the <code>GPUParticles2D</code> node itself, not the material). This makes it act like a single burst.</li> <li>Save this scene.</li> </ul> </li> <li>Create <code>res://_Body/Scripts/Visuals/ParticleManager.gd</code>:</li> </ol> <pre><code># _Body/Scripts/Visuals/ParticleManager.gd\nclass_name ParticleManager extends Node\n\nstatic var instance: ParticleManager\n\n# Particle pools for different effects\nvar _glyph_input_fx_pool: Array[GPUParticles2D] = []\nconst GLYPH_INPUT_FX_SCENE: PackedScene = preload(\"res://_Body/Scenes/VFX/GlyphInputFX.tscn\")\nconst GLYPH_INPUT_POOL_SIZE: int = 10\n\nfunc _init():\n    if instance != null:\n        push_error(\"ParticleManager: More than one instance detected!\")\n        queue_free()\n        return\n    instance = self\n\nfunc _ready():\n    GD.print(\"ParticleManager: Initialized. Pre-populating particle pools.\")\n    _populate_pool(GLYPH_INPUT_FX_SCENE, _glyph_input_fx_pool, GLYPH_INPUT_POOL_SIZE)\n\n    # Connect to C# events for visual feedback\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnGlyphInput.connect(Callable(self, \"_on_glyph_input\"))\n        GameManager.Instance.Events.OnCastStateChanged.connect(Callable(self, \"_on_cast_state_changed\"))\n        GameManager.Instance.Events.OnSpellEffectExecuted.connect(Callable(self, \"_on_spell_effect_executed\"))\n        GD.print(\"ParticleManager: Connected to C# magic events.\")\n    else:\n        push_error(\"ParticleManager: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _populate_pool(scene: PackedScene, pool: Array[GPUParticles2D], size: int) -&gt; void:\n    for i in range(size):\n        var fx: GPUParticles2D = scene.instantiate()\n        add_child(fx)\n        fx.process_mode = GPUParticles2D.PROCESS_MODE_PAUSED # Ensure it's not emitting\n        fx.emitting = false # Explicitly set to false\n        pool.append(fx)\n\nfunc _get_free_fx(pool: Array[GPUParticles2D]) -&gt; GPUParticles2D:\n    for fx in pool:\n        if not fx.emitting: # Check if it's currently not emitting (available)\n            return fx\n    # If no free particles, expand pool (or return null if strictly fixed size)\n    push_warning(\"ParticleManager: Particle pool exhausted! Expanding pool.\")\n    var new_fx: GPUParticles2D = pool[0].get_scene_file().instantiate() # Instantiate from original scene\n    add_child(new_fx)\n    new_fx.process_mode = GPUParticles2D.PROCESS_MODE_PAUSED\n    new_fx.emitting = false\n    pool.append(new_fx)\n    return new_fx\n\n## Spawns a generic particle effect at a given position.\nfunc spawn_glyph_input_fx(position: Vector2, color: Color) -&gt; void:\n    var fx: GPUParticles2D = _get_free_fx(_glyph_input_fx_pool)\n    if fx != null:\n        fx.global_position = position\n        # Temporarily override particle material color\n        if fx.process_material is ParticlesMaterial:\n            (fx.process_material as ParticlesMaterial).color = color\n\n        fx.restart() # This implicitly sets emitting to true for one shot\n        # GD.print(\"ParticleManager: Spawned glyph FX at %s with color %s\" % [position, color])\n\n## Handler for C# OnGlyphInput event.\n## (TDD 02.5: Particle Manager - Signal: OnGlyphInput(GlyphType type))\nfunc _on_glyph_input(id: int, symbol_id: String, concept: int, knowledge_state: int, is_known: bool, is_valid: bool) -&gt; void:\n    # Only show FX for player's input\n    if id == GameManager.Instance.Entities.GetPlayerEntityID().Index: # Access C# player ID via Index\n        var player_entity_view = EntityViewManager.instance._active_entity_views.get(id)\n        if player_entity_view != null:\n            var fx_color: Color = Color.WHITE # Default color\n            match concept: # Match concept (int) to a color (TDD 02.5: Color matches the element)\n                Magic.GlyphConcept.Bloom: fx_color = Color.GREEN\n                Magic.GlyphConcept.Veil: fx_color = Color.BLUE\n                Magic.GlyphConcept.Pulse: fx_color = Color.RED\n                Magic.GlyphConcept.Bind: fx_color = Color.PURPLE\n                Magic.GlyphConcept.Consume: fx_color = Color.BLACK\n                Magic.GlyphConcept.Fracture: fx_color = Color.ORANGE\n                Magic.GlyphConcept.Echo: fx_color = Color.CYAN\n                Magic.GlyphConcept.Project: fx_color = Color.YELLOW\n                Magic.GlyphConcept.Conjure: fx_color = Color.BROWN\n                Magic.GlyphConcept.Shape: fx_color = Color.GRAY\n                Magic.GlyphConcept.Flux: fx_color = Color.MAGENTA\n                Magic.GlyphConcept.Chain: fx_color = Color.DARK_RED\n                _: fx_color = Color.WHITE # Default for None or unknown\n\n            spawn_glyph_input_fx(player_entity_view.global_position, fx_color)\n\n## Handler for C# OnCastStateChanged event.\nfunc _on_cast_state_changed(id: int, new_state: int, spell_id: String) -&gt; void:\n    if id == GameManager.Instance.Entities.GetPlayerEntityID().Index:\n        match new_state:\n            Magic.CastState.CastStart:\n                GD.print(\"ParticleManager: Player started casting '%s'.\" % spell_id)\n                # Play specific cast start VFX here (e.g., charging particles)\n            Magic.CastState.Casting:\n                GD.print(\"ParticleManager: Player is actively casting '%s'.\" % spell_id)\n                # Play sustained casting VFX here\n            Magic.CastState.Recovery:\n                GD.print(\"ParticleManager: Player is in recovery after casting '%s'.\" % spell_id)\n            Magic.CastState.Interrupted:\n                GD.print(\"ParticleManager: Player cast '%s' was interrupted.\" % spell_id)\n\n## Handler for C# OnSpellEffectExecuted event.\nfunc _on_spell_effect_executed(id: int, spell: Variant) -&gt; void:\n    if id == GameManager.Instance.Entities.GetPlayerEntityID().Index:\n        GD.print(\"ParticleManager: Player executed spell effect for '%s'.\" % spell.ID)\n        var player_entity_view = EntityViewManager.instance._active_entity_views.get(id)\n        if player_entity_view != null:\n            # Spawn specific spell effect VFX based on spell.Projectile.VisualID, spell.AoE.VisualID\n            # For now, a generic burst at player position\n            # (Example: spawn_vfx_by_id(spell.Projectile.VisualID, player_entity_view.global_position))\n            spawn_glyph_input_fx(player_entity_view.global_position, Color.GOLD) # Generic burst for any effect\n</code></pre>"},{"location":"29-chapter-29/#3-implementing-an-animationcontrollergd-conceptual","title":"3. Implementing an <code>AnimationController.gd</code> (Conceptual)","text":"<p>TDD 02.5 mentions an <code>AnimationController</code>. This would be a script that listens to <code>OnCastStateChanged</code> and <code>OnSpellEffectExecuted</code> events and triggers specific animations on the <code>EntityView</code>'s <code>AnimationPlayer</code>. For now, we'll keep this conceptual, as <code>EntityView.gd</code> already has a <code>play_animation</code> method.</p> <p>Conceptual <code>AnimationController.gd</code> (not a new file, just for understanding):</p> <pre><code># (Inside EntityView.gd or a dedicated AnimationController.gd attached to EntityRoot)\n# ...\nfunc _on_cast_state_changed(id: int, new_state: int, spell_id: String) -&gt; void:\n    if entity_id == id: # Check if this event is for *this* entity_view\n        match new_state:\n            Magic.CastState.Channeling:\n                play_animation(\"channel_loop\") # Play a glyph channeling animation\n            Magic.CastState.CastStart:\n                play_animation(\"cast_start\") # Play a short animation for spell wind-up\n            Magic.CastState.Casting:\n                play_animation(\"cast_loop\") # Play a sustained casting animation\n            Magic.CastState.Recovery:\n                play_animation(\"cast_recovery\") # Play a post-cast animation\n            Magic.CastState.Idle:\n                play_animation(\"idle\") # Return to idle animation\n            Magic.CastState.Interrupted:\n                play_animation(\"interrupted\") # Play an interrupted animation\n# ...\nfunc _on_spell_effect_executed(id: int, spell: Variant) -&gt; void:\n    if entity_id == id:\n        # Trigger specific animations for spell execution\n        # Example: play_animation(\"attack_spell_\" + spell.ID)\n        pass\n</code></pre> <p>For now, <code>ParticleManager.gd</code> will handle the visual feedback, and <code>EntityView.gd</code>'s existing <code>play_animation</code> will be used if triggered by the Brain.</p>"},{"location":"29-chapter-29/#4-integrating-particlemanagergd-into-maintscn","title":"4. Integrating <code>ParticleManager.gd</code> into <code>Main.tscn</code>","text":"<ol> <li>Open <code>res://Main.tscn</code>.</li> <li>Add an instance of <code>res://_Body/Scripts/Visuals/ParticleManager.gd</code> as a child of the <code>Main</code> root node.</li> <li>Save <code>Main.tscn</code>.</li> </ol>"},{"location":"29-chapter-29/#5-testing-visual-feedback","title":"5. Testing Visual Feedback","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Test 1 (Glyph Input FX): Press <code>0</code> (hotbar slot 0, for <code>testSymbol</code>).<ul> <li>You should see a particle burst at the player's position, colored according to the concept (e.g., green for Bloom).</li> <li>The console will show <code>ParticleManager: Player input glyph...</code></li> </ul> </li> <li>Test 2 (Casting State FX): Quickly press <code>0</code> then <code>1</code> (for <code>Test_BloomConsume</code>).<ul> <li>You should see a particle burst for each glyph input.</li> <li>The console will show:<ul> <li><code>ParticleManager: Player started casting 'Test_BloomConsume'.</code></li> <li><code>ParticleManager: Player executed spell effect for 'Test_BloomConsume'.</code> (followed by a gold particle burst)</li> <li><code>ParticleManager: Player is in recovery after casting 'Test_BloomConsume'.</code></li> </ul> </li> </ul> </li> </ol> <p>This confirms that our <code>ParticleManager.gd</code> is correctly reacting to C# events and providing visual feedback for glyph inputs and spell execution.</p>"},{"location":"29-chapter-29/#summary","title":"Summary","text":"<p>You have successfully implemented Visual Feedback for Sigilborne's magic system, creating a <code>ParticleManager.gd</code> in the GDScript Body to react to C# Brain events. By designing a particle pooling system and connecting it to <code>OnGlyphInput</code>, <code>OnCastStateChanged</code>, and <code>OnSpellEffectExecuted</code> events, you've ensured that glyph inputs and spell effects are visually represented with immediate and context-sensitive particle bursts, strictly adhering to TDD 02.5's specifications. This crucial step brings our spells to life, enhancing player immersion and clarity.</p>"},{"location":"29-chapter-29/#next-steps","title":"Next Steps","text":"<p>This concludes Module 4: Combos &amp; Casting - The Art of Ninjutsu. We will now move on to Module 5: Chakra &amp; Life Systems, starting with Biological Simulation - The Bio-Tick (C#), where we will implement a slower, dedicated update loop for biological stats to manage player and NPC well-being efficiently.</p>"},{"location":"30-chapter-30/","title":"Chapter 5.1: Biological Simulation - The Bio-Tick (C#)","text":""},{"location":"30-chapter-30/#chapter-51-biological-simulation-the-bio-tick-c","title":"Chapter 5.1: Biological Simulation - The Bio-Tick (C#)","text":"<p>Welcome to Module 5: Chakra &amp; Life Systems! This module delves into the intricate biological and environmental simulation that governs character well-being. Unlike fast-paced combat, biological stats like hunger, thirst, and fatigue don't need to update every physics frame. This chapter implements a dedicated Bio-Tick system in the C# Brain, running at a slower frequency (e.g., 1Hz), to efficiently manage these stats, as specified in TDD 03.2.</p>"},{"location":"30-chapter-30/#1-the-need-for-a-slower-bio-tick","title":"1. The Need for a Slower Bio-Tick","text":"<ul> <li>Performance: Updating every biological stat for every NPC (even virtual ones, to be covered later) at 20Hz (our <code>_PhysicsProcess</code> rate) is overkill and computationally expensive.</li> <li>Realism: Biological processes occur over seconds, minutes, or hours, not milliseconds. A slower tick rate aligns better with this.</li> <li>Decoupling: Separates biological updates from the core physics and input loops.</li> </ul>"},{"location":"30-chapter-30/#2-defining-biostate","title":"2. Defining <code>BioState</code>","text":"<p>TDD 03.2 specifies a <code>readonly struct</code> for <code>BioState</code> to pass biological data around safely and efficiently.</p> <ol> <li>Create <code>res://_Brain/Systems/Biology/BioState.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Biology/BioState.cs\nusing System;\nusing Godot; // For Vector2, though not directly used in this struct\n\nnamespace Sigilborne.Systems.Biology\n{\n    /// &lt;summary&gt;\n    /// Stores the core biological state of an entity.\n    /// This is a readonly struct for efficiency and immutability when passing data.\n    /// (TDD 03.2)\n    /// &lt;/summary&gt;\n    public struct BioState\n    {\n        public float Health;\n        public float MaxHealth;\n        public float Stamina;\n        public float MaxStamina;\n        public float Chakra;\n        public float MaxChakra;\n        public float Hunger;       // 0-100, 0 = starving\n        public float MaxHunger;    // Always 100 for simplicity\n        public float Thirst;       // 0-100, 0 = dehydrated\n        public float MaxThirst;    // Always 100 for simplicity\n        public float BodyTemp;     // Celsius (e.g., 37.0 = normal, lower/higher causes penalties)\n        public float NormalBodyTemp; // Reference normal temp for this entity\n\n        public BioState(float maxHealth, float maxStamina, float maxChakra, float normalBodyTemp = 37.0f)\n        {\n            MaxHealth = maxHealth;\n            Health = maxHealth;\n            MaxStamina = maxStamina;\n            Stamina = maxStamina;\n            MaxChakra = maxChakra;\n            Chakra = maxChakra;\n            MaxHunger = 100f;\n            Hunger = MaxHunger; // Start full\n            MaxThirst = 100f;\n            Thirst = MaxThirst; // Start full\n            NormalBodyTemp = normalBodyTemp;\n            BodyTemp = normalBodyTemp;\n        }\n\n        public override string ToString()\n        {\n            return $\"HP: {Health}/{MaxHealth}, Sta: {Stamina}/{MaxStamina}, Cha: {Chakra}/{MaxChakra}, Hunger: {Hunger:F0}, Thirst: {Thirst:F0}, Temp: {BodyTemp:F1}\u00b0C\";\n        }\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#3-implementing-biologicalsystemcs-with-the-bio-tick","title":"3. Implementing <code>BiologicalSystem.cs</code> with the Bio-Tick","text":"<p>This system will manage <code>BioState</code> for all entities that possess it (player, NPCs, animals) and apply updates on its own tick.</p> <ol> <li>Create <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics; // For potential physics interactions\nusing Sigilborne.Systems.Movement; // For activity level\n\nnamespace Sigilborne.Systems.Biology\n{\n    /// &lt;summary&gt;\n    /// Manages the biological simulation for entities (player, NPCs, animals).\n    /// Updates stats like hunger, thirst, and body temperature on a slower Bio-Tick.\n    /// (TDD 03.2)\n    /// &lt;/summary&gt;\n    public class BiologicalSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem; // To get entity positions for environmental effects\n        private MovementSystem _movementSystem;   // To determine activity level\n\n        // Dictionary to store BioState for all entities that have one.\n        private Dictionary&lt;EntityID, BioState&gt; _bioStates = new Dictionary&lt;EntityID, BioState&gt;();\n\n        // TDD 03.2: The Bio-Tick\n        private const float BIO_TICK_RATE = 1.0f; // 1.0f = once per real second (1Hz)\n        private float _bioTickTimer;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n\n            // Subscribe to entity lifecycle events to manage BioStates\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add BioState to living entities (Player, NPC, Animal)\n            if (type == EntityType.Player || type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // For player, initial stats are handled by PlayerStatSystem.\n                // For NPCs/Animals, we'd load from definitionID (e.g., \"goblin_grunt\" has 50HP, 20Chakra).\n                // For now, let's give generic stats. PlayerStatSystem will override for player.\n                _bioStates.Add(id, new BioState(100f, 75f, 50f));\n                GD.Print($\"BiologicalSystem: Added BioState for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityID id)\n        {\n            _bioStates.Remove(id);\n            GD.Print($\"BiologicalSystem: Removed BioState for {id}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the BiologicalSystem.\n        /// Manages the Bio-Tick.\n        /// (TDD 03.2)\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _bioTickTimer += (float)delta;\n            if (_bioTickTimer &gt;= BIO_TICK_RATE)\n            {\n                ProcessBioTick();\n                _bioTickTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Processes a single Bio-Tick for all entities with BioState.\n        /// (TDD 03.2)\n        /// &lt;/summary&gt;\n        private void ProcessBioTick()\n        {\n            // GD.Print($\"BiologicalSystem: Processing Bio-Tick (Game Time: {GameManager.Instance.Time.CurrentGameTime:F1})\");\n\n            foreach (var kvp in _bioStates)\n            {\n                EntityID id = kvp.Key;\n                ref BioState bioState = ref _bioStates.GetValueRef(id); // Get mutable ref\n\n                if (!_entityManager.IsValid(id)) continue; // Ensure entity is still valid\n\n                // --- Metabolism System (TDD 03.2) ---\n                float activityMultiplier = GetActivityLevel(id); // 1x Idle, 2x Running, 5x Combat\n                float weatherMultiplier = 1.0f; // Placeholder for weather effects (TDD 03.3)\n\n                // Hunger decay\n                bioState.Hunger -= 1.0f * activityMultiplier * weatherMultiplier; // Base decay of 1 per tick\n                bioState.Hunger = Mathf.Max(0, bioState.Hunger); // Clamp at 0\n\n                // Thirst decay\n                bioState.Thirst -= 1.5f * activityMultiplier * weatherMultiplier; // Thirst decays faster\n                bioState.Thirst = Mathf.Max(0, bioState.Thirst); // Clamp at 0\n\n                // Body temperature (placeholder for environmental effects)\n                // bioState.BodyTemp = AdjustBodyTemperature(id, bioState.BodyTemp, activityMultiplier, weatherMultiplier);\n\n                // --- Apply consequences of low stats (GDD B14.4) ---\n                if (bioState.Hunger &lt;= 0)\n                {\n                    // GD.Print($\"BiologicalSystem: {id} is starving!\");\n                    // _eventBus.Publish(new EntityStarvingEvent { EntityID = id });\n                    // Apply health damage or stat penalties here.\n                }\n                if (bioState.Thirst &lt;= 0)\n                {\n                    // GD.Print($\"BiologicalSystem: {id} is dehydrated!\");\n                    // _eventBus.Publish(new EntityDehydratedEvent { EntityID = id });\n                    // Apply health damage or stat penalties here.\n                }\n\n                // Publish updates for the Body (e.g., UI for player, visual cues for NPCs)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerBioStateChangedEvent { PlayerID = id, NewBioState = bioState });\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Determines the activity level of an entity for metabolism calculations.\n        /// (TDD 03.2)\n        /// &lt;/summary&gt;\n        private float GetActivityLevel(EntityID id)\n        {\n            // For now, only player has a MovementSystem.\n            if (id == _entityManager.GetPlayerEntityID())\n            {\n                // Access player's velocity from MovementSystem (if it stored it, or from TransformSystem)\n                // For simplicity, let's assume a \"moving\" state based on velocity magnitude.\n                if (_movementSystem.GetVelocity(id).LengthSquared() &gt; 1.0f) // If moving significantly\n                {\n                    return 2.0f; // 2x decay for running\n                }\n            }\n            return 1.0f; // Default 1x decay for idle/NPCs\n        }\n\n        /// &lt;summary&gt;\n        /// Provides a mutable reference to an entity's BioState.\n        /// Other systems (e.g., PlayerStatSystem, CombatSystem) can modify health, stamina, chakra.\n        /// &lt;/summary&gt;\n        public ref BioState GetBioStateRef(EntityID id)\n        {\n            if (!_entityManager.IsValid(id) || !_bioStates.ContainsKey(id))\n            {\n                throw new InvalidOperationException($\"Entity {id} is invalid or does not have a BioState.\");\n            }\n            return ref _bioStates.GetValueRef(id);\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerBioStateChangedEvent { public EntityID PlayerID; public BioState NewBioState; }\n        // public struct EntityStarvingEvent { public EntityID EntityID; } // Example\n        // public struct EntityDehydratedEvent { public EntityID EntityID; } // Example\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#31-update-movementsystemcs-to-expose-getvelocity","title":"3.1. Update <code>MovementSystem.cs</code> to expose <code>GetVelocity</code>","text":"<p>The <code>BiologicalSystem</code> needs to query the player's velocity.</p> <p>Open <code>res://_Brain/Systems/Movement/MovementSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Movement/MovementSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Input;\n\nnamespace Sigilborne.Systems.Movement\n{\n    // ... (existing structs) ...\n\n    public class MovementSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        public void Tick(double delta) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Retrieves the current velocity of an entity.\n        /// &lt;/summary&gt;\n        public Vector2 GetVelocity(EntityID id)\n        {\n            if (_velocities.TryGetValue(id, out VelocityComponent vel))\n            {\n                return vel.Velocity;\n            }\n            return Vector2.Zero;\n        }\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#4-integrating-biologicalsystem-into-gamemanager","title":"4. Integrating <code>BiologicalSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Biology;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>BiologicalSystem</code> property.</li> <li>Initialize <code>BiologicalSystem</code> in <code>InitializeSystems()</code>.</li> <li>Call <code>BiologicalSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PlayerStatSystem PlayerStats { get; private set; }\n    public BiologicalSystem Biology { get; private set; } // Add BiologicalSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Biology.Tick(delta); // Call BiologicalSystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to PlayerStatSystem) ...\n\n        DebugCommands = new DebugCommandSystem(this);\n        GD.Print(\"  - DebugCommandSystem initialized.\");\n\n        Input = new InputSystem();\n        GD.Print(\"  - InputSystem initialized.\");\n\n        Movement = new MovementSystem(Entities, Input, Events, Transforms);\n        GD.Print(\"  - MovementSystem initialized.\");\n\n        Physics = new PhysicsSystem(Entities, Transforms, Events);\n        GD.Print(\"  - PhysicsSystem initialized.\");\n\n        int currentWorldSeed = 12345;\n        int numGlyphsForWorld = 10;\n        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);\n        GD.Print(\"  - WorldGlyphMap initialized.\");\n\n        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);\n        GD.Print(\"  - PlayerGlyphKnowledgeSystem initialized.\");\n\n        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);\n        GD.Print(\"  - PlayerHotbarSystem initialized.\");\n\n        ComboResolver = new ComboResolver();\n        GD.Print(\"  - ComboResolver initialized.\");\n\n        Casting = new CastingSystem(Entities, Events, PlayerStats, Transforms);\n        GD.Print(\"  - CastingSystem initialized.\");\n\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver, Casting);\n        GD.Print(\"  - MagicSystem initialized.\");\n\n        // Initialize BiologicalSystem AFTER PlayerStatSystem (as PlayerStatSystem sets initial player health)\n        Biology = new BiologicalSystem(Entities, Events, Transforms, Movement); // Initialize BiologicalSystem here\n        GD.Print(\"  - BiologicalSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#41-update-playerstatsystemcs-to-use-biologicalsystem","title":"4.1. Update <code>PlayerStatSystem.cs</code> to use <code>BiologicalSystem</code>","text":"<p>The <code>PlayerStatSystem</code> currently manages <code>PlayerStats</code> directly. It should now delegate to <code>BiologicalSystem</code>'s <code>GetBioStateRef</code> for core stats like health, stamina, chakra. This makes <code>BiologicalSystem</code> the single source of truth for these stats.</p> <p>Open <code>res://_Brain/Systems/Biology/PlayerStatSystem.cs</code> and modify it:</p> <pre><code>// _Brain/Systems/Biology/PlayerStatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Biology\n{\n    // ... (PlayerStats struct) ...\n\n    public class PlayerStatSystem\n    {\n        private EventBus _eventBus;\n        private EntityManager _entityManager;\n        private BiologicalSystem _biologicalSystem; // New: Reference to BiologicalSystem\n\n        private EntityID _playerEntityID; // Store player ID directly\n\n        public PlayerStatSystem(EventBus eventBus, EntityManager entityManager, BiologicalSystem biologicalSystem) // Add BiologicalSystem\n        {\n            _eventBus = eventBus;\n            _entityManager = entityManager;\n            _biologicalSystem = biologicalSystem; // Store BiologicalSystem reference\n\n            _playerEntityID = _entityManager.GetPlayerEntityID(); // Get player ID once\n\n            GD.Print(\"PlayerStatSystem: Initialized.\");\n\n            // PlayerStatSystem no longer needs to listen to OnEntitySpawned to initialize BioState,\n            // as BiologicalSystem handles that. It just needs to get a reference to the player's BioState.\n            // We'll initialize it in _Ready() or a later method.\n            // For now, ensure player's BioState is created by BiologicalSystem before this is called.\n\n            // Publish initial player stats from BiologicalSystem's BioState\n            ref BioState playerBioState = ref _biologicalSystem.GetBioStateRef(_playerEntityID);\n            _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = _playerEntityID, NewHealth = playerBioState.Health, MaxHealth = playerBioState.MaxHealth });\n            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerEntityID, NewChakra = playerBioState.Chakra, MaxChakra = playerBioState.MaxChakra });\n            // Add Stamina changed event as well\n            _eventBus.Publish(new PlayerStaminaChangedEvent { PlayerID = _playerEntityID, NewStamina = playerBioState.Stamina, MaxStamina = playerBioState.MaxStamina });\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a copy of the player's current stats from the BiologicalSystem.\n        /// &lt;/summary&gt;\n        public PlayerStats GetPlayerStats()\n        {\n            // Construct PlayerStats from BiologicalSystem's authoritative BioState\n            ref BioState bioState = ref _biologicalSystem.GetBioStateRef(_playerEntityID);\n            return new PlayerStats(_playerEntityID, bioState.MaxHealth, bioState.MaxChakra, bioState.MaxStamina)\n            {\n                Health = bioState.Health,\n                Chakra = bioState.Chakra,\n                Stamina = bioState.Stamina\n            };\n        }\n\n        public void TakeDamage(float amount)\n        {\n            ref BioState playerBioState = ref _biologicalSystem.GetBioStateRef(_playerEntityID);\n            if (playerBioState.Health &lt;= 0) return;\n\n            playerBioState.Health -= amount;\n            if (playerBioState.Health &lt; 0) playerBioState.Health = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} took {amount} damage. New Health: {playerBioState.Health}\");\n            _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = _playerEntityID, NewHealth = playerBioState.Health, MaxHealth = playerBioState.MaxHealth });\n\n            if (playerBioState.Health == 0)\n            {\n                GD.Print($\"PlayerStatSystem: Player {_playerEntityID} has died!\");\n                _eventBus.Publish(new PlayerDiedEvent { PlayerID = _playerEntityID });\n            }\n        }\n\n        public void TakeChakra(float amount)\n        {\n            ref BioState playerBioState = ref _biologicalSystem.GetBioStateRef(_playerEntityID);\n            if (amount &lt; 0) return;\n\n            playerBioState.Chakra -= amount;\n            if (playerBioState.Chakra &lt; 0) playerBioState.Chakra = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} used {amount} chakra. New Chakra: {playerBioState.Chakra}\");\n            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerEntityID, NewChakra = playerBioState.Chakra, MaxChakra = playerBioState.MaxChakra });\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerHealthChangedEvent { public EntityID PlayerID; public float NewHealth; public float MaxHealth; }\n        public struct PlayerDiedEvent { public EntityID PlayerID; }\n        public struct PlayerChakraChangedEvent { public EntityID PlayerID; public float NewChakra; public float MaxChakra; }\n        public struct PlayerStaminaChangedEvent { public EntityID PlayerID; public float NewStamina; public float MaxStamina; } // New event\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#42-update-eventbuscs-for-playerstaminachangedevent","title":"4.2. Update <code>EventBus.cs</code> for PlayerStaminaChangedEvent","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnPlayerStaminaChanged</code> delegate:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Player Stat Events (TDD 01.4) - updated with Stamina\n        public event Action&lt;EntityID, float, float&gt; OnPlayerHealthChanged;\n        public event Action&lt;EntityID&gt; OnPlayerDied;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerChakraChanged;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerStaminaChanged; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerStatSystem.PlayerChakraChangedEvent chakraEvent)\n            {\n                OnPlayerChakraChanged?.Invoke(chakraEvent.PlayerID, chakraEvent.NewChakra, chakraEvent.MaxChakra);\n            }\n            else if (eventData is PlayerStatSystem.PlayerStaminaChangedEvent staminaEvent) // New condition\n            {\n                OnPlayerStaminaChanged?.Invoke(staminaEvent.PlayerID, staminaEvent.NewStamina, staminaEvent.MaxStamina);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#5-displaying-player-biostate-in-the-body-gdscript-ui","title":"5. Displaying Player BioState in the Body (GDScript UI)","text":"<p>Let's update our <code>HUDController.gd</code> to display Chakra, Stamina, Hunger, and Thirst.</p> <p>Open <code>res://_Body/Scenes/UI/HUD.tscn</code> and modify it:</p> <ul> <li>Add <code>Label</code> nodes for Chakra, Stamina, Hunger, Thirst.</li> <li>Arrange them (e.g., in <code>VBoxContainer</code> or <code>HBoxContainer</code>).</li> <li>Example:     <code>HUD (CanvasLayer)     \u2514\u2500\u2500 MainHBox (HBoxContainer)         \u251c\u2500\u2500 VBoxStats (VBoxContainer)         \u2502   \u251c\u2500\u2500 HealthLabel (Label)         \u2502   \u251c\u2500\u2500 ChakraLabel (Label)         \u2502   \u251c\u2500\u2500 StaminaLabel (Label)         \u2514\u2500\u2500 VBoxNeeds (VBoxContainer)             \u251c\u2500\u2500 HungerLabel (Label)             \u2514\u2500\u2500 ThirstLabel (Label)</code></li> </ul> <p>Open <code>res://_Body/Scripts/UI/HUDController.gd</code> and modify it:</p> <pre><code># _Body/Scripts/UI/HUDController.gd\nclass_name HUDController extends CanvasLayer\n\n@onready var health_label: Label = $MainHBox/VBoxStats/HealthLabel\n@onready var chakra_label: Label = $MainHBox/VBoxStats/ChakraLabel # New\n@onready var stamina_label: Label = $MainHBox/VBoxStats/StaminaLabel # New\n@onready var hunger_label: Label = $MainHBox/VBoxNeeds/HungerLabel # New\n@onready var thirst_label: Label = $MainHBox/VBoxNeeds/ThirstLabel # New\n\nvar player_entity_id: int = -1\n\nfunc _ready():\n    GD.print(\"HUDController: Initialized. Connecting to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnPlayerHealthChanged.connect(Callable(self, \"_on_player_health_changed\"))\n        GameManager.Instance.Events.OnPlayerChakraChanged.connect(Callable(self, \"_on_player_chakra_changed\")) # New\n        GameManager.Instance.Events.OnPlayerStaminaChanged.connect(Callable(self, \"_on_player_stamina_changed\")) # New\n        GameManager.Instance.Events.OnPlayerBioStateChanged.connect(Callable(self, \"_on_player_bio_state_changed\")) # New\n        GameManager.Instance.Events.OnPlayerDied.connect(Callable(self, \"_on_player_died\"))\n        GameManager.Instance.Events.OnEntitySpawned.connect(Callable(self, \"_on_entity_spawned\"))\n        GD.print(\"HUDController: Successfully connected to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    else:\n        push_error(\"HUDController: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if type == 0: # EntityType.Player has value 0\n        player_entity_id = id\n        GD.print(\"HUDController: Detected player entity with ID: %s\" % player_entity_id)\n\nfunc _on_player_health_changed(id: int, new_health: float, max_health: float) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"HP: %s/%s\" % [int(new_health), int(max_health)]\n\nfunc _on_player_chakra_changed(id: int, new_chakra: float, max_chakra: float) -&gt; void: # New\n    if id == player_entity_id:\n        chakra_label.text = \"CHA: %s/%s\" % [int(new_chakra), int(max_chakra)]\n\nfunc _on_player_stamina_changed(id: int, new_stamina: float, max_stamina: float) -&gt; void: # New\n    if id == player_entity_id:\n        stamina_label.text = \"STA: %s/%s\" % [int(new_stamina), int(max_stamina)]\n\n## Handler for C# PlayerBioStateChangedEvent (for Hunger, Thirst, Temp)\nfunc _on_player_bio_state_changed(id: int, new_bio_state: Variant) -&gt; void: # Variant to receive C# struct\n    if id == player_entity_id:\n        # Access fields of the BioState struct (marshaled as a Dictionary or similar)\n        # Godot's C# binding usually marshals structs as Dictionaries in GDScript.\n        hunger_label.text = \"HUN: %s\" % int(new_bio_state.Hunger)\n        thirst_label.text = \"THI: %s\" % int(new_bio_state.Thirst)\n        # You can add BodyTemp here too if you display it\n        # GD.print(\"HUDController: Player %s BioState Updated: %s\" % [id, new_bio_state])\n\nfunc _on_player_died(id: int) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"HP: DEAD\"\n        chakra_label.text = \"CHA: DEAD\"\n        stamina_label.text = \"STA: DEAD\"\n        hunger_label.text = \"HUN: DEAD\"\n        thirst_label.text = \"THI: DEAD\"\n        GD.print(\"HUDController: Player %s has died visually!\" % id)\n</code></pre>"},{"location":"30-chapter-30/#51-update-eventbuscs-for-playerbiostatechangedevent","title":"5.1. Update <code>EventBus.cs</code> for PlayerBioStateChangedEvent","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnPlayerBioStateChanged</code> delegate:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Biological System Events (TDD 03.2)\n        public event Action&lt;EntityID, BioState&gt; OnPlayerBioStateChanged; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is BiologicalSystem.PlayerBioStateChangedEvent bioStateEvent) // New condition\n            {\n                OnPlayerBioStateChanged?.Invoke(bioStateEvent.PlayerID, bioStateEvent.NewBioState);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"30-chapter-30/#6-testing-the-bio-tick-and-ui-updates","title":"6. Testing the Bio-Tick and UI Updates","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the new UI elements for Hunger and Thirst.</li> <li>Wait for a few seconds. You should see Hunger and Thirst values slowly decreasing, and the UI updating every second (our <code>BIO_TICK_RATE</code>).</li> <li>Move the player (WASD). You should see Hunger and Thirst decrease faster due to increased <code>activityMultiplier</code>.</li> <li>Cast a spell (e.g., <code>0</code> then <code>1</code>). You should see Chakra decrease.</li> </ol> <p>This confirms that: *   The C# <code>BiologicalSystem</code> is ticking independently at 1Hz. *   Hunger and Thirst are decaying based on <code>activityMultiplier</code>. *   The GDScript <code>HUDController</code> is correctly listening to <code>OnPlayerBioStateChanged</code> and <code>OnPlayerChakraChanged</code> events and updating the UI.</p>"},{"location":"30-chapter-30/#summary","title":"Summary","text":"<p>You have successfully implemented the Bio-Tick system in the C# Brain, establishing a dedicated, slower update loop for managing biological stats like hunger, thirst, and body temperature. By designing <code>BioState</code> and creating <code>BiologicalSystem</code> to manage these stats and apply metabolism rules, you've created an efficient simulation layer. Furthermore, by updating <code>PlayerStatSystem</code> to delegate core stat management to <code>BiologicalSystem</code> and enhancing <code>HUDController.gd</code> to reactively display these stats, you've ensured accurate and performant biological simulation, strictly adhering to TDD 03.2's specifications.</p>"},{"location":"30-chapter-30/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Core Stats (Struct), further defining the complete set of biological and combat-related stats for entities, and how they are managed and accessed across various systems.</p>"},{"location":"31-chapter-31/","title":"Chapter 5.2: Core Stats (Struct)","text":""},{"location":"31-chapter-31/#chapter-52-core-stats-struct","title":"Chapter 5.2: Core Stats (Struct)","text":"<p>In Sigilborne, every living entity (player, NPC, animal) possesses a set of fundamental statistics that define its capabilities and well-being. This chapter focuses on thoroughly defining the Core Stats struct, building upon our existing <code>BioState</code> and <code>PlayerStats</code> concepts. This will centralize stat management, making it efficient to access and modify these values across various systems in the C# Brain, as specified in TDD 03.2.</p>"},{"location":"31-chapter-31/#1-the-need-for-a-unified-core-stats-definition","title":"1. The Need for a Unified Core Stats Definition","text":"<p>We currently have <code>BioState</code> (for hunger, thirst, temp) and <code>PlayerStats</code> (for health, chakra, stamina). While <code>BioState</code> is authoritative for biological needs, <code>PlayerStats</code> is a bit redundant now that <code>BiologicalSystem</code> is the source of truth for the player's core combat stats.</p> <p>A single, comprehensive <code>CoreStats</code> struct will:</p> <ul> <li>Centralize Data: All critical stats in one place.</li> <li>Efficiency: <code>struct</code> for value semantics and cache-friendliness.</li> <li>Clarity: Clear definition of an entity's capabilities.</li> <li>Flexibility: Easily extendable for new stats.</li> </ul>"},{"location":"31-chapter-31/#2-defining-corestatscs","title":"2. Defining <code>CoreStats.cs</code>","text":"<p>This <code>CoreStats</code> struct will replace the role of <code>PlayerStats</code> and be the primary stat container within <code>BiologicalSystem</code> for all entities.</p> <ol> <li>Create <code>res://_Brain/Systems/Biology/CoreStats.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Biology/CoreStats.cs\nusing System;\nusing Godot; // For Vector2 if needed\n\nnamespace Sigilborne.Systems.Biology\n{\n    /// &lt;summary&gt;\n    /// Stores the core statistics for any entity that has biological or combat capabilities.\n    /// This struct serves as the comprehensive stat container for entities.\n    /// (TDD 03.2 - Expanding on BioState concept)\n    /// &lt;/summary&gt;\n    public struct CoreStats\n    {\n        // --- Core Survival/Biological Stats (from BioState) ---\n        public float Health;\n        public float MaxHealth;\n        public float Stamina;\n        public float MaxStamina;\n        public float Chakra;\n        public float MaxChakra;\n        public float Hunger;       // 0-100, 0 = starving\n        public float MaxHunger;    // Always 100 for simplicity\n        public float Thirst;       // 0-100, 0 = dehydrated\n        public float MaxThirst;    // Always 100 for simplicity\n        public float BodyTemp;     // Celsius\n        public float NormalBodyTemp; // Reference normal temp for this entity\n\n        // --- Combat/Magic-related Stats (new or consolidated) ---\n        public float BaseDamage;       // Base physical damage for attacks\n        public float AttackSpeed;      // How fast an entity attacks\n        public float Armor;            // Physical damage reduction\n        public float MagicResistance;  // Magical damage reduction\n        public float MoveSpeed;        // Base movement speed\n        public float SprintMultiplier; // Multiplier for sprint speed\n        public float CastSpeed;        // Multiplier for spell cast time (lower = faster)\n        public float Stability;        // Current Chakra Stability (0-100) (GDD B03.6)\n        public float MaxStability;     // Max Chakra Stability (e.g., 100)\n        public float StabilityRegenRate; // How fast stability recovers\n        public float ChakraRegenRate;  // How fast chakra recovers\n        public float StaminaRegenRate; // How fast stamina recovers\n\n        public CoreStats(float maxHealth, float maxStamina, float maxChakra, float baseDamage = 10f, float attackSpeed = 1.0f,\n                         float armor = 0f, float magicResistance = 0f, float moveSpeed = 150f, float sprintMultiplier = 1.5f,\n                         float castSpeed = 1.0f, float maxStability = 100f, float stabilityRegenRate = 5f,\n                         float chakraRegenRate = 2f, float staminaRegenRate = 10f, float normalBodyTemp = 37.0f)\n        {\n            MaxHealth = maxHealth;\n            Health = maxHealth;\n            MaxStamina = maxStamina;\n            Stamina = maxStamina;\n            MaxChakra = maxChakra;\n            Chakra = maxChakra;\n            MaxHunger = 100f;\n            Hunger = MaxHunger;\n            MaxThirst = 100f;\n            Thirst = MaxThirst;\n            NormalBodyTemp = normalBodyTemp;\n            BodyTemp = normalBodyTemp;\n\n            BaseDamage = baseDamage;\n            AttackSpeed = attackSpeed;\n            Armor = armor;\n            MagicResistance = magicResistance;\n            MoveSpeed = moveSpeed;\n            SprintMultiplier = sprintMultiplier;\n            CastSpeed = castSpeed;\n            MaxStability = maxStability;\n            Stability = MaxStability; // Start full\n            StabilityRegenRate = stabilityRegenRate;\n            ChakraRegenRate = chakraRegenRate;\n            StaminaRegenRate = staminaRegenRate;\n        }\n\n        public override string ToString()\n        {\n            return $\"HP: {Health:F0}/{MaxHealth:F0}, Sta: {Stamina:F0}/{MaxStamina:F0}, Cha: {Chakra:F0}/{MaxChakra:F0}, Stab: {Stability:F0}/{MaxStability:F0}, Hunger: {Hunger:F0}, Thirst: {Thirst:F0}, Temp: {BodyTemp:F1}\u00b0C, Spd: {MoveSpeed:F0}\";\n        }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#3-refactoring-biologicalsystemcs-to-use-corestats","title":"3. Refactoring <code>BiologicalSystem.cs</code> to use <code>CoreStats</code>","text":"<p>The <code>BiologicalSystem</code> will now store <code>CoreStats</code> for each entity instead of <code>BioState</code>. This means <code>PlayerStatSystem</code> will also directly interact with <code>CoreStats</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>.</li> <li>Replace <code>private Dictionary&lt;EntityID, BioState&gt; _bioStates = new Dictionary&lt;EntityID, BioState&gt;();</code> with:     <code>private Dictionary&lt;EntityID, CoreStats&gt; _entityCoreStats = new Dictionary&lt;EntityID, CoreStats&gt;();</code></li> <li>Modify <code>OnEntitySpawned</code> to add <code>CoreStats</code> instances.</li> <li>Modify <code>OnEntityDespawned</code> to remove <code>CoreStats</code> instances.</li> <li>Update <code>ProcessBioTick</code> to operate on <code>CoreStats</code> and include regeneration logic for Health, Stamina, Chakra, and Stability.</li> <li>Update <code>GetBioStateRef</code> to <code>GetCoreStatsRef</code>.</li> <li>Update <code>PlayerBioStateChangedEvent</code> to <code>PlayerCoreStatsChangedEvent</code> and pass <code>CoreStats</code>.</li> </ol> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic; // For GlyphConcept if environmental resonance affects regen\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem;\n        private MovementSystem _movementSystem;\n\n        // Dictionary to store CoreStats for all entities that have one.\n        private Dictionary&lt;EntityID, CoreStats&gt; _entityCoreStats = new Dictionary&lt;EntityID, CoreStats&gt;(); // Changed from _bioStates\n\n        private const float BIO_TICK_RATE = 1.0f; // 1.0f = once per real second (1Hz)\n        private float _bioTickTimer;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player || type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // Initialize CoreStats (TDD 03.2)\n                // For player, PlayerStatSystem will further initialize/override this.\n                // For NPCs/Animals, load from definitionID (e.g., \"goblin_grunt\" has specific stats).\n                // For now, let's give generic stats.\n                _entityCoreStats.Add(id, new CoreStats(100f, 75f, 50f)); // HP, Stamina, Chakra\n                GD.Print($\"BiologicalSystem: Added CoreStats for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityID id)\n        {\n            _entityCoreStats.Remove(id); // Changed from _bioStates\n            GD.Print($\"BiologicalSystem: Removed CoreStats for {id}.\");\n        }\n\n        public void Tick(double delta)\n        {\n            _bioTickTimer += (float)delta;\n            if (_bioTickTimer &gt;= BIO_TICK_RATE)\n            {\n                ProcessBioTick();\n                _bioTickTimer = 0;\n            }\n        }\n\n        private void ProcessBioTick()\n        {\n            // GD.Print($\"BiologicalSystem: Processing Bio-Tick (Game Time: {GameManager.Instance.Time.CurrentGameTime:F1})\");\n\n            foreach (var kvp in _entityCoreStats) // Changed from _bioStates\n            {\n                EntityID id = kvp.Key;\n                ref CoreStats coreStats = ref _entityCoreStats.GetValueRef(id); // Get mutable ref\n\n                if (!_entityManager.IsValid(id)) continue;\n\n                float activityMultiplier = GetActivityLevel(id);\n                float weatherMultiplier = 1.0f;\n\n                // --- Hunger and Thirst Decay ---\n                coreStats.Hunger -= 1.0f * activityMultiplier * weatherMultiplier;\n                coreStats.Hunger = Mathf.Max(0, coreStats.Hunger);\n\n                coreStats.Thirst -= 1.5f * activityMultiplier * weatherMultiplier;\n                coreStats.Thirst = Mathf.Max(0, coreStats.Thirst);\n\n                // --- Regeneration (Health, Stamina, Chakra, Stability) (GDD B03.4, B03.6) ---\n                // Health Regen (only if not starving/dehydrated, and not in combat)\n                if (coreStats.Hunger &gt; 10 &amp;&amp; coreStats.Thirst &gt; 10 &amp;&amp; coreStats.Health &lt; coreStats.MaxHealth)\n                {\n                    coreStats.Health += coreStats.HealthRegenRate * BIO_TICK_RATE;\n                    coreStats.Health = Mathf.Min(coreStats.MaxHealth, coreStats.Health);\n                }\n\n                // Stamina Regen\n                if (coreStats.Stamina &lt; coreStats.MaxStamina)\n                {\n                    coreStats.Stamina += coreStats.StaminaRegenRate * BIO_TICK_RATE;\n                    coreStats.Stamina = Mathf.Min(coreStats.MaxStamina, coreStats.Stamina);\n                }\n\n                // Chakra Regen\n                if (coreStats.Chakra &lt; coreStats.MaxChakra)\n                {\n                    coreStats.Chakra += coreStats.ChakraRegenRate * BIO_TICK_RATE;\n                    coreStats.Chakra = Mathf.Min(coreStats.MaxChakra, coreStats.Chakra);\n                }\n\n                // Stability Regen (GDD B03.6)\n                if (coreStats.Stability &lt; coreStats.MaxStability)\n                {\n                    coreStats.Stability += coreStats.StabilityRegenRate * BIO_TICK_RATE;\n                    coreStats.Stability = Mathf.Min(coreStats.MaxStability, coreStats.Stability);\n                }\n\n                // --- Apply consequences of low stats (GDD B14.4) ---\n                if (coreStats.Hunger &lt;= 0) { /* GD.Print($\"BiologicalSystem: {id} is starving!\"); */ }\n                if (coreStats.Thirst &lt;= 0) { /* GD.Print($\"BiologicalSystem: {id} is dehydrated!\"); */ }\n\n                // Publish updates for the Body (e.g., UI for player)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerCoreStatsChangedEvent { PlayerID = id, NewCoreStats = coreStats }); // Changed event\n                }\n            }\n        }\n\n        public float GetActivityLevel(EntityID id) { /* ... */ return 1.0f; }\n\n        /// &lt;summary&gt;\n        /// Provides a mutable reference to an entity's CoreStats.\n        /// Other systems (e.g., PlayerStatSystem, CombatSystem) can modify these.\n        /// &lt;/summary&gt;\n        public ref CoreStats GetCoreStatsRef(EntityID id) // Changed from GetBioStateRef\n        {\n            if (!_entityManager.IsValid(id) || !_entityCoreStats.ContainsKey(id)) // Changed from _bioStates\n            {\n                throw new InvalidOperationException($\"Entity {id} is invalid or does not have CoreStats.\");\n            }\n            return ref _entityCoreStats.GetValueRef(id); // Changed from _bioStates\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerCoreStatsChangedEvent { public EntityID PlayerID; public CoreStats NewCoreStats; } // Changed event\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#4-refactoring-playerstatsystemcs-to-use-biologicalsystems-corestats","title":"4. Refactoring <code>PlayerStatSystem.cs</code> to use <code>BiologicalSystem</code>'s <code>CoreStats</code>","text":"<p>The <code>PlayerStatSystem</code> no longer needs its own <code>PlayerStats</code> struct. It will directly access and modify the player's <code>CoreStats</code> via <code>BiologicalSystem</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Biology/PlayerStatSystem.cs</code>.</li> <li>Remove the <code>PlayerStats</code> struct definition.</li> <li>Modify the <code>PlayerStatSystem</code> class to interact with <code>BiologicalSystem</code>'s <code>CoreStats</code> directly.</li> <li>Remove <code>OnEntitySpawned</code> logic, as <code>BiologicalSystem</code> handles initial <code>CoreStats</code> creation.</li> <li>Update <code>GetPlayerStats</code>, <code>TakeDamage</code>, <code>TakeChakra</code> to use <code>_biologicalSystem.GetCoreStatsRef()</code>.</li> <li>Add <code>TakeStamina</code> method.</li> <li>Update event structs to pass individual float values, as <code>CoreStats</code> is too large for frequent full struct passing.</li> </ol> <pre><code>// _Brain/Systems/Biology/PlayerStatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Biology\n{\n    // Removed PlayerStats struct definition.\n\n    public class PlayerStatSystem\n    {\n        private EventBus _eventBus;\n        private EntityManager _entityManager;\n        private BiologicalSystem _biologicalSystem;\n\n        private EntityID _playerEntityID;\n\n        public PlayerStatSystem(EventBus eventBus, EntityManager entityManager, BiologicalSystem biologicalSystem)\n        {\n            _eventBus = eventBus;\n            _entityManager = entityManager;\n            _biologicalSystem = biologicalSystem;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n\n            GD.Print(\"PlayerStatSystem: Initialized.\");\n\n            // Publish initial player stats from BiologicalSystem's CoreStats\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Health, MaxValue = playerCoreStats.MaxHealth });\n            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Chakra, MaxValue = playerCoreStats.MaxChakra });\n            _eventBus.Publish(new PlayerStaminaChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Stamina, MaxValue = playerCoreStats.MaxStamina });\n            _eventBus.Publish(new PlayerStabilityChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Stability, MaxValue = playerCoreStats.MaxStability }); // New event\n        }\n\n        // Removed GetPlayerStats(), as systems should access CoreStats via BiologicalSystem directly or use events.\n\n        public void TakeDamage(float amount)\n        {\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            if (playerCoreStats.Health &lt;= 0) return;\n\n            playerCoreStats.Health -= amount;\n            if (playerCoreStats.Health &lt; 0) playerCoreStats.Health = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} took {amount} damage. New Health: {playerCoreStats.Health}\");\n            _eventBus.Publish(new PlayerHealthChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Health, MaxValue = playerCoreStats.MaxHealth });\n\n            if (playerCoreStats.Health == 0)\n            {\n                GD.Print($\"PlayerStatSystem: Player {_playerEntityID} has died!\");\n                _eventBus.Publish(new PlayerDiedEvent { PlayerID = _playerEntityID });\n            }\n        }\n\n        public void TakeChakra(float amount)\n        {\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            if (amount &lt; 0) return;\n\n            playerCoreStats.Chakra -= amount;\n            if (playerCoreStats.Chakra &lt; 0) playerCoreStats.Chakra = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} used {amount} chakra. New Chakra: {playerCoreStats.Chakra}\");\n            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Chakra, MaxValue = playerCoreStats.MaxChakra });\n        }\n\n        /// &lt;summary&gt;\n        /// Authoritatively deducts stamina from the player.\n        /// &lt;/summary&gt;\n        public void TakeStamina(float amount) // New method\n        {\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            if (amount &lt; 0) return;\n\n            playerCoreStats.Stamina -= amount;\n            if (playerCoreStats.Stamina &lt; 0) playerCoreStats.Stamina = 0;\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} used {amount} stamina. New Stamina: {playerCoreStats.Stamina}\");\n            _eventBus.Publish(new PlayerStaminaChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Stamina, MaxValue = playerCoreStats.MaxStamina });\n        }\n\n        /// &lt;summary&gt;\n        /// Authoritatively deducts stability from the player.\n        /// (GDD B03.6)\n        /// &lt;/summary&gt;\n        public void TakeStability(float amount) // New method\n        {\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            if (amount &lt; 0) return;\n\n            playerCoreStats.Stability -= amount;\n            if (playerCoreStats.Stability &lt; 0) playerCoreStats.Stability = 0; // Stability can potentially go negative for chaos residue effects later.\n\n            GD.Print($\"PlayerStatSystem: Player {_playerEntityID} lost {amount} stability. New Stability: {playerCoreStats.Stability}\");\n            _eventBus.Publish(new PlayerStabilityChangedEvent { PlayerID = _playerEntityID, NewValue = playerCoreStats.Stability, MaxValue = playerCoreStats.MaxStability });\n        }\n\n\n        // --- Helper Events for Body Sync ---\n        // Changed event structs to pass NewValue and MaxValue for generic display.\n        public struct PlayerHealthChangedEvent { public EntityID PlayerID; public float NewValue; public float MaxValue; }\n        public struct PlayerChakraChangedEvent { public EntityID PlayerID; public float NewValue; public float MaxValue; }\n        public struct PlayerStaminaChangedEvent { public EntityID PlayerID; public float NewValue; public float MaxValue; }\n        public struct PlayerStabilityChangedEvent { public EntityID PlayerID; public float NewValue; public float MaxValue; } // New event\n        public struct PlayerDiedEvent { public EntityID PlayerID; }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#41-update-gamemanager-to-pass-biologicalsystem-to-playerstatsystem","title":"4.1. Update <code>GameManager</code> to Pass <code>BiologicalSystem</code> to <code>PlayerStatSystem</code>","text":"<p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the <code>PlayerStatSystem</code> initialization in <code>InitializeSystems()</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        BiologicalSystem = new BiologicalSystem(Entities, Events, Transforms, Movement);\n        GD.Print(\"  - BiologicalSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem); // Pass BiologicalSystem\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n// ...\n</code></pre>"},{"location":"31-chapter-31/#42-update-eventbuscs-for-new-playerstatsystem-events","title":"4.2. Update <code>EventBus.cs</code> for New PlayerStatSystem Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and modify/add delegates for <code>PlayerStatSystem</code>'s new event signatures.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Player Stat Events (TDD 01.4) - updated signatures\n        public event Action&lt;EntityID, float, float&gt; OnPlayerHealthChanged;\n        public event Action&lt;EntityID&gt; OnPlayerDied;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerChakraChanged;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerStaminaChanged;\n        public event Action&lt;EntityID, float, float&gt; OnPlayerStabilityChanged; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is PlayerStatSystem.PlayerHealthChangedEvent healthEvent) // Updated signature\n            {\n                OnPlayerHealthChanged?.Invoke(healthEvent.PlayerID, healthEvent.NewValue, healthEvent.MaxValue);\n            }\n            else if (eventData is PlayerStatSystem.PlayerChakraChangedEvent chakraEvent) // Updated signature\n            {\n                OnPlayerChakraChanged?.Invoke(chakraEvent.PlayerID, chakraEvent.NewValue, chakraEvent.MaxValue);\n            }\n            else if (eventData is PlayerStatSystem.PlayerStaminaChangedEvent staminaEvent) // Updated signature\n            {\n                OnPlayerStaminaChanged?.Invoke(staminaEvent.PlayerID, staminaEvent.NewValue, staminaEvent.MaxValue);\n            }\n            else if (eventData is PlayerStatSystem.PlayerStabilityChangedEvent stabilityEvent) // New condition\n            {\n                OnPlayerStabilityChanged?.Invoke(stabilityEvent.PlayerID, stabilityEvent.NewValue, stabilityEvent.MaxValue);\n            }\n            else if (eventData is BiologicalSystem.PlayerCoreStatsChangedEvent bioStateEvent) // Updated to CoreStats\n            {\n                // This event is now for the *full* CoreStats update, used for UI that displays all.\n                OnPlayerCoreStatsChanged?.Invoke(bioStateEvent.PlayerID, bioStateEvent.NewCoreStats);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#5-refactoring-movementsystemcs-for-corestats","title":"5. Refactoring <code>MovementSystem.cs</code> for <code>CoreStats</code>","text":"<p>The <code>MovementSystem</code> needs to get <code>MoveSpeed</code> and <code>SprintMultiplier</code> from <code>CoreStats</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Movement/MovementSystem.cs</code>.</li> <li>Remove the <code>MovementParametersComponent</code> struct definition.</li> <li>Remove <code>private Dictionary&lt;EntityID, MovementParametersComponent&gt; _movementParams</code>.</li> <li>Modify <code>OnEntitySpawned</code> to remove <code>_movementParams.Add()</code>.</li> <li>Update <code>Tick</code> to retrieve <code>MoveSpeed</code> and <code>SprintMultiplier</code> directly from <code>BiologicalSystem.GetCoreStatsRef(id)</code>.</li> </ol> <pre><code>// _Brain/Systems/Movement/MovementSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Biology; // Add this using directive\n\nnamespace Sigilborne.Systems.Movement\n{\n    // ... (VelocityComponent struct) ...\n    // Removed MovementParametersComponent struct definition.\n\n    public class MovementSystem\n    {\n        private EntityManager _entityManager;\n        private InputSystem _inputSystem;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem;\n        private BiologicalSystem _biologicalSystem; // New: Reference to BiologicalSystem\n\n        private Dictionary&lt;EntityID, VelocityComponent&gt; _velocities = new Dictionary&lt;EntityID, VelocityComponent&gt;();\n        // Removed _movementParams dictionary.\n        private Dictionary&lt;EntityID, PlayerMovementStateComponent&gt; _playerMovementStates = new Dictionary&lt;EntityID, PlayerMovementStateComponent&gt;();\n\n        public MovementSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus, TransformSystem transformSystem, BiologicalSystem biologicalSystem) // Add BiologicalSystem\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _biologicalSystem = biologicalSystem; // Store BiologicalSystem reference\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"MovementSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player)\n            {\n                _velocities.Add(id, new VelocityComponent(Vector2.Zero));\n                // MovementParametersComponent is no longer added here.\n                _playerMovementStates.Add(id, new PlayerMovementStateComponent());\n                GD.Print($\"MovementSystem: Added movement components for Player {id}\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityID id)\n        {\n            _velocities.Remove(id);\n            // Removed _movementParams.Remove(id);\n            _playerMovementStates.Remove(id);\n            GD.Print($\"MovementSystem: Removed movement components for {id}\");\n        }\n\n        public void Tick(double delta)\n        {\n            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();\n\n            foreach (var kvp in _velocities)\n            {\n                EntityID id = kvp.Key;\n\n                // Get CoreStats for movement parameters (TDD 03.2)\n                if (!_entityManager.IsValid(id) || !_biologicalSystem.TryGetCoreStats(id, out CoreStats coreStats)) // Use TryGetCoreStats for safety\n                {\n                    continue;\n                }\n\n                ref VelocityComponent currentVelocity = ref _velocities.GetValueRef(id);\n                Vector2 targetMoveVector = currentInput.MoveVector;\n                float currentSpeed = coreStats.MoveSpeed; // Get from CoreStats\n                float friction = 0.8f; // Default friction, could be part of CoreStats or external\n                float acceleration = 10f; // Default acceleration, could be part of CoreStats or external\n                float targetRotationDegrees = _transformSystem.GetTransformRef(id).RotationDegrees;\n\n                // --- Player-specific Movement Logic (Shift-Sliding) ---\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    ref PlayerMovementStateComponent playerMoveState = ref _playerMovementStates.GetValueRef(id);\n\n                    if (currentInput.IsShiftHeld)\n                    {\n                        if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                        {\n                            playerMoveState.LastLockedMoveVector = targetMoveVector;\n                            playerMoveState.IsShiftSliding = true;\n                        }\n                        targetMoveVector = playerMoveState.LastLockedMoveVector;\n                        playerMoveState.IsShiftSliding = (targetMoveVector.LengthSquared() &gt; 0.1f);\n                    }\n                    else\n                    {\n                        playerMoveState.IsShiftSliding = false;\n                        playerMoveState.LastLockedMoveVector = Vector2.Zero;\n                    }\n                }\n                // --- End Player-specific Movement Logic ---\n\n                if (currentInput.IsSprintHeld &amp;&amp; !(_playerMovementStates.TryGetValue(id, out var state) &amp;&amp; state.IsShiftSliding))\n                {\n                    currentSpeed *= coreStats.SprintMultiplier; // Get from CoreStats\n                }\n\n                Vector2 desiredVelocity = targetMoveVector * currentSpeed;\n\n                currentVelocity.Velocity = currentVelocity.Velocity.Lerp(desiredVelocity, acceleration * (float)delta);\n\n                if (!(_playerMovementStates.TryGetValue(id, out var state2) &amp;&amp; state2.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &gt; 0.1f)\n                {\n                    currentVelocity.Velocity = currentVelocity.Velocity.Lerp(Vector2.Zero, friction * (float)delta);\n                }\n                else if (!(_playerMovementStates.TryGetValue(id, out var state3) &amp;&amp; state3.IsShiftSliding) &amp;&amp; targetMoveVector == Vector2.Zero &amp;&amp; currentVelocity.Velocity.LengthSquared() &lt;= 0.1f)\n                {\n                    currentVelocity.Velocity = Vector2.Zero;\n                }\n\n                if (targetMoveVector.LengthSquared() &gt; 0.1f)\n                {\n                    targetRotationDegrees = targetMoveVector.Angle() * (180f / Mathf.Pi);\n                }\n\n                _eventBus.Publish(new EntityManager.EntityVelocityUpdateEvent { ID = id, TargetVelocity = currentVelocity.Velocity, TargetRotationDegrees = targetRotationDegrees });\n            }\n        }\n\n        public Vector2 GetVelocity(EntityID id) { /* ... */ return Vector2.Zero; }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#51-add-trygetcorestats-to-biologicalsystemcs","title":"5.1. Add <code>TryGetCoreStats</code> to <code>BiologicalSystem.cs</code>","text":"<p>The <code>MovementSystem</code> needs a safe way to get <code>CoreStats</code>.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        public ref CoreStats GetCoreStatsRef(EntityID id) { /* ... */ return ref _entityCoreStats.GetValueRef(id); }\n\n        /// &lt;summary&gt;\n        /// Safely attempts to get a copy of an entity's CoreStats.\n        /// &lt;/summary&gt;\n        public bool TryGetCoreStats(EntityID id, out CoreStats coreStats)\n        {\n            if (_entityManager.IsValid(id) &amp;&amp; _entityCoreStats.TryGetValue(id, out coreStats))\n            {\n                return true;\n            }\n            coreStats = default;\n            return false;\n        }\n\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#52-update-gamemanager-to-pass-biologicalsystem-to-movementsystem","title":"5.2. Update <code>GameManager</code> to Pass <code>BiologicalSystem</code> to <code>MovementSystem</code>","text":"<p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the <code>MovementSystem</code> initialization in <code>InitializeSystems()</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        Movement = new MovementSystem(Entities, Input, Events, Transforms, BiologicalSystem); // Pass BiologicalSystem\n        GD.Print(\"  - MovementSystem initialized.\");\n// ...\n</code></pre>"},{"location":"31-chapter-31/#6-refactor-magicsystemcs-for-corestats","title":"6. Refactor <code>MagicSystem.cs</code> for <code>CoreStats</code>","text":"<p>The <code>MagicSystem</code> needs to deduct chakra and stability, and potentially check <code>CastSpeed</code> from <code>CoreStats</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>.</li> <li>Modify <code>MagicSystem</code> constructor to pass <code>BiologicalSystem</code>.</li> <li>Update <code>ProcessGlyphInput</code> and <code>ResolveCombo</code> to use <code>BiologicalSystem.GetCoreStatsRef()</code>.</li> </ol> <pre><code>// _Brain/Systems/Magic/MagicSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Biology; // Add this using directive\n\nnamespace Sigilborne.Systems.Magic\n{\n    public class MagicSystem\n    {\n        // ... (existing fields) ...\n        private BiologicalSystem _biologicalSystem; // New: Reference to BiologicalSystem\n\n        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,\n                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,\n                           WorldGlyphMap worldGlyphMap, GameManager gameManager, ComboResolver comboResolver,\n                           CastingSystem castingSystem, BiologicalSystem biologicalSystem) // Add BiologicalSystem\n        {\n            _entityManager = entityManager;\n            _inputSystem = inputSystem;\n            _eventBus = eventBus;\n            _playerHotbar = playerHotbar;\n            _playerGlyphKnowledge = playerGlyphKnowledge;\n            _worldGlyphMap = worldGlyphMap;\n            _gameManager = gameManager;\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n\n            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE);\n            _comboResolver = comboResolver;\n            _castingSystem = castingSystem;\n            _biologicalSystem = biologicalSystem; // Store BiologicalSystem reference\n            GD.Print(\"MagicSystem: Initialized.\");\n        }\n\n        // ... (Tick, ProcessGlyphInput methods) ...\n\n        private void ResolveCombo()\n        {\n            ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY);\n\n            if (recentInputsSpan.IsEmpty) return;\n\n            // Check if player is currently in a state that prevents new casts (TDD 02.4)\n            if (_castingSystem.GetPlayerCastingState().CurrentState != CastState.Idle)\n            {\n                GD.Print($\"MagicSystem: Player is not Idle ({_castingSystem.GetPlayerCastingState().CurrentState}), cannot initiate new cast.\");\n                return; // Cannot initiate a new cast if not idle\n            }\n\n            GD.Print($\"MagicSystem: Attempting to resolve combo with {recentInputsSpan.Length} recent inputs.\");\n\n            SpellDefinition resolvedSpell = _comboResolver.ResolveCombo(recentInputsSpan);\n\n            if (resolvedSpell != null)\n            {\n                // Get player's current CoreStats for resource checks (Chakra, Stability, CastSpeed)\n                ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n\n                // Check Chakra cost\n                if (playerCoreStats.Chakra &lt; resolvedSpell.ChakraCost)\n                {\n                    GD.Print($\"CastingSystem: Insufficient Chakra to cast '{resolvedSpell.ID}'. (Need: {resolvedSpell.ChakraCost}, Have: {playerCoreStats.Chakra})\");\n                    _eventBus.Publish(new CastingSystem.CastFailedEvent { PlayerID = _playerEntityID, Reason = \"Insufficient Chakra\" });\n                    return;\n                }\n                // Check Stability cost (GDD B03.2)\n                if (playerCoreStats.Stability &lt; resolvedSpell.StabilityCost)\n                {\n                    GD.Print($\"CastingSystem: Insufficient Stability to cast '{resolvedSpell.ID}'. (Need: {resolvedSpell.StabilityCost}, Have: {playerCoreStats.Stability})\");\n                    _eventBus.Publish(new CastingSystem.CastFailedEvent { PlayerID = _playerEntityID, Reason = \"Insufficient Stability\" });\n                    return;\n                }\n\n                // If resources are sufficient, initiate the cast via CastingSystem.\n                // CastingSystem will deduct resources and manage state.\n                if (_castingSystem.InitiateCast(resolvedSpell)) // InitiateCast will now deduct resources\n                {\n                    GD.Print($\"MagicSystem: Resolved and initiated cast for known spell: '{resolvedSpell.ID}'!\");\n                    _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = false, ResultText = $\"Cast {resolvedSpell.ID}!\", ConceptSequence = resolvedSpell.Sequence });\n                    _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());\n                }\n                else\n                {\n                    GD.Print($\"MagicSystem: Failed to initiate cast for '{resolvedSpell.ID}' (e.g., CastingSystem rejected).\");\n                }\n                return;\n            }\n            // ... (existing placeholder resolution logic) ...\n        }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#61-update-castingsystemcs-to-use-biologicalsystems-corestats","title":"6.1. Update <code>CastingSystem.cs</code> to use <code>BiologicalSystem</code>'s <code>CoreStats</code>","text":"<p>The <code>CastingSystem</code> needs to deduct chakra and stability.</p> <ol> <li>Open <code>res://_Brain/Systems/Magic/CastingSystem.cs</code>.</li> <li>Modify <code>CastingSystem</code> constructor to pass <code>BiologicalSystem</code>.</li> <li>Remove direct <code>_playerStatSystem</code> calls for chakra/stability deduction. Delegate to <code>PlayerStatSystem</code> which in turn uses <code>BiologicalSystem</code>.</li> </ol> <pre><code>// _Brain/Systems/Magic/CastingSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic.Components;\n\nnamespace Sigilborne.Systems.Magic\n{\n    public class CastingSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private PlayerStatSystem _playerStatSystem; // Still needed for damage/chakra/stamina deduction methods\n        private TransformSystem _transformSystem;\n        private BiologicalSystem _biologicalSystem; // New: Reference to BiologicalSystem\n\n        private EntityID _playerEntityID;\n        private PlayerCastingState _playerCastingState;\n\n        private const float DEFAULT_RECOVERY_TIME = 0.3f;\n\n        public CastingSystem(EntityManager entityManager, EventBus eventBus, PlayerStatSystem playerStatSystem, TransformSystem transformSystem, BiologicalSystem biologicalSystem) // Add BiologicalSystem\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _playerStatSystem = playerStatSystem;\n            _transformSystem = transformSystem;\n            _biologicalSystem = biologicalSystem; // Store BiologicalSystem reference\n\n            _playerEntityID = _entityManager.GetPlayerEntityID();\n            _playerCastingState = new PlayerCastingState(_playerEntityID);\n\n            GD.Print(\"CastingSystem: Initialized.\");\n        }\n\n        public void Tick(double delta) { /* ... */ }\n\n        public bool InitiateCast(SpellDefinition spell)\n        {\n            if (_playerCastingState.CurrentState != CastState.Idle)\n            {\n                GD.Print($\"CastingSystem: Cannot cast spell '{spell.ID}', not in Idle state ({_playerCastingState.CurrentState}).\");\n                return false;\n            }\n\n            // Resource checks are now done in MagicSystem before calling InitiateCast.\n            // So, if we reach here, resources are sufficient.\n\n            // Deduct resources (TDD 02.4: Mana deducted)\n            _playerStatSystem.TakeChakra(spell.ChakraCost); // Deduct chakra\n            _playerStatSystem.TakeStability(spell.StabilityCost); // Deduct stability (GDD B03.2)\n\n            // Adjust CastTime based on player's CastSpeed (from CoreStats)\n            ref CoreStats playerCoreStats = ref _biologicalSystem.GetCoreStatsRef(_playerEntityID);\n            double finalCastTime = spell.CastTime / playerCoreStats.CastSpeed; // Faster CastSpeed reduces cast time\n\n            _playerCastingState.CurrentSpell = spell;\n            TransitionToState(CastState.CastStart, finalCastTime); // Use finalCastTime\n\n            GD.Print($\"CastingSystem: Initiated cast for '{spell.ID}'. Chakra cost: {spell.ChakraCost}, Stability cost: {spell.StabilityCost}. Final Cast Time: {finalCastTime:F2}s.\");\n            _eventBus.Publish(new CastStateChangedEvent { PlayerID = _playerEntityID, NewState = CastState.CastStart, SpellID = spell.ID });\n\n            return true;\n        }\n\n        public PlayerCastingState GetPlayerCastingState() { return _playerCastingState; }\n\n        private void TransitionToState(CastState newState, double timerDuration = 0) { /* ... */ }\n        private void ExecuteSpellEffect(SpellDefinition spell) { /* ... */ }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#62-update-gamemanager-to-pass-biologicalsystem-to-castingsystem","title":"6.2. Update <code>GameManager</code> to Pass <code>BiologicalSystem</code> to <code>CastingSystem</code>","text":"<p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the <code>CastingSystem</code> initialization in <code>InitializeSystems()</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize CastingSystem, passing BiologicalSystem\n        Casting = new CastingSystem(Entities, Events, PlayerStats, Transforms, BiologicalSystem); // Pass BiologicalSystem\n        GD.Print(\"  - CastingSystem initialized.\");\n\n        // Initialize MagicSystem, passing CastingSystem and BiologicalSystem\n        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver, Casting, BiologicalSystem); // Pass BiologicalSystem\n        GD.Print(\"  - MagicSystem initialized.\");\n// ...\n</code></pre>"},{"location":"31-chapter-31/#7-update-debug-console","title":"7. Update Debug Console","text":"<p>Open <code>res://_Brain/Utils/DebugCommandSystem.cs</code> and update the <code>damage</code> command to use <code>PlayerStats.TakeDamage</code> (which is now updated). Also add commands for <code>chakra</code> and <code>stability</code>.</p> <pre><code>// _Brain/Utils/DebugCommandSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\n\nnamespace Sigilborne.Utils\n{\n    // ... (DebugCommand struct) ...\n\n    public class DebugCommandSystem\n    {\n        // ... (fields and constructor) ...\n\n        private void RegisterDefaultCommands()\n        {\n            // ... (existing commands) ...\n\n            RegisterCommand(\"damage\", \"Damages the player: /damage [amount]\", (args) =&gt;\n            {\n                if (args.Length != 1 || !float.TryParse(args[0], out float amount))\n                {\n                    GD.PrintErr(\"Usage: /damage [amount]\");\n                    return;\n                }\n                _gameManager.PlayerStats.TakeDamage(amount);\n                GD.Print($\"Player took {amount} damage.\");\n            });\n\n            RegisterCommand(\"chakra\", \"Adds/removes chakra: /chakra [amount]\", (args) =&gt;\n            {\n                if (args.Length != 1 || !float.TryParse(args[0], out float amount))\n                {\n                    GD.PrintErr(\"Usage: /chakra [amount]\");\n                    return;\n                }\n                // For adding chakra, we'll need a different method or a direct CoreStats access.\n                // For now, let's just make it take chakra (negative amount means adding).\n                _gameManager.PlayerStats.TakeChakra(-amount); // Negative amount to add\n                GD.Print($\"Player chakra adjusted by {amount}.\");\n            });\n\n            RegisterCommand(\"stability\", \"Adds/removes stability: /stability [amount]\", (args) =&gt;\n            {\n                if (args.Length != 1 || !float.TryParse(args[0], out float amount))\n                {\n                    GD.PrintErr(\"Usage: /stability [amount]\");\n                    return;\n                }\n                _gameManager.PlayerStats.TakeStability(-amount); // Negative amount to add\n                GD.Print($\"Player stability adjusted by {amount}.\");\n            });\n\n            RegisterCommand(\"spawn\", \"Spawns an entity: /spawn [type] [def_id] [x] [y]\", (args) =&gt;\n            {\n                // ... (existing spawn command) ...\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"31-chapter-31/#8-update-gdscript-hud","title":"8. Update GDScript HUD","text":"<p>Open <code>res://_Body/Scripts/UI/HUDController.gd</code> and add a <code>stability_label</code> and connect to <code>OnPlayerStabilityChanged</code>.</p> <pre><code># _Body/Scripts/UI/HUDController.gd\nclass_name HUDController extends CanvasLayer\n\n@onready var health_label: Label = $MainHBox/VBoxStats/HealthLabel\n@onready var chakra_label: Label = $MainHBox/VBoxStats/ChakraLabel\n@onready var stamina_label: Label = $MainHBox/VBoxStats/StaminaLabel\n@onready var stability_label: Label = $MainHBox/VBoxStats/StabilityLabel # New\n@onready var hunger_label: Label = $MainHBox/VBoxNeeds/HungerLabel\n@onready var thirst_label: Label = $MainHBox/VBoxNeeds/ThirstLabel\n\nvar player_entity_id: int = -1\n\nfunc _ready():\n    GD.print(\"HUDController: Initialized. Connecting to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnPlayerHealthChanged.connect(Callable(self, \"_on_player_health_changed\"))\n        GameManager.Instance.Events.OnPlayerChakraChanged.connect(Callable(self, \"_on_player_chakra_changed\"))\n        GameManager.Instance.Events.OnPlayerStaminaChanged.connect(Callable(self, \"_on_player_stamina_changed\"))\n        GameManager.Instance.Events.OnPlayerStabilityChanged.connect(Callable(self, \"_on_player_stability_changed\")) # New\n        GameManager.Instance.Events.OnPlayerDied.connect(Callable(self, \"_on_player_died\"))\n        GameManager.Instance.Events.OnPlayerCoreStatsChanged.connect(Callable(self, \"_on_player_core_stats_changed\")) # Updated from BioStateChanged\n        GameManager.Instance.Events.OnEntitySpawned.connect(Callable(self, \"_on_entity_spawned\"))\n        GD.print(\"HUDController: Successfully connected to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    else:\n        push_error(\"HUDController: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if type == 0: # EntityType.Player has value 0\n        player_entity_id = id\n        GD.print(\"HUDController: Detected player entity with ID: %s\" % player_entity_id)\n\nfunc _on_player_health_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"HP: %s/%s\" % [int(new_value), int(max_value)]\n\nfunc _on_player_chakra_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id:\n        chakra_label.text = \"CHA: %s/%s\" % [int(new_value), int(max_value)]\n\nfunc _on_player_stamina_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id:\n        stamina_label.text = \"STA: %s/%s\" % [int(new_value), int(max_value)]\n\nfunc _on_player_stability_changed(id: int, new_value: float, max_value: float) -&gt; void: # New\n    if id == player_entity_id:\n        stability_label.text = \"STAB: %s/%s\" % [int(new_value), int(max_value)]\n\nfunc _on_player_core_stats_changed(id: int, new_core_stats: Variant) -&gt; void: # Updated to CoreStats\n    if id == player_entity_id:\n        hunger_label.text = \"HUN: %s\" % int(new_core_stats.Hunger)\n        thirst_label.text = \"THI: %s\" % int(new_core_stats.Thirst)\n\nfunc _on_player_died(id: int) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"HP: DEAD\"\n        chakra_label.text = \"CHA: DEAD\"\n        stamina_label.text = \"STA: DEAD\"\n        stability_label.text = \"STAB: DEAD\"\n        hunger_label.text = \"HUN: DEAD\"\n        thirst_label.text = \"THI: DEAD\"\n        GD.print(\"HUDController: Player %s has died visually!\" % id)\n</code></pre> <p>Also, update <code>res://_Body/Scenes/UI/HUD.tscn</code> to add a <code>StabilityLabel</code> to <code>VBoxStats</code>.</p>"},{"location":"31-chapter-31/#9-testing-the-casting-state-machine-with-corestats","title":"9. Testing the Casting State Machine with CoreStats","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the new Stability UI element. It should start at 100/100.</li> <li>Test 1 (Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code>):<ul> <li>Quickly press <code>0</code> then <code>1</code>.</li> <li>Observe the Chakra and Stability values decreasing on the HUD as the spell casts.</li> </ul> </li> <li>Test 2 (Insufficient Chakra/Stability):<ul> <li>Use the debug console <code>/chakra -50</code> (to reduce chakra) or <code>/stability -100</code> (to reduce stability).</li> <li>Attempt to cast <code>Test_BloomConsume</code>.</li> <li>You should see messages about insufficient chakra/stability in the console, and the spell should not initiate.</li> </ul> </li> <li>Test 3 (CastSpeed effect):<ul> <li>The player's default <code>CastSpeed</code> is 1.0.</li> <li>If you could modify <code>PlayerStats.CastSpeed</code> (e.g., via a debug command: <code>/castspeed 2.0</code>), the <code>CastStart</code> duration would halve.</li> </ul> </li> </ol> <p>This comprehensive test confirms that <code>CastingSystem</code> correctly manages the player's casting flow, interacts with <code>PlayerStatSystem</code> to deduct chakra and stability from <code>CoreStats</code>, and uses <code>CoreStats.CastSpeed</code> to determine spell <code>CastTime</code>.</p>"},{"location":"31-chapter-31/#summary","title":"Summary","text":"<p>You have successfully implemented the Casting State Machine in the C# Brain, governing the player's spellcasting flow through distinct states (Idle, Channeling, CastStart, Casting, Recovery). By designing <code>CastingSystem</code> to manage these transitions, deduct <code>ChakraCost</code> and <code>StabilityCost</code> from <code>CoreStats</code> (via <code>PlayerStatSystem</code>), and utilize <code>CoreStats.CastSpeed</code> for <code>CastTime</code> adjustments, you've established precise control over spell execution. This crucial system strictly adheres to TDD 02.4's specifications, providing a robust foundation for Sigilborne's dynamic magic, with all core stats now unified under <code>CoreStats</code>.</p>"},{"location":"31-chapter-31/#next-steps","title":"Next Steps","text":"<p>This concludes Module 4: Combos &amp; Casting - The Art of Ninjutsu. We will now move back to Module 5: Chakra &amp; Life Systems, starting with Metabolism System - Dynamic Decay Rates (C#), where we will refine how hunger, thirst, and other biological needs dynamically decay based on player activity and environmental factors.</p>"},{"location":"32-chapter-32/","title":"Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)","text":""},{"location":"32-chapter-32/#chapter-53-metabolism-system-dynamic-decay-rates-c","title":"Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)","text":"<p>Building on our <code>BiologicalSystem</code> and <code>CoreStats</code>, this chapter refines the management of biological needs by implementing a Metabolism System. This system will dynamically adjust the decay rates of <code>Hunger</code> and <code>Thirst</code> based on the entity's <code>ActivityLevel</code> and (conceptually) <code>WeatherMultiplier</code>, ensuring a more realistic and engaging survival simulation, as specified in TDD 03.2.</p>"},{"location":"32-chapter-32/#1-the-dynamic-nature-of-metabolism","title":"1. The Dynamic Nature of Metabolism","text":"<p>The GDD (B14.4) states that lack of sleep/overexertion causes elevated strain and miscast risk. This implies that high activity should have consequences beyond just stamina drain. A dynamic metabolism system ensures:</p> <ul> <li>Realism: Active entities burn more calories and get thirsty faster.</li> <li>Player Choice: Encourages strategic rest and resource management.</li> <li>Environmental Interaction: Weather will (conceptually) further influence metabolic rates.</li> </ul>"},{"location":"32-chapter-32/#2-enhancing-biologicalsystemcs-for-metabolism","title":"2. Enhancing <code>BiologicalSystem.cs</code> for Metabolism","text":"<p>Our <code>BiologicalSystem</code> already contains the <code>ProcessBioTick</code> method where hunger and thirst decay. We'll enhance <code>GetActivityLevel</code> and integrate <code>WeatherSystem</code> (which we'll define conceptually for now, as TDD 03.3 covers it later) to apply these dynamic modifiers.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather; // New: For WeatherSystem\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem;\n        private MovementSystem _movementSystem;\n        private WeatherSystem _weatherSystem; // New: Reference to WeatherSystem\n\n        private Dictionary&lt;EntityID, CoreStats&gt; _entityCoreStats = new Dictionary&lt;EntityID, CoreStats&gt;();\n\n        private const float BIO_TICK_RATE = 1.0f; // 1.0f = once per real second (1Hz)\n        private float _bioTickTimer;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem, WeatherSystem weatherSystem) // Add WeatherSystem\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem; // Store WeatherSystem reference\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnEntityDespawned, Tick methods) ...\n\n        private void ProcessBioTick()\n        {\n            foreach (var kvp in _entityCoreStats)\n            {\n                EntityID id = kvp.Key;\n                ref CoreStats coreStats = ref _entityCoreStats.GetValueRef(id);\n\n                if (!_entityManager.IsValid(id)) continue;\n\n                // --- Metabolism System (TDD 03.2) ---\n                float activityMultiplier = GetActivityLevel(id); // 1x Idle, 2x Running, 5x Combat (conceptual)\n                float weatherMultiplier = GetWeatherMultiplier(id); // New: Get multiplier based on local weather\n\n                // Hunger decay\n                coreStats.Hunger -= 1.0f * activityMultiplier * weatherMultiplier; // Base decay of 1 per tick\n                coreStats.Hunger = Mathf.Max(0, coreStats.Hunger);\n\n                // Thirst decay\n                coreStats.Thirst -= 1.5f * activityMultiplier * weatherMultiplier; // Thirst decays faster\n                coreStats.Thirst = Mathf.Max(0, coreStats.Thirst);\n\n                // Body temperature (placeholder for environmental effects)\n                // coreStats.BodyTemp = AdjustBodyTemperature(id, coreStats.BodyTemp, activityMultiplier, weatherMultiplier);\n\n                // --- Regeneration (Health, Stamina, Chakra, Stability) ---\n                // ... (existing regen logic) ...\n\n                // --- Apply consequences of low stats (GDD B14.4) ---\n                // ... (existing low stat consequences) ...\n\n                // Publish updates for the Body (e.g., UI for player)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerCoreStatsChangedEvent { PlayerID = id, NewCoreStats = coreStats });\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Determines the activity level of an entity for metabolism calculations.\n        /// (TDD 03.2)\n        /// &lt;/summary&gt;\n        private float GetActivityLevel(EntityID id)\n        {\n            // For player, activity is based on movement.\n            if (id == _entityManager.GetPlayerEntityID())\n            {\n                // If the player has a significant velocity, consider them \"running\".\n                if (_movementSystem.GetVelocity(id).LengthSquared() &gt; 1.0f)\n                {\n                    return 2.0f; // 2x decay for running\n                }\n                // Later: check if in combat for 5x multiplier (conceptual)\n                // if (_combatSystem.IsInCombat(id)) return 5.0f;\n            }\n            // For NPCs/Animals, could be based on their AI state (e.g., fleeing, fighting, patrolling).\n            return 1.0f; // Default 1x decay for idle/NPCs\n        }\n\n        /// &lt;summary&gt;\n        /// Determines the weather-based multiplier for metabolism.\n        /// (TDD 03.3) - Conceptual for now, will be fleshed out in Chapter 5.4.\n        /// &lt;/summary&gt;\n        private float GetWeatherMultiplier(EntityID id)\n        {\n            // For now, a simple placeholder.\n            // In Chapter 5.4, this will query the WeatherSystem based on entity's location.\n            // Example:\n            // if (_transformSystem.TryGetTransform(id, out TransformComponent transform))\n            // {\n            //     WeatherType currentWeather = _weatherSystem.GetCurrentWeatherAt(transform.Position);\n            //     float temperature = _weatherSystem.GetTemperatureAt(transform.Position);\n            //     if (temperature &lt; coreStats.NormalBodyTemp - 10) return 1.2f; // Colder increases metabolism\n            //     if (temperature &gt; coreStats.NormalBodyTemp + 10) return 1.1f; // Hotter increases thirst decay more\n            // }\n            return 1.0f; // Default no multiplier\n        }\n\n        public ref CoreStats GetCoreStatsRef(EntityID id) { /* ... */ return ref _entityCoreStats.GetValueRef(id); }\n        public bool TryGetCoreStats(EntityID id, out CoreStats coreStats) { /* ... */ return false; }\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"32-chapter-32/#3-implementing-a-conceptual-weathersystemcs","title":"3. Implementing a Conceptual <code>WeatherSystem.cs</code>","text":"<p>For <code>BiologicalSystem</code> to compile, we need a placeholder <code>WeatherSystem</code>. We'll flesh this out in Chapter 5.4.</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Weather/</code>.</li> <li>Create <code>res://_Brain/Systems/Weather/WeatherSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Weather/WeatherSystem.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Systems.Weather\n{\n    /// &lt;summary&gt;\n    /// Placeholder for the WeatherSystem, which will manage global and local weather states.\n    /// (TDD 03.3)\n    /// &lt;/summary&gt;\n    public class WeatherSystem\n    {\n        public enum WeatherType { Clear, Rain, Storm, Snow, Fog, AshFall }\n\n        public WeatherSystem()\n        {\n            GD.Print(\"WeatherSystem: Initialized (placeholder).\");\n        }\n\n        // Placeholder methods for BiologicalSystem to call\n        public WeatherType GetCurrentWeatherAt(Vector2 position) =&gt; WeatherType.Clear;\n        public float GetTemperatureAt(Vector2 position) =&gt; 20.0f; // Default 20 C\n    }\n}\n</code></pre>"},{"location":"32-chapter-32/#4-integrating-weathersystem-into-gamemanager","title":"4. Integrating <code>WeatherSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Weather;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>WeatherSystem</code> property.</li> <li>Initialize <code>WeatherSystem</code> in <code>InitializeSystems()</code> before <code>BiologicalSystem</code>.</li> <li>Pass <code>WeatherSystem</code> to <code>BiologicalSystem</code>'s constructor.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public BiologicalSystem Biology { get; private set; }\n    public WeatherSystem Weather { get; private set; } // Add WeatherSystem property\n\n    public override void _Ready() { /* ... */ }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Biology.Tick(delta);\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to PhysicsSystem) ...\n\n        // ... (existing magic system initializations) ...\n\n        // Initialize WeatherSystem BEFORE BiologicalSystem\n        Weather = new WeatherSystem(); // Initialize WeatherSystem here\n        GD.Print(\"  - WeatherSystem initialized.\");\n\n        // Initialize BiologicalSystem, passing WeatherSystem\n        Biology = new BiologicalSystem(Entities, Events, Transforms, Movement, Weather); // Pass WeatherSystem\n        GD.Print(\"  - BiologicalSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"32-chapter-32/#5-testing-dynamic-decay-rates","title":"5. Testing Dynamic Decay Rates","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe Hunger and Thirst values on the HUD.<ul> <li>Idle: Stand still. Hunger and Thirst should decay at their base rates (1.0 and 1.5 per second).</li> <li>Moving: Move the player (WASD). Hunger and Thirst should decay faster (2.0 and 3.0 per second) due to the <code>activityMultiplier</code> from <code>GetActivityLevel()</code>.</li> </ul> </li> </ol> <p>This confirms that the <code>Metabolism System</code> in <code>BiologicalSystem</code> is dynamically adjusting decay rates based on activity, laying the groundwork for more complex environmental interactions.</p>"},{"location":"32-chapter-32/#summary","title":"Summary","text":"<p>You have successfully implemented the Metabolism System in the C# Brain, dynamically adjusting the decay rates of <code>Hunger</code> and <code>Thirst</code> within <code>BiologicalSystem</code>. By enhancing <code>GetActivityLevel</code> to factor in movement and integrating a conceptual <code>WeatherSystem</code>, you've created a more realistic and engaging survival simulation, strictly adhering to TDD 03.2's specifications. This crucial step ensures biological needs are not static but react to player activity, influencing resource management.</p>"},{"location":"32-chapter-32/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Weather &amp; Environment, where we will fully implement the <code>WeatherSystem</code> to manage global and local weather states, and design how environmental pressure directly impacts <code>CoreStats</code> and biological processes.</p>"},{"location":"33-chapter-33/","title":"Chapter 5.4: Weather & Environment - Global Environmental State (C#)","text":""},{"location":"33-chapter-33/#chapter-54-weather-environment-global-environmental-state-c","title":"Chapter 5.4: Weather &amp; Environment - Global Environmental State (C#)","text":"<p>Our <code>BiologicalSystem</code> is now dynamically adjusting metabolism based on activity. The next step is to integrate environmental factors. This chapter focuses on fully implementing the WeatherSystem in the C# Brain to manage global and local weather states, and designing how environmental pressure (temperature, specific weather types) directly impacts <code>CoreStats</code> and biological processes, as specified in TDD 03.3 and GDD B14.7.</p>"},{"location":"33-chapter-33/#1-the-dynamic-nature-of-sigilbornes-environment","title":"1. The Dynamic Nature of Sigilborne's Environment","text":"<p>The GDD (B14.7, B14.8) emphasizes that weather and temperature alter gameplay, affecting: *   Visibility, stealth difficulty. *   Chakra stability. *   Movement. *   Residue spread. *   Sensing accuracy. *   And, crucially, fatigue rate (which ties into metabolism).</p> <p>Our <code>WeatherSystem</code> will be the authoritative source for all environmental conditions.</p>"},{"location":"33-chapter-33/#2-enhancing-weathersystemcs","title":"2. Enhancing <code>WeatherSystem.cs</code>","text":"<p>Our <code>WeatherSystem</code> currently exists as a placeholder. We'll expand it to: *   Track <code>CurrentWeather</code>, <code>Temperature</code>, <code>WindDirection</code>, and <code>Humidity</code> globally. *   Implement a simple update loop for weather transitions. *   Provide methods for other systems to query environmental conditions.</p> <p>Open <code>res://_Brain/Systems/Weather/WeatherSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Weather/WeatherSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core; // For EventBus, TimeSystem\n\nnamespace Sigilborne.Systems.Weather\n{\n    /// &lt;summary&gt;\n    /// Stores the global weather state.\n    /// (TDD 03.3)\n    /// &lt;/summary&gt;\n    public struct GlobalWeatherState\n    {\n        public WeatherType CurrentWeather;\n        public Vector2 WindDirection; // Normalized vector\n        public float Temperature;     // Ambient Celsius\n        public float Humidity;        // 0-1 (0=dry, 1=humid)\n        public float Precipitation;   // 0-1 (0=none, 1=heavy)\n\n        public GlobalWeatherState(WeatherType currentWeather, Vector2 windDirection, float temperature, float humidity, float precipitation)\n        {\n            CurrentWeather = currentWeather;\n            WindDirection = windDirection;\n            Temperature = temperature;\n            Humidity = humidity;\n            Precipitation = precipitation;\n        }\n\n        public override string ToString()\n        {\n            return $\"Weather: {CurrentWeather}, Temp: {Temperature:F1}\u00b0C, Wind: {WindDirection}, Hum: {Humidity:P0}, Precip: {Precipitation:P0}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Manages the global and local weather states, and their transitions.\n    /// (TDD 03.3)\n    /// &lt;/summary&gt;\n    public class WeatherSystem\n    {\n        private EventBus _eventBus;\n        private TimeSystem _timeSystem; // To react to day/night, seasons (conceptual)\n\n        private GlobalWeatherState _currentGlobalWeather;\n        private const float WEATHER_UPDATE_INTERVAL = 60.0f; // Update global weather every 60 game minutes (1 real minute)\n        private float _weatherUpdateTimer;\n\n        public WeatherSystem(EventBus eventBus, TimeSystem timeSystem)\n        {\n            _eventBus = eventBus;\n            _timeSystem = timeSystem;\n\n            // Initialize with default clear weather\n            _currentGlobalWeather = new GlobalWeatherState(WeatherType.Clear, Vector2.Down, 20.0f, 0.5f, 0f);\n            GD.Print($\"WeatherSystem: Initialized. Current: {_currentGlobalWeather}\");\n\n            // Publish initial weather state for Body (VFX, UI)\n            _eventBus.Publish(new GlobalWeatherChangedEvent { NewWeatherState = _currentGlobalWeather });\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the WeatherSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _weatherUpdateTimer += (float)delta;\n            if (_weatherUpdateTimer &gt;= WEATHER_UPDATE_INTERVAL)\n            {\n                UpdateGlobalWeather();\n                _weatherUpdateTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Simulates transitions in global weather.\n        /// For now, a simple cycle. Later, this would be based on biome, season, anomalies.\n        /// &lt;/summary&gt;\n        private void UpdateGlobalWeather()\n        {\n            // Simple sequential transition for testing\n            WeatherType nextWeather = _currentGlobalWeather.CurrentWeather switch\n            {\n                WeatherType.Clear =&gt; WeatherType.Rain,\n                WeatherType.Rain =&gt; WeatherType.Fog,\n                WeatherType.Fog =&gt; WeatherType.Clear,\n                _ =&gt; WeatherType.Clear, // Fallback\n            };\n\n            // Randomize temperature slightly\n            Random rand = new Random(GameManager.Instance.WorldSeed + (int)_timeSystem.CurrentGameTime); // Use world seed and time for determinism\n            float newTemperature = Mathf.Clamp(_currentGlobalWeather.Temperature + (float)(rand.NextDouble() * 5 - 2.5), -10f, 40f); // +/- 2.5 C\n\n            _currentGlobalWeather = new GlobalWeatherState(nextWeather, Vector2.Down, newTemperature, 0.5f, nextWeather == WeatherType.Rain ? 0.7f : 0f); // Update precipitation for rain\n\n            GD.Print($\"WeatherSystem: Global weather updated to: {_currentGlobalWeather}\");\n            _eventBus.Publish(new GlobalWeatherChangedEvent { NewWeatherState = _currentGlobalWeather });\n        }\n\n        /// &lt;summary&gt;\n        /// Returns the current global weather state.\n        /// For more complex worlds, this would take a position and return local weather.\n        /// &lt;/summary&gt;\n        public GlobalWeatherState GetCurrentGlobalWeather()\n        {\n            return _currentGlobalWeather;\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct GlobalWeatherChangedEvent { public GlobalWeatherState NewWeatherState; }\n    }\n}\n</code></pre>"},{"location":"33-chapter-33/#3-integrating-weathersystem-into-gamemanager","title":"3. Integrating <code>WeatherSystem</code> into <code>GameManager</code>","text":"<p>We already added the <code>WeatherSystem</code> property and initialized it. We just need to ensure <code>TimeSystem</code> is passed to its constructor.</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize WeatherSystem BEFORE BiologicalSystem\n        Weather = new WeatherSystem(Events, Time); // Pass TimeSystem\n        GD.Print(\"  - WeatherSystem initialized.\");\n// ...\n</code></pre>"},{"location":"33-chapter-33/#4-enhancing-biologicalsystemcs-with-environmental-pressure","title":"4. Enhancing <code>BiologicalSystem.cs</code> with Environmental Pressure","text":"<p>Now, <code>BiologicalSystem</code> will use <code>WeatherSystem</code> to get the <code>WeatherMultiplier</code> and apply environmental pressure to <code>CoreStats</code>.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather; // Ensure this is present\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        // ... (existing fields) ...\n        private WeatherSystem _weatherSystem;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem, WeatherSystem weatherSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnEntityDespawned, Tick methods) ...\n\n        private void ProcessBioTick()\n        {\n            foreach (var kvp in _entityCoreStats)\n            {\n                EntityID id = kvp.Key;\n                ref CoreStats coreStats = ref _entityCoreStats.GetValueRef(id);\n\n                if (!_entityManager.IsValid(id)) continue;\n\n                float activityMultiplier = GetActivityLevel(id);\n\n                // --- NEW: Get weather multiplier and apply environmental pressure (TDD 03.3) ---\n                float weatherMetabolismMultiplier = 1.0f;\n                float ambientTemperature = coreStats.NormalBodyTemp; // Default to normal temp\n\n                if (_transformSystem.TryGetTransform(id, out TransformComponent transform))\n                {\n                    // For now, assume global weather applies everywhere. Later, this would be local.\n                    GlobalWeatherState currentGlobalWeather = _weatherSystem.GetCurrentGlobalWeather();\n                    ambientTemperature = currentGlobalWeather.Temperature; // Get ambient temp\n\n                    // Colder/hotter weather increases metabolism (GDD B14.8)\n                    float tempDiff = Mathf.Abs(ambientTemperature - coreStats.NormalBodyTemp);\n                    if (tempDiff &gt; 5f) // If temperature deviates by more than 5 degrees\n                    {\n                        weatherMetabolismMultiplier += tempDiff * 0.05f; // 5% increase per 5 degrees diff\n                    }\n                    if (currentGlobalWeather.Precipitation &gt; 0.5f) // Rain/snow increases energy expenditure\n                    {\n                        weatherMetabolismMultiplier += 0.1f;\n                    }\n\n                    // TDD 03.3: AshFall (C04) increases Chakra instability (conceptual)\n                    // if (currentGlobalWeather.CurrentWeather == WeatherSystem.WeatherType.AshFall)\n                    // {\n                    //     // Apply chakra stability penalty here\n                    //     coreStats.Stability -= 0.5f * BIO_TICK_RATE;\n                    // }\n                }\n                // --- END NEW ---\n\n                // Hunger decay (TDD 03.2)\n                coreStats.Hunger -= 1.0f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Hunger = Mathf.Max(0, coreStats.Hunger);\n\n                // Thirst decay (TDD 03.2)\n                coreStats.Thirst -= 1.5f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Thirst = Mathf.Max(0, coreStats.Thirst);\n\n                // --- Body temperature adjustment (TDD 03.2) ---\n                // Slowly drift body temp towards ambient temp\n                coreStats.BodyTemp = Mathf.Lerp(coreStats.BodyTemp, ambientTemperature, 0.1f * BIO_TICK_RATE);\n                // Apply penalties for extreme body temp (GDD B14.8)\n                if (Mathf.Abs(coreStats.BodyTemp - coreStats.NormalBodyTemp) &gt; 10f)\n                {\n                    // GD.Print($\"BiologicalSystem: {id} has extreme body temperature ({coreStats.BodyTemp:F1}\u00b0C)!\");\n                    // Apply fatigue, stat penalties, or even health damage if severe.\n                }\n\n\n                // --- Regeneration (Health, Stamina, Chakra, Stability) ---\n                // ... (existing regen logic) ...\n\n                // ... (Apply consequences of low stats) ...\n\n                // Publish updates for the Body (e.g., UI for player)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerCoreStatsChangedEvent { PlayerID = id, NewCoreStats = coreStats });\n                }\n            }\n        }\n        // ... (GetActivityLevel, GetCoreStatsRef, TryGetCoreStats, Helper Events methods) ...\n    }\n}\n</code></pre>"},{"location":"33-chapter-33/#5-displaying-weather-and-updated-biostate-in-the-body-gdscript-ui","title":"5. Displaying Weather and Updated BioState in the Body (GDScript UI)","text":"<p>Let's update our <code>HUDController.gd</code> to display the current weather and the player's Body Temperature.</p> <ol> <li> <p>Open <code>res://_Body/Scenes/UI/HUD.tscn</code> and modify it:</p> <ul> <li>Add a <code>Label</code> node for <code>WeatherLabel</code>.</li> <li>Add a <code>Label</code> node for <code>TemperatureLabel</code>.</li> <li>Arrange them (e.g., within <code>VBoxNeeds</code> or a new container).</li> </ul> </li> <li> <p>Open <code>res://_Body/Scripts/UI/HUDController.gd</code> and modify it:</p> </li> </ol> <pre><code># _Body/Scripts/UI/HUDController.gd\nclass_name HUDController extends CanvasLayer\n\n@onready var health_label: Label = $MainHBox/VBoxStats/HealthLabel\n@onready var chakra_label: Label = $MainHBox/VBoxStats/ChakraLabel\n@onready var stamina_label: Label = $MainHBox/VBoxStats/StaminaLabel\n@onready var stability_label: Label = $MainHBox/VBoxStats/StabilityLabel\n@onready var hunger_label: Label = $MainHBox/VBoxNeeds/HungerLabel\n@onready var thirst_label: Label = $MainHBox/VBoxNeeds/ThirstLabel\n@onready var weather_label: Label = $MainHBox/VBoxNeeds/WeatherLabel # New\n@onready var temperature_label: Label = $MainHBox/VBoxNeeds/TemperatureLabel # New\n\nvar player_entity_id: int = -1\n\nfunc _ready():\n    GD.print(\"HUDController: Initialized. Connecting to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        GameManager.Instance.Events.OnPlayerHealthChanged.connect(Callable(self, \"_on_player_health_changed\"))\n        GameManager.Instance.Events.OnPlayerChakraChanged.connect(Callable(self, \"_on_player_chakra_changed\"))\n        GameManager.Instance.Events.OnPlayerStaminaChanged.connect(Callable(self, \"_on_player_stamina_changed\"))\n        GameManager.Instance.Events.OnPlayerStabilityChanged.connect(Callable(self, \"_on_player_stability_changed\"))\n        GameManager.Instance.Events.OnPlayerDied.connect(Callable(self, \"_on_player_died\"))\n        GameManager.Instance.Events.OnPlayerCoreStatsChanged.connect(Callable(self, \"_on_player_core_stats_changed\"))\n        GameManager.Instance.Events.OnEntitySpawned.connect(Callable(self, \"_on_entity_spawned\"))\n        GameManager.Instance.Events.OnGlobalWeatherChanged.connect(Callable(self, \"_on_global_weather_changed\")) # New\n        GD.print(\"HUDController: Successfully connected to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    else:\n        push_error(\"HUDController: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if type == 0:\n        player_entity_id = id\n        GD.print(\"HUDController: Detected player entity with ID: %s\" % player_entity_id)\n\nfunc _on_player_health_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id: health_label.text = \"HP: %s/%s\" % [int(new_value), int(max_value)]\nfunc _on_player_chakra_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id: chakra_label.text = \"CHA: %s/%s\" % [int(new_value), int(max_value)]\nfunc _on_player_stamina_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id: stamina_label.text = \"STA: %s/%s\" % [int(new_value), int(max_value)]\nfunc _on_player_stability_changed(id: int, new_value: float, max_value: float) -&gt; void:\n    if id == player_entity_id: stability_label.text = \"STAB: %s/%s\" % [int(new_value), int(max_value)]\n\n## Handler for C# PlayerCoreStatsChangedEvent (for Hunger, Thirst, Temp)\nfunc _on_player_core_stats_changed(id: int, new_core_stats: Variant) -&gt; void:\n    if id == player_entity_id:\n        hunger_label.text = \"HUN: %s\" % int(new_core_stats.Hunger)\n        thirst_label.text = \"THI: %s\" % int(new_core_stats.Thirst)\n        temperature_label.text = \"TEMP: %s\u00b0C\" % int(new_core_stats.BodyTemp) # Update temperature\n\n## Handler for C# OnGlobalWeatherChanged event.\nfunc _on_global_weather_changed(new_weather_state: Variant) -&gt; void: # Variant to receive C# struct\n    weather_label.text = \"WTH: %s\" % new_weather_state.CurrentWeather # Access enum name directly\n    temperature_label.text = \"TEMP: %s\u00b0C\" % int(new_weather_state.Temperature) # Update temperature\n    GD.print(\"HUDController: Global Weather Updated to %s\" % new_weather_state.CurrentWeather)\n\n\nfunc _on_player_died(id: int) -&gt; void:\n    if id == player_entity_id:\n        health_label.text = \"HP: DEAD\"\n        chakra_label.text = \"CHA: DEAD\"\n        stamina_label.text = \"STA: DEAD\"\n        stability_label.text = \"STAB: DEAD\"\n        hunger_label.text = \"HUN: DEAD\"\n        thirst_label.text = \"THI: DEAD\"\n        temperature_label.text = \"TEMP: N/A\"\n        weather_label.text = \"WTH: N/A\"\n        GD.print(\"HUDController: Player %s has died visually!\" % id)\n</code></pre>"},{"location":"33-chapter-33/#6-testing-weather-and-environmental-pressure","title":"6. Testing Weather and Environmental Pressure","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the new Weather and Temperature labels on the HUD.<ul> <li>The <code>WeatherSystem</code> will update every 60 game minutes (1 real minute). You should see the weather cycle through Clear, Rain, Fog.</li> <li>Temperature will fluctuate.</li> <li>When the weather changes (especially to Rain), you should observe Hunger and Thirst decay rates increase slightly due to <code>weatherMetabolismMultiplier</code>.</li> <li><code>BodyTemp</code> will slowly drift towards <code>AmbientTemperature</code>.</li> </ul> </li> </ol> <p>This confirms that the <code>WeatherSystem</code> is active, updating the global environment, and <code>BiologicalSystem</code> is correctly applying environmental pressure to <code>CoreStats</code>.</p>"},{"location":"33-chapter-33/#summary","title":"Summary","text":"<p>You have successfully implemented the WeatherSystem in the C# Brain, establishing it as the authoritative source for global environmental conditions. By designing its update loop and integrating it with <code>BiologicalSystem</code>, you've ensured that environmental pressures (like temperature and precipitation) dynamically impact <code>CoreStats</code> and metabolic rates, strictly adhering to TDD 03.3's specifications. Furthermore, <code>HUDController.gd</code> now reactively displays these environmental factors, enhancing player immersion and strategic awareness.</p>"},{"location":"33-chapter-33/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Damage &amp; Recovery Pipeline, detailing how entities take damage, how mitigation is applied, and the process of generating <code>StatusEffect</code>s (like Bleed or Fracture) from injuries.</p>"},{"location":"34-chapter-34/","title":"Chapter 5.5: Damage & Recovery Pipeline - Wounds & Status Effects (C#)","text":""},{"location":"34-chapter-34/#chapter-55-damage-recovery-pipeline-wounds-status-effects-c","title":"Chapter 5.5: Damage &amp; Recovery Pipeline - Wounds &amp; Status Effects (C#)","text":"<p>Combat in Sigilborne is not just about reducing a health bar; it's about systemic injuries and lasting consequences. This chapter implements the Damage &amp; Recovery Pipeline, detailing how entities take damage, how mitigation (armor) is applied, and how injuries can generate <code>StatusEffect</code>s (like Bleed or Fracture), as specified in TDD 03.4 and GDD B12.</p>"},{"location":"34-chapter-34/#1-the-systemic-nature-of-damage","title":"1. The Systemic Nature of Damage","text":"<p>The GDD (B12.2) emphasizes that damage depends on the technique, attacker mastery, defender mastery, and environmental resonance. It also states that \"injuries are not minor debuffs; they fundamentally alter performance.\" This requires a robust pipeline:</p> <ul> <li>Raw Damage: The initial value from an attack.</li> <li>Mitigation: Reduction based on defender's <code>Armor</code> and <code>MagicResistance</code>.</li> <li>Application: Reducing <code>Health</code> in <code>CoreStats</code>.</li> <li>Wound Generation: Chance to apply <code>StatusEffect</code>s based on damage type and severity.</li> <li>Recovery: Mechanisms for healing and clearing status effects.</li> </ul>"},{"location":"34-chapter-34/#2-defining-damagetype-and-damageresult","title":"2. Defining <code>DamageType</code> and <code>DamageResult</code>","text":"<p>We need enums for different damage types and a struct to encapsulate the outcome of a damage calculation. TDD 04.3 defines <code>DamageResult</code>.</p> <ol> <li>Create <code>res://_Brain/Systems/Combat/DamageTypes.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/DamageTypes.cs\nusing System;\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Defines the types of damage that can be dealt.\n    /// (GDD B12.2)\n    /// &lt;/summary&gt;\n    public enum DamageType\n    {\n        None,\n        Physical,   // Cuts, blunt strikes, fractures\n        Chakra,     // Internal flow disruption, energy drain\n        Elemental,  // Heat, cold, shock, pressure\n        Spiritual,  // Soul pressure, illusion backlash\n        Residue,    // Corruption, mutation stress\n        Internal    // Organ/nerve damage, blood loss\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/Combat/DamageResult.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/DamageResult.cs\nusing System;\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Encapsulates the result of a damage calculation.\n    /// (TDD 04.3)\n    /// &lt;/summary&gt;\n    public struct DamageResult\n    {\n        public float FinalDamage;\n        public bool IsCrit;\n        public bool IsBlocked;\n        public DamageType Type;\n        public EntityID AttackerID; // Who dealt the damage\n        public EntityID DefenderID; // Who received the damage\n\n        public DamageResult(float finalDamage, bool isCrit, bool isBlocked, DamageType type, EntityID attackerID, EntityID defenderID)\n        {\n            FinalDamage = finalDamage;\n            IsCrit = isCrit;\n            IsBlocked = isBlocked;\n            Type = type;\n            AttackerID = attackerID;\n            DefenderID = defenderID;\n        }\n\n        public override string ToString()\n        {\n            return $\"Dmg: {FinalDamage:F1} ({Type}) | Crit: {IsCrit}, Block: {IsBlocked}\";\n        }\n    }\n}\n</code></pre>"},{"location":"34-chapter-34/#3-implementing-damagesystemcs","title":"3. Implementing <code>DamageSystem.cs</code>","text":"<p>This system will be responsible for the entire damage pipeline: calculation, application, and wound generation.</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/Combat/</code>.</li> <li>Create <code>res://_Brain/Systems/Combat/DamageSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/DamageSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing Sigilborne.Systems.StatusEffects; // For StatusEffectSystem\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Manages the full damage pipeline: calculation, application to CoreStats,\n    /// and generation of StatusEffects (wounds).\n    /// (TDD 03.4, TDD 04.3)\n    /// &lt;/summary&gt;\n    public class DamageSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem; // To access/modify CoreStats\n        private StatusEffectSystem _statusEffectSystem; // To apply wounds\n\n        public DamageSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _statusEffectSystem = statusEffectSystem; // Store StatusEffectSystem reference\n            GD.Print(\"DamageSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Calculates and applies damage to a target entity.\n        /// This is the entry point for all damage in the game.\n        /// (TDD 03.4: Damage Pipeline)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"attackerID\"&gt;The entity dealing damage.&lt;/param&gt;\n        /// &lt;param name=\"defenderID\"&gt;The entity receiving damage.&lt;/param&gt;\n        /// &lt;param name=\"rawDamage\"&gt;The base damage value.&lt;/param&gt;\n        /// &lt;param name=\"damageType\"&gt;The type of damage.&lt;/param&gt;\n        /// &lt;param name=\"penetration\"&gt;How much the damage ignores defender's mitigation.&lt;/param&gt;\n        /// &lt;returns&gt;The final DamageResult.&lt;/returns&gt;\n        public DamageResult ApplyDamage(EntityID attackerID, EntityID defenderID, float rawDamage, DamageType damageType, float penetration = 0f)\n        {\n            if (!_entityManager.IsValid(defenderID))\n            {\n                GD.PrintErr($\"DamageSystem: Attempted to apply damage to invalid defender {defenderID}.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, defenderID);\n            }\n\n            if (!_biologicalSystem.TryGetCoreStats(defenderID, out CoreStats defenderStats))\n            {\n                GD.PrintErr($\"DamageSystem: Defender {defenderID} has no CoreStats. Cannot apply damage.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, defenderID);\n            }\n\n            // 1. Raw Damage: Already provided.\n\n            // 2. Mitigation (TDD 03.4, TDD 04.3)\n            float mitigation = 0;\n            switch (damageType)\n            {\n                case DamageType.Physical:\n                    mitigation = defenderStats.Armor * (1.0f - penetration);\n                    break;\n                case DamageType.Chakra:\n                case DamageType.Elemental:\n                case DamageType.Spiritual:\n                case DamageType.Residue:\n                    mitigation = defenderStats.MagicResistance * (1.0f - penetration);\n                    break;\n                case DamageType.Internal:\n                    mitigation = 0; // Internal damage often bypasses armor\n                    break;\n            }\n            float finalDamage = rawDamage - mitigation;\n            finalDamage = Mathf.Max(0, finalDamage); // Damage cannot be negative\n\n            // Placeholder for crit/block logic (TDD 04.3)\n            bool isCrit = false; // (Implement crit chance logic here)\n            bool isBlocked = false; // (Implement block chance logic here)\n\n            DamageResult result = new DamageResult(finalDamage, isCrit, isBlocked, damageType, attackerID, defenderID);\n            GD.Print($\"DamageSystem: {attackerID} dealt {result} to {defenderID}.\");\n\n            // 3. Application (TDD 03.4)\n            if (result.FinalDamage &gt; 0)\n            {\n                ref CoreStats targetCoreStats = ref _biologicalSystem.GetCoreStatsRef(defenderID);\n                targetCoreStats.Health -= result.FinalDamage;\n                if (targetCoreStats.Health &lt; 0) targetCoreStats.Health = 0; // Clamp health at 0\n\n                // Publish health change (PlayerStatSystem already does this for player)\n                if (defenderID == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = defenderID, NewValue = targetCoreStats.Health, MaxValue = targetCoreStats.MaxHealth });\n                }\n                // For NPCs, we'd need a generic EntityHealthChangedEvent.\n\n                // 4. Wound Generation (TDD 03.4) - Chance to create a StatusEffect\n                // GDD B12.4: Injuries fundamentally alter performance.\n                GenerateWounds(defenderID, result);\n\n                if (targetCoreStats.Health == 0)\n                {\n                    GD.Print($\"DamageSystem: {defenderID} has been defeated!\");\n                    // Publish entity defeated event\n                    if (defenderID == _entityManager.GetPlayerEntityID())\n                    {\n                        _eventBus.Publish(new PlayerStatSystem.PlayerDiedEvent { PlayerID = defenderID });\n                    }\n                    // _eventBus.Publish(new EntityDefeatedEvent { EntityID = defenderID, KillerID = attackerID });\n                }\n            }\n\n            return result;\n        }\n\n        /// &lt;summary&gt;\n        /// Generates StatusEffect \"wounds\" based on damage type and severity.\n        /// (TDD 03.4, GDD B12.4)\n        /// &lt;/summary&gt;\n        private void GenerateWounds(EntityID targetID, DamageResult result)\n        {\n            if (result.FinalDamage &lt;= 0) return;\n\n            // Simple wound generation for now. Later, this would be more complex.\n            float woundChance = result.FinalDamage / _biologicalSystem.GetCoreStatsRef(targetID).MaxHealth; // Higher damage = higher chance\n            if (woundChance &gt; 0.1f) // 10% damage means 10% chance to bleed\n            {\n                Random rand = new Random(targetID.Index + (int)GameManager.Instance.Time.CurrentGameTime); // Deterministic random\n                if (rand.NextDouble() &lt; woundChance)\n                {\n                    string effectId = \"\";\n                    float duration = 0;\n                    float strength = 0;\n\n                    switch (result.Type)\n                    {\n                        case DamageType.Physical:\n                            effectId = \"bleed_t1\";\n                            duration = 5f;\n                            strength = result.FinalDamage * 0.05f; // Bleed for 5% of damage dealt\n                            break;\n                        case DamageType.Elemental:\n                            effectId = \"burn_t1\";\n                            duration = 3f;\n                            strength = result.FinalDamage * 0.03f;\n                            break;\n                        case DamageType.Chakra:\n                            effectId = \"chakra_drain_t1\";\n                            duration = 2f;\n                            strength = result.FinalDamage * 0.02f; // Drains chakra\n                            break;\n                        case DamageType.Residue:\n                            effectId = \"void_sickness_t1\";\n                            duration = 10f;\n                            strength = result.FinalDamage * 0.01f; // Accumulates void sickness\n                            break;\n                        default:\n                            return; // No wound for other damage types for now\n                    }\n\n                    if (!string.IsNullOrEmpty(effectId))\n                    {\n                        // _statusEffectSystem.ApplyEffect(targetID, new StatusEffectData(effectId, duration, strength));\n                        GD.Print($\"DamageSystem: {targetID} received wound: {effectId} (Strength: {strength:F1})\");\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"34-chapter-34/#4-implementing-statuseffectsystemcs-placeholder","title":"4. Implementing <code>StatusEffectSystem.cs</code> (Placeholder)","text":"<p>The <code>DamageSystem</code> references a <code>StatusEffectSystem</code>. We need a placeholder for it. We'll fully implement this in Chapter 5.6.</p> <ol> <li>Create a new folder <code>res://_Brain/Systems/StatusEffects/</code>.</li> <li>Create <code>res://_Brain/Systems/StatusEffects/StatusEffectSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/StatusEffects/StatusEffectSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components; // For StatusEffectData\n\nnamespace Sigilborne.Systems.StatusEffects\n{\n    /// &lt;summary&gt;\n    /// Placeholder for the StatusEffectSystem, which will manage buffs, debuffs, and wounds.\n    /// (TDD 03.4, TDD 18)\n    /// &lt;/summary&gt;\n    public class StatusEffectSystem\n    {\n        public StatusEffectSystem()\n        {\n            GD.Print(\"StatusEffectSystem: Initialized (placeholder).\");\n        }\n\n        // Placeholder for applying an effect (DamageSystem needs this)\n        public void ApplyEffect(EntityID targetID, StatusEffectData effectData)\n        {\n            GD.Print($\"StatusEffectSystem: (Placeholder) Applied '{effectData.EffectID}' to {targetID}.\");\n            // In Chapter 5.6, this will add the effect to the target's active effects list.\n        }\n    }\n}\n</code></pre>"},{"location":"34-chapter-34/#5-integrating-damagesystem-and-statuseffectsystem-into-gamemanager","title":"5. Integrating <code>DamageSystem</code> and <code>StatusEffectSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Combat;</code> and <code>using Sigilborne.Systems.StatusEffects;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add <code>DamageSystem</code> and <code>StatusEffectSystem</code> properties.</li> <li>Initialize <code>StatusEffectSystem</code> first, then <code>DamageSystem</code>, in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.Combat; // Add this using directive\nusing Sigilborne.Systems.StatusEffects; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public BiologicalSystem Biology { get; private set; }\n    public StatusEffectSystem StatusEffects { get; private set; } // Add StatusEffectSystem property\n    public DamageSystem Combat { get; private set; } // Add DamageSystem property (named Combat as per TDD 04.3)\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n\n        // --- Test Damage &amp; Recovery Pipeline ---\n        GD.Print(\"\\n--- Testing Damage &amp; Recovery Pipeline ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID npcID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Get NPC ID assuming it's still ID 1, Gen 1\n\n        GD.Print($\"Player initial HP: {Biology.GetCoreStatsRef(playerID).Health}\");\n        GD.Print($\"NPC initial HP: {Biology.GetCoreStatsRef(npcID).Health}\");\n\n        // Player attacks NPC\n        Combat.ApplyDamage(playerID, npcID, 20f, DamageType.Physical);\n        Combat.ApplyDamage(playerID, npcID, 15f, DamageType.Physical);\n        Combat.ApplyDamage(playerID, npcID, 70f, DamageType.Elemental); // High damage, higher wound chance\n\n        // NPC attacks Player\n        Combat.ApplyDamage(npcID, playerID, 5f, DamageType.Physical);\n        Combat.ApplyDamage(npcID, playerID, 10f, DamageType.Chakra);\n        Combat.ApplyDamage(npcID, playerID, 20f, DamageType.Residue); // Should trigger void sickness\n        Combat.ApplyDamage(npcID, playerID, 65f, DamageType.Physical); // Should kill player\n\n        GD.Print(\"--- End Testing Damage &amp; Recovery Pipeline ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Biology.Tick(delta); // BiologicalSystem needs to tick for regen\n        // Combat and StatusEffects don't have a Tick method for now, their operations are command-driven.\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to BiologicalSystem) ...\n\n        // Initialize StatusEffectSystem BEFORE DamageSystem\n        StatusEffects = new StatusEffectSystem(); // Initialize StatusEffectSystem here\n        GD.Print(\"  - StatusEffectSystem initialized.\");\n\n        // Initialize DamageSystem, passing BiologicalSystem and StatusEffectSystem\n        Combat = new DamageSystem(Entities, Events, BiologicalSystem, StatusEffects); // Initialize DamageSystem here\n        GD.Print(\"  - DamageSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"34-chapter-34/#6-testing-the-damage-recovery-pipeline","title":"6. Testing the Damage &amp; Recovery Pipeline","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.</li> </ol> <pre><code>...\nStatusEffectSystem: Initialized (placeholder).\n  - StatusEffectSystem initialized.\nDamageSystem: Initialized.\n  - DamageSystem initialized.\nPlayerStatSystem: Initialized.\nPlayerStatSystem: Player EntityID(0, Gen:1) took 0 damage. New Health: 100.0\nPlayerStatSystem: Player EntityID(0, Gen:1) used 0 chakra. New Chakra: 50.0\nPlayerStatSystem: Player EntityID(0, Gen:1) used 0 stamina. New Stamina: 75.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 0 stability. New Stability: 100.0\n  - PlayerStatSystem initialized.\n  - WorldSimulation initialized.\n\n--- Testing Damage &amp; Recovery Pipeline ---\nPlayer initial HP: 100.0\nNPC initial HP: 100.0\nDamageSystem: EntityID(0, Gen:1) dealt Dmg: 20.0 (Physical) | Crit: False, Block: False to EntityID(1, Gen:1).\nStatusEffectSystem: (Placeholder) Applied 'bleed_t1' to EntityID(1, Gen:1).\nDamageSystem: EntityID(0, Gen:1) dealt Dmg: 15.0 (Physical) | Crit: False, Block: False to EntityID(1, Gen:1).\nDamageSystem: EntityID(0, Gen:1) dealt Dmg: 70.0 (Elemental) | Crit: False, Block: False to EntityID(1, Gen:1).\nStatusEffectSystem: (Placeholder) Applied 'burn_t1' to EntityID(1, Gen:1).\nDamageSystem: EntityID(1, Gen:1) dealt Dmg: 5.0 (Physical) | Crit: False, Block: False to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 5.0 damage. New Health: 95.0\nDamageSystem: EntityID(1, Gen:1) dealt Dmg: 10.0 (Chakra) | Crit: False, Block: False to EntityID(0, Gen:1).\nStatusEffectSystem: (Placeholder) Applied 'chakra_drain_t1' to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 10.0 damage. New Health: 85.0\nDamageSystem: EntityID(1, Gen:1) dealt Dmg: 20.0 (Residue) | Crit: False, Block: False to EntityID(0, Gen:1).\nStatusEffectSystem: (Placeholder) Applied 'void_sickness_t1' to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 20.0 damage. New Health: 65.0\nDamageSystem: EntityID(1, Gen:1) dealt Dmg: 65.0 (Physical) | Crit: False, Block: False to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 65.0 damage. New Health: 0.0\nPlayerStatSystem: Player EntityID(0, Gen:1) has died!\n--- End Testing Damage &amp; Recovery Pipeline ---\n...\n</code></pre> <p>This output confirms that: *   <code>DamageSystem</code> correctly calculates damage, applies mitigation, and reduces health in <code>CoreStats</code>. *   <code>GenerateWounds</code> attempts to apply <code>StatusEffect</code>s based on damage type and severity, calling our <code>StatusEffectSystem</code> placeholder. *   The player's death is correctly detected and broadcast.</p>"},{"location":"34-chapter-34/#summary","title":"Summary","text":"<p>You have successfully implemented the foundational Damage &amp; Recovery Pipeline for Sigilborne, detailing how entities take damage, how mitigation (armor/magic resistance) is applied, and how injuries can generate <code>StatusEffect</code>s (wounds). By designing <code>DamageSystem</code> to handle this entire process and integrating it with <code>BiologicalSystem</code> and a placeholder <code>StatusEffectSystem</code>, you've established a robust mechanism for systemic combat, strictly adhering to TDD 03.4 and GDD B12's specifications. This crucial step enables deep and meaningful consequences from combat encounters.</p>"},{"location":"34-chapter-34/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Status Effect Data - Definition vs. Instance, where we will fully implement the <code>StatusEffectSystem</code> to manage buffs, debuffs, and wounds, defining their lifecycle and how they modify entity <code>CoreStats</code>.</p>"},{"location":"35-chapter-35/","title":"Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)","text":""},{"location":"35-chapter-35/#chapter-56-status-effect-data-definition-vs-instance-c","title":"Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)","text":"<p>Our <code>DamageSystem</code> can now trigger <code>StatusEffect</code>s (wounds), and our <code>BiologicalSystem</code> manages <code>CoreStats</code>. This chapter focuses on fully implementing the Status Effect System, starting with defining <code>EffectDefinition</code> (static data) and <code>ActiveEffect</code> (runtime instance) to manage buffs, debuffs, and wounds. This standardized lifecycle ensures effects are applied, tick, and are cleaned up correctly, preventing bugs like \"infinite burn,\" as specified in TDD 18.2.</p>"},{"location":"35-chapter-35/#1-the-dual-nature-of-status-effects","title":"1. The Dual Nature of Status Effects","text":"<p>TDD 18.2 distinguishes between:</p> <ul> <li><code>EffectDefinition</code>: The static blueprint of an effect (e.g., \"Bleed_T1\" always lasts 5 seconds, ticks for X damage). This is data.</li> <li><code>ActiveEffect</code>: A live instance of an effect applied to a specific entity, with its current <code>TimeRemaining</code>, <code>Stacks</code>, and <code>SourceID</code>. This is runtime state.</li> </ul> <p>This separation allows for flexible data-driven effect creation and efficient runtime management.</p>"},{"location":"35-chapter-35/#2-defining-effectdefinition","title":"2. Defining <code>EffectDefinition</code>","text":"<p>This will be our static blueprint for all status effects.</p> <ol> <li>Open <code>res://_Brain/Systems/StatusEffects/StatusEffectSystem.cs</code> and add <code>EffectDefinition</code> as a nested class (or in its own file if preferred, but for now, nested is fine for cohesion).</li> </ol> <pre><code>// _Brain/Systems/StatusEffects/StatusEffectSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components; // For StatusEffectData\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing Sigilborne.Core; // For EventBus\n\nnamespace Sigilborne.Systems.StatusEffects\n{\n    /// &lt;summary&gt;\n    /// Defines the types of status effects.\n    /// &lt;/summary&gt;\n    public enum EffectType\n    {\n        None,\n        DamageOverTime, // DoT\n        StatModifier,   // Modifies a stat (e.g., speed, armor)\n        Buff,           // Positive stat modifier\n        Debuff,         // Negative stat modifier\n        HealingOverTime, // HoT\n        ChakraDrain,    // Drains chakra over time\n        StabilityDrain, // Drains stability over time\n        ControlImpair,  // Stun, Root, Slow\n        VoidSickness    // Permanent/persistent corruption effect (C04)\n    }\n\n    /// &lt;summary&gt;\n    /// Static data defining a status effect.\n    /// (TDD 18.2.1)\n    /// &lt;/summary&gt;\n    public class EffectDefinition\n    {\n        public string ID { get; private set; } // \"burn_t1\", \"slow_short\"\n        public EffectType Type { get; private set; }\n        public int MaxStacks { get; private set; }\n        public float BaseDuration { get; private set; } // Base duration before modifiers\n        public float TickRate { get; private set; } // How often the effect \"ticks\" (for DoT, HoT, etc.)\n        public float BaseStrength { get; private set; } // Base magnitude of the effect\n        public bool IsPermanent { get; private set; } // TDD 18.4.1: VoidSickness is permanent until cured.\n        public string VisualFXID { get; private set; } // ID for Body to play VFX (e.g., \"burn_particles\")\n        public string SoundFXID { get; private set; } // ID for Body to play SFX\n\n        // For StatModifier effects: which CoreStats field to modify and how\n        public string StatToModify { get; private set; } // e.g., \"MoveSpeed\", \"Armor\"\n        public float StatModifierValue { get; private set; } // e.g., -0.2 (20% reduction), 10.0 (flat increase)\n        public bool IsPercentageModifier { get; private set; } // true for % mod, false for flat\n\n        public EffectDefinition(string id, EffectType type, int maxStacks, float baseDuration, float tickRate, float baseStrength, bool isPermanent = false, string visualFxId = null, string soundFxId = null, string statToModify = null, float statModifierValue = 0f, bool isPercentageModifier = false)\n        {\n            ID = id;\n            Type = type;\n            MaxStacks = maxStacks;\n            BaseDuration = baseDuration;\n            TickRate = tickRate;\n            BaseStrength = baseStrength;\n            IsPermanent = isPermanent;\n            VisualFXID = visualFxId;\n            SoundFXID = soundFxId;\n            StatToModify = statToModify;\n            StatModifierValue = statModifierValue;\n            IsPercentageModifier = isPercentageModifier;\n        }\n\n        public override string ToString()\n        {\n            return $\"EffectDef: '{ID}' ({Type}) | Str: {BaseStrength}, Dur: {BaseDuration}, Stacks: {MaxStacks}\";\n        }\n    }\n    // ... (rest of StatusEffectSystem class) ...\n}\n</code></pre>"},{"location":"35-chapter-35/#3-defining-activeeffect","title":"3. Defining <code>ActiveEffect</code>","text":"<p>This represents a live instance of an effect on an entity.</p> <ol> <li>Open <code>res://_Brain/Systems/StatusEffects/StatusEffectSystem.cs</code> and add <code>ActiveEffect</code> as a nested struct.</li> </ol> <pre><code>// _Brain/Systems/StatusEffects/StatusEffectSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components; // For StatusEffectData\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing Sigilborne.Core; // For EventBus\n\nnamespace Sigilborne.Systems.StatusEffects\n{\n    // ... (EffectType enum) ...\n    // ... (EffectDefinition class) ...\n\n    /// &lt;summary&gt;\n    /// Represents an active instance of a status effect applied to an entity.\n    /// (TDD 18.2.2)\n    /// &lt;/summary&gt;\n    public struct ActiveEffect\n    {\n        public EffectDefinition Definition; // Reference to the static definition\n        public int Stacks;                  // Current number of stacks (TDD 18.2.2)\n        public float TimeRemaining;         // Remaining duration of the effect (TDD 18.2.2)\n        public float TimeSinceLastTick;     // For effects that tick periodically\n        public EntityID SourceID;           // Who applied this effect (for kill credit, etc.)\n        public EntityID TargetID;           // Who has this effect\n\n        public ActiveEffect(EffectDefinition definition, EntityID targetID, EntityID sourceID, float initialDuration, float initialStrength, int initialStacks = 1)\n        {\n            Definition = definition;\n            TargetID = targetID;\n            SourceID = sourceID;\n            Stacks = initialStacks;\n            TimeRemaining = initialDuration;\n            TimeSinceLastTick = 0; // Start at 0 for first tick\n            // Initial strength from EffectDefinition is used, initialStrength parameter\n            // allows for overrides (e.g., spell specific strength).\n        }\n\n        public override string ToString()\n        {\n            return $\"ActiveEffect: '{Definition.ID}' | Stacks: {Stacks}, Rem: {TimeRemaining:F1}s\";\n        }\n    }\n    // ... (rest of StatusEffectSystem class) ...\n}\n</code></pre>"},{"location":"35-chapter-35/#4-enhancing-statuseffectsystemcs-with-data-management","title":"4. Enhancing <code>StatusEffectSystem.cs</code> with Data Management","text":"<p>Now, let's update <code>StatusEffectSystem</code> to manage a collection of <code>EffectDefinition</code>s and <code>ActiveEffect</code>s.</p> <ol> <li>Open <code>res://_Brain/Systems/StatusEffects/StatusEffectSystem.cs</code>.</li> <li>Modify the class to include dictionaries for definitions and active effects.</li> <li>Implement <code>RegisterEffectDefinition</code> and <code>ApplyEffect</code>.</li> <li>Implement the <code>Tick</code> method for the <code>StatusEffectSystem</code> itself.</li> </ol> <pre><code>// _Brain/Systems/StatusEffects/StatusEffectSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Core;\nusing System.Linq; // For Any()\n\nnamespace Sigilborne.Systems.StatusEffects\n{\n    // ... (EffectType enum) ...\n    // ... (EffectDefinition class) ...\n    // ... (ActiveEffect struct) ...\n\n    /// &lt;summary&gt;\n    /// Manages the lifecycle and application of all status effects (buffs, debuffs, wounds).\n    /// (TDD 03.4, TDD 18)\n    /// &lt;/summary&gt;\n    public class StatusEffectSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem; // To modify CoreStats\n\n        // Static definitions of all possible effects\n        private Dictionary&lt;string, EffectDefinition&gt; _effectDefinitions = new Dictionary&lt;string, EffectDefinition&gt;();\n\n        // Active effects on entities: Dictionary&lt;EntityID, List&lt;ActiveEffect&gt;&gt;\n        // Using a List&lt;ActiveEffect&gt; as an entity can have multiple effects.\n        private Dictionary&lt;EntityID, List&lt;ActiveEffect&gt;&gt; _activeEffects = new Dictionary&lt;EntityID, List&lt;ActiveEffect&gt;&gt;();\n\n        public StatusEffectSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            GD.Print(\"StatusEffectSystem: Initialized.\");\n\n            // Subscribe to entity despawn events to clean up effects\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultEffects(); // Register some default effects for testing\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _activeEffects.Remove(e.ID); // Clean up all effects on a despawned entity\n            GD.Print($\"StatusEffectSystem: Cleared effects for despawned entity {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static EffectDefinition.\n        /// &lt;/summary&gt;\n        public void RegisterEffectDefinition(EffectDefinition def)\n        {\n            _effectDefinitions[def.ID] = def;\n            GD.Print($\"StatusEffectSystem: Registered effect definition '{def.ID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some common default effects for initial testing.\n        /// &lt;/summary&gt;\n        private void RegisterDefaultEffects()\n        {\n            RegisterEffectDefinition(new EffectDefinition(\"bleed_t1\", EffectType.DamageOverTime, 3, 5f, 1f, 2f, visualFxId: \"bleed_vfx\"));\n            RegisterEffectDefinition(new EffectDefinition(\"burn_t1\", EffectType.DamageOverTime, 5, 3f, 0.5f, 3f, visualFxId: \"burn_vfx\"));\n            RegisterEffectDefinition(new EffectDefinition(\"chakra_drain_t1\", EffectType.ChakraDrain, 1, 2f, 0.5f, 5f, visualFxId: \"drain_vfx\"));\n            RegisterEffectDefinition(new EffectDefinition(\"void_sickness_t1\", EffectType.VoidSickness, 100, float.MaxValue, 10f, 1f, isPermanent: true, visualFxId: \"void_aura_vfx\")); // TDD 18.4.1\n            RegisterEffectDefinition(new EffectDefinition(\"slow_short\", EffectType.ControlImpair, 1, 3f, 0f, 0.5f, statToModify: \"MoveSpeed\", isPercentageModifier: true)); // 50% slow\n            RegisterEffectDefinition(new EffectDefinition(\"regen_t1\", EffectType.HealingOverTime, 1, 5f, 1f, 5f));\n            // Add more as needed\n        }\n\n        /// &lt;summary&gt;\n        /// Applies a status effect to a target entity.\n        /// (TDD 18.3.1: Application)\n        /// &lt;/summary&gt;\n        public void ApplyEffect(EntityID targetID, StatusEffectData effectData, EntityID sourceID = default)\n        {\n            if (!_entityManager.IsValid(targetID))\n            {\n                GD.PrintErr($\"StatusEffectSystem: Attempted to apply effect to invalid entity {targetID}.\");\n                return;\n            }\n            if (!_effectDefinitions.TryGetValue(effectData.EffectID, out EffectDefinition def))\n            {\n                GD.PrintErr($\"StatusEffectSystem: Effect definition '{effectData.EffectID}' not found.\");\n                return;\n            }\n\n            if (!_activeEffects.ContainsKey(targetID))\n            {\n                _activeEffects[targetID] = new List&lt;ActiveEffect&gt;();\n            }\n\n            // Check if the target already has this effect (TDD 18.3.1)\n            int existingEffectIndex = _activeEffects[targetID].FindIndex(ae =&gt; ae.Definition.ID == def.ID);\n\n            if (existingEffectIndex != -1)\n            {\n                // Effect already exists: Refresh duration or stack (TDD 18.3.1)\n                ActiveEffect existingEffect = _activeEffects[targetID][existingEffectIndex];\n\n                // Refresh duration\n                existingEffect.TimeRemaining = def.BaseDuration;\n\n                // Stack if allowed\n                if (existingEffect.Stacks &lt; def.MaxStacks)\n                {\n                    existingEffect.Stacks++;\n                    GD.Print($\"StatusEffectSystem: Stacked '{def.ID}' on {targetID}. New stacks: {existingEffect.Stacks}\");\n                }\n                _activeEffects[targetID][existingEffectIndex] = existingEffect; // Update struct in list\n\n                // Emit event for UI/VFX update (e.g., stack count changed)\n                _eventBus.Publish(new EffectUpdatedEvent { TargetID = targetID, Effect = existingEffect, IsNew = false });\n            }\n            else\n            {\n                // New effect: Create and add\n                ActiveEffect newEffect = new ActiveEffect(def, targetID, sourceID, def.BaseDuration, effectData.Strength);\n                _activeEffects[targetID].Add(newEffect);\n                GD.Print($\"StatusEffectSystem: Applied new effect '{def.ID}' to {targetID}.\");\n\n                // Emit event for UI/VFX update (e.g., new icon, particle effect)\n                _eventBus.Publish(new EffectAppliedEvent { TargetID = targetID, Effect = newEffect });\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the StatusEffectSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// (TDD 18.3.2: The Tick Loop)\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            List&lt;EntityID&gt; entitiesToRemoveEffectsFrom = new List&lt;EntityID&gt;();\n\n            foreach (var kvp in _activeEffects)\n            {\n                EntityID targetID = kvp.Key;\n                List&lt;ActiveEffect&gt; effectsOnTarget = kvp.Value;\n\n                if (!_entityManager.IsValid(targetID))\n                {\n                    entitiesToRemoveEffectsFrom.Add(targetID); // Mark for cleanup\n                    continue;\n                }\n\n                List&lt;ActiveEffect&gt; effectsToRemove = new List&lt;ActiveEffect&gt;();\n                for (int i = effectsOnTarget.Count - 1; i &gt;= 0; i--)\n                {\n                    ActiveEffect effect = effectsOnTarget[i];\n                    effect.TimeRemaining -= (float)delta;\n                    effect.TimeSinceLastTick += (float)delta;\n\n                    // Apply effect tick (TDD 18.3.2)\n                    if (effect.Definition.TickRate &gt; 0 &amp;&amp; effect.TimeSinceLastTick &gt;= effect.Definition.TickRate)\n                    {\n                        ApplyEffectTick(targetID, effect);\n                        effect.TimeSinceLastTick = 0; // Reset tick timer\n                    }\n\n                    // Check for expiration (TDD 18.3.2)\n                    if (!effect.Definition.IsPermanent &amp;&amp; effect.TimeRemaining &lt;= 0)\n                    {\n                        effectsToRemove.Add(effect);\n                        GD.Print($\"StatusEffectSystem: Effect '{effect.Definition.ID}' expired on {targetID}.\");\n                    }\n                    else\n                    {\n                        effectsOnTarget[i] = effect; // Update the struct in the list\n                    }\n                }\n\n                // Remove expired effects\n                foreach (var expiredEffect in effectsToRemove)\n                {\n                    effectsOnTarget.Remove(expiredEffect);\n                    _eventBus.Publish(new EffectRemovedEvent { TargetID = targetID, EffectID = expiredEffect.Definition.ID });\n                }\n\n                if (effectsOnTarget.Count == 0)\n                {\n                    entitiesToRemoveEffectsFrom.Add(targetID);\n                }\n            }\n\n            // Clean up entities with no active effects\n            foreach (var id in entitiesToRemoveEffectsFrom)\n            {\n                _activeEffects.Remove(id);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Applies the periodic effect of an active status effect.\n        /// (TDD 18.3.2)\n        /// &lt;/summary&gt;\n        private void ApplyEffectTick(EntityID targetID, ActiveEffect effect)\n        {\n            if (!_biologicalSystem.TryGetCoreStats(targetID, out CoreStats coreStats)) return;\n\n            float strength = effect.Definition.BaseStrength * effect.Stacks; // Strength scales with stacks\n\n            switch (effect.Definition.Type)\n            {\n                case EffectType.DamageOverTime:\n                    // Apply direct damage (GDD B12.4: Cumulative Injuries)\n                    GameManager.Instance.Combat.ApplyDamage(effect.SourceID, targetID, strength, DamageType.Physical); // DoT is typically physical/elemental\n                    break;\n                case EffectType.HealingOverTime:\n                    // Apply healing (GDD B12.11: Natural Healing Speed)\n                    ref CoreStats targetStatsHeal = ref _biologicalSystem.GetCoreStatsRef(targetID);\n                    targetStatsHeal.Health = Mathf.Min(targetStatsHeal.MaxHealth, targetStatsHeal.Health + strength);\n                    _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = targetID, NewValue = targetStatsHeal.Health, MaxValue = targetStatsHeal.MaxHealth });\n                    break;\n                case EffectType.ChakraDrain:\n                    ref CoreStats targetStatsChakra = ref _biologicalSystem.GetCoreStatsRef(targetID);\n                    targetStatsChakra.Chakra = Mathf.Max(0, targetStatsChakra.Chakra - strength);\n                     _eventBus.Publish(new PlayerStatSystem.PlayerChakraChangedEvent { PlayerID = targetID, NewValue = targetStatsChakra.Chakra, MaxValue = targetStatsChakra.MaxChakra });\n                    break;\n                case EffectType.StabilityDrain:\n                    ref CoreStats targetStatsStability = ref _biologicalSystem.GetCoreStatsRef(targetID);\n                    targetStatsStability.Stability = Mathf.Max(0, targetStatsStability.Stability - strength);\n                    _eventBus.Publish(new PlayerStatSystem.PlayerStabilityChangedEvent { PlayerID = targetID, NewValue = targetStatsStability.Stability, MaxValue = targetStatsStability.MaxStability });\n                    break;\n                case EffectType.VoidSickness: // TDD 18.4.1\n                    // Apply long-term void sickness effects here (e.g., reduce MaxHealth/Chakra, random miscasts)\n                    GD.Print($\"StatusEffectSystem: {targetID} suffering Void Sickness tick (Stacks: {effect.Stacks}).\");\n                    // Example: reduce max health permanently\n                    // ref CoreStats voidStats = ref _biologicalSystem.GetCoreStatsRef(targetID);\n                    // voidStats.MaxHealth -= strength * 0.1f; // Small permanent max health reduction per tick\n                    break;\n                // StatModifier and ControlImpair effects are typically applied continuously/on demand, not per tick.\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all active effects on a specific entity.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;ActiveEffect&gt; GetActiveEffects(EntityID targetID)\n        {\n            if (_activeEffects.TryGetValue(targetID, out List&lt;ActiveEffect&gt; effects))\n            {\n                return effects.AsReadOnly();\n            }\n            return new List&lt;ActiveEffect&gt;().AsReadOnly();\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct EffectAppliedEvent { public EntityID TargetID; public ActiveEffect Effect; }\n        public struct EffectUpdatedEvent { public EntityID TargetID; public ActiveEffect Effect; public bool IsNew; } // IsNew for UI to know if to create/update\n        public struct EffectRemovedEvent { public EntityID TargetID; public string EffectID; }\n    }\n}\n</code></pre>"},{"location":"35-chapter-35/#5-integrating-statuseffectsystem-into-gamemanager","title":"5. Integrating <code>StatusEffectSystem</code> into <code>GameManager</code>","text":"<p>We already added the <code>StatusEffectSystem</code> property and initialized it. We just need to ensure <code>BiologicalSystem</code> is passed to its constructor.</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        BiologicalSystem = new BiologicalSystem(Entities, Events, Transforms, Movement, Weather);\n        GD.Print(\"  - BiologicalSystem initialized.\");\n\n        // Initialize StatusEffectSystem, passing BiologicalSystem\n        StatusEffects = new StatusEffectSystem(Entities, Events, BiologicalSystem); // Pass BiologicalSystem\n        GD.Print(\"  - StatusEffectSystem initialized.\");\n// ...\n</code></pre>"},{"location":"35-chapter-35/#6-updating-damagesystemcs-to-use-statuseffectsystem","title":"6. Updating <code>DamageSystem.cs</code> to use <code>StatusEffectSystem</code>","text":"<p>Our <code>DamageSystem</code> placeholder now needs to use the fully implemented <code>StatusEffectSystem</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Combat/DamageSystem.cs</code>.</li> <li>Uncomment the <code>_statusEffectSystem.ApplyEffect()</code> call in <code>GenerateWounds()</code>.</li> </ol> <pre><code>// _Brain/Systems/Combat/DamageSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.StatusEffects; // Ensure this is present\n\nnamespace Sigilborne.Systems.Combat\n{\n    // ... (DamageType, DamageResult structs/enums) ...\n\n    public class DamageSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        public DamageResult ApplyDamage(EntityID attackerID, EntityID defenderID, float rawDamage, DamageType damageType, float penetration = 0f)\n        {\n            // ... (existing damage calculation and health application) ...\n\n            // 4. Wound Generation (TDD 03.4) - Chance to create a StatusEffect\n            GenerateWounds(defenderID, result);\n\n            // ... (existing defeat logic) ...\n        }\n\n        private void GenerateWounds(EntityID targetID, DamageResult result)\n        {\n            if (result.FinalDamage &lt;= 0) return;\n\n            float woundChance = result.FinalDamage / _biologicalSystem.GetCoreStatsRef(targetID).MaxHealth;\n            if (woundChance &gt; 0.1f)\n            {\n                Random rand = new Random(targetID.Index + (int)GameManager.Instance.Time.CurrentGameTime);\n                if (rand.NextDouble() &lt; woundChance)\n                {\n                    string effectId = \"\";\n                    float duration = 0;\n                    float strength = 0;\n\n                    switch (result.Type)\n                    {\n                        case DamageType.Physical:\n                            effectId = \"bleed_t1\";\n                            duration = 5f;\n                            strength = result.FinalDamage * 0.05f;\n                            break;\n                        case DamageType.Elemental:\n                            effectId = \"burn_t1\";\n                            duration = 3f;\n                            strength = result.FinalDamage * 0.03f;\n                            break;\n                        case DamageType.Chakra:\n                            effectId = \"chakra_drain_t1\";\n                            duration = 2f;\n                            strength = result.FinalDamage * 0.02f;\n                            break;\n                        case DamageType.Residue:\n                            effectId = \"void_sickness_t1\";\n                            duration = 10f; // TDD 18.4.1 says permanent, but for test, give a duration.\n                            strength = result.FinalDamage * 0.01f;\n                            break;\n                        default:\n                            return;\n                    }\n\n                    if (!string.IsNullOrEmpty(effectId))\n                    {\n                        // Now calling the real ApplyEffect method (uncommented)\n                        _statusEffectSystem.ApplyEffect(targetID, new StatusEffectData(effectId, duration, strength), result.AttackerID);\n                        // GD.Print($\"DamageSystem: {targetID} received wound: {effectId} (Strength: {strength:F1})\"); // StatusEffectSystem prints this now.\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"35-chapter-35/#7-update-eventbuscs-for-status-effect-events","title":"7. Update <code>EventBus.cs</code> for Status Effect Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add delegates for <code>StatusEffectSystem</code>'s new events.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Status Effect Events (TDD 18.3.1)\n        public event Action&lt;EntityID, ActiveEffect&gt; OnEffectApplied;\n        public event Action&lt;EntityID, ActiveEffect, bool&gt; OnEffectUpdated; // TargetID, Effect, IsNew (true if new, false if just stacked/refreshed)\n        public event Action&lt;EntityID, string&gt; OnEffectRemoved; // TargetID, EffectID\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is StatusEffectSystem.EffectAppliedEvent effectAppliedEvent) // New condition\n            {\n                OnEffectApplied?.Invoke(effectAppliedEvent.TargetID, effectAppliedEvent.Effect);\n            }\n            else if (eventData is StatusEffectSystem.EffectUpdatedEvent effectUpdatedEvent) // New condition\n            {\n                OnEffectUpdated?.Invoke(effectUpdatedEvent.TargetID, effectUpdatedEvent.Effect, effectUpdatedEvent.IsNew);\n            }\n            else if (eventData is StatusEffectSystem.EffectRemovedEvent effectRemovedEvent) // New condition\n            {\n                OnEffectRemoved?.Invoke(effectRemovedEvent.TargetID, effectRemovedEvent.EffectID);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"35-chapter-35/#8-testing-status-effect-lifecycle","title":"8. Testing Status Effect Lifecycle","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output. The <code>DamageSystem</code> will apply damage and now call <code>StatusEffectSystem.ApplyEffect</code>.<ul> <li>You should see messages like:<ul> <li><code>StatusEffectSystem: Applied new effect 'bleed_t1' to EntityID(1, Gen:1).</code></li> <li><code>StatusEffectSystem: Effect 'bleed_t1' expired on EntityID(1, Gen:1).</code> (after 5 seconds for bleed_t1)</li> <li><code>StatusEffectSystem: Applied new effect 'burn_t1' to EntityID(1, Gen:1).</code> (after high elemental damage)</li> <li><code>StatusEffectSystem: Applied new effect 'void_sickness_t1' to EntityID(0, Gen:1).</code> (after residue damage to player)</li> <li>You'll also see <code>DamageOverTime</code> ticks reducing health, <code>ChakraDrain</code> ticks reducing chakra, etc.</li> </ul> </li> </ul> </li> </ol> <p>This confirms that: *   <code>EffectDefinition</code>s are registered. *   <code>DamageSystem</code> correctly calls <code>StatusEffectSystem.ApplyEffect()</code>. *   <code>StatusEffectSystem</code> manages <code>ActiveEffect</code> instances, refreshes/stacks them, and ticks their effects. *   Effects expire after their <code>TimeRemaining</code> (unless <code>IsPermanent</code>). *   The <code>ApplyEffectTick</code> correctly applies damage, healing, or resource drain.</p>"},{"location":"35-chapter-35/#summary","title":"Summary","text":"<p>You have successfully implemented the Status Effect System for Sigilborne, defining <code>EffectDefinition</code> as static blueprints and <code>ActiveEffect</code> as runtime instances. By designing <code>StatusEffectSystem</code> to manage their lifecycle\u00e2\u20ac\u201dfrom application and stacking/refreshing to periodic ticking and expiration\u00e2\u20ac\u201dyou've created a robust mechanism for handling buffs, debuffs, and wounds. This crucial system correctly integrates with <code>DamageSystem</code> and <code>BiologicalSystem</code> to modify <code>CoreStats</code>, strictly adhering to TDD 18.2's specifications and laying the groundwork for complex, lasting combat consequences.</p>"},{"location":"35-chapter-35/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Recovery Logic, detailing how entities heal naturally, manage stamina and chakra regeneration, and how these processes interact with status effects and environmental conditions.</p>"},{"location":"36-chapter-36/","title":"Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)","text":""},{"location":"36-chapter-36/#chapter-57-recovery-logic-health-stamina-chakra-regeneration-c","title":"Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)","text":"<p>Our <code>BiologicalSystem</code> currently applies hunger/thirst decay and basic regeneration. This chapter refines the Recovery Logic for <code>Health</code>, <code>Stamina</code>, <code>Chakra</code>, and <code>Stability</code> in the C# Brain. We'll ensure regeneration rates are influenced by <code>CoreStats</code>, activity levels, and (conceptually) status effects or environmental conditions, providing a comprehensive system for entity well-being, as specified in TDD 03.4 and GDD B12.11.</p>"},{"location":"36-chapter-36/#1-the-importance-of-dynamic-recovery","title":"1. The Importance of Dynamic Recovery","text":"<p>The GDD (B03.4) highlights deliberate recovery mechanisms (meditation, food, rest). This implies that recovery isn't just a static rate but should be influenced by:</p> <ul> <li>CoreStats: <code>ChakraRegenRate</code>, <code>StaminaRegenRate</code>, <code>StabilityRegenRate</code>.</li> <li>Activity Level: Rest should accelerate recovery, high activity should slow or halt it.</li> <li>Status Effects: Wounds (e.g., Bleed) or debuffs (e.g., Chakra Drain) should impair regeneration.</li> <li>Environment: Resonant locations (GDD B03.4.E) could boost recovery.</li> </ul>"},{"location":"36-chapter-36/#2-enhancing-biologicalsystemcs-for-regeneration","title":"2. Enhancing <code>BiologicalSystem.cs</code> for Regeneration","text":"<p>Our <code>BiologicalSystem.ProcessBioTick</code> already has basic regeneration. We'll refine it to use <code>CoreStats</code>'s dedicated regeneration rates and factor in activity level.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects; // New: For StatusEffectSystem\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem;\n        private MovementSystem _movementSystem;\n        private WeatherSystem _weatherSystem;\n        private StatusEffectSystem _statusEffectSystem; // New: Reference to StatusEffectSystem\n\n        private Dictionary&lt;EntityID, CoreStats&gt; _entityCoreStats = new Dictionary&lt;EntityID, CoreStats&gt;();\n\n        private const float BIO_TICK_RATE = 1.0f; // 1.0f = once per real second (1Hz)\n        private float _bioTickTimer;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem, WeatherSystem weatherSystem, StatusEffectSystem statusEffectSystem) // Add StatusEffectSystem\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n            _statusEffectSystem = statusEffectSystem; // Store StatusEffectSystem reference\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnEntityDespawned, Tick methods) ...\n\n        private void ProcessBioTick()\n        {\n            foreach (var kvp in _entityCoreStats)\n            {\n                EntityID id = kvp.Key;\n                ref CoreStats coreStats = ref _entityCoreStats.GetValueRef(id);\n\n                if (!_entityManager.IsValid(id) || coreStats.Health &lt;= 0) continue; // Don't process dead entities\n\n                float activityMultiplier = GetActivityLevel(id); // 1x Idle, 2x Running, 5x Combat (conceptual)\n                float weatherMetabolismMultiplier = GetWeatherMultiplier(id);\n\n                // --- Hunger and Thirst Decay ---\n                coreStats.Hunger -= 1.0f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Hunger = Mathf.Max(0, coreStats.Hunger);\n\n                coreStats.Thirst -= 1.5f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Thirst = Mathf.Max(0, coreStats.Thirst);\n\n                // --- Body temperature adjustment ---\n                // ... (existing temp logic) ...\n\n                // --- Regeneration (Health, Stamina, Chakra, Stability) (TDD 03.4) ---\n                // GDD B12.11: Natural Healing Speed (slow)\n                // GDD B03.4: Strain Reset Mechanisms\n\n                float regenRateMultiplier = 1.0f;\n                if (activityMultiplier &gt; 1.0f) regenRateMultiplier = 0.5f; // Reduce regen if active\n                if (activityMultiplier &gt; 4.0f) regenRateMultiplier = 0.0f; // Halt regen if in combat (conceptual)\n\n                // Check for status effects that impair regeneration\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.ChakraDrain) || _statusEffectSystem.HasEffectOfType(id, EffectType.StabilityDrain))\n                {\n                    regenRateMultiplier *= 0.1f; // Severely impair regen\n                }\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.ControlImpair)) // e.g., Stun, Root\n                {\n                    regenRateMultiplier *= 0.5f; // Reduce regen\n                }\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.DamageOverTime)) // Bleeding/Burning\n                {\n                    regenRateMultiplier *= 0.2f; // Significantly impair regen\n                }\n\n                // Health Regen (only if not starving/dehydrated, and not in combat, and not full)\n                if (coreStats.Hunger &gt; 10 &amp;&amp; coreStats.Thirst &gt; 10 &amp;&amp; coreStats.Health &lt; coreStats.MaxHealth)\n                {\n                    coreStats.Health += coreStats.HealthRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Health = Mathf.Min(coreStats.MaxHealth, coreStats.Health);\n                }\n\n                // Stamina Regen (GDD B03.4)\n                if (coreStats.Stamina &lt; coreStats.MaxStamina)\n                {\n                    coreStats.Stamina += coreStats.StaminaRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Stamina = Mathf.Min(coreStats.MaxStamina, coreStats.Stamina);\n                }\n\n                // Chakra Regen (GDD B03.4)\n                if (coreStats.Chakra &lt; coreStats.MaxChakra)\n                {\n                    coreStats.Chakra += coreStats.ChakraRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Chakra = Mathf.Min(coreStats.MaxChakra, coreStats.Chakra);\n                }\n\n                // Stability Regen (GDD B03.6)\n                if (coreStats.Stability &lt; coreStats.MaxStability)\n                {\n                    coreStats.Stability += coreStats.StabilityRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Stability = Mathf.Min(coreStats.MaxStability, coreStats.Stability);\n                }\n\n                // --- Apply consequences of low stats ---\n                // ... (existing low stat consequences) ...\n\n                // Publish updates for the Body (e.g., UI for player)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerCoreStatsChangedEvent { PlayerID = id, NewCoreStats = coreStats });\n                }\n            }\n        }\n\n        public float GetActivityLevel(EntityID id)\n        {\n            // For player, activity is based on movement.\n            if (id == _entityManager.GetPlayerEntityID())\n            {\n                if (_movementSystem.GetVelocity(id).LengthSquared() &gt; 1.0f)\n                {\n                    return 2.0f; // 2x decay for running\n                }\n            }\n            return 1.0f; // Default 1x decay for idle/NPCs\n        }\n\n        // ... (GetWeatherMultiplier, GetCoreStatsRef, TryGetCoreStats methods) ...\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"36-chapter-36/#21-add-haseffectoftype-to-statuseffectsystemcs","title":"2.1. Add <code>HasEffectOfType</code> to <code>StatusEffectSystem.cs</code>","text":"<p><code>BiologicalSystem</code> needs to query active effects.</p> <p>Open <code>res://_Brain/Systems/StatusEffects/StatusEffectSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/StatusEffects/StatusEffectSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Core;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.StatusEffects\n{\n    // ... (EffectType, EffectDefinition, ActiveEffect structs/classes) ...\n\n    public class StatusEffectSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        public void Tick(double delta) { /* ... */ }\n        private void ApplyEffectTick(EntityID targetID, ActiveEffect effect) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Checks if an entity has any active effect of a specific type.\n        /// &lt;/summary&gt;\n        public bool HasEffectOfType(EntityID targetID, EffectType type)\n        {\n            if (_activeEffects.TryGetValue(targetID, out List&lt;ActiveEffect&gt; effects))\n            {\n                return effects.Any(e =&gt; e.Definition.Type == type);\n            }\n            return false;\n        }\n\n        // ... (GetActiveEffects, Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"36-chapter-36/#3-integrating-statuseffectsystem-into-biologicalsystem","title":"3. Integrating <code>StatusEffectSystem</code> into <code>BiologicalSystem</code>","text":"<ol> <li>Open <code>res://_Brain/Core/GameManager.cs</code>.</li> <li>Modify the <code>BiologicalSystem</code> initialization in <code>InitializeSystems()</code> to pass <code>StatusEffects</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize BiologicalSystem, passing StatusEffectSystem\n        Biology = new BiologicalSystem(Entities, Events, Transforms, Movement, Weather, StatusEffects); // Pass StatusEffects\n        GD.Print(\"  - BiologicalSystem initialized.\");\n// ...\n</code></pre>"},{"location":"36-chapter-36/#4-testing-dynamic-recovery","title":"4. Testing Dynamic Recovery","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe Health, Stamina, Chakra, and Stability on the HUD.<ul> <li>Idle Regeneration: Stand still. All four stats should slowly regenerate towards their max values.</li> <li>Active Regeneration: Move the player (WASD). Regeneration rates for all stats should decrease due to the <code>regenRateMultiplier</code> based on <code>activityMultiplier</code>.</li> <li>Impaired Regeneration (Conceptual): Use the debug console to apply a <code>DamageOverTime</code> effect (e.g., <code>/damage 1 Physical</code>, if <code>bleed_t1</code> is generated). You won't see the effect icon yet, but in the console, <code>DamageSystem</code> will apply the bleed, and <code>BiologicalSystem</code> will show reduced regeneration if <code>bleed_t1</code> is applied.</li> </ul> </li> </ol> <p>This confirms that the <code>Recovery Logic</code> in <code>BiologicalSystem</code> is dynamically adjusting regeneration rates based on activity and (conceptually) impairing them with status effects.</p>"},{"location":"36-chapter-36/#summary","title":"Summary","text":"<p>You have successfully implemented the Recovery Logic for <code>Health</code>, <code>Stamina</code>, <code>Chakra</code>, and <code>Stability</code> in the C# Brain, ensuring regeneration rates are dynamically influenced by <code>CoreStats</code> and <code>ActivityLevel</code>. By enhancing <code>BiologicalSystem</code> to apply a <code>regenRateMultiplier</code> and query <code>StatusEffectSystem</code> for impairments, you've created a comprehensive system for entity well-being, strictly adhering to TDD 03.4 and GDD B12.11's specifications. This crucial step adds depth to resource management and interaction with in-game conditions.</p>"},{"location":"36-chapter-36/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Environmental Pressure, where we will fully implement the <code>WeatherSystem</code> to manage global and local weather states, and design how environmental pressure (temperature, specific weather types) directly impacts <code>CoreStats</code> and biological processes.</p>"},{"location":"37-chapter-37/","title":"Chapter 5.8: Weather & Environment - Global Environmental State (C#)","text":""},{"location":"37-chapter-37/#chapter-58-weather-environment-global-environmental-state-c","title":"Chapter 5.8: Weather &amp; Environment - Global Environmental State (C#)","text":"<p>Our <code>BiologicalSystem</code> is now dynamically adjusting metabolism based on activity. The next step is to integrate environmental factors. This chapter focuses on fully implementing the WeatherSystem in the C# Brain to manage global and local weather states, and designing how environmental pressure (temperature, specific weather types) directly impacts <code>CoreStats</code> and biological processes, as specified in TDD 03.3 and GDD B14.7.</p>"},{"location":"37-chapter-37/#1-the-dynamic-nature-of-sigilbornes-environment","title":"1. The Dynamic Nature of Sigilborne's Environment","text":"<p>The GDD (B14.7, B14.8) emphasizes that weather and temperature alter gameplay, affecting: *   Visibility, stealth difficulty. *   Chakra stability. *   Movement. *   Residue spread. *   Sensing accuracy. *   And, crucially, fatigue rate (which ties into metabolism).</p> <p>Our <code>WeatherSystem</code> will be the authoritative source for all environmental conditions, providing a <code>GlobalWeatherState</code> that <code>BiologicalSystem</code> will use to modify entity <code>CoreStats</code>.</p>"},{"location":"37-chapter-37/#2-enhancing-weathersystemcs","title":"2. Enhancing <code>WeatherSystem.cs</code>","text":"<p>Our <code>WeatherSystem</code> currently exists as a placeholder. We'll expand it to: *   Use a <code>Random</code> instance for more dynamic transitions. *   Implement a more realistic (though still simple) cycle for <code>CurrentWeather</code>, <code>Temperature</code>, <code>WindDirection</code>, and <code>Humidity</code>. *   Ensure it publishes <code>GlobalWeatherChangedEvent</code> for the Body to react.</p> <p>Open <code>res://_Brain/Systems/Weather/WeatherSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Weather/WeatherSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core; // For EventBus, TimeSystem\nusing System.Linq; // For random weather selection\n\nnamespace Sigilborne.Systems.Weather\n{\n    /// &lt;summary&gt;\n    /// Stores the global weather state.\n    /// (TDD 03.3)\n    /// &lt;/summary&gt;\n    public struct GlobalWeatherState\n    {\n        public WeatherType CurrentWeather;\n        public Vector2 WindDirection; // Normalized vector\n        public float Temperature;     // Ambient Celsius\n        public float Humidity;        // 0-1 (0=dry, 1=humid)\n        public float Precipitation;   // 0-1 (0=none, 1=heavy)\n\n        public GlobalWeatherState(WeatherType currentWeather, Vector2 windDirection, float temperature, float humidity, float precipitation)\n        {\n            CurrentWeather = currentWeather;\n            WindDirection = windDirection;\n            Temperature = temperature;\n            Humidity = humidity;\n            Precipitation = precipitation;\n        }\n\n        public override string ToString()\n        {\n            return $\"Weather: {CurrentWeather}, Temp: {Temperature:F1}\u00b0C, Wind: {WindDirection}, Hum: {Humidity:P0}, Precip: {Precipitation:P0}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Manages the global and local weather states, and their transitions.\n    /// (TDD 03.3)\n    /// &lt;/summary&gt;\n    public class WeatherSystem\n    {\n        private EventBus _eventBus;\n        private TimeSystem _timeSystem;\n        private Random _rand; // New: Random instance for dynamic weather\n\n        private GlobalWeatherState _currentGlobalWeather;\n        private const float WEATHER_UPDATE_INTERVAL = 60.0f; // Update global weather every 60 game minutes (1 real minute)\n        private float _weatherUpdateTimer;\n\n        public WeatherSystem(EventBus eventBus, TimeSystem timeSystem, int worldSeed) // Add worldSeed for deterministic random\n        {\n            _eventBus = eventBus;\n            _timeSystem = timeSystem;\n            _rand = new Random(worldSeed + (int)timeSystem.CurrentGameTime); // Seed with world seed + current time\n\n            // Initialize with default clear weather\n            _currentGlobalWeather = new GlobalWeatherState(WeatherType.Clear, Vector2.Down, 20.0f, 0.5f, 0f);\n            GD.Print($\"WeatherSystem: Initialized. Current: {_currentGlobalWeather}\");\n\n            _eventBus.Publish(new GlobalWeatherChangedEvent { NewWeatherState = _currentGlobalWeather });\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the WeatherSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _weatherUpdateTimer += (float)delta;\n            if (_weatherUpdateTimer &gt;= WEATHER_UPDATE_INTERVAL)\n            {\n                UpdateGlobalWeather();\n                _weatherUpdateTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Simulates transitions in global weather.\n        /// (TDD 03.3)\n        /// &lt;/summary&gt;\n        private void UpdateGlobalWeather()\n        {\n            // --- Dynamic Weather Transition Logic ---\n            WeatherType newWeather = _currentGlobalWeather.CurrentWeather;\n            float newTemperature = _currentGlobalWeather.Temperature;\n            float newHumidity = _currentGlobalWeather.Humidity;\n            float newPrecipitation = _currentGlobalWeather.Precipitation;\n            Vector2 newWindDirection = _currentGlobalWeather.WindDirection;\n\n            // Simple chance to change weather\n            if (_rand.NextDouble() &lt; 0.3) // 30% chance to change every interval\n            {\n                // Select a random weather type (excluding None)\n                WeatherType[] possibleWeathers = Enum.GetValues(typeof(WeatherType))\n                                                    .Cast&lt;WeatherType&gt;()\n                                                    .Where(w =&gt; w != WeatherType.None)\n                                                    .ToArray();\n                newWeather = possibleWeathers[_rand.Next(possibleWeathers.Length)];\n            }\n\n            // Adjust temperature based on current weather and time of day (conceptual)\n            float baseTempChange = (float)(_rand.NextDouble() * 4 - 2); // +/- 2 C\n            newTemperature = Mathf.Clamp(newTemperature + baseTempChange, -10f, 40f);\n\n            // Adjust humidity and precipitation based on weather\n            switch (newWeather)\n            {\n                case WeatherType.Clear:\n                    newHumidity = Mathf.Lerp(newHumidity, 0.4f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 0f, 0.2f);\n                    break;\n                case WeatherType.Rain:\n                    newHumidity = Mathf.Lerp(newHumidity, 0.8f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 0.7f, 0.2f);\n                    break;\n                case WeatherType.Storm:\n                    newHumidity = Mathf.Lerp(newHumidity, 0.9f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 1.0f, 0.2f);\n                    newWindDirection = new Vector2((float)(_rand.NextDouble() * 2 - 1), (float)(_rand.NextDouble() * 2 - 1)).Normalized();\n                    break;\n                case WeatherType.Snow:\n                    newTemperature = Mathf.Min(newTemperature, 5f); // Ensure cold\n                    newHumidity = Mathf.Lerp(newHumidity, 0.6f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 0.8f, 0.2f);\n                    break;\n                case WeatherType.Fog:\n                    newHumidity = Mathf.Lerp(newHumidity, 0.9f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 0.1f, 0.2f);\n                    break;\n                case WeatherType.AshFall: // C04 specific weather\n                    newHumidity = Mathf.Lerp(newHumidity, 0.1f, 0.2f);\n                    newPrecipitation = Mathf.Lerp(newPrecipitation, 0.5f, 0.2f);\n                    break;\n            }\n\n            _currentGlobalWeather = new GlobalWeatherState(newWeather, newWindDirection, newTemperature, newHumidity, newPrecipitation);\n\n            GD.Print($\"WeatherSystem: Global weather updated to: {_currentGlobalWeather}\");\n            _eventBus.Publish(new GlobalWeatherChangedEvent { NewWeatherState = _currentGlobalWeather });\n        }\n\n        /// &lt;summary&gt;\n        /// Returns the current global weather state.\n        /// (TDD 03.3)\n        /// For more complex worlds, this would take a position and return local weather,\n        /// but for now, global applies everywhere.\n        /// &lt;/summary&gt;\n        public GlobalWeatherState GetCurrentGlobalWeather()\n        {\n            return _currentGlobalWeather;\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct GlobalWeatherChangedEvent { public GlobalWeatherState NewWeatherState; }\n    }\n}\n</code></pre>"},{"location":"37-chapter-37/#3-integrating-weathersystem-into-gamemanager","title":"3. Integrating <code>WeatherSystem</code> into <code>GameManager</code>","text":"<p>We already added the <code>WeatherSystem</code> property and initialized it. We just need to ensure <code>WorldSeed</code> is passed to its constructor.</p> <ol> <li>Add a <code>WorldSeed</code> property to <code>GameManager</code>.</li> <li>Modify the <code>WeatherSystem</code> initialization in <code>InitializeSystems()</code> to pass <code>GameManager.Instance.WorldSeed</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public WeatherSystem Weather { get; private set; }\n    public int WorldSeed { get; private set; } = 12345; // New: Store world seed\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n\n        // --- Test Damage &amp; Recovery Pipeline ---\n        // ... (existing damage tests) ...\n        // --- End Testing Damage &amp; Recovery Pipeline ---\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta); // Call WeatherSystem's tick method\n        Biology.Tick(delta);\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to PhysicsSystem) ...\n\n        // ... (existing magic system initializations) ...\n\n        // Initialize WeatherSystem BEFORE BiologicalSystem, pass WorldSeed\n        Weather = new WeatherSystem(Events, Time, WorldSeed); // Pass WorldSeed\n        GD.Print(\"  - WeatherSystem initialized.\");\n\n        // Initialize BiologicalSystem, passing WeatherSystem\n        Biology = new BiologicalSystem(Entities, Events, Transforms, Movement, Weather, StatusEffects);\n        GD.Print(\"  - BiologicalSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"37-chapter-37/#4-enhancing-biologicalsystemcs-with-full-environmental-pressure","title":"4. Enhancing <code>BiologicalSystem.cs</code> with Full Environmental Pressure","text":"<p>Now, <code>BiologicalSystem</code> will fully leverage the <code>WeatherSystem</code>'s data in <code>ProcessBioTick</code> to apply environmental pressure to <code>CoreStats</code>.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        // ... (existing fields) ...\n        private WeatherSystem _weatherSystem;\n        private StatusEffectSystem _statusEffectSystem;\n\n        public BiologicalSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, MovementSystem movementSystem, WeatherSystem weatherSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n            _statusEffectSystem = statusEffectSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"BiologicalSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnEntityDespawned, Tick methods) ...\n\n        private void ProcessBioTick()\n        {\n            foreach (var kvp in _entityCoreStats)\n            {\n                EntityID id = kvp.Key;\n                ref CoreStats coreStats = ref _entityCoreStats.GetValueRef(id);\n\n                if (!_entityManager.IsValid(id) || coreStats.Health &lt;= 0) continue;\n\n                float activityMultiplier = GetActivityLevel(id);\n\n                // --- Get Weather Multipliers (TDD 03.3) ---\n                float weatherMetabolismMultiplier = 1.0f; // Influences hunger/thirst decay\n                float weatherChakraStabilityPenalty = 0.0f; // Influences chakra stability (GDD B14.7)\n\n                GlobalWeatherState currentGlobalWeather = _weatherSystem.GetCurrentGlobalWeather();\n                float ambientTemperature = currentGlobalWeather.Temperature;\n\n                // Metabolism based on temperature deviation (GDD B14.8)\n                float tempDiff = Mathf.Abs(ambientTemperature - coreStats.NormalBodyTemp);\n                if (tempDiff &gt; 5f)\n                {\n                    weatherMetabolismMultiplier += tempDiff * 0.02f; // 2% increase per degree of deviation &gt; 5 deg\n                }\n                if (currentGlobalWeather.Precipitation &gt; 0.5f) // Rain/snow increases energy expenditure\n                {\n                    weatherMetabolismMultiplier += 0.1f;\n                }\n\n                // TDD 03.3: AshFall (C04) increases Chakra instability (GDD B14.7)\n                if (currentGlobalWeather.CurrentWeather == WeatherSystem.WeatherType.AshFall)\n                {\n                    weatherChakraStabilityPenalty += 1.0f; // Significant penalty\n                }\n                // --- END Weather Multipliers ---\n\n                // Hunger decay\n                coreStats.Hunger -= 1.0f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Hunger = Mathf.Max(0, coreStats.Hunger);\n\n                // Thirst decay\n                coreStats.Thirst -= 1.5f * activityMultiplier * weatherMetabolismMultiplier;\n                coreStats.Thirst = Mathf.Max(0, coreStats.Thirst);\n\n                // --- Body temperature adjustment (TDD 03.2) ---\n                // Slowly drift body temp towards ambient temp\n                coreStats.BodyTemp = Mathf.Lerp(coreStats.BodyTemp, ambientTemperature, 0.1f * BIO_TICK_RATE);\n                // Apply penalties for extreme body temp (GDD B14.8)\n                if (Mathf.Abs(coreStats.BodyTemp - coreStats.NormalBodyTemp) &gt; 10f)\n                {\n                    // Apply fatigue, stat penalties, or even health damage if severe.\n                    // coreStats.Stamina -= 1.0f * BIO_TICK_RATE; // Example: lose stamina from extreme temp\n                }\n\n                // --- Regeneration (Health, Stamina, Chakra, Stability) ---\n                float regenRateMultiplier = 1.0f;\n                if (activityMultiplier &gt; 1.0f) regenRateMultiplier = 0.5f;\n                if (activityMultiplier &gt; 4.0f) regenRateMultiplier = 0.0f;\n\n                // Impair regeneration from status effects\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.ChakraDrain) || _statusEffectSystem.HasEffectOfType(id, EffectType.StabilityDrain))\n                {\n                    regenRateMultiplier *= 0.1f;\n                }\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.ControlImpair))\n                {\n                    regenRateMultiplier *= 0.5f;\n                }\n                if (_statusEffectSystem.HasEffectOfType(id, EffectType.DamageOverTime))\n                {\n                    regenRateMultiplier *= 0.2f;\n                }\n\n                // Health Regen\n                if (coreStats.Hunger &gt; 10 &amp;&amp; coreStats.Thirst &gt; 10 &amp;&amp; coreStats.Health &lt; coreStats.MaxHealth)\n                {\n                    coreStats.Health += coreStats.HealthRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Health = Mathf.Min(coreStats.MaxHealth, coreStats.Health);\n                }\n\n                // Stamina Regen\n                if (coreStats.Stamina &lt; coreStats.MaxStamina)\n                {\n                    coreStats.Stamina += coreStats.StaminaRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Stamina = Mathf.Min(coreStats.MaxStamina, coreStats.Stamina);\n                }\n\n                // Chakra Regen\n                if (coreStats.Chakra &lt; coreStats.MaxChakra)\n                {\n                    coreStats.Chakra += coreStats.ChakraRegenRate * regenRateMultiplier * BIO_TICK_RATE;\n                    coreStats.Chakra = Mathf.Min(coreStats.MaxChakra, coreStats.Chakra);\n                }\n\n                // Stability Regen (GDD B03.6)\n                // Apply weather penalty here\n                coreStats.Stability += (coreStats.StabilityRegenRate * regenRateMultiplier - weatherChakraStabilityPenalty) * BIO_TICK_RATE;\n                coreStats.Stability = Mathf.Min(coreStats.MaxStability, coreStats.Stability);\n                coreStats.Stability = Mathf.Max(0, coreStats.Stability); // Clamp at 0 for now\n\n\n                // --- Apply consequences of low stats ---\n                // ... (existing low stat consequences) ...\n\n                // Publish updates for the Body (e.g., UI for player)\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerCoreStatsChangedEvent { PlayerID = id, NewCoreStats = coreStats });\n                }\n            }\n        }\n        // ... (GetActivityLevel, GetCoreStatsRef, TryGetCoreStats, Helper Events methods) ...\n    }\n}\n</code></pre>"},{"location":"37-chapter-37/#5-testing-weather-and-environmental-pressure","title":"5. Testing Weather and Environmental Pressure","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the Weather and Temperature labels on the HUD.<ul> <li>Every 1 real minute (60 game minutes), the weather should dynamically change (e.g., Clear -&gt; Rain -&gt; Fog -&gt; Clear).</li> <li>Temperature will fluctuate.</li> <li>When the weather changes (e.g., to Rain or if temperature deviates significantly), you should observe Hunger and Thirst decay rates increase due to <code>weatherMetabolismMultiplier</code>.</li> <li><code>BodyTemp</code> will slowly drift towards <code>AmbientTemperature</code>.</li> <li>(Optional Test): Use the debug console to force <code>AshFall</code> weather (e.g., <code>/weather set AshFall</code> - this command needs to be added to <code>DebugCommandSystem</code>). Observe Chakra stability decreasing due to <code>weatherChakraStabilityPenalty</code>.</li> </ul> </li> </ol> <p>This confirms that the <code>WeatherSystem</code> is active, dynamically updating the global environment, and <code>BiologicalSystem</code> is correctly applying environmental pressure to <code>CoreStats</code>'s metabolism and regeneration, including chakra stability.</p>"},{"location":"37-chapter-37/#summary","title":"Summary","text":"<p>You have successfully implemented the Weather &amp; Environment system, fully enhancing <code>WeatherSystem</code> in the C# Brain to manage dynamic global weather states. By integrating this system with <code>BiologicalSystem</code>, you've ensured that environmental pressures (temperature, precipitation, and specific weather types like AshFall) directly impact entity <code>CoreStats</code>'s metabolism, body temperature, and chakra stability. This crucial step strictly adheres to TDD 03.3 and GDD B14.7's specifications, creating a living, reactive environment that influences character well-being and strategic gameplay.</p>"},{"location":"37-chapter-37/#next-steps","title":"Next Steps","text":"<p>This concludes Module 5: Chakra &amp; Life Systems. We will now move on to Module 6: Combat &amp; Tactical Engagement, starting with Physics Layer - Hitbox &amp; Hurtbox Detection (GDScript), where we will set up Godot's <code>Area2D</code> nodes for collision detection in combat.</p>"},{"location":"38-chapter-38/","title":"Chapter 6.1: Physics Layer - Hitbox & Hurtbox Detection (GDScript)","text":""},{"location":"38-chapter-38/#chapter-61-physics-layer-hitbox-hurtbox-detection-gdscript","title":"Chapter 6.1: Physics Layer - Hitbox &amp; Hurtbox Detection (GDScript)","text":"<p>Welcome to Module 6: Combat &amp; Tactical Engagement! This module dives into the core mechanics of Sigilborne's combat system. The foundation of any combat interaction is collision detection. This chapter focuses on implementing Hitbox &amp; Hurtbox detection using Godot's <code>Area2D</code> nodes in the GDScript Body. These visual components will detect overlaps and send <code>HitEvent</code>s to the C# Brain for authoritative damage calculation, as specified in TDD 04.2.</p>"},{"location":"38-chapter-38/#1-the-role-of-hitboxes-and-hurtboxes","title":"1. The Role of Hitboxes and Hurtboxes","text":"<ul> <li>Hitbox: Represents the attacking part of an entity (e.g., a sword swing, a projectile). It defines \"where I am hitting.\"</li> <li>Hurtbox: Represents the vulnerable part of an entity (e.g., a character's body, a monster's head). It defines \"where I can be hit.\"</li> </ul> <p>Key Principles:</p> <ul> <li>Body-Owned: Hitboxes and Hurtboxes are <code>Area2D</code> nodes in the GDScript Body, responsible for detecting overlaps.</li> <li>Brain-Informed: When an overlap occurs, the Body sends a <code>HitEvent</code> to the C# Brain.</li> <li>Decoupled Logic: The Body does not calculate damage; it merely reports a potential hit. The Brain decides the outcome.</li> </ul>"},{"location":"38-chapter-38/#2-defining-physics-layers","title":"2. Defining Physics Layers","text":"<p>TDD 17.4 provides a standard for physics layers. We need to ensure these are set up in Godot's Project Settings.</p> <ol> <li>Go to <code>Project &gt; Project Settings... &gt; Layer Names &gt; 2D Physics</code>.</li> <li> <p>Rename the layers according to TDD 17.4:</p> Bit Layer Name 1 <code>World</code> 2 <code>Player</code> 3 <code>Enemy</code> 4 <code>Projectile</code> 5 <code>Interaction</code> 6 <code>Hitbox</code> </li> <li> <p>Close Project Settings.</p> </li> </ol>"},{"location":"38-chapter-38/#3-implementing-hurtboxes-for-entities","title":"3. Implementing Hurtboxes for Entities","text":"<p>Every living entity (player, NPC, animal) that can take damage needs a Hurtbox. This will be a child of our <code>EntityRoot.tscn</code> scene.</p> <ol> <li>Open <code>res://_Body/Scenes/Entities/EntityRoot.tscn</code>.</li> <li>Add an <code>Area2D</code> node as a child of <code>EntityRoot</code>.<ul> <li>Rename it <code>Hurtbox</code>.</li> <li>In the Inspector, set its <code>Collision Layer</code> to <code>Player</code> (for the player) or <code>Enemy</code> (for NPCs/animals).<ul> <li>For <code>EntityRoot</code>, let's default it to <code>Player</code> layer for now, and we'll change it dynamically for NPCs.</li> </ul> </li> <li>Set its <code>Collision Mask</code> to <code>Hitbox</code> (it should detect hits from Hitboxes).</li> </ul> </li> <li>Add a <code>CollisionShape2D</code> as a child of <code>Hurtbox</code>.<ul> <li>In the Inspector, set its <code>Shape</code> to <code>New CapsuleShape2D</code>.</li> <li>Select the <code>CapsuleShape2D</code> resource. Adjust its <code>Radius</code> (e.g., <code>8</code>) and <code>Height</code> (e.g., <code>20</code>) to roughly match a humanoid character.</li> <li>Position the <code>CollisionShape2D</code> (e.g., <code>y=-10</code>) to center it on the character.</li> </ul> </li> <li>Save <code>EntityRoot.tscn</code>.</li> </ol>"},{"location":"38-chapter-38/#4-implementing-hitboxes-for-attacks-conceptual","title":"4. Implementing Hitboxes for Attacks (Conceptual)","text":"<p>Hitboxes are typically attached to weapons, spell effects, or animation frames. For this chapter, we'll conceptually prepare for them.</p> <ul> <li>A weapon scene (e.g., <code>IronSword.tscn</code>) would have an <code>Area2D</code> child named <code>Hitbox</code>.</li> <li>A projectile scene (e.g., <code>Fireball.tscn</code>) would have an <code>Area2D</code> as its root or child.</li> </ul> <p>Common Hitbox Properties:</p> <ul> <li><code>Collision Layer</code>: <code>Hitbox</code>.</li> <li><code>Collision Mask</code>: <code>Player</code> or <code>Enemy</code> (who it can hit).</li> <li>Data: Hitboxes need to carry <code>DamageProfileID</code> (TDD 04.2) and <code>AttackerID</code> (who owns this hitbox).</li> </ul>"},{"location":"38-chapter-38/#5-hitevent-data-structure-brain","title":"5. <code>HitEvent</code> Data Structure (Brain)","text":"<p>When a <code>Hitbox</code> detects a <code>Hurtbox</code>, the Body needs to send precise data to the C# Brain. TDD 04.2 specifies <code>HitEvent</code>.</p> <ol> <li>Create <code>res://_Brain/Systems/Combat/HitEvent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/HitEvent.cs\nusing System;\nusing Godot; // For Vector2\nusing Sigilborne.Entities;\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Data describing a potential hit, sent from the GDScript Body to the C# Brain.\n    /// (TDD 04.2.2)\n    /// &lt;/summary&gt;\n    public struct HitEvent\n    {\n        public EntityID AttackerID;         // The entity that owns the hitbox.\n        public EntityID DefenderID;         // The entity that owns the hurtbox.\n        public string HitboxDefinitionID;   // ID of the hitbox (e.g., \"sword_slash_01\", \"fireball_projectile\").\n        public string HurtboxBodyPart;      // Which part of the defender was hit (e.g., \"head\", \"torso\").\n        public Vector2 HitPosition;         // World position where the hit occurred.\n        public Vector2 HitNormal;          // Normal vector of the collision (useful for knockback direction).\n\n        public HitEvent(EntityID attackerID, EntityID defenderID, string hitboxDefinitionID, string hurtboxBodyPart, Vector2 hitPosition, Vector2 hitNormal)\n        {\n            AttackerID = attackerID;\n            DefenderID = defenderID;\n            HitboxDefinitionID = hitboxDefinitionID;\n            HurtboxBodyPart = hurtboxBodyPart;\n            HitPosition = hitPosition;\n            HitNormal = hitNormal;\n        }\n\n        public override string ToString()\n        {\n            return $\"Hit! Attacker: {AttackerID}, Defender: {DefenderID}, Hitbox: '{HitboxDefinitionID}', Part: '{HurtboxBodyPart}', Pos: {HitPosition}\";\n        }\n    }\n}\n</code></pre>"},{"location":"38-chapter-38/#6-updating-entityviewgd-to-handle-hurtbox-detection","title":"6. Updating <code>EntityView.gd</code> to Handle Hurtbox Detection","text":"<p><code>EntityView.gd</code> will manage its <code>Hurtbox</code> and, when it detects an overlap, will call a C# method to register the hit.</p> <ol> <li>Open <code>res://_Body/Scripts/Visuals/EntityView.gd</code>.</li> <li>Add a new method <code>_on_hurtbox_area_entered</code> and connect it to the <code>Hurtbox</code> node's <code>area_entered</code> signal.</li> </ol> <pre><code># _Body/Scripts/Visuals/EntityView.gd\nclass_name EntityView extends CharacterBody2D\n\n# ... (existing properties and node references) ...\n@onready var hurtbox: Area2D = $Hurtbox # New: Reference to Hurtbox\n# @onready var hitbox: Area2D = $Hitbox # Conceptual: If this entity also has a hitbox\n\n\nfunc setup(id: int, initial_position: Vector2, initial_rotation: float, definition_id: String) -&gt; void:\n    entity_id = id\n    global_position = initial_position\n    brain_target_position = initial_position\n    brain_target_rotation_degrees = initial_rotation\n    visuals.rotation_degrees = initial_rotation\n\n    # ... (animation_player setup) ...\n\n    # --- Setup Hurtbox (TDD 04.2) ---\n    if hurtbox != null:\n        hurtbox.area_entered.connect(Callable(self, \"_on_hurtbox_area_entered\"))\n        # Set collision layer dynamically based on EntityType (conceptual)\n        # For now, EntityRoot is assumed to be player, so Player layer (bit 1) is set in scene.\n        # For NPC/Animal, it would be Enemy layer (bit 2).\n        # if definition_id.begins_with(\"player\"):\n        #     hurtbox.set_collision_layer_value(1, true) # Player layer\n        #     hurtbox.set_collision_layer_value(2, false) # Not Enemy layer\n        # else: # NPC/Animal\n        #     hurtbox.set_collision_layer_value(1, false)\n        #     hurtbox.set_collision_layer_value(2, true) # Enemy layer\n        GD.print(\"EntityView %s: Hurtbox initialized.\" % entity_id)\n\n    GD.print(\"EntityView: Setup for C# EntityID %s (Def: %s) at %s\" % [entity_id, definition_id, global_position])\n\n    # ... (existing C# event connections) ...\n    pass\n\n# ... (existing _physics_process, _on_entity_moved_reconciliation, _on_entity_velocity_update,\n#      _on_animation_finished, _on_anim_track_event, play_animation methods) ...\n\n\n## Handles when a Hitbox enters this entity's Hurtbox.\n## (TDD 04.2.2: Body detects collision via area_entered signal)\nfunc _on_hurtbox_area_entered(other_area: Area2D) -&gt; void:\n    # Check if the other_area is a Hitbox (e.g., by checking its collision layer or name)\n    # For now, we'll assume any Area2D on the Hitbox layer is a valid hitbox.\n    if other_area.get_collision_layer_value(6): # Layer 6 is Hitbox\n        # We need to get information from the Hitbox itself.\n        # Hitboxes should carry data like AttackerID and HitboxDefinitionID.\n        # For now, let's assume the Hitbox has a script or metadata attached.\n\n        # Conceptual: Get data from the Hitbox (e.g., from its parent EntityView script if it's a weapon)\n        var hitbox_attacker_id: int = -1 # Placeholder\n        var hitbox_def_id: String = \"unknown_hitbox\" # Placeholder\n\n        # Example: If the hitbox is part of a projectile, its parent EntityView would be the projectile.\n        # If it's a weapon swing, its parent EntityView would be the attacker.\n        var attacker_entity_view: EntityView = other_area.get_parent_node_3d() # Or get_parent() if 2D\n        if attacker_entity_view != null and attacker_entity_view is EntityView:\n            hitbox_attacker_id = attacker_entity_view.entity_id\n            # We would also get hitbox_def_id from the attacker_entity_view's current attack definition.\n\n        # Get hit position and normal\n        var hit_position: Vector2 = other_area.global_position # Simple approximation\n        var hit_normal: Vector2 = (global_position - other_area.global_position).normalized() # Normal from hitbox to hurtbox center\n\n        # Get hurtbox body part (conceptual for now, could be dynamic based on hit location)\n        var hurtbox_body_part: String = \"torso\"\n\n        # TDD 04.2.2: Body sends HitEvent to the Brain.\n        if GameManager.Instance != null and GameManager.Instance.Combat != null:\n            # We need to pass EntityID structs, not just indices.\n            # GameManager.Instance.Entities.GetEntityMeta(entity_id).Generation\n            var defender_entity_id_struct = GameManager.Instance.Entities.GetEntityMeta(entity_id)\n            var attacker_entity_id_struct = GameManager.Instance.Entities.GetEntityMeta(hitbox_attacker_id)\n\n            # Create a C# HitEvent struct and pass it.\n            var hit_event = HitEvent.new() # Instantiate C# struct via Godot binding\n            hit_event.AttackerID = attacker_entity_id_struct # Need a way to convert int to EntityID struct\n            hit_event.DefenderID = defender_entity_id_struct\n            hit_event.HitboxDefinitionID = hitbox_def_id\n            hit_event.HurtboxBodyPart = hurtbox_body_part\n            hit_event.HitPosition = hit_position\n            hit_event.HitNormal = hit_normal\n\n            GameManager.Instance.Combat.RegisterHit(hit_event) # Call C# method\n            get_viewport().set_input_as_handled() # Prevent multiple hits from one frame if needed.\n        else:\n            push_error(\"EntityView: GameManager or CombatSystem not ready to register hit.\")\n</code></pre> <p>Key Changes in <code>EntityView.gd</code>:</p> <ul> <li><code>@onready var hurtbox</code>: Gets a reference to the <code>Hurtbox</code> node.</li> <li><code>setup()</code>: Connects <code>hurtbox.area_entered</code> signal.</li> <li><code>_on_hurtbox_area_entered()</code>:<ul> <li>This is the signal handler for incoming hits.</li> <li>It conceptually extracts <code>AttackerID</code> and <code>HitboxDefinitionID</code> from the <code>other_area</code> (the hitbox).</li> <li>It gathers <code>HitPosition</code> and <code>HitNormal</code>.</li> <li>Crucially: It creates a C# <code>HitEvent</code> struct instance and calls <code>GameManager.Instance.Combat.RegisterHit(hit_event)</code> to send the data to the Brain.</li> </ul> </li> </ul>"},{"location":"38-chapter-38/#61-update-entitymanagercs-for-getentitymeta-for-gdscript","title":"6.1. Update <code>EntityManager.cs</code> for <code>GetEntityMeta</code> for GDScript","text":"<p><code>EntityView.gd</code> needs to get the full <code>EntityID</code> struct, not just the index, to reconstruct it for the <code>HitEvent</code>.</p> <p>Open <code>res://_Brain/Entities/EntityManager.cs</code> and add this helper method:</p> <pre><code>// _Brain/Entities/EntityManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\n\nnamespace Sigilborne.Entities\n{\n    // ... (EntityID, EntityMeta, EntityType structs/enums) ...\n\n    public class EntityManager\n    {\n        // ... (existing fields and constructor) ...\n\n        /// &lt;summary&gt;\n        /// Retrieves the EntityMeta struct for a given entity index.\n        /// Primarily for GDScript interop to reconstruct EntityID from index.\n        /// &lt;/summary&gt;\n        public EntityMeta GetEntityMeta(int index)\n        {\n            if (index &lt; 0 || index &gt;= MAX_ENTITIES)\n            {\n                GD.PrintErr($\"EntityManager: Invalid index {index} requested for GetEntityMeta.\");\n                return new EntityMeta { Generation = -1, IsActive = false, Type = EntityType.Invalid, DefinitionID = \"invalid\" };\n            }\n            return _entityMetas[index];\n        }\n\n        // ... (other methods) ...\n    }\n}\n</code></pre>"},{"location":"38-chapter-38/#7-implementing-combatsystemcs-brain-backend","title":"7. Implementing <code>CombatSystem.cs</code> (Brain Backend)","text":"<p>This is the system that will receive the <code>HitEvent</code> from GDScript and orchestrate damage calculation.</p> <ol> <li>Open <code>res://_Brain/Systems/Combat/DamageSystem.cs</code> and rename the class to <code>CombatSystem</code> (as per TDD 04).</li> <li>Add a <code>RegisterHit</code> method.</li> </ol> <pre><code>// _Brain/Systems/Combat/CombatSystem.cs (formerly DamageSystem.cs)\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.StatusEffects;\n\nnamespace Sigilborne.Systems.Combat\n{\n    // ... (DamageType, DamageResult structs/enums) ...\n    // ... (HitEvent struct) ...\n\n    /// &lt;summary&gt;\n    /// Manages the full combat pipeline: receiving hit events, damage calculation,\n    /// application to CoreStats, and generation of StatusEffects (wounds).\n    /// (TDD 03.4, TDD 04.2, TDD 04.3)\n    /// &lt;/summary&gt;\n    public class CombatSystem // Renamed from DamageSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem;\n        private StatusEffectSystem _statusEffectSystem;\n\n        public CombatSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _statusEffectSystem = statusEffectSystem;\n            GD.Print(\"CombatSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a hit event received from the GDScript Body.\n        /// (TDD 04.2.2: Body sends HitEvent to the Brain, Brain calculates the result)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"hitEvent\"&gt;The HitEvent data from the Body.&lt;/param&gt;\n        public void RegisterHit(HitEvent hitEvent)\n        {\n            // Basic validation\n            if (!_entityManager.IsValid(hitEvent.AttackerID) || !_entityManager.IsValid(hitEvent.DefenderID))\n            {\n                GD.PrintErr($\"CombatSystem: Invalid attacker or defender in hit event: {hitEvent}.\");\n                return;\n            }\n\n            GD.Print($\"CombatSystem: Received hit event: {hitEvent}.\");\n\n            // --- Actual damage calculation (from previous ApplyDamage logic) ---\n            // For now, let's use a dummy raw damage based on hitbox ID.\n            float rawDamage = 10f; // Default\n            DamageType damageType = DamageType.Physical; // Default\n            float penetration = 0f;\n\n            if (hitEvent.HitboxDefinitionID.Contains(\"fireball\"))\n            {\n                rawDamage = 25f;\n                damageType = DamageType.Elemental;\n            }\n            else if (hitEvent.HitboxDefinitionID.Contains(\"void\"))\n            {\n                rawDamage = 30f;\n                damageType = DamageType.Residue;\n            }\n\n            // Call the core damage application logic.\n            ApplyDamage(hitEvent.AttackerID, hitEvent.DefenderID, rawDamage, damageType, penetration);\n        }\n\n\n        /// &lt;summary&gt;\n        /// Calculates and applies damage to a target entity.\n        /// This is the entry point for all damage in the game.\n        /// (TDD 03.4: Damage Pipeline)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"attackerID\"&gt;The entity dealing damage.&lt;/param&gt;\n        /// &lt;param name=\"defenderID\"&gt;The entity receiving damage.&lt;/param&gt;\n        /// &lt;param name=\"rawDamage\"&gt;The base damage value.&lt;/param&gt;\n        /// &lt;param name=\"damageType\"&gt;The type of damage.&lt;/param&gt;\n        /// &lt;param name=\"penetration\"&gt;How much the damage ignores defender's mitigation.&lt;/param&gt;\n        /// &lt;returns&gt;The final DamageResult.&lt;/returns&gt;\n        public DamageResult ApplyDamage(EntityID attackerID, EntityID defenderID, float rawDamage, DamageType damageType, float penetration = 0f)\n        {\n            // ... (existing ApplyDamage logic from previous chapter) ...\n            if (!_biologicalSystem.TryGetCoreStats(defenderID, out CoreStats defenderStats))\n            {\n                GD.PrintErr($\"CombatSystem: Defender {defenderID} has no CoreStats. Cannot apply damage.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, defenderID);\n            }\n\n            float mitigation = 0;\n            switch (damageType)\n            {\n                case DamageType.Physical:\n                    mitigation = defenderStats.Armor * (1.0f - penetration);\n                    break;\n                case DamageType.Chakra:\n                case DamageType.Elemental:\n                case DamageType.Spiritual:\n                case DamageType.Residue:\n                    mitigation = defenderStats.MagicResistance * (1.0f - penetration);\n                    break;\n                case DamageType.Internal:\n                    mitigation = 0; // Internal damage often bypasses armor\n                    break;\n            }\n            float finalDamage = rawDamage - mitigation;\n            finalDamage = Mathf.Max(0, finalDamage);\n\n            bool isCrit = false;\n            bool isBlocked = false;\n\n            DamageResult result = new DamageResult(finalDamage, isCrit, isBlocked, damageType, attackerID, defenderID);\n            GD.Print($\"CombatSystem: {attackerID} dealt {result} to {defenderID}.\");\n\n            if (result.FinalDamage &gt; 0)\n            {\n                ref CoreStats targetCoreStats = ref _biologicalSystem.GetCoreStatsRef(defenderID);\n                targetCoreStats.Health -= result.FinalDamage;\n                if (targetCoreStats.Health &lt; 0) targetCoreStats.Health = 0;\n\n                if (defenderID == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = defenderID, NewValue = targetCoreStats.Health, MaxValue = targetCoreStats.MaxHealth });\n                }\n\n                GenerateWounds(defenderID, result);\n\n                if (targetCoreStats.Health == 0)\n                {\n                    GD.Print($\"CombatSystem: {defenderID} has been defeated!\");\n                    if (defenderID == _entityManager.GetPlayerEntityID())\n                    {\n                        _eventBus.Publish(new PlayerStatSystem.PlayerDiedEvent { PlayerID = defenderID });\n                    }\n                }\n            }\n            return result;\n        }\n\n        private void GenerateWounds(EntityID targetID, DamageResult result)\n        {\n            // ... (existing GenerateWounds logic) ...\n            if (result.FinalDamage &lt;= 0) return;\n\n            float woundChance = result.FinalDamage / _biologicalSystem.GetCoreStatsRef(targetID).MaxHealth;\n            if (woundChance &gt; 0.1f)\n            {\n                Random rand = new Random(targetID.Index + (int)GameManager.Instance.Time.CurrentGameTime);\n                if (rand.NextDouble() &lt; woundChance)\n                {\n                    string effectId = \"\";\n                    float duration = 0;\n                    float strength = 0;\n\n                    switch (result.Type)\n                    {\n                        case DamageType.Physical:\n                            effectId = \"bleed_t1\";\n                            duration = 5f;\n                            strength = result.FinalDamage * 0.05f;\n                            break;\n                        case DamageType.Elemental:\n                            effectId = \"burn_t1\";\n                            duration = 3f;\n                            strength = result.FinalDamage * 0.03f;\n                            break;\n                        case DamageType.Chakra:\n                            effectId = \"chakra_drain_t1\";\n                            duration = 2f;\n                            strength = result.FinalDamage * 0.02f;\n                            break;\n                        case DamageType.Residue:\n                            effectId = \"void_sickness_t1\";\n                            duration = 10f;\n                            strength = result.FinalDamage * 0.01f;\n                            break;\n                        default:\n                            return;\n                    }\n\n                    if (!string.IsNullOrEmpty(effectId))\n                    {\n                        _statusEffectSystem.ApplyEffect(targetID, new StatusEffectData(effectId, duration, strength), result.AttackerID);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"38-chapter-38/#8-updating-gamemanager-to-reflect-combatsystem","title":"8. Updating <code>GameManager</code> to Reflect <code>CombatSystem</code>","text":"<ol> <li>Rename <code>Combat</code> property in <code>GameManager</code> from <code>DamageSystem</code> to <code>CombatSystem</code>.</li> <li>Update its initialization in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\n// ...\nusing Sigilborne.Systems.Combat; // Add this using directive\n// ...\n\npublic partial class GameManager : Node\n{\n    // ... (existing system properties) ...\n    public CombatSystem Combat { get; private set; } // Renamed from DamageSystem\n\n    public override void _Ready()\n    {\n        // ... (existing test code) ...\n\n        // --- Test Damage &amp; Recovery Pipeline ---\n        GD.Print(\"\\n--- Testing Damage &amp; Recovery Pipeline ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        // Get NPC ID assuming it's still ID 1, Gen 1\n        // We need a way to get the Generation dynamically for NPCs.\n        // For now, let's just create a dummy NPC for this test.\n        EntityID testNpcID = Entities.CreateEntity(EntityType.NPC, \"test_dummy_npc\", new Vector2(500, 200));\n\n        GD.Print($\"Player initial HP: {Biology.GetCoreStatsRef(playerID).Health}\");\n        GD.Print($\"Test NPC initial HP: {Biology.GetCoreStatsRef(testNpcID).Health}\");\n\n        // Player attacks NPC (will be triggered by HitEvent from GDScript)\n        // For testing, we'll manually call RegisterHit.\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_sword_slash\", \"torso\", new Vector2(450, 200), Vector2.Left));\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_fireball\", \"torso\", new Vector2(450, 200), Vector2.Left));\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_void_blast\", \"torso\", new Vector2(450, 200), Vector2.Left)); // Should trigger void sickness\n\n        // NPC attacks Player (will be triggered by HitEvent from GDScript)\n        // For testing, we'll manually call RegisterHit.\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_claw\", \"torso\", new Vector2(250, 200), Vector2.Right));\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_poison_spit\", \"torso\", new Vector2(250, 200), Vector2.Right));\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_heavy_hit\", \"torso\", new Vector2(250, 200), Vector2.Right)); // Should kill player\n\n        GD.Print(\"--- End Testing Damage &amp; Recovery Pipeline ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to BiologicalSystem) ...\n\n        // Initialize StatusEffectSystem BEFORE CombatSystem\n        StatusEffects = new StatusEffectSystem(Entities, Events, BiologicalSystem);\n        GD.Print(\"  - StatusEffectSystem initialized.\");\n\n        // Initialize CombatSystem (renamed from DamageSystem), passing BiologicalSystem and StatusEffectSystem\n        Combat = new CombatSystem(Entities, Events, BiologicalSystem, StatusEffects); // Renamed to CombatSystem\n        GD.Print(\"  - CombatSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"38-chapter-38/#9-testing-hitbox-hurtbox-detection-conceptual","title":"9. Testing Hitbox &amp; Hurtbox Detection (Conceptual)","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>The console output will show the direct <code>CombatSystem.RegisterHit</code> calls and their results.</li> </ol> <p>To truly test the GDScript -&gt; C# Hitbox/Hurtbox pipeline:</p> <ul> <li>You would need to create a dummy <code>Hitbox</code> scene (e.g., a simple <code>Area2D</code> with <code>CollisionShape2D</code> on layer <code>Hitbox</code>).</li> <li>Attach a script to this <code>Hitbox</code> that, when it enters another <code>Area2D</code> on <code>Player</code> or <code>Enemy</code> layer, calls <code>GameManager.Instance.Combat.RegisterHit()</code> with appropriate <code>EntityID</code>s.</li> <li>For now, our manual calls in <code>GameManager._Ready()</code> simulate this, showing that the C# backend is ready to process these events.</li> </ul> <p>This confirms the C# backend for combat is ready to receive <code>HitEvent</code>s from the GDScript Body.</p>"},{"location":"38-chapter-38/#summary","title":"Summary","text":"<p>You have successfully implemented the foundational Hitbox &amp; Hurtbox detection system for Sigilborne's combat. By defining <code>DamageType</code>, <code>DamageResult</code>, and <code>HitEvent</code> structs, and enhancing <code>CombatSystem</code> (formerly <code>DamageSystem</code>) to receive and process <code>HitEvent</code>s from the GDScript Body, you've established the core pipeline for collision detection and authoritative damage calculation. <code>EntityView.gd</code> is prepared to manage its <code>Hurtbox</code> and send <code>HitEvent</code>s, strictly adhering to TDD 04.2's specifications. This crucial step enables systemic and precise combat interactions.</p>"},{"location":"38-chapter-38/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on The Math Layer, where we will fully implement the <code>Damage Calculator</code> within the C# <code>CombatSystem</code>, incorporating <code>CoreStats</code> (Armor, MagicResistance) and advanced formulas to determine final damage, critical hits, and blocks.</p>"},{"location":"39-chapter-39/","title":"Chapter 6.2: The Math Layer - Damage Calculator (C#)","text":""},{"location":"39-chapter-39/#chapter-62-the-math-layer-damage-calculator-c","title":"Chapter 6.2: The Math Layer - Damage Calculator (C#)","text":"<p>Our <code>CombatSystem</code> can now receive <code>HitEvent</code>s and trigger the damage application. This chapter focuses on fully implementing The Math Layer within the C# <code>CombatSystem</code>, specifically the <code>Damage Calculator</code>. We'll incorporate <code>CoreStats</code> (Armor, MagicResistance, BaseDamage, AttackSpeed) and other factors to determine the <code>FinalDamage</code>, <code>IsCrit</code>, and <code>IsBlocked</code> values, as specified in TDD 04.3.</p>"},{"location":"39-chapter-39/#1-the-importance-of-an-authoritative-damage-calculator","title":"1. The Importance of an Authoritative Damage Calculator","text":"<ul> <li>Determinism: All damage calculations happen in the C# Brain, ensuring consistent results.</li> <li>Balance: Centralized formulas make it easier to balance combat.</li> <li>Complexity: Allows for intricate interactions between stats, damage types, and status effects.</li> <li>GDD Alignment: Supports mastery-based damage scaling (B12.3) and variable realism (B12.2).</li> </ul>"},{"location":"39-chapter-39/#2-enhancing-combatsystemcs-for-damage-calculation","title":"2. Enhancing <code>CombatSystem.cs</code> for Damage Calculation","text":"<p>Our <code>CombatSystem</code> already has an <code>ApplyDamage</code> method that performs basic mitigation. We'll expand it to include more sophisticated calculations for critical hits, blocks, and to use <code>CoreStats</code> more thoroughly.</p> <p>Open <code>res://_Brain/Systems/Combat/CombatSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Combat/CombatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Magic; // For SpellDefinition if spells have base damage\n\nnamespace Sigilborne.Systems.Combat\n{\n    // ... (DamageType, DamageResult, HitEvent structs/enums) ...\n\n    public class CombatSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem;\n        private StatusEffectSystem _statusEffectSystem;\n\n        public CombatSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _statusEffectSystem = statusEffectSystem;\n            GD.Print(\"CombatSystem: Initialized.\");\n        }\n\n        public void RegisterHit(HitEvent hitEvent)\n        {\n            if (!_entityManager.IsValid(hitEvent.AttackerID) || !_entityManager.IsValid(hitEvent.DefenderID))\n            {\n                GD.PrintErr($\"CombatSystem: Invalid attacker or defender in hit event: {hitEvent}.\");\n                return;\n            }\n\n            GD.Print($\"CombatSystem: Received hit event: {hitEvent}.\");\n\n            // --- Determine Raw Damage and Type from Hitbox Definition (Conceptual) ---\n            // In a real game, this would query an \"AttackDefinition\" database based on hitEvent.HitboxDefinitionID.\n            // For now, we'll use placeholder logic.\n            float baseRawDamage = 0f;\n            DamageType damageType = DamageType.Physical;\n            float penetration = 0f;\n            float critChance = 0.05f; // 5% base crit chance\n            float critMultiplier = 1.5f; // 150% crit damage\n\n            // Example: If attacker has a weapon, use its stats. If it's a spell, use SpellDefinition.\n            // For now, let's use attacker's BaseDamage from CoreStats.\n            if (_biologicalSystem.TryGetCoreStats(hitEvent.AttackerID, out CoreStats attackerStats))\n            {\n                baseRawDamage = attackerStats.BaseDamage;\n                // critChance += attackerStats.CritChanceBonus; // Conceptual\n            }\n\n            if (hitEvent.HitboxDefinitionID.Contains(\"fireball\"))\n            {\n                baseRawDamage = 25f;\n                damageType = DamageType.Elemental;\n            }\n            else if (hitEvent.HitboxDefinitionID.Contains(\"void\"))\n            {\n                baseRawDamage = 30f;\n                damageType = DamageType.Residue;\n            }\n            // --- End Raw Damage Determination ---\n\n            // Call the core damage application logic.\n            ApplyDamage(hitEvent.AttackerID, hitEvent.DefenderID, baseRawDamage, damageType, penetration, critChance, critMultiplier);\n        }\n\n\n        /// &lt;summary&gt;\n        /// Calculates and applies damage to a target entity.\n        /// This is the entry point for all damage in the game.\n        /// (TDD 03.4: Damage Pipeline, TDD 04.3: Damage Calculator)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"attackerID\"&gt;The entity dealing damage.&lt;/param&gt;\n        /// &lt;param name=\"defenderID\"&gt;The entity receiving damage.&lt;/param&gt;\n        /// &lt;param name=\"rawDamage\"&gt;The base damage value.&lt;/param&gt;\n        /// &lt;param name=\"damageType\"&gt;The type of damage.&lt;/param&gt;\n        /// &lt;param name=\"penetration\"&gt;How much the damage ignores defender's mitigation (0-1).&lt;/param&gt;\n        /// &lt;param name=\"critChance\"&gt;Base chance for a critical hit (0-1).&lt;/param&gt;\n        /// &lt;param name=\"critMultiplier\"&gt;Multiplier for critical hit damage (e.g., 1.5 for 150%).&lt;/param&gt;\n        /// &lt;returns&gt;The final DamageResult.&lt;/returns&gt;\n        public DamageResult ApplyDamage(EntityID attackerID, EntityID defenderID, float rawDamage, DamageType damageType, float penetration, float critChance, float critMultiplier)\n        {\n            if (!_biologicalSystem.TryGetCoreStats(defenderID, out CoreStats defenderStats))\n            {\n                GD.PrintErr($\"CombatSystem: Defender {defenderID} has no CoreStats. Cannot apply damage.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, defenderID);\n            }\n\n            // --- 1. Base Damage --- (TDD 04.3)\n            float calculatedDamage = rawDamage;\n\n            // --- 2. Mitigation (Armor, Magic Resistance) --- (TDD 03.4, TDD 04.3)\n            float mitigation = 0;\n            switch (damageType)\n            {\n                case DamageType.Physical:\n                    mitigation = defenderStats.Armor * (1.0f - penetration);\n                    break;\n                case DamageType.Chakra:\n                case DamageType.Elemental:\n                case DamageType.Spiritual:\n                case DamageType.Residue:\n                    mitigation = defenderStats.MagicResistance * (1.0f - penetration);\n                    break;\n                case DamageType.Internal:\n                    mitigation = 0; // Internal damage often bypasses armor\n                    break;\n            }\n            calculatedDamage -= mitigation;\n            calculatedDamage = Mathf.Max(0, calculatedDamage); // Damage cannot be negative\n\n            // --- 3. Critical Hit &amp; Block Logic --- (TDD 04.3)\n            bool isCrit = false;\n            bool isBlocked = false; // Placeholder for block logic\n\n            // Use a deterministic random number generator (seeded by time + entity IDs)\n            Random rand = new Random(attackerID.Index + defenderID.Index + (int)GameManager.Instance.Time.CurrentGameTime);\n\n            // Critical Hit (TDD 04.3)\n            if (rand.NextDouble() &lt; critChance)\n            {\n                isCrit = true;\n                calculatedDamage *= critMultiplier;\n            }\n\n            // Block (Conceptual: Implement block chance/mechanic here)\n            // if (rand.NextDouble() &lt; defenderStats.BlockChance) { isBlocked = true; calculatedDamage *= defenderStats.BlockReduction; }\n\n            // --- 4. Multipliers (TDD 04.3) ---\n            // Add other multipliers here (e.g., backstab, status effect vulnerabilities, environmental bonuses)\n            // if (IsBackstab(attacker, defender)) calculatedDamage *= 1.5f; // Conceptual\n\n            // Final damage result\n            DamageResult result = new DamageResult(calculatedDamage, isCrit, isBlocked, damageType, attackerID, defenderID);\n            GD.Print($\"CombatSystem: {attackerID} dealt {result} to {defenderID}.\");\n\n            // --- 5. Application to Health &amp; Wound Generation --- (TDD 03.4)\n            if (result.FinalDamage &gt; 0)\n            {\n                ref CoreStats targetCoreStats = ref _biologicalSystem.GetCoreStatsRef(defenderID);\n                targetCoreStats.Health -= result.FinalDamage;\n                if (targetCoreStats.Health &lt; 0) targetCoreStats.Health = 0;\n\n                // Publish health change (PlayerStatSystem already does this for player)\n                if (defenderID == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = defenderID, NewValue = targetCoreStats.Health, MaxValue = targetCoreStats.MaxHealth });\n                }\n                // For NPCs, we'd need a generic EntityHealthChangedEvent.\n\n                // 4. Wound Generation (TDD 03.4)\n                GenerateWounds(defenderID, result);\n\n                if (targetCoreStats.Health == 0)\n                {\n                    GD.Print($\"CombatSystem: {defenderID} has been defeated!\");\n                    if (defenderID == _entityManager.GetPlayerEntityID())\n                    {\n                        _eventBus.Publish(new PlayerStatSystem.PlayerDiedEvent { PlayerID = defenderID });\n                    }\n                    // _eventBus.Publish(new EntityDefeatedEvent { EntityID = defenderID, KillerID = attackerID });\n                }\n            }\n            // TDD 04.2.2: Body (GDScript) reacts to OnDamageTaken signal.\n            // This event is already implicitly handled by PlayerStatSystem.PlayerHealthChangedEvent for players.\n            // For general entities, we might need a more generic event.\n            _eventBus.Publish(new DamageTakenEvent { DefenderID = defenderID, Result = result }); // New generic event for visual feedback\n            return result;\n        }\n\n        private void GenerateWounds(EntityID targetID, DamageResult result)\n        {\n            // ... (existing GenerateWounds logic) ...\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct DamageTakenEvent { public EntityID DefenderID; public DamageResult Result; } // New event\n    }\n}\n</code></pre>"},{"location":"39-chapter-39/#21-update-corestatscs-with-combat-related-stats","title":"2.1. Update <code>CoreStats.cs</code> with Combat-Related Stats","text":"<p>We need to add <code>CritChance</code>, <code>CritMultiplier</code>, and <code>BlockChance</code> (conceptual) to <code>CoreStats</code>.</p> <p>Open <code>res://_Brain/Systems/Biology/CoreStats.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/CoreStats.cs\nusing System;\nusing Godot;\n\nnamespace Sigilborne.Systems.Biology\n{\n    public struct CoreStats\n    {\n        // ... (existing survival/biological stats) ...\n\n        // --- Combat/Magic-related Stats ---\n        public float BaseDamage;\n        public float AttackSpeed;\n        public float Armor;\n        public float MagicResistance;\n        public float MoveSpeed;\n        public float SprintMultiplier;\n        public float CastSpeed;\n        public float Stability;\n        public float MaxStability;\n        public float StabilityRegenRate;\n        public float ChakraRegenRate;\n        public float StaminaRegenRate;\n        public float CritChance;       // New: Chance to land a critical hit (0-1)\n        public float CritMultiplier;   // New: Multiplier for critical hit damage (e.g., 1.5)\n        public float BlockChance;      // New: Chance to block an attack (0-1)\n        public float BlockReduction;   // New: Percentage damage reduction on block (0-1)\n\n        public CoreStats(float maxHealth, float maxStamina, float maxChakra, float baseDamage = 10f, float attackSpeed = 1.0f,\n                         float armor = 0f, float magicResistance = 0f, float moveSpeed = 150f, float sprintMultiplier = 1.5f,\n                         float castSpeed = 1.0f, float maxStability = 100f, float stabilityRegenRate = 5f,\n                         float chakraRegenRate = 2f, float staminaRegenRate = 10f, float normalBodyTemp = 37.0f,\n                         float critChance = 0.05f, float critMultiplier = 1.5f, float blockChance = 0f, float blockReduction = 0.5f) // New params\n        {\n            MaxHealth = maxHealth;\n            Health = maxHealth;\n            MaxStamina = maxStamina;\n            Stamina = maxStamina;\n            MaxChakra = maxChakra;\n            Chakra = maxChakra;\n            MaxHunger = 100f;\n            Hunger = MaxHunger;\n            MaxThirst = 100f;\n            Thirst = MaxThirst;\n            NormalBodyTemp = normalBodyTemp;\n            BodyTemp = normalBodyTemp;\n\n            BaseDamage = baseDamage;\n            AttackSpeed = attackSpeed;\n            Armor = armor;\n            MagicResistance = magicResistance;\n            MoveSpeed = moveSpeed;\n            SprintMultiplier = sprintMultiplier;\n            CastSpeed = castSpeed;\n            MaxStability = maxStability;\n            Stability = MaxStability;\n            StabilityRegenRate = stabilityRegenRate;\n            ChakraRegenRate = chakraRegenRate;\n            StaminaRegenRate = staminaRegenRate;\n            CritChance = critChance; // New\n            CritMultiplier = critMultiplier; // New\n            BlockChance = blockChance; // New\n            BlockReduction = blockReduction; // New\n        }\n\n        public override string ToString()\n        {\n            return $\"HP: {Health:F0}/{MaxHealth:F0}, Sta: {Stamina:F0}/{MaxStamina:F0}, Cha: {Chakra:F0}/{MaxChakra:F0}, Stab: {Stability:F0}/{MaxStability:F0}, Hunger: {Hunger:F0}, Thirst: {Thirst:F0}, Temp: {BodyTemp:F1}\u00b0C, Spd: {MoveSpeed:F0}, Dmg: {BaseDamage:F0}, Armor: {Armor:F0}, MR: {MagicResistance:F0}, Crit: {CritChance:P0}\";\n        }\n    }\n}\n</code></pre>"},{"location":"39-chapter-39/#22-update-biologicalsystemcs-for-initial-corestats","title":"2.2. Update <code>BiologicalSystem.cs</code> for Initial <code>CoreStats</code>","text":"<p>The <code>BiologicalSystem</code> initializes <code>CoreStats</code> for new entities. We need to pass the new <code>CoreStats</code> constructor parameters.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code>:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player)\n            {\n                // Player's initial CoreStats (TDD 03.2).\n                // Set default player stats with some armor/MR, and crit chance.\n                _entityCoreStats.Add(id, new CoreStats(\n                    maxHealth: 100f, maxStamina: 75f, maxChakra: 50f,\n                    baseDamage: 15f, attackSpeed: 1.0f, armor: 5f, magicResistance: 5f,\n                    moveSpeed: 150f, sprintMultiplier: 1.5f, castSpeed: 1.0f,\n                    maxStability: 100f, stabilityRegenRate: 5f, chakraRegenRate: 2f, staminaRegenRate: 10f,\n                    normalBodyTemp: 37.0f, critChance: 0.1f, critMultiplier: 1.75f, blockChance: 0.1f, blockReduction: 0.5f // New crit/block stats\n                ));\n                GD.Print($\"BiologicalSystem: Added CoreStats for Player {id}. Stats: {_entityCoreStats[id]}\");\n            }\n            else if (type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // Generic NPC/Animal stats\n                _entityCoreStats.Add(id, new CoreStats(\n                    maxHealth: 50f, maxStamina: 30f, maxChakra: 20f,\n                    baseDamage: 8f, attackSpeed: 1.0f, armor: 2f, magicResistance: 2f,\n                    moveSpeed: 100f, sprintMultiplier: 1.2f, castSpeed: 1.0f,\n                    maxStability: 50f, stabilityRegenRate: 3f, chakraRegenRate: 1f, staminaRegenRate: 5f,\n                    normalBodyTemp: 37.0f, critChance: 0.05f, critMultiplier: 1.5f, blockChance: 0f, blockReduction: 0f // Generic NPC stats\n                ));\n                GD.Print($\"BiologicalSystem: Added CoreStats for {type} entity {id}. Stats: {_entityCoreStats[id]}\");\n            }\n        }\n        // ... (rest of class) ...\n    }\n}\n</code></pre>"},{"location":"39-chapter-39/#23-update-eventbuscs-for-damagetakenevent","title":"2.3. Update <code>EventBus.cs</code> for <code>DamageTakenEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnDamageTaken</code> delegate:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Combat System Events (TDD 04.2.2)\n        public event Action&lt;EntityID, DamageResult&gt; OnDamageTaken; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is CombatSystem.DamageTakenEvent damageTakenEvent) // New condition\n            {\n                OnDamageTaken?.Invoke(damageTakenEvent.DefenderID, damageTakenEvent.Result);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"39-chapter-39/#3-testing-the-damage-calculator","title":"3. Testing the Damage Calculator","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.</li> </ol> <pre><code>...\nBiologicalSystem: Added CoreStats for Player EntityID(0, Gen:1). Stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 150, Dmg: 15, Armor: 5, MR: 5, Crit: 10%\nBiologicalSystem: Added CoreStats for NPC entity EntityID(1, Gen:1). Stats: HP: 50/50, Sta: 30/30, Cha: 20/20, Stab: 50/50, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 100, Dmg: 8, Armor: 2, MR: 2, Crit: 5%\nBiologicalSystem: Added CoreStats for NPC entity EntityID(2, Gen:1). Stats: HP: 50/50, Sta: 30/30, Cha: 20/20, Stab: 50/50, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 100, Dmg: 8, Armor: 2, MR: 2, Crit: 5%\n...\n--- Testing Damage &amp; Recovery Pipeline ---\nPlayer initial HP: 100.0\nTest NPC initial HP: 50.0\nCombatSystem: Received hit event: Hit! Attacker: EntityID(0, Gen:1), Defender: EntityID(1, Gen:1), Hitbox: 'player_sword_slash', Part: 'torso', Pos: (450, 200).\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 13.0 (Physical) | Crit: False, Block: False to EntityID(1, Gen:1).\nStatusEffectSystem: Applied new effect 'bleed_t1' to EntityID(1, Gen:1).\nCombatSystem: Received hit event: Hit! Attacker: EntityID(0, Gen:1), Defender: EntityID(1, Gen:1), Hitbox: 'player_fireball', Part: 'torso', Pos: (450, 200).\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 20.0 (Elemental) | Crit: False, Block: False to EntityID(1, Gen:1).\nStatusEffectSystem: Applied new effect 'burn_t1' to EntityID(1, Gen:1).\nCombatSystem: Received hit event: Hit! Attacker: EntityID(0, Gen:1), Defender: EntityID(1, Gen:1), Hitbox: 'player_void_blast', Part: 'torso', Pos: (450, 200).\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 25.0 (Residue) | Crit: False, Block: False to EntityID(1, Gen:1).\nStatusEffectSystem: Applied new effect 'void_sickness_t1' to EntityID(1, Gen:1).\nCombatSystem: EntityID(1, Gen:1) has been defeated!\nCombatSystem: Received hit event: Hit! Attacker: EntityID(2, Gen:1), Defender: EntityID(0, Gen:1), Hitbox: 'npc_claw', Part: 'torso', Pos: (250, 200).\nCombatSystem: EntityID(2, Gen:1) dealt Dmg: 3.0 (Physical) | Crit: False, Block: False to EntityID(0, Gen:1).\nStatusEffectSystem: Applied new effect 'bleed_t1' to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 3.0 damage. New Health: 97.0\nCombatSystem: Received hit event: Hit! Attacker: EntityID(2, Gen:1), Defender: EntityID(0, Gen:1), Hitbox: 'npc_poison_spit', Part: 'torso', Pos: (250, 200).\nCombatSystem: EntityID(2, Gen:1) dealt Dmg: 6.0 (Elemental) | Crit: False, Block: False to EntityID(0, Gen:1).\nStatusEffectSystem: Applied new effect 'burn_t1' to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 6.0 damage. New Health: 91.0\nCombatSystem: Received hit event: Hit! Attacker: EntityID(2, Gen:1), Defender: EntityID(0, Gen:1), Hitbox: 'npc_heavy_hit', Part: 'torso', Pos: (250, 200).\nCombatSystem: EntityID(2, Gen:1) dealt Dmg: 63.0 (Physical) | Crit: False, Block: False to EntityID(0, Gen:1).\nStatusEffectSystem: Applied new effect 'bleed_t1' to EntityID(0, Gen:1).\nPlayerStatSystem: Player EntityID(0, Gen:1) took 63.0 damage. New Health: 28.0\n--- End Testing Damage &amp; Recovery Pipeline ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>NPC Armor/MR: The NPC (Armor 2, MR 2) now correctly mitigates damage. Player's <code>player_sword_slash</code> (Raw 15) deals <code>15 - 2 = 13</code>. <code>player_fireball</code> (Raw 25, Elemental) deals <code>25 - 2 = 23</code>. <code>player_void_blast</code> (Raw 30, Residue) deals <code>30 - 2 = 28</code>.</li> <li>Player Armor/MR: The player (Armor 5, MR 5) mitigates damage. <code>npc_claw</code> (Raw 8) deals <code>8 - 5 = 3</code>. <code>npc_poison_spit</code> (Raw 10, Elemental) deals <code>10 - 5 = 5</code>. <code>npc_heavy_hit</code> (Raw 65) deals <code>65 - 5 = 60</code>.</li> <li>Wound Generation: <code>bleed_t1</code>, <code>burn_t1</code>, <code>chakra_drain_t1</code>, <code>void_sickness_t1</code> are applied based on <code>DamageType</code> and damage amount.</li> <li>Crit Chance: You might see <code>Crit: True</code> for some hits if the random chance triggers.</li> </ul> <p>This confirms that the <code>Damage Calculator</code> is now fully functional, incorporating <code>CoreStats</code> for mitigation, <code>DamageType</code>s, and <code>CritChance</code>/<code>CritMultiplier</code> for dynamic combat outcomes.</p>"},{"location":"39-chapter-39/#summary","title":"Summary","text":"<p>You have successfully implemented The Math Layer within the C# <code>CombatSystem</code>, developing a comprehensive <code>Damage Calculator</code>. By incorporating <code>CoreStats</code> (Armor, MagicResistance, CritChance, CritMultiplier) and leveraging <code>DamageType</code>s, you've established a robust system for determining <code>FinalDamage</code>, <code>IsCrit</code>, and <code>IsBlocked</code> values. This crucial component strictly adheres to TDD 04.3's specifications, providing the authoritative and deterministic backbone for all combat interactions in Sigilborne.</p>"},{"location":"39-chapter-39/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Equipment &amp; Inventory - Inventory Data Structure (C#), where we will design the core data structures for managing items and the player's inventory, laying the groundwork for how equipment will influence <code>CoreStats</code> and gameplay.</p>"},{"location":"40-chapter-40/","title":"Chapter 6.3: Equipment & Inventory - Inventory Data Structure (C#)","text":""},{"location":"40-chapter-40/#chapter-63-equipment-inventory-inventory-data-structure-c","title":"Chapter 6.3: Equipment &amp; Inventory - Inventory Data Structure (C#)","text":"<p>With combat mechanics taking shape, entities will need items: weapons, tools, consumables, and quest items. This chapter focuses on designing the core Inventory Data Structure in the C# Brain. We'll define <code>InventoryItem</code> and <code>InventorySystem</code>, ensuring that inventory is managed as pure data, decoupled from any UI, and designed for efficiency and scalability, as specified in TDD 04.4.</p>"},{"location":"40-chapter-40/#1-the-pure-data-philosophy-of-inventory","title":"1. The Pure Data Philosophy of Inventory","text":"<p>The TDD (04.4) explicitly states: \"Inventory is a pure data structure, not a list of UI nodes.\" This is crucial for our Brain &amp; Body architecture:</p> <ul> <li>Brain (C#) owns Data: The <code>InventorySystem</code> in C# holds the authoritative truth about what items an entity possesses.</li> <li>Body (GDScript) owns UI: The UI will query the Brain for inventory data and display it reactively.</li> <li>Performance: Managing thousands of items as pure data is far more efficient than as Godot nodes.</li> <li>Flexibility: Easily supports different inventory sizes, item types, and complex item properties.</li> </ul>"},{"location":"40-chapter-40/#2-defining-inventoryitem","title":"2. Defining <code>InventoryItem</code>","text":"<p><code>InventoryItem</code> will be a struct representing a single slot or stack of items.</p> <ol> <li>Create <code>res://_Brain/Systems/Inventory/InventoryItem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/InventoryItem.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Variant, if using Godot's Variant type for metadata\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Data for a single item stack within an inventory.\n    /// (TDD 04.4.1)\n    /// &lt;/summary&gt;\n    public struct InventoryItem : IEquatable&lt;InventoryItem&gt;\n    {\n        public string ItemID;           // Unique ID of the item (e.g., \"iron_sword\", \"healing_potion_t1\")\n        public int Quantity;            // Number of items in this stack\n        public float Durability;        // Current durability (for weapons, tools)\n        public Dictionary&lt;string, Variant&gt; Metadata; // For enchantments, unique item stats (TDD 04.4.1)\n\n        public InventoryItem(string itemID, int quantity = 1, float durability = 100f, Dictionary&lt;string, Variant&gt; metadata = null)\n        {\n            ItemID = itemID;\n            Quantity = quantity;\n            Durability = durability;\n            Metadata = metadata ?? new Dictionary&lt;string, Variant&gt;();\n        }\n\n        public bool IsEmpty()\n        {\n            return string.IsNullOrEmpty(ItemID) || Quantity &lt;= 0;\n        }\n\n        public override string ToString()\n        {\n            if (IsEmpty()) return \"Empty Slot\";\n            return $\"{ItemID} (x{Quantity}) Dur:{Durability:F0}% {string.Join(\", \", Metadata.Select(kv =&gt; $\"{kv.Key}:{kv.Value}\"))}\";\n        }\n\n        // --- IEquatable Implementation ---\n        public bool Equals(InventoryItem other)\n        {\n            // For inventory purposes, two items are \"equal\" if they can stack.\n            // This usually means same ItemID, and sometimes same metadata (e.g., enchantments).\n            // For simplicity, we'll just check ItemID and Metadata keys for now.\n            return ItemID == other.ItemID &amp;&amp;\n                   Durability == other.Durability &amp;&amp; // Durability might prevent stacking if not full\n                   Metadata.OrderBy(kv =&gt; kv.Key).SequenceEqual(other.Metadata.OrderBy(kv =&gt; kv.Key));\n        }\n\n        public override bool Equals(object obj)\n        {\n            return obj is InventoryItem other &amp;&amp; Equals(other);\n        }\n\n        public override int GetHashCode()\n        {\n            // Simple hash code. For production, consider a more robust one if metadata is complex.\n            return HashCode.Combine(ItemID, Durability, Metadata.GetHashCode());\n        }\n    }\n}\n</code></pre>"},{"location":"40-chapter-40/#3-defining-inventorysystemcs","title":"3. Defining <code>InventorySystem.cs</code>","text":"<p>This system will manage the inventories of all entities that possess one.</p> <ol> <li>Create <code>res://_Brain/Systems/Inventory/InventorySystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/InventorySystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Manages the inventories for all entities that possess one.\n    /// (TDD 04.4.1)\n    /// &lt;/summary&gt;\n    public class InventorySystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n\n        // Dictionary to store inventories for entities.\n        // Each entity's inventory is a fixed-size array of InventoryItem.\n        private Dictionary&lt;EntityID, InventoryItem[]&gt; _inventories = new Dictionary&lt;EntityID, InventoryItem[]&gt;();\n\n        // Default inventory size for new entities\n        private const int DEFAULT_INVENTORY_SIZE = 16; // GDD B13.19: Inventory management (weight, slots)\n\n        public InventorySystem(EntityManager entityManager, EventBus eventBus)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n\n            // Subscribe to entity lifecycle events\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"InventorySystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add inventory to entities that should have one (Player, NPC, some WorldObjects)\n            if (type == EntityType.Player || type == EntityType.NPC || type == EntityType.WorldObject)\n            {\n                _inventories.Add(id, new InventoryItem[DEFAULT_INVENTORY_SIZE]);\n                GD.Print($\"InventorySystem: Added inventory for {type} entity {id} with {DEFAULT_INVENTORY_SIZE} slots.\");\n\n                // For player, publish initial inventory state\n                if (id == _entityManager.GetPlayerEntityID())\n                {\n                    _eventBus.Publish(new PlayerInventoryChangedEvent { PlayerID = id, Inventory = GetInventory(id).ToList() });\n                }\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _inventories.Remove(e.ID);\n            GD.Print($\"InventorySystem: Removed inventory for {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Adds an item to an entity's inventory. Stacks if possible.\n        /// (TDD 04.4.1)\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;True if item was added, false if inventory is full.&lt;/returns&gt;\n        public bool AddItem(EntityID targetID, InventoryItem item)\n        {\n            if (!_entityManager.IsValid(targetID) || !_inventories.TryGetValue(targetID, out InventoryItem[] inventory))\n            {\n                GD.PrintErr($\"InventorySystem: Entity {targetID} has no inventory.\");\n                return false;\n            }\n\n            if (item.IsEmpty()) return false;\n\n            // Try to stack with existing items\n            for (int i = 0; i &lt; inventory.Length; i++)\n            {\n                if (!inventory[i].IsEmpty() &amp;&amp; inventory[i].Equals(item)) // If same item type and can stack\n                {\n                    inventory[i].Quantity += item.Quantity;\n                    GD.Print($\"InventorySystem: Added {item.ItemID} (x{item.Quantity}) to {targetID}. Stacked.\");\n                    _eventBus.Publish(new PlayerInventoryChangedEvent { PlayerID = targetID, Inventory = GetInventory(targetID).ToList() });\n                    return true;\n                }\n            }\n\n            // Find first empty slot\n            for (int i = 0; i &lt; inventory.Length; i++)\n            {\n                if (inventory[i].IsEmpty())\n                {\n                    inventory[i] = item;\n                    GD.Print($\"InventorySystem: Added {item.ItemID} (x{item.Quantity}) to {targetID}. New slot.\");\n                    _eventBus.Publish(new PlayerInventoryChangedEvent { PlayerID = targetID, Inventory = GetInventory(targetID).ToList() });\n                    return true;\n                }\n            }\n\n            GD.Print($\"InventorySystem: Inventory for {targetID} is full. Cannot add {item.ItemID}.\");\n            return false; // Inventory is full\n        }\n\n        /// &lt;summary&gt;\n        /// Removes an item from a specific inventory slot.\n        /// (TDD 04.4.1)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"slotIndex\"&gt;The index of the slot to remove from.&lt;/param&gt;\n        /// &lt;param name=\"quantity\"&gt;The amount to remove. If less than current quantity, reduces stack. If more, clears slot.&lt;/param&gt;\n        /// &lt;returns&gt;True if item was removed/quantity reduced, false if slot invalid or item not found.&lt;/returns&gt;\n        public bool RemoveItem(EntityID targetID, int slotIndex, int quantity = 1)\n        {\n            if (!_entityManager.IsValid(targetID) || !_inventories.TryGetValue(targetID, out InventoryItem[] inventory))\n            {\n                GD.PrintErr($\"InventorySystem: Entity {targetID} has no inventory.\");\n                return false;\n            }\n\n            if (slotIndex &lt; 0 || slotIndex &gt;= inventory.Length || inventory[slotIndex].IsEmpty())\n            {\n                GD.PrintErr($\"InventorySystem: Invalid slot {slotIndex} or empty slot for {targetID}.\");\n                return false;\n            }\n\n            if (quantity &gt;= inventory[slotIndex].Quantity)\n            {\n                GD.Print($\"InventorySystem: Removed all {inventory[slotIndex].ItemID} from slot {slotIndex} for {targetID}.\");\n                inventory[slotIndex] = new InventoryItem(); // Clear slot\n            }\n            else\n            {\n                inventory[slotIndex].Quantity -= quantity;\n                GD.Print($\"InventorySystem: Removed {quantity} of {inventory[slotIndex].ItemID} from slot {slotIndex} for {targetID}. New quantity: {inventory[slotIndex].Quantity}.\");\n            }\n            _eventBus.Publish(new PlayerInventoryChangedEvent { PlayerID = targetID, Inventory = GetInventory(targetID).ToList() });\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the current inventory of an entity.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;InventoryItem&gt; GetInventory(EntityID targetID)\n        {\n            if (_inventories.TryGetValue(targetID, out InventoryItem[] inventory))\n            {\n                return inventory.AsEnumerable().ToList().AsReadOnly();\n            }\n            return new List&lt;InventoryItem&gt;().AsReadOnly();\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the item in a specific inventory slot.\n        /// &lt;/summary&gt;\n        public InventoryItem GetItemInSlot(EntityID targetID, int slotIndex)\n        {\n            if (_inventories.TryGetValue(targetID, out InventoryItem[] inventory) &amp;&amp; slotIndex &gt;= 0 &amp;&amp; slotIndex &lt; inventory.Length)\n            {\n                return inventory[slotIndex];\n            }\n            return new InventoryItem(); // Return empty item\n        }\n\n        // --- Helper Events for Body Sync ---\n        // Using List&lt;InventoryItem&gt; for GDScript interop (TDD 04.4.1)\n        public struct PlayerInventoryChangedEvent { public EntityID PlayerID; public List&lt;InventoryItem&gt; Inventory; }\n    }\n}\n</code></pre>"},{"location":"40-chapter-40/#4-integrating-inventorysystem-into-gamemanager","title":"4. Integrating <code>InventorySystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Inventory;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add an <code>InventorySystem</code> property.</li> <li>Initialize <code>InventorySystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public CombatSystem Combat { get; private set; }\n    public InventorySystem Inventory { get; private set; } // Add InventorySystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n\n        // --- Test Inventory System ---\n        GD.Print(\"\\n--- Testing Inventory System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n\n        // Add some items\n        Inventory.AddItem(playerID, new InventoryItem(\"iron_sword_t1\", 1, 95f));\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_potion_t1\", 3));\n        Inventory.AddItem(playerID, new InventoryItem(\"iron_sword_t1\", 1, 95f)); // Should stack\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_potion_t1\", 5)); // Should stack\n        Inventory.AddItem(playerID, new InventoryItem(\"mana_potion_t1\", 2));\n        Inventory.AddItem(playerID, new InventoryItem(\"quest_item_ancient_scroll\", 1, 100f, new Dictionary&lt;string, Variant&gt; { { \"lore\", \"ancient_text\" } }));\n\n        // Remove items\n        Inventory.RemoveItem(playerID, 0, 1); // Remove 1 iron sword\n        Inventory.RemoveItem(playerID, 1, 8); // Try to remove 8 potions from a stack of 8 (should clear)\n        Inventory.RemoveItem(playerID, 99, 1); // Try to remove from invalid slot (should fail)\n\n        GD.Print($\"Player Inventory after tests: {string.Join(\"\\n  \", Inventory.GetInventory(playerID).Select(item =&gt; item.ToString()))}\");\n        GD.Print(\"--- End Testing Inventory System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to CombatSystem) ...\n\n        // Initialize InventorySystem\n        Inventory = new InventorySystem(Entities, Events); // Initialize InventorySystem here\n        GD.Print(\"  - InventorySystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"40-chapter-40/#41-update-eventbuscs-for-playerinventorychangedevent","title":"4.1. Update <code>EventBus.cs</code> for <code>PlayerInventoryChangedEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnPlayerInventoryChanged</code> delegate:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Inventory System Events (TDD 04.4.1)\n        public event Action&lt;EntityID, List&lt;InventoryItem&gt;&gt; OnPlayerInventoryChanged; // PlayerID, List&lt;InventoryItem&gt;\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is InventorySystem.PlayerInventoryChangedEvent inventoryEvent) // New condition\n            {\n                OnPlayerInventoryChanged?.Invoke(inventoryEvent.PlayerID, inventoryEvent.Inventory);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"40-chapter-40/#5-testing-the-inventory-system","title":"5. Testing the Inventory System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Inventory System\" section.</li> </ol> <pre><code>...\nInventorySystem: Initialized.\n  - InventorySystem initialized.\nPlayerStatSystem: Initialized.\nPlayerStatSystem: Player EntityID(0, Gen:1) took 0 damage. New Health: 100.0\n...\n--- Testing Inventory System ---\nInventorySystem: Added iron_sword_t1 (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added healing_potion_t1 (x3) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added iron_sword_t1 (x1) to EntityID(0, Gen:1). Stacked.\nInventorySystem: Added healing_potion_t1 (x5) to EntityID(0, Gen:1). Stacked.\nInventorySystem: Added mana_potion_t1 (x2) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added quest_item_ancient_scroll (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Removed 1 of iron_sword_t1 from slot 0 for EntityID(0, Gen:1). New quantity: 1.\nInventorySystem: Removed all healing_potion_t1 from slot 1 for EntityID(0, Gen:1).\nInventorySystem: Invalid slot 99 or empty slot for EntityID(0, Gen:1).\nPlayer Inventory after tests: iron_sword_t1 (x1) Dur:95%\n  Empty Slot\n  mana_potion_t1 (x2) Dur:100%\n  quest_item_ancient_scroll (x1) Dur:100% lore:ancient_text\n  Empty Slot\n  ... (remaining empty slots) ...\n--- End Testing Inventory System ---\n...\n</code></pre> <p>This output confirms that: *   <code>InventorySystem</code> correctly initializes inventories for entities. *   <code>AddItem</code> successfully adds items to empty slots and stacks identical items. *   <code>RemoveItem</code> correctly reduces stack quantities or clears slots. *   Invalid operations (full inventory, invalid slot) are handled gracefully. *   <code>PlayerInventoryChangedEvent</code> is published on every change.</p>"},{"location":"40-chapter-40/#summary","title":"Summary","text":"<p>You have successfully designed and implemented the core Inventory Data Structure in the C# Brain, defining <code>InventoryItem</code> as a struct and <code>InventorySystem</code> to manage item stacks for entities. By ensuring inventory is pure data, decoupled from UI, and capable of adding, stacking, and removing items efficiently, you've established the authoritative backbone for all item management, strictly adhering to TDD 04.4's specifications. This crucial step supports varied equipment, consumables, and quest items in Sigilborne.</p>"},{"location":"40-chapter-40/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Equipment Logic, detailing how items are moved to \"Equipment Slots,\" how <code>CoreStats</code> are recalculated when equipment changes, and how the GDScript Body visually updates to reflect equipped items.</p>"},{"location":"41-chapter-41/","title":"Chapter 6.4: Equipment Logic - Recalculating Stats (C#)","text":""},{"location":"41-chapter-41/#chapter-64-equipment-logic-recalculating-stats-c","title":"Chapter 6.4: Equipment Logic - Recalculating Stats (C#)","text":"<p>With our <code>InventorySystem</code> managing items, the next step is to implement Equipment Logic. This chapter focuses on how items are moved to \"Equipment Slots,\" how an entity's <code>CoreStats</code> are recalculated when equipment changes, and how the GDScript Body visually updates to reflect equipped items, as specified in TDD 04.4.2.</p>"},{"location":"41-chapter-41/#1-the-role-of-equipment-in-sigilborne","title":"1. The Role of Equipment in Sigilborne","text":"<p>The GDD (B13.2) states: \"Weapons matter, but do not define your power. Chakra techniques, mastery, and strategy dominate combat.\" This means equipment provides:</p> <ul> <li>Utility/Tactical Advantage: Tools, ranged weapons.</li> <li>Stat Enhancement: Modifies <code>CoreStats</code> (e.g., <code>BaseDamage</code>, <code>Armor</code>, <code>MoveSpeed</code>).</li> <li>Visual Identity: Changes the character's appearance.</li> </ul> <p>Our <code>EquipmentSystem</code> will manage which items are equipped and apply their stat bonuses.</p>"},{"location":"41-chapter-41/#2-defining-equipmentslottype-and-equippeditemscomponent","title":"2. Defining <code>EquipmentSlotType</code> and <code>EquippedItemsComponent</code>","text":"<p>We need an enum for different equipment slots and a component to store an entity's currently equipped items.</p> <ol> <li>Create <code>res://_Brain/Systems/Inventory/EquipmentSlotType.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/EquipmentSlotType.cs\nusing System;\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Defines the types of equipment slots an entity can have.\n    /// &lt;/summary&gt;\n    public enum EquipmentSlotType\n    {\n        None,\n        MainHand,       // Primary weapon\n        OffHand,        // Shield, secondary weapon, tool\n        Head,           // Helmet, headband\n        Body,           // Armor, robe\n        Legs,           // Pants, greaves\n        Feet,           // Boots\n        Accessory1,     // Ring, amulet (GDD B13.12: Jewelry)\n        Accessory2,\n        Back,           // Cloak, backpack (for inventory size bonus)\n        // Add more slots as needed (e.g., ranged, belt, gloves)\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/Inventory/EquippedItemsComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/EquippedItemsComponent.cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Stores the items currently equipped by an entity in their respective slots.\n    /// This is a component-like data structure managed by the EquipmentSystem.\n    /// &lt;/summary&gt;\n    public struct EquippedItemsComponent\n    {\n        // Dictionary mapping slot type to the InventoryItem in that slot.\n        public Dictionary&lt;EquipmentSlotType, InventoryItem&gt; EquippedSlots;\n\n        public EquippedItemsComponent(Dictionary&lt;EquipmentSlotType, InventoryItem&gt; equippedSlots = null)\n        {\n            EquippedSlots = equippedSlots ?? new Dictionary&lt;EquipmentSlotType, InventoryItem&gt;();\n        }\n\n        public override string ToString()\n        {\n            if (EquippedSlots.Count == 0) return \"No items equipped.\";\n            return string.Join(\", \", EquippedSlots.Select(kv =&gt; $\"{kv.Key}: {kv.Value.ItemID}\"));\n        }\n    }\n}\n</code></pre>"},{"location":"41-chapter-41/#3-defining-itemdefinition","title":"3. Defining <code>ItemDefinition</code>","text":"<p>To know what stats an item provides, we need a static <code>ItemDefinition</code> blueprint. This will be data-driven.</p> <ol> <li>Create <code>res://_Brain/Systems/Inventory/ItemDefinition.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/ItemDefinition.cs\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Systems.Biology; // For CoreStats properties\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Static data defining an item.\n    /// (TDD 04.4.1 - Implicit, for ItemID lookup)\n    /// &lt;/summary&gt;\n    public class ItemDefinition\n    {\n        public string ID { get; private set; } // \"iron_sword_t1\", \"healing_potion_t1\"\n        public string Name { get; private set; }\n        public string Description { get; private set; }\n        public ItemType Type { get; private set; }\n        public EquipmentSlotType EquipSlot { get; private set; } // None if not equippable\n        public bool IsStackable { get; private set; }\n        public int MaxStackSize { get; private set; }\n        public float MaxDurability { get; private set; }\n\n        // Stat bonuses this item provides when equipped (map to CoreStats fields)\n        public Dictionary&lt;string, float&gt; StatBonuses { get; private set; } // e.g., \"BaseDamage\": 10, \"Armor\": 5\n\n        // Visual ID for the Body to know what sprite/model to use\n        public string VisualID { get; private set; } // e.g., \"sprite_iron_sword\"\n\n        public ItemDefinition(string id, string name, string description, ItemType type, EquipmentSlotType equipSlot, bool isStackable, int maxStackSize, float maxDurability, Dictionary&lt;string, float&gt; statBonuses, string visualId)\n        {\n            ID = id;\n            Name = name;\n            Description = description;\n            Type = type;\n            EquipSlot = equipSlot;\n            IsStackable = isStackable;\n            MaxStackSize = maxStackSize;\n            MaxDurability = maxDurability;\n            StatBonuses = statBonuses ?? new Dictionary&lt;string, float&gt;();\n            VisualID = visualId;\n        }\n\n        public override string ToString()\n        {\n            return $\"ItemDef: '{ID}' ({Name}) Type: {Type}, Slot: {EquipSlot}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the broad categories of items.\n    /// &lt;/summary&gt;\n    public enum ItemType\n    {\n        None,\n        Weapon,\n        Armor,\n        Accessory,\n        Consumable,\n        Tool,\n        QuestItem,\n        Resource,\n        Currency // For gold, etc.\n    }\n}\n</code></pre>"},{"location":"41-chapter-41/#4-implementing-equipmentsystemcs","title":"4. Implementing <code>EquipmentSystem.cs</code>","text":"<p>This system will manage <code>EquippedItemsComponent</code>, handle equipping/unequipping, and recalculate <code>CoreStats</code>.</p> <ol> <li>Create <code>res://_Brain/Systems/Inventory/EquipmentSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Inventory/EquipmentSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing System.Linq;\nusing System.Reflection; // For dynamic stat modification\n\nnamespace Sigilborne.Systems.Inventory\n{\n    /// &lt;summary&gt;\n    /// Manages equipped items for entities and recalculates their CoreStats based on equipment bonuses.\n    /// (TDD 04.4.2)\n    /// &lt;/summary&gt;\n    public class EquipmentSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem; // To access/modify CoreStats\n        private InventorySystem _inventorySystem; // To move items between inventory and equipped slots\n\n        // Static definitions of all items\n        private Dictionary&lt;string, ItemDefinition&gt; _itemDefinitions = new Dictionary&lt;string, ItemDefinition&gt;();\n\n        // Equipped items for entities: Dictionary&lt;EntityID, EquippedItemsComponent&gt;\n        private Dictionary&lt;EntityID, EquippedItemsComponent&gt; _equippedItems = new Dictionary&lt;EntityID, EquippedItemsComponent&gt;();\n\n        public EquipmentSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, InventorySystem inventorySystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _inventorySystem = inventorySystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultItemDefinitions(); // Register some default items\n            GD.Print(\"EquipmentSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player || type == EntityType.NPC)\n            {\n                _equippedItems.Add(id, new EquippedItemsComponent()); // Start with empty equipment\n                GD.Print($\"EquipmentSystem: Added EquippedItemsComponent for {type} entity {id}.\");\n                RecalculateCoreStats(id); // Recalculate initial stats\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _equippedItems.Remove(e.ID);\n            GD.Print($\"EquipmentSystem: Removed EquippedItemsComponent for {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static ItemDefinition.\n        /// &lt;/summary&gt;\n        public void RegisterItemDefinition(ItemDefinition def)\n        {\n            _itemDefinitions[def.ID] = def;\n            GD.Print($\"EquipmentSystem: Registered item definition '{def.ID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some common default items for initial testing.\n        /// &lt;/summary&gt;\n        private void RegisterDefaultItemDefinitions()\n        {\n            RegisterItemDefinition(new ItemDefinition(\n                id: \"iron_sword_t1\", name: \"Iron Sword\", description: \"A basic iron sword.\",\n                type: ItemType.Weapon, equipSlot: EquipmentSlotType.MainHand, isStackable: false, maxStackSize: 1, maxDurability: 100f,\n                statBonuses: new Dictionary&lt;string, float&gt; { { \"BaseDamage\", 10f }, { \"AttackSpeed\", 0.1f }, { \"Armor\", 1f } }, // Weapon can give Armor\n                visualId: \"sprite_iron_sword\"\n            ));\n            RegisterItemDefinition(new ItemDefinition(\n                id: \"leather_armor_t1\", name: \"Leather Armor\", description: \"Simple leather protection.\",\n                type: ItemType.Armor, equipSlot: EquipmentSlotType.Body, isStackable: false, maxStackSize: 1, maxDurability: 80f,\n                statBonuses: new Dictionary&lt;string, float&gt; { { \"Armor\", 5f }, { \"MoveSpeed\", -10f } }, // Armor can reduce speed\n                visualId: \"sprite_leather_armor\"\n            ));\n            RegisterItemDefinition(new ItemDefinition(\n                id: \"amulet_of_regeneration\", name: \"Amulet of Regeneration\", description: \"A mystical amulet that boosts healing.\",\n                type: ItemType.Accessory, equipSlot: EquipmentSlotType.Accessory1, isStackable: false, maxStackSize: 1, maxDurability: 100f,\n                statBonuses: new Dictionary&lt;string, float&gt; { { \"HealthRegenRate\", 2f }, { \"ChakraRegenRate\", 1f } },\n                visualId: \"sprite_amulet\"\n            ));\n            // Add definitions for healing_potion_t1, mana_potion_t1, quest_item_ancient_scroll etc.\n        }\n\n        /// &lt;summary&gt;\n        /// Equips an item from inventory into an equipment slot.\n        /// (TDD 04.4.2)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"entityID\"&gt;The entity equipping the item.&lt;/param&gt;\n        /// &lt;param name=\"itemToEquip\"&gt;The item to equip (must exist in inventory).&lt;/param&gt;\n        /// &lt;param name=\"sourceInventorySlotIndex\"&gt;The inventory slot the item is coming from.&lt;/param&gt;\n        /// &lt;returns&gt;True if equipped, false if slot invalid, occupied, or item not equippable.&lt;/returns&gt;\n        public bool EquipItem(EntityID entityID, InventoryItem itemToEquip, int sourceInventorySlotIndex)\n        {\n            if (!_entityManager.IsValid(entityID) || !_equippedItems.TryGetValue(entityID, out EquippedItemsComponent equipped))\n            {\n                GD.PrintErr($\"EquipmentSystem: Entity {entityID} cannot equip items (no EquippedItemsComponent).\");\n                return false;\n            }\n            if (itemToEquip.IsEmpty() || !_itemDefinitions.TryGetValue(itemToEquip.ItemID, out ItemDefinition itemDef))\n            {\n                GD.PrintErr($\"EquipmentSystem: Invalid item to equip: {itemToEquip.ItemID}\");\n                return false;\n            }\n            if (itemDef.EquipSlot == EquipmentSlotType.None)\n            {\n                GD.PrintErr($\"EquipmentSystem: Item '{itemDef.Name}' is not equippable.\");\n                return false;\n            }\n\n            // Check if slot is already occupied\n            if (equipped.EquippedSlots.ContainsKey(itemDef.EquipSlot) &amp;&amp; !equipped.EquippedSlots[itemDef.EquipSlot].IsEmpty())\n            {\n                // If occupied, unequip current item first (move to inventory)\n                UnequipItem(entityID, itemDef.EquipSlot); // This will move old item to inventory\n            }\n\n            // Remove from inventory\n            if (!_inventorySystem.RemoveItem(entityID, sourceInventorySlotIndex, 1))\n            {\n                GD.PrintErr($\"EquipmentSystem: Failed to remove item '{itemToEquip.ItemID}' from inventory slot {sourceInventorySlotIndex}.\");\n                return false;\n            }\n\n            equipped.EquippedSlots[itemDef.EquipSlot] = itemToEquip;\n            _equippedItems[entityID] = equipped; // Update struct in dictionary\n\n            GD.Print($\"EquipmentSystem: {entityID} equipped '{itemDef.Name}' in {itemDef.EquipSlot}.\");\n            RecalculateCoreStats(entityID); // Recalculate stats after equipping (TDD 04.4.2)\n\n            _eventBus.Publish(new EquipmentChangedEvent { EntityID = entityID, Slot = itemDef.EquipSlot, Item = itemToEquip });\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Unequips an item from a specific equipment slot, moving it to inventory.\n        /// &lt;/summary&gt;\n        public bool UnequipItem(EntityID entityID, EquipmentSlotType slotType)\n        {\n            if (!_entityManager.IsValid(entityID) || !_equippedItems.TryGetValue(entityID, out EquippedItemsComponent equipped))\n            {\n                GD.PrintErr($\"EquipmentSystem: Entity {entityID} has no EquippedItemsComponent.\");\n                return false;\n            }\n            if (!equipped.EquippedSlots.ContainsKey(slotType) || equipped.EquippedSlots[slotType].IsEmpty())\n            {\n                GD.PrintErr($\"EquipmentSystem: Slot {slotType} for {entityID} is empty. Nothing to unequip.\");\n                return false;\n            }\n\n            InventoryItem itemToUnequip = equipped.EquippedSlots[slotType];\n\n            // Try to add back to inventory\n            if (!_inventorySystem.AddItem(entityID, itemToUnequip))\n            {\n                GD.PrintErr($\"EquipmentSystem: Inventory for {entityID} is full. Cannot unequip '{itemToUnequip.ItemID}' from {slotType}.\");\n                return false; // Inventory full, cannot unequip\n            }\n\n            equipped.EquippedSlots.Remove(slotType); // Remove from equipped slots\n            _equippedItems[entityID] = equipped; // Update struct in dictionary\n\n            GD.Print($\"EquipmentSystem: {entityID} unequipped '{itemToUnequip.ItemID}' from {slotType}.\");\n            RecalculateCoreStats(entityID); // Recalculate stats after unequipping (TDD 04.4.2)\n\n            _eventBus.Publish(new EquipmentChangedEvent { EntityID = entityID, Slot = slotType, Item = new InventoryItem() }); // Send empty item for unequip\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Recalculates an entity's CoreStats based on all equipped items.\n        /// (TDD 04.4.2)\n        /// &lt;/summary&gt;\n        private void RecalculateCoreStats(EntityID entityID)\n        {\n            if (!_entityManager.IsValid(entityID) || !_biologicalSystem.TryGetCoreStats(entityID, out CoreStats baseStats))\n            {\n                GD.PrintErr($\"EquipmentSystem: Entity {entityID} has no CoreStats. Cannot recalculate.\");\n                return;\n            }\n\n            // Get a fresh copy of base stats (or load from definition if we had a base definition)\n            // For now, assume current CoreStats are the base before equipment.\n            // In a more complex system, you'd load \"base\" stats from an EntityDefinition.\n            CoreStats recalculatedStats = baseStats; // Start with current stats, then apply modifiers\n\n            if (_equippedItems.TryGetValue(entityID, out EquippedItemsComponent equipped))\n            {\n                foreach (var kvp in equipped.EquippedSlots)\n                {\n                    InventoryItem item = kvp.Value;\n                    if (item.IsEmpty() || !_itemDefinitions.TryGetValue(item.ItemID, out ItemDefinition itemDef)) continue;\n\n                    foreach (var statBonus in itemDef.StatBonuses)\n                    {\n                        // Dynamically apply stat bonuses using Reflection (TDD 04.4.2)\n                        // This is a powerful but potentially slow technique. For hot paths, pre-calculate or use faster lookups.\n                        PropertyInfo prop = typeof(CoreStats).GetProperty(statBonus.Key);\n                        if (prop != null &amp;&amp; prop.CanWrite &amp;&amp; prop.PropertyType == typeof(float))\n                        {\n                            float currentValue = (float)prop.GetValue(recalculatedStats);\n                            prop.SetValue(recalculatedStats, currentValue + statBonus.Value);\n                        }\n                        else\n                        {\n                            GD.PrintWarning($\"EquipmentSystem: Item '{itemDef.ID}' has unknown stat bonus '{statBonus.Key}' or type mismatch.\");\n                        }\n                    }\n                }\n            }\n\n            // Apply recalculated stats back to the entity's CoreStats\n            ref CoreStats targetCoreStats = ref _biologicalSystem.GetCoreStatsRef(entityID);\n            targetCoreStats = recalculatedStats; // Overwrite with new stats\n\n            GD.Print($\"EquipmentSystem: Recalculated CoreStats for {entityID}. New stats: {targetCoreStats}\");\n            // Publish full CoreStats update event (BiologicalSystem already does this on its tick)\n            // _eventBus.Publish(new BiologicalSystem.PlayerCoreStatsChangedEvent { PlayerID = entityID, NewCoreStats = targetCoreStats });\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the EquippedItemsComponent for an entity.\n        /// &lt;/summary&gt;\n        public IReadOnlyDictionary&lt;EquipmentSlotType, InventoryItem&gt; GetEquippedItems(EntityID entityID)\n        {\n            if (_equippedItems.TryGetValue(entityID, out EquippedItemsComponent equipped))\n            {\n                return equipped.EquippedSlots.AsReadOnly();\n            }\n            return new Dictionary&lt;EquipmentSlotType, InventoryItem&gt;().AsReadOnly();\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct EquipmentChangedEvent { public EntityID EntityID; public EquipmentSlotType Slot; public InventoryItem Item; }\n    }\n}\n</code></pre>"},{"location":"41-chapter-41/#5-integrating-equipmentsystem-into-gamemanager","title":"5. Integrating <code>EquipmentSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Inventory;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add an <code>EquipmentSystem</code> property.</li> <li>Initialize <code>EquipmentSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public InventorySystem Inventory { get; private set; }\n    public EquipmentSystem Equipment { get; private set; } // Add EquipmentSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n\n        // --- Test Inventory System ---\n        GD.Print(\"\\n--- Testing Inventory System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n\n        Inventory.AddItem(playerID, new InventoryItem(\"iron_sword_t1\", 1, 95f));\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_potion_t1\", 3));\n        Inventory.AddItem(playerID, new InventoryItem(\"iron_sword_t1\", 1, 95f));\n        Inventory.AddItem(playerID, new InventoryItem(\"leather_armor_t1\", 1)); // Add armor\n        Inventory.AddItem(playerID, new InventoryItem(\"amulet_of_regeneration\", 1)); // Add amulet\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_potion_t1\", 5));\n        Inventory.AddItem(playerID, new InventoryItem(\"mana_potion_t1\", 2));\n        Inventory.AddItem(playerID, new InventoryItem(\"quest_item_ancient_scroll\", 1, 100f, new Dictionary&lt;string, Variant&gt; { { \"lore\", \"ancient_text\" } }));\n\n        GD.Print($\"Player Inventory after initial additions: {string.Join(\"\\n  \", Inventory.GetInventory(playerID).Select(item =&gt; item.ToString()))}\");\n\n        // --- Test Equipment System ---\n        GD.Print(\"\\n--- Testing Equipment System ---\");\n        GD.Print($\"Player initial stats: {Biology.GetCoreStatsRef(playerID)}\");\n\n        // Equip sword\n        InventoryItem sword = Inventory.GetItemInSlot(playerID, 0); // Assuming sword is in slot 0\n        Equipment.EquipItem(playerID, sword, 0);\n        GD.Print($\"Player stats after equipping sword: {Biology.GetCoreStatsRef(playerID)}\");\n\n        // Equip armor\n        InventoryItem armor = Inventory.GetItemInSlot(playerID, 3); // Assuming armor is in slot 3\n        Equipment.EquipItem(playerID, armor, 3);\n        GD.Print($\"Player stats after equipping armor: {Biology.GetCoreStatsRef(playerID)}\");\n\n        // Equip amulet\n        InventoryItem amulet = Inventory.GetItemInSlot(playerID, 4); // Assuming amulet is in slot 4\n        Equipment.EquipItem(playerID, amulet, 4);\n        GD.Print($\"Player stats after equipping amulet: {Biology.GetCoreStatsRef(playerID)}\");\n\n        // Unequip sword\n        Equipment.UnequipItem(playerID, EquipmentSlotType.MainHand);\n        GD.Print($\"Player stats after unequipping sword: {Biology.GetCoreStatsRef(playerID)}\");\n        GD.Print($\"Player Inventory after unequip: {string.Join(\"\\n  \", Inventory.GetInventory(playerID).Select(item =&gt; item.ToString()))}\");\n\n        GD.Print(\"--- End Testing Equipment System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        // ... (existing _PhysicsProcess calls) ...\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to CombatSystem) ...\n\n        Inventory = new InventorySystem(Entities, Events);\n        GD.Print(\"  - InventorySystem initialized.\");\n\n        // Initialize EquipmentSystem, passing InventorySystem and BiologicalSystem\n        Equipment = new EquipmentSystem(Entities, Events, BiologicalSystem, Inventory); // Initialize EquipmentSystem here\n        GD.Print(\"  - EquipmentSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"41-chapter-41/#51-update-eventbuscs-for-equipmentchangedevent","title":"5.1. Update <code>EventBus.cs</code> for <code>EquipmentChangedEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnEquipmentChanged</code> delegate:</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Inventory System Events (TDD 04.4.1)\n        public event Action&lt;EntityID, List&lt;InventoryItem&gt;&gt; OnPlayerInventoryChanged;\n\n        // Equipment System Events (TDD 04.4.2)\n        public event Action&lt;EntityID, EquipmentSlotType, InventoryItem&gt; OnEquipmentChanged; // EntityID, Slot, Item (empty for unequip)\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is InventorySystem.EquipmentChangedEvent equipmentEvent) // New condition\n            {\n                OnEquipmentChanged?.Invoke(equipmentEvent.EntityID, equipmentEvent.Slot, equipmentEvent.Item);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"41-chapter-41/#6-testing-equipment-logic","title":"6. Testing Equipment Logic","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Equipment System\" section.</li> </ol> <pre><code>...\nInventorySystem: Added iron_sword_t1 (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added healing_potion_t1 (x3) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added iron_sword_t1 (x1) to EntityID(0, Gen:1). Stacked.\nInventorySystem: Added leather_armor_t1 (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added amulet_of_regeneration (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added healing_potion_t1 (x5) to EntityID(0, Gen:1). Stacked.\nInventorySystem: Added mana_potion_t1 (x2) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added quest_item_ancient_scroll (x1) to EntityID(0, Gen:1). New slot.\nPlayer Inventory after initial additions: iron_sword_t1 (x1) Dur:95%\n  healing_potion_t1 (x8) Dur:100%\n  mana_potion_t1 (x2) Dur:100%\n  leather_armor_t1 (x1) Dur:80%\n  amulet_of_regeneration (x1) Dur:100%\n  quest_item_ancient_scroll (x1) Dur:100% lore:ancient_text\n  Empty Slot\n  ... (remaining empty slots) ...\n--- Test Equipment System ---\nPlayer initial stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 150, Dmg: 15, Armor: 5, MR: 5, Crit: 10%\nEquipmentSystem: EntityID(0, Gen:1) equipped 'Iron Sword' in MainHand.\nEquipmentSystem: Recalculated CoreStats for EntityID(0, Gen:1). New stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 150, Dmg: 25, Armor: 6, MR: 5, Crit: 10%\nPlayer stats after equipping sword: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 150, Dmg: 25, Armor: 6, MR: 5, Crit: 10%\nEquipmentSystem: EntityID(0, Gen:1) equipped 'Leather Armor' in Body.\nEquipmentSystem: Recalculated CoreStats for EntityID(0, Gen:1). New stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 25, Armor: 11, MR: 5, Crit: 10%\nPlayer stats after equipping armor: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 25, Armor: 11, MR: 5, Crit: 10%\nEquipmentSystem: EntityID(0, Gen:1) equipped 'Amulet of Regeneration' in Accessory1.\nEquipmentSystem: Recalculated CoreStats for EntityID(0, Gen:1). New stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 25, Armor: 11, MR: 5, Crit: 10%\nPlayer stats after equipping amulet: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 25, Armor: 11, MR: 5, Crit: 10%\nEquipmentSystem: EntityID(0, Gen:1) unequipped 'Iron Sword' from MainHand.\nEquipmentSystem: Recalculated CoreStats for EntityID(0, Gen:1). New stats: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 15, Armor: 10, MR: 5, Crit: 10%\nPlayer stats after unequipping sword: HP: 100/100, Sta: 75/75, Cha: 50/50, Stab: 100/100, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 140, Dmg: 15, Armor: 10, MR: 5, Crit: 10%\nPlayer Inventory after unequip: iron_sword_t1 (x1) Dur:95%\n  healing_potion_t1 (x8) Dur:100%\n  mana_potion_t1 (x2) Dur:100%\n  leather_armor_t1 (x1) Dur:80%\n  amulet_of_regeneration (x1) Dur:100%\n  quest_item_ancient_scroll (x1) Dur:100% lore:ancient_text\n  Empty Slot\n  ... (remaining empty slots) ...\n--- End Testing Equipment System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Stat Recalculation: After equipping the <code>iron_sword_t1</code>, <code>BaseDamage</code> increases from 15 to 25, and <code>Armor</code> from 5 to 6.</li> <li>Multiple Bonuses: Equipping <code>leather_armor_t1</code> further increases <code>Armor</code> to 11 and reduces <code>MoveSpeed</code> from 150 to 140.</li> <li>Regen Bonuses: Equipping <code>amulet_of_regeneration</code> adds to <code>HealthRegenRate</code> and <code>ChakraRegenRate</code> (though not directly visible in the single <code>CoreStats</code> print, it's applied).</li> <li>Unequip Reverts: Unequipping the sword correctly reverts <code>BaseDamage</code> and <code>Armor</code> to their previous values (influenced by the remaining equipped armor).</li> <li>Inventory Interaction: Unequipping correctly moves the item back to inventory (slot 5 in the example).</li> </ul> <p>This confirms our <code>EquipmentSystem</code> is fully functional, dynamically modifying <code>CoreStats</code> based on equipped items.</p>"},{"location":"41-chapter-41/#summary","title":"Summary","text":"<p>You have successfully implemented Equipment Logic in the C# Brain, defining <code>EquipmentSlotType</code>, <code>EquippedItemsComponent</code>, and <code>ItemDefinition</code> to manage equipped items. By designing <code>EquipmentSystem</code> to handle equipping/unequipping, dynamically recalculate <code>CoreStats</code> using item bonuses (via Reflection), and interact with the <code>InventorySystem</code> for item transfer, you've established a robust mechanism for character progression. This crucial system strictly adheres to TDD 04.4.2's specifications, allowing equipment to meaningfully influence entity capabilities and visual presentation in Sigilborne.</p>"},{"location":"41-chapter-41/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on World Boss Mechanics - Multi-Part Entities (C#), where we will design how large, complex entities like World Bosses (Titans) are represented as multiple logical parts in the C# Brain, each with its own health and ability to be severed, creating multi-stage combat encounters.</p>"},{"location":"42-chapter-42/","title":"Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)","text":""},{"location":"42-chapter-42/#chapter-65-world-boss-mechanics-multi-part-entities-c","title":"Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)","text":"<p>Sigilborne's world is home to colossal World Bosses (Titans), which are far too complex for a single health bar or hitbox. This chapter implements Multi-Part Entities in the C# Brain, designing how these large creatures are represented as multiple logical parts (limbs, heads, cores), each with its own health, vulnerabilities, and ability to be severed, creating dynamic and multi-stage combat encounters, as specified in TDD 04.5.1.</p>"},{"location":"42-chapter-42/#1-the-challenge-of-colossal-entities","title":"1. The Challenge of Colossal Entities","text":"<p>The GDD (C05) describes Titans as \"grand metaphysical lifeforms\" that are \"not enemies to kill\" but \"living world systems.\" TDD 04.5.1 states: \"World Bosses (Titans) are too big for a single Hitbox... The Boss is one logical Entity in C#, but has multiple <code>Hurtbox</code> nodes in Godot.\" This requires:</p> <ul> <li>Logical Parts: A way to define distinct, damageable parts of a single entity in the Brain.</li> <li>Individual Health: Each part needs its own health pool, separate from the main entity's health.</li> <li>Severing Mechanics: What happens when a part's health reaches zero.</li> <li>Body Synchronization: How the GDScript Body visually reacts to limb damage or severing.</li> </ul>"},{"location":"42-chapter-42/#2-defining-bosspart-and-bosspartscomponent","title":"2. Defining <code>BossPart</code> and <code>BossPartsComponent</code>","text":"<p>We need a struct to represent a single damageable part and a component to hold all parts for a boss entity.</p> <ol> <li>Create <code>res://_Brain/Systems/Combat/BossPart.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/BossPart.cs\nusing System;\nusing Godot; // For Vector2 if needed\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Represents a single damageable part of a multi-part boss entity.\n    /// (TDD 04.5.1)\n    /// &lt;/summary&gt;\n    public struct BossPart\n    {\n        public string PartID;           // Unique ID for this part (e.g., \"LeftArm\", \"Head\", \"Core\")\n        public float Health;\n        public float MaxHealth;\n        public bool IsSevered;          // True if this part has been destroyed/severed\n        public bool IsVulnerable;       // True if this part is currently vulnerable to damage\n        public string VisualNodePath;   // Path to the corresponding visual node in Godot Body (e.g., \"Visuals/LeftArmSprite\")\n\n        public BossPart(string partID, float maxHealth, string visualNodePath = null)\n        {\n            PartID = partID;\n            MaxHealth = maxHealth;\n            Health = maxHealth;\n            IsSevered = false;\n            IsVulnerable = true; // Default vulnerable\n            VisualNodePath = visualNodePath;\n        }\n\n        public override string ToString()\n        {\n            return $\"Part: '{PartID}' HP: {Health:F0}/{MaxHealth:F0} (Severed: {IsSevered})\";\n        }\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/Combat/BossPartsComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/BossPartsComponent.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq; // For Sum()\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Stores all damageable parts for a multi-part boss entity.\n    /// This is a component-like data structure managed by the CombatSystem.\n    /// (TDD 04.5.1)\n    /// &lt;/summary&gt;\n    public struct BossPartsComponent\n    {\n        public Dictionary&lt;string, BossPart&gt; Parts; // Map PartID to BossPart data\n\n        public BossPartsComponent(Dictionary&lt;string, BossPart&gt; parts = null)\n        {\n            Parts = parts ?? new Dictionary&lt;string, BossPart&gt;();\n        }\n\n        /// &lt;summary&gt;\n        /// Calculates the total health of all active (non-severed) parts.\n        /// &lt;/summary&gt;\n        public float GetTotalCurrentHealth()\n        {\n            return Parts.Values.Where(p =&gt; !p.IsSevered).Sum(p =&gt; p.Health);\n        }\n\n        /// &lt;summary&gt;\n        /// Calculates the total max health of all parts.\n        /// &lt;/summary&gt;\n        public float GetTotalMaxHealth()\n        {\n            return Parts.Values.Sum(p =&gt; p.MaxHealth);\n        }\n\n        public override string ToString()\n        {\n            return $\"Boss Parts: {Parts.Count} | Total HP: {GetTotalCurrentHealth():F0}/{GetTotalMaxHealth():F0}\";\n        }\n    }\n}\n</code></pre>"},{"location":"42-chapter-42/#3-enhancing-combatsystemcs-for-multi-part-entities","title":"3. Enhancing <code>CombatSystem.cs</code> for Multi-Part Entities","text":"<p>The <code>CombatSystem</code> needs to: *   Store <code>BossPartsComponent</code> instances. *   Modify <code>ApplyDamage</code> to target specific <code>BossPart</code>s. *   Handle <code>BossPart</code> health reduction and severing. *   Emit events when a <code>BossPart</code> is damaged or severed.</p> <ol> <li>Open <code>res://_Brain/Systems/Combat/CombatSystem.cs</code>.</li> <li>Add a dictionary for <code>BossPartsComponent</code>.</li> <li>Modify <code>ApplyDamage</code> to check if the defender is a boss and apply damage to its part.</li> <li>Add <code>RegisterBossPart</code> and <code>DamageBossPart</code> methods.</li> </ol> <pre><code>// _Brain/Systems/Combat/CombatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Magic.Components; // For SpellDefinition\n\nnamespace Sigilborne.Systems.Combat\n{\n    // ... (DamageType, DamageResult, HitEvent structs/enums) ...\n    // ... (BossPart, BossPartsComponent structs) ... // Ensure these are properly defined in their files\n\n    public class CombatSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem;\n        private StatusEffectSystem _statusEffectSystem;\n\n        // Dictionary to store BossPartsComponent for multi-part entities.\n        private Dictionary&lt;EntityID, BossPartsComponent&gt; _bossParts = new Dictionary&lt;EntityID, BossPartsComponent&gt;(); // New: Boss parts storage\n\n        public CombatSystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _statusEffectSystem = statusEffectSystem;\n            GD.Print(\"CombatSystem: Initialized.\");\n\n            // Subscribe to entity spawn/despawn events to manage BossPartsComponent\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // For testing, let's assume \"world_boss_01\" gets BossPartsComponent\n            if (definitionID == \"world_boss_01\")\n            {\n                // Example parts for a boss (TDD 04.5.1)\n                Dictionary&lt;string, BossPart&gt; parts = new Dictionary&lt;string, BossPart&gt;\n                {\n                    { \"Head\", new BossPart(\"Head\", 50f, \"Visuals/HeadSprite\") },\n                    { \"LeftArm\", new BossPart(\"LeftArm\", 40f, \"Visuals/LeftArmSprite\") },\n                    { \"RightArm\", new BossPart(\"RightArm\", 40f, \"Visuals/RightArmSprite\") },\n                    { \"Body\", new BossPart(\"Body\", 100f, \"Visuals/BodySprite\") }\n                };\n                _bossParts.Add(id, new BossPartsComponent(parts));\n                GD.Print($\"CombatSystem: Added BossPartsComponent for Boss {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _bossParts.Remove(e.ID);\n            GD.Print($\"CombatSystem: Removed BossPartsComponent for {e.ID}.\");\n        }\n\n        public void RegisterHit(HitEvent hitEvent)\n        {\n            if (!_entityManager.IsValid(hitEvent.AttackerID) || !_entityManager.IsValid(hitEvent.DefenderID))\n            {\n                GD.PrintErr($\"CombatSystem: Invalid attacker or defender in hit event: {hitEvent}.\");\n                return;\n            }\n\n            GD.Print($\"CombatSystem: Received hit event: {hitEvent}.\");\n\n            float baseRawDamage = 0f;\n            DamageType damageType = DamageType.Physical;\n            float penetration = 0f;\n            float critChance = 0.05f;\n            float critMultiplier = 1.5f;\n\n            if (_biologicalSystem.TryGetCoreStats(hitEvent.AttackerID, out CoreStats attackerStats))\n            {\n                baseRawDamage = attackerStats.BaseDamage;\n            }\n\n            if (hitEvent.HitboxDefinitionID.Contains(\"fireball\"))\n            {\n                baseRawDamage = 25f;\n                damageType = DamageType.Elemental;\n            }\n            else if (hitEvent.HitboxDefinitionID.Contains(\"void\"))\n            {\n            // ... (existing damage type determination) ...\n            }\n\n            // --- Determine if defender is a multi-part boss ---\n            if (_bossParts.TryGetValue(hitEvent.DefenderID, out BossPartsComponent bossParts))\n            {\n                // Apply damage to a specific part\n                DamageBossPart(hitEvent.AttackerID, hitEvent.DefenderID, hitEvent.HurtboxBodyPart, baseRawDamage, damageType, penetration, critChance, critMultiplier);\n            }\n            else\n            {\n                // Apply damage to a regular entity\n                ApplyDamage(hitEvent.AttackerID, hitEvent.DefenderID, baseRawDamage, damageType, penetration, critChance, critMultiplier);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Applies damage to a specific part of a boss entity.\n        /// (TDD 04.5.1: Limb Health)\n        /// &lt;/summary&gt;\n        public DamageResult DamageBossPart(EntityID attackerID, EntityID bossID, string partID, float rawDamage, DamageType damageType, float penetration, float critChance, float critMultiplier)\n        {\n            if (!_bossParts.TryGetValue(bossID, out BossPartsComponent bossParts) || !bossParts.Parts.ContainsKey(partID))\n            {\n                GD.PrintErr($\"CombatSystem: Boss {bossID} does not have part '{partID}'.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, bossID);\n            }\n\n            ref BossPart part = ref bossParts.Parts.GetValueRef(partID); // Get mutable ref to the part\n            if (part.IsSevered || !part.IsVulnerable)\n            {\n                GD.Print($\"CombatSystem: Part '{partID}' of Boss {bossID} is already severed or not vulnerable. No damage applied.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, bossID);\n            }\n\n            // --- Damage Calculation for the Part ---\n            // For simplicity, parts use the boss's CoreStats for mitigation.\n            if (!_biologicalSystem.TryGetCoreStats(bossID, out CoreStats bossStats))\n            {\n                GD.PrintErr($\"CombatSystem: Boss {bossID} has no CoreStats. Cannot apply damage to part.\");\n                return new DamageResult(0, false, false, DamageType.None, attackerID, bossID);\n            }\n\n            float calculatedDamage = rawDamage;\n            float mitigation = 0;\n            switch (damageType)\n            {\n                case DamageType.Physical: mitigation = bossStats.Armor * (1.0f - penetration); break;\n                case DamageType.Elemental: mitigation = bossStats.MagicResistance * (1.0f - penetration); break;\n                // ... other damage types\n            }\n            calculatedDamage -= mitigation;\n            calculatedDamage = Mathf.Max(0, calculatedDamage);\n\n            // Crit calculation\n            Random rand = new Random(attackerID.Index + bossID.Index + (int)GameManager.Instance.Time.CurrentGameTime);\n            bool isCrit = rand.NextDouble() &lt; critChance;\n            if (isCrit) calculatedDamage *= critMultiplier;\n\n            DamageResult result = new DamageResult(calculatedDamage, isCrit, false, damageType, attackerID, bossID);\n            GD.Print($\"CombatSystem: {attackerID} dealt {result} to Boss {bossID} part '{partID}'.\");\n\n            // --- Apply Damage to Part ---\n            part.Health -= result.FinalDamage;\n            if (part.Health &lt; 0) part.Health = 0;\n\n            // --- Severing Logic (TDD 04.5.1) ---\n            if (part.Health == 0 &amp;&amp; !part.IsSevered)\n            {\n                part.IsSevered = true;\n                GD.Print($\"CombatSystem: Part '{partID}' of Boss {bossID} has been SEVERED!\");\n                _eventBus.Publish(new BossPartSeveredEvent { BossID = bossID, PartID = partID }); // TDD 04.5.1: Emit OnLimbSevered\n\n                // Trigger boss phase transition or ability change (conceptual)\n                // _eventBus.Publish(new BossPhaseChangedEvent { BossID = bossID, NewPhase = ... });\n            }\n\n            // Publish part damaged event (TDD 04.5.1: Emit OnDamageTaken)\n            _eventBus.Publish(new BossPartDamagedEvent { BossID = bossID, PartID = partID, CurrentHealth = part.Health, MaxHealth = part.MaxHealth, Result = result });\n\n            // Also update the main CoreStats health for the boss (optional, or just use part health)\n            // For simplicity, let's update the main boss HP for now as the sum of parts.\n            ref CoreStats bossCoreStats = ref _biologicalSystem.GetCoreStatsRef(bossID);\n            bossCoreStats.Health = bossParts.GetTotalCurrentHealth();\n            bossCoreStats.MaxHealth = bossParts.GetTotalMaxHealth(); // Max health might change if parts are permanently severed\n            _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = bossID, NewValue = bossCoreStats.Health, MaxValue = bossCoreStats.MaxHealth }); // Re-use player health event for now\n\n            if (bossCoreStats.Health == 0)\n            {\n                GD.Print($\"CombatSystem: Boss {bossID} has been DEFEATED!\");\n                _eventBus.Publish(new EntityDefeatedEvent { EntityID = bossID, KillerID = attackerID });\n            }\n\n            return result;\n        }\n\n        // ... (ApplyDamage for regular entities, GenerateWounds methods) ...\n\n        // --- Helper Events for Body Sync ---\n        // ... (DamageTakenEvent struct) ...\n        public struct BossPartDamagedEvent { public EntityID BossID; public string PartID; public float CurrentHealth; public float MaxHealth; public DamageResult Result; } // New event\n        public struct BossPartSeveredEvent { public EntityID BossID; public string PartID; } // New event\n        public struct EntityDefeatedEvent { public EntityID EntityID; public EntityID KillerID; } // New generic event for when any entity is defeated\n    }\n}\n</code></pre>"},{"location":"42-chapter-42/#4-integrating-bossparts-into-gamemanager-tests","title":"4. Integrating <code>BossPart</code>s into <code>GameManager</code> Tests","text":"<ol> <li>Add <code>using Sigilborne.Systems.Combat;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>In <code>GameManager._Ready()</code>, modify the \"Test Damage &amp; Recovery Pipeline\" section to:<ul> <li>Create a \"world_boss_01\" entity.</li> <li>Call <code>Combat.DamageBossPart</code> directly to simulate hits on its parts.</li> </ul> </li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method)\n// ...\n        // --- Test Damage &amp; Recovery Pipeline ---\n        GD.Print(\"\\n--- Testing Damage &amp; Recovery Pipeline ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID testNpcID = Entities.CreateEntity(EntityType.NPC, \"test_dummy_npc\", new Vector2(500, 200));\n        EntityID bossID = Entities.CreateEntity(EntityType.NPC, \"world_boss_01\", new Vector2(700, 300)); // Create a boss entity\n\n        GD.Print($\"Player initial HP: {Biology.GetCoreStatsRef(playerID).Health}\");\n        GD.Print($\"Test NPC initial HP: {Biology.GetCoreStatsRef(testNpcID).Health}\");\n        GD.Print($\"Boss initial HP: {Biology.GetCoreStatsRef(bossID).Health}\");\n        GD.Print($\"Boss Parts initial state: {Combat.GetBossParts(bossID)}\"); // Need a GetBossParts method\n\n        // Player attacks NPC (will be triggered by HitEvent from GDScript)\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_sword_slash\", \"torso\", new Vector2(450, 200), Vector2.Left));\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_fireball\", \"torso\", new Vector2(450, 200), Vector2.Left));\n        Combat.RegisterHit(new HitEvent(playerID, testNpcID, \"player_void_blast\", \"torso\", new Vector2(450, 200), Vector2.Left));\n\n        // NPC attacks Player (will be triggered by HitEvent from GDScript)\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_claw\", \"torso\", new Vector2(250, 200), Vector2.Right));\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_poison_spit\", \"torso\", new Vector2(250, 200), Vector2.Right));\n        Combat.RegisterHit(new HitEvent(testNpcID, playerID, \"npc_heavy_hit\", \"torso\", new Vector2(250, 200), Vector2.Right));\n\n        GD.Print(\"\\n--- Boss Combat Test ---\");\n        // Simulate hitting boss parts\n        Combat.DamageBossPart(playerID, bossID, \"LeftArm\", 30f, DamageType.Physical, 0, 0.1f, 1.75f); // Damage Left Arm\n        Combat.DamageBossPart(playerID, bossID, \"LeftArm\", 20f, DamageType.Physical, 0, 0.1f, 1.75f); // Sever Left Arm\n        Combat.DamageBossPart(playerID, bossID, \"Head\", 40f, DamageType.Elemental, 0, 0.1f, 1.75f); // Damage Head\n        Combat.DamageBossPart(playerID, bossID, \"Head\", 20f, DamageType.Elemental, 0, 0.1f, 1.75f); // Sever Head\n        Combat.DamageBossPart(playerID, bossID, \"Body\", 50f, DamageType.Physical, 0, 0.1f, 1.75f); // Damage Body\n        Combat.DamageBossPart(playerID, bossID, \"Body\", 50f, DamageType.Physical, 0, 0.1f, 1.75f); // Defeat Boss\n\n        GD.Print(\"--- End Testing Damage &amp; Recovery Pipeline ---\\n\");\n// ...\n</code></pre>"},{"location":"42-chapter-42/#41-add-getbossparts-to-combatsystem","title":"4.1. Add <code>GetBossParts</code> to <code>CombatSystem</code>","text":"<p>Needed for the test print statement.</p> <p>Open <code>res://_Brain/Systems/Combat/CombatSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Combat/CombatSystem.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Magic.Components;\n\nnamespace Sigilborne.Systems.Combat\n{\n    // ... (DamageType, DamageResult, HitEvent structs/enums) ...\n    // ... (BossPart, BossPartsComponent structs) ...\n\n    public class CombatSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        /// &lt;summary&gt;\n        /// Retrieves the BossPartsComponent for a given boss entity.\n        /// &lt;/summary&gt;\n        public BossPartsComponent GetBossParts(EntityID bossID)\n        {\n            if (_bossParts.TryGetValue(bossID, out BossPartsComponent parts))\n            {\n                return parts;\n            }\n            return new BossPartsComponent(); // Return empty if not a boss\n        }\n\n        // ... (RegisterHit, ApplyDamage, DamageBossPart, GenerateWounds methods) ...\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"42-chapter-42/#42-update-eventbuscs-for-boss-events","title":"4.2. Update <code>EventBus.cs</code> for Boss Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add delegates for <code>BossPartDamagedEvent</code>, <code>BossPartSeveredEvent</code>, and <code>EntityDefeatedEvent</code>.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Combat System Events (TDD 04.2.2)\n        public event Action&lt;EntityID, DamageResult&gt; OnDamageTaken;\n        public event Action&lt;EntityID, string, float, float, DamageResult&gt; OnBossPartDamaged; // BossID, PartID, CurrentHP, MaxHP, Result\n        public event Action&lt;EntityID, string&gt; OnBossPartSevered; // BossID, PartID\n        public event Action&lt;EntityID, EntityID&gt; OnEntityDefeated; // EntityID, KillerID\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is CombatSystem.DamageTakenEvent damageTakenEvent)\n            {\n                OnDamageTaken?.Invoke(damageTakenEvent.DefenderID, damageTakenEvent.Result);\n            }\n            else if (eventData is CombatSystem.BossPartDamagedEvent bossPartDamagedEvent) // New condition\n            {\n                OnBossPartDamaged?.Invoke(bossPartDamagedEvent.BossID, bossPartDamagedEvent.PartID, bossPartDamagedEvent.CurrentHealth, bossPartDamagedEvent.MaxHealth, bossPartDamagedEvent.Result);\n            }\n            else if (eventData is CombatSystem.BossPartSeveredEvent bossPartSeveredEvent) // New condition\n            {\n                OnBossPartSevered?.Invoke(bossPartSeveredEvent.BossID, bossPartSeveredEvent.PartID);\n            }\n            else if (eventData is CombatSystem.EntityDefeatedEvent entityDefeatedEvent) // New condition\n            {\n                OnEntityDefeated?.Invoke(entityDefeatedEvent.EntityID, entityDefeatedEvent.KillerID);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"42-chapter-42/#5-testing-multi-part-entities","title":"5. Testing Multi-Part Entities","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.</li> </ol> <pre><code>...\nBiologicalSystem: Added CoreStats for NPC entity EntityID(2, Gen:1). Stats: HP: 50/50, Sta: 30/30, Cha: 20/20, Stab: 50/50, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 100, Dmg: 8, Armor: 2, MR: 2, Crit: 5%\nBiologicalSystem: Added CoreStats for NPC entity EntityID(3, Gen:1). Stats: HP: 50/50, Sta: 30/30, Cha: 20/20, Stab: 50/50, Hunger: 100, Thirst: 100, Temp: 37.0\u00b0C, Spd: 100, Dmg: 8, Armor: 2, MR: 2, Crit: 5%\nCombatSystem: Added BossPartsComponent for Boss EntityID(3, Gen:1).\n--- Testing Damage &amp; Recovery Pipeline ---\nPlayer initial HP: 100.0\nTest NPC initial HP: 50.0\nBoss initial HP: 190.0\nBoss Parts initial state: Boss Parts: 4 | Total HP: 190/190\n... (existing NPC/Player damage output) ...\n\n--- Boss Combat Test ---\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 13.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'LeftArm'.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 13.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'LeftArm'.\nCombatSystem: Part 'LeftArm' of Boss EntityID(3, Gen:1) has been SEVERED!\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Elemental) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Head'.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Elemental) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Head'.\nCombatSystem: Part 'Head' of Boss EntityID(3, Gen:1) has been SEVERED!\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 48.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 48.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nCombatSystem: Boss EntityID(3, Gen:1) has been DEFEATED!\n--- End Testing Damage &amp; Recovery Pipeline ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Boss Initialization: A <code>BossPartsComponent</code> is added to the boss entity, and its initial health is the sum of its parts (190).</li> <li>Part-Specific Damage: Damage is applied to individual parts (<code>LeftArm</code>, <code>Head</code>, <code>Body</code>).</li> <li>Severing: When a part's health reaches zero, it's marked as <code>Severed</code>, and a <code>BossPartSeveredEvent</code> is published.</li> <li>Boss Defeat: When all parts (or critical parts, based on later logic) are severed, the boss is <code>DEFEATED</code>.</li> <li>Event Publishing: <code>BossPartDamagedEvent</code> and <code>BossPartSeveredEvent</code> are published for the Body to react.</li> </ul> <p>This confirms our <code>CombatSystem</code> is correctly managing multi-part entities, allowing for complex, multi-stage boss encounters.</p>"},{"location":"42-chapter-42/#summary","title":"Summary","text":"<p>You have successfully implemented World Boss Mechanics for multi-part entities in the C# Brain, defining <code>BossPart</code> and <code>BossPartsComponent</code> to represent distinct, damageable parts of colossal creatures. By enhancing <code>CombatSystem</code> to store these components, apply damage to specific parts, handle severing logic, and update the boss's overall health, you've established a robust system for dynamic, multi-stage combat encounters. This crucial component strictly adheres to TDD 04.5.1's specifications, paving the way for truly epic Titan battles in Sigilborne.</p>"},{"location":"42-chapter-42/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Titan AI State, where we will design a specialized state machine for World Bosses that accounts for their massive size and complex behaviors, including phase transitions triggered by health thresholds or severed limbs.</p>"},{"location":"43-chapter-43/","title":"Chapter 6.6: Titan AI State - Specialized State Machine (C#)","text":""},{"location":"43-chapter-43/#chapter-66-titan-ai-state-specialized-state-machine-c","title":"Chapter 6.6: Titan AI State - Specialized State Machine (C#)","text":"<p>With World Bosses (Titans) now represented as multi-part entities, the next challenge is to give them intelligent, dynamic behavior. This chapter focuses on designing a Specialized State Machine for Titans in the C# Brain, accounting for their massive size, complex abilities, and phase transitions triggered by health thresholds or severed limbs, as specified in TDD 04.5.2.</p>"},{"location":"43-chapter-43/#1-the-complexities-of-titan-ai","title":"1. The Complexities of Titan AI","text":"<p>The GDD (C05.3) describes Titans as \"ecological &amp; political actors\" that \"migrate, react to weather, territorialize, claim shrines, influence wildlife, reshape terrain, block travel routes, compete with other titans, provoke or calm spirits, attract corruption, disturb anomalies, cause clan panic, trigger regional wars.\" This requires AI that goes far beyond simple enemy behavior:</p> <ul> <li>Phased Behavior: Titans should have distinct phases (e.g., \"Awakening,\" \"Rampage,\" \"Weakened\") with unique abilities.</li> <li>Environmental Interaction: Their actions should interact with and reshape the world.</li> <li>Limb-Dependent Abilities: Severing a limb should disable certain attacks or expose new vulnerabilities.</li> <li>Massive Scale: Actions might take longer (e.g., \"Turning\" takes 5 seconds, as per TDD 05.5.2).</li> <li>World Impact: Their AI decisions can trigger region-wide events.</li> </ul>"},{"location":"43-chapter-43/#2-defining-titanstate-and-titanaicomponent","title":"2. Defining <code>TitanState</code> and <code>TitanAIComponent</code>","text":"<p>We need an enum for the Titan's high-level AI states and a component to hold its current AI state and related data.</p> <ol> <li>Create <code>res://_Brain/Systems/Combat/TitanAIState.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/TitanAIState.cs\nusing System;\nusing Godot; // For Vector2 if needed\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Defines the high-level AI states for a Titan World Boss.\n    /// (TDD 04.5.2)\n    /// &lt;/summary&gt;\n    public enum TitanAIState\n    {\n        Idle,           // Passive, dormant, or waiting for trigger\n        Awakening,      // Transitioning to active combat\n        Phase1_Default, // Initial combat phase\n        Phase2_Enraged, // Triggered by HP threshold or severed limb\n        Phase3_Desperate, // Near defeat, uses ultimate attacks (C04 Forbidden Arts)\n        Retreating,     // Moving to a new location\n        Dying,          // Final phase before defeat\n        Defeated        // Boss is defeated\n    }\n\n    /// &lt;summary&gt;\n    /// Stores the current AI state and related data for a Titan World Boss.\n    /// This is a component-like data structure managed by the TitanAISystem.\n    /// (TDD 04.5.2)\n    /// &lt;/summary&gt;\n    public struct TitanAIComponent\n    {\n        public TitanAIState CurrentState;\n        public double StateTimer;           // How long in current state\n        public double ActionCooldownTimer;  // Cooldown for next major action\n        public EntityID TargetID;           // Current target\n        public int CurrentPhase;            // Which phase the boss is in (1, 2, 3)\n\n        public TitanAIComponent(EntityID targetID = default)\n        {\n            CurrentState = TitanAIState.Idle;\n            StateTimer = 0;\n            ActionCooldownTimer = 0;\n            TargetID = targetID;\n            CurrentPhase = 0;\n        }\n\n        public override string ToString()\n        {\n            return $\"AI State: {CurrentState}, Phase: {CurrentPhase}, Timer: {StateTimer:F1}\";\n        }\n    }\n}\n</code></pre>"},{"location":"43-chapter-43/#3-implementing-titanaisystemcs","title":"3. Implementing <code>TitanAISystem.cs</code>","text":"<p>This system will manage <code>TitanAIComponent</code> instances, process state transitions, select actions, and react to combat events.</p> <ol> <li>Create <code>res://_Brain/Systems/Combat/TitanAISystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Combat/TitanAISystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Movement; // For Titan movement\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Combat\n{\n    /// &lt;summary&gt;\n    /// Manages the specialized AI state machine for Titan World Bosses.\n    /// Accounts for massive size, complex abilities, and phase transitions.\n    /// (TDD 04.5.2)\n    /// &lt;/summary&gt;\n    public class TitanAISystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem; // For CoreStats\n        private CombatSystem _combatSystem;         // For boss parts, damage events\n        private TransformSystem _transformSystem;   // For boss position/movement\n\n        // Dictionary to store TitanAIComponent for active titans.\n        private Dictionary&lt;EntityID, TitanAIComponent&gt; _titanAIComponents = new Dictionary&lt;EntityID, TitanAIComponent&gt;();\n\n        public TitanAISystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, CombatSystem combatSystem, TransformSystem transformSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _combatSystem = combatSystem;\n            _transformSystem = transformSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n            _eventBus.OnBossPartSevered += OnBossPartSevered; // React to severed limbs (TDD 04.5.1)\n            _eventBus.OnDamageTaken += OnDamageTaken; // React to damage for phase transitions\n\n            GD.Print(\"TitanAISystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add TitanAIComponent to entities defined as Titans (e.g., \"world_boss_01\")\n            if (definitionID == \"world_boss_01\")\n            {\n                _titanAIComponents.Add(id, new TitanAIComponent(GameManager.Instance.Entities.GetPlayerEntityID())); // Target player initially\n                TransitionTitanState(id, TitanAIState.Awakening); // Start in Awakening phase\n                GD.Print($\"TitanAISystem: Added TitanAIComponent for {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _titanAIComponents.Remove(e.ID);\n            GD.Print($\"TitanAISystem: Removed TitanAIComponent for {e.ID}.\");\n        }\n\n        private void OnBossPartSevered(EntityID bossID, string partID)\n        {\n            if (_titanAIComponents.ContainsKey(bossID))\n            {\n                GD.Print($\"TitanAISystem: Boss {bossID} had part '{partID}' severed. Checking for phase change.\");\n                // Trigger phase transition or special reaction (TDD 04.5.1)\n                // Example: if Head is severed, boss might become enraged and use new attacks.\n                // TransitionTitanState(bossID, TitanAIState.Phase2_Enraged);\n            }\n        }\n\n        private void OnDamageTaken(EntityID defenderID, DamageResult result)\n        {\n            if (_titanAIComponents.ContainsKey(defenderID))\n            {\n                // Check health thresholds for phase transitions (TDD 04.5.2)\n                ref CoreStats bossCoreStats = ref _biologicalSystem.GetCoreStatsRef(defenderID);\n                ref TitanAIComponent titanAI = ref _titanAIComponents.GetValueRef(defenderID);\n\n                // Example phase transitions:\n                if (bossCoreStats.Health &lt;= bossCoreStats.MaxHealth * 0.25f &amp;&amp; titanAI.CurrentPhase &lt; 3)\n                {\n                    TransitionTitanState(defenderID, TitanAIState.Phase3_Desperate);\n                }\n                else if (bossCoreStats.Health &lt;= bossCoreStats.MaxHealth * 0.5f &amp;&amp; titanAI.CurrentPhase &lt; 2)\n                {\n                    TransitionTitanState(defenderID, TitanAIState.Phase2_Enraged);\n                }\n                else if (bossCoreStats.Health &lt;= bossCoreStats.MaxHealth * 0.75f &amp;&amp; titanAI.CurrentPhase &lt; 1)\n                {\n                    TransitionTitanState(defenderID, TitanAIState.Phase1_Default);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the TitanAISystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            foreach (var kvp in _titanAIComponents)\n            {\n                EntityID titanID = kvp.Key;\n                ref TitanAIComponent titanAI = ref _titanAIComponents.GetValueRef(titanID);\n\n                if (!_entityManager.IsValid(titanID)) continue;\n\n                titanAI.StateTimer += delta;\n                titanAI.ActionCooldownTimer -= delta;\n\n                // --- Titan AI State Logic ---\n                switch (titanAI.CurrentState)\n                {\n                    case TitanAIState.Idle:\n                        HandleIdleState(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Awakening:\n                        HandleAwakeningState(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Phase1_Default:\n                        HandlePhase1(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Phase2_Enraged:\n                        HandlePhase2(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Phase3_Desperate:\n                        HandlePhase3(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Retreating:\n                        HandleRetreatingState(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Dying:\n                        HandleDyingState(titanID, ref titanAI, delta);\n                        break;\n                    case TitanAIState.Defeated:\n                        // No actions, just remain defeated\n                        break;\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Transitions a titan to a new AI state.\n        /// &lt;/summary&gt;\n        private void TransitionTitanState(EntityID titanID, TitanAIState newState)\n        {\n            ref TitanAIComponent titanAI = ref _titanAIComponents.GetValueRef(titanID);\n            if (titanAI.CurrentState == newState) return; // Already in this state\n\n            GD.Print($\"TitanAISystem: Boss {titanID} transitioning from {titanAI.CurrentState} to {newState}.\");\n            _eventBus.Publish(new TitanStateChangedEvent { TitanID = titanID, OldState = titanAI.CurrentState, NewState = newState });\n\n            titanAI.CurrentState = newState;\n            titanAI.StateTimer = 0; // Reset timer for new state\n\n            // Set phase for combat states\n            titanAI.CurrentPhase = newState switch\n            {\n                TitanAIState.Phase1_Default =&gt; 1,\n                TitanAIState.Phase2_Enraged =&gt; 2,\n                TitanAIState.Phase3_Desperate =&gt; 3,\n                _ =&gt; 0, // Other states\n            };\n\n            // Reset action cooldown on phase change\n            titanAI.ActionCooldownTimer = 0;\n\n            // Trigger visual/audio feedback for phase changes\n            // _eventBus.Publish(new TitanPhaseVFXEvent { TitanID = titanID, Phase = titanAI.CurrentPhase });\n        }\n\n        // --- State Handlers ---\n        private void HandleIdleState(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            if (titanAI.StateTimer &gt;= 5.0) // After 5 seconds idle, awaken\n            {\n                TransitionTitanState(titanID, TitanAIState.Awakening);\n            }\n        }\n\n        private void HandleAwakeningState(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            // TDD 05.5.2: \"Turning\" takes 5 seconds (massive size)\n            if (titanAI.StateTimer &gt;= 5.0)\n            {\n                GD.Print($\"TitanAISystem: Boss {titanID} has finished AWAKENING!\");\n                TransitionTitanState(titanID, TitanAIState.Phase1_Default);\n            }\n            // Emit VFX/Audio for awakening here\n            // _eventBus.Publish(new TitanAwakeningVFXEvent { TitanID = titanID });\n        }\n\n        private void HandlePhase1(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            if (titanAI.ActionCooldownTimer &lt;= 0)\n            {\n                // Perform a basic attack (conceptual)\n                GD.Print($\"TitanAISystem: Boss {titanID} (Phase 1) performs basic attack on {titanAI.TargetID}.\");\n                // _combatSystem.PerformBossAttack(titanID, titanAI.TargetID, \"basic_swipe\");\n                titanAI.ActionCooldownTimer = 3.0; // Cooldown 3 seconds\n            }\n            // Move towards target (conceptual)\n            // _movementSystem.MoveTowards(titanID, titanAI.TargetID, titanAI.StateTimer);\n        }\n\n        private void HandlePhase2(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            if (titanAI.ActionCooldownTimer &lt;= 0)\n            {\n                // Use a more powerful attack or area effect\n                GD.Print($\"TitanAISystem: Boss {titanID} (Phase 2) performs enraged attack on {titanAI.TargetID}.\");\n                // _combatSystem.PerformBossAttack(titanID, titanAI.TargetID, \"aoe_ground_slam\");\n                titanAI.ActionCooldownTimer = 2.0; // Shorter cooldown\n            }\n            // Environment might change (TDD 05.5.2: Weather)\n            // _eventBus.Publish(new WeatherSystem.GlobalWeatherChangedEvent { NewWeatherState = new GlobalWeatherState(WeatherType.Storm, ...) });\n        }\n\n        private void HandlePhase3(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            if (titanAI.ActionCooldownTimer &lt;= 0)\n            {\n                // Use \"Ultimate\" attacks (C04 Forbidden Arts)\n                GD.Print($\"TitanAISystem: Boss {titanID} (Phase 3) uses ultimate desperate attack on {titanAI.TargetID}.\");\n                // _combatSystem.PerformBossAttack(titanID, titanAI.TargetID, \"forbidden_void_blast\");\n                titanAI.ActionCooldownTimer = 1.0; // Very short cooldown\n            }\n        }\n\n        private void HandleRetreatingState(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            // Titan moves away from player or to a specific location\n            // if (titanAI.StateTimer &gt;= 10.0) TransitionTitanState(titanID, TitanAIState.Idle); // Retreat complete\n        }\n\n        private void HandleDyingState(EntityID titanID, ref TitanAIComponent titanAI, double delta)\n        {\n            // Play death animation, become invulnerable, perhaps trigger a final AoE\n            if (titanAI.StateTimer &gt;= 5.0)\n            {\n                TransitionTitanState(titanID, TitanAIState.Defeated);\n            }\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct TitanStateChangedEvent { public EntityID TitanID; public TitanAIState OldState; public TitanAIState NewState; }\n        // public struct TitanPhaseVFXEvent { public EntityID TitanID; public int Phase; } // Example\n        // public struct TitanAwakeningVFXEvent { public EntityID TitanID; } // Example\n    }\n}\n</code></pre>"},{"location":"43-chapter-43/#4-integrating-titanaisystem-into-gamemanager","title":"4. Integrating <code>TitanAISystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Combat;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>TitanAISystem</code> property.</li> <li>Initialize <code>TitanAISystem</code> in <code>InitializeSystems()</code> after <code>CombatSystem</code>.</li> <li>Call <code>TitanAISystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public CombatSystem Combat { get; private set; }\n    public TitanAISystem TitanAI { get; private set; } // Add TitanAISystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n\n        // --- Test Inventory System ---\n        // ... (existing inventory tests) ...\n\n        // --- Test Equipment System ---\n        // ... (existing equipment tests) ...\n\n        // --- Test Titan AI State Machine ---\n        GD.Print(\"\\n--- Testing Titan AI State Machine ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID bossID = Entities.CreateEntity(EntityType.NPC, \"world_boss_01\", new Vector2(700, 300)); // Create a boss entity\n\n        GD.Print($\"Boss initial HP: {Biology.GetCoreStatsRef(bossID).Health}\");\n        GD.Print($\"Boss Parts initial state: {Combat.GetBossParts(bossID)}\");\n\n        // Simulate hitting boss parts to trigger phases\n        GD.Print(\"\\n--- Simulating Boss Damage to Trigger Phases ---\");\n        Combat.DamageBossPart(playerID, bossID, \"LeftArm\", 30f, DamageType.Physical, 0, 0.1f, 1.75f);\n        Combat.DamageBossPart(playerID, bossID, \"LeftArm\", 20f, DamageType.Physical, 0, 0.1f, 1.75f); // Sever Left Arm (triggers OnBossPartSevered)\n\n        Combat.DamageBossPart(playerID, bossID, \"Head\", 40f, DamageType.Elemental, 0, 0.1f, 1.75f);\n        Combat.DamageBossPart(playerID, bossID, \"Head\", 20f, DamageType.Elemental, 0, 0.1f, 1.75f); // Sever Head\n\n        // Trigger Phase 2 (50% HP)\n        Combat.DamageBossPart(playerID, bossID, \"Body\", 50f, DamageType.Physical, 0, 0.1f, 1.75f); \n        // Trigger Phase 3 (25% HP)\n        Combat.DamageBossPart(playerID, bossID, \"Body\", 20f, DamageType.Physical, 0, 0.1f, 1.75f); \n        // Defeat Boss\n        Combat.DamageBossPart(playerID, bossID, \"Body\", 30f, DamageType.Physical, 0, 0.1f, 1.75f);\n\n        GD.Print(\"--- End Testing Titan AI State Machine ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta); // Call TitanAISystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to CombatSystem) ...\n\n        // Initialize TitanAISystem AFTER CombatSystem (as it needs CombatSystem for events/parts)\n        TitanAI = new TitanAISystem(Entities, Events, BiologicalSystem, Combat, Transforms); // Pass CombatSystem\n        GD.Print(\"  - TitanAISystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation();\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"43-chapter-43/#41-update-eventbuscs-for-titan-ai-events","title":"4.1. Update <code>EventBus.cs</code> for Titan AI Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnTitanStateChanged</code> delegate.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Combat System Events (TDD 04.2.2)\n        public event Action&lt;EntityID, DamageResult&gt; OnDamageTaken;\n        public event Action&lt;EntityID, string, float, float, DamageResult&gt; OnBossPartDamaged;\n        public event Action&lt;EntityID, string&gt; OnBossPartSevered;\n        public event Action&lt;EntityID, EntityID&gt; OnEntityDefeated;\n\n        // Titan AI Events (TDD 04.5.2)\n        public event Action&lt;EntityID, TitanAIState, TitanAIState&gt; OnTitanStateChanged; // TitanID, OldState, NewState\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is CombatSystem.BossPartDamagedEvent bossPartDamagedEvent)\n            {\n                OnBossPartDamaged?.Invoke(bossPartDamagedEvent.BossID, bossPartDamagedEvent.PartID, bossPartDamagedEvent.CurrentHealth, bossPartDamagedEvent.MaxHealth, bossPartDamagedEvent.Result);\n            }\n            else if (eventData is CombatSystem.BossPartSeveredEvent bossPartSeveredEvent)\n            {\n                OnBossPartSevered?.Invoke(bossPartSeveredEvent.BossID, bossPartSeveredEvent.PartID);\n            }\n            else if (eventData is CombatSystem.EntityDefeatedEvent entityDefeatedEvent)\n            {\n                OnEntityDefeated?.Invoke(entityDefeatedEvent.EntityID, entityDefeatedEvent.KillerID);\n            }\n            else if (eventData is CombatSystem.TitanAISystem.TitanStateChangedEvent titanStateChangedEvent) // New condition\n            {\n                OnTitanStateChanged?.Invoke(titanStateChangedEvent.TitanID, titanStateChangedEvent.OldState, titanStateChangedEvent.NewState);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"43-chapter-43/#5-testing-titan-ai-state-machine","title":"5. Testing Titan AI State Machine","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.</li> </ol> <pre><code>...\nCombatSystem: Added BossPartsComponent for Boss EntityID(3, Gen:1).\nTitanAISystem: Initialized.\nTitanAISystem: Added TitanAIComponent for EntityID(3, Gen:1).\nTitanAISystem: Boss EntityID(3, Gen:1) transitioning from Idle to Awakening.\nTitanAISystem: Boss EntityID(3, Gen:1) transitioning from Idle to Awakening.\n  - TitanAISystem initialized.\nPlayerStatSystem: Initialized.\n...\n--- Testing Titan AI State Machine ---\nBoss initial HP: 190.0\nBoss Parts initial state: Boss Parts: 4 | Total HP: 190/190\n\n--- Simulating Boss Damage to Trigger Phases ---\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 13.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'LeftArm'.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 13.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'LeftArm'.\nCombatSystem: Part 'LeftArm' of Boss EntityID(3, Gen:1) has been SEVERED!\nTitanAISystem: Boss EntityID(3, Gen:1) had part 'LeftArm' severed. Checking for phase change.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Elemental) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Head'.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Elemental) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Head'.\nCombatSystem: Part 'Head' of Boss EntityID(3, Gen:1) has been SEVERED!\nTitanAISystem: Boss EntityID(3, Gen:1) had part 'Head' severed. Checking for phase change.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 48.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nTitanAISystem: Boss EntityID(3, Gen:1) transitioning from Awakening to Phase1_Default.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 48.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nTitanAISystem: Boss EntityID(3, Gen:1) transitioning from Phase1_Default to Phase2_Enraged.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nTitanAISystem: Boss EntityID(3, Gen:1) transitioning from Phase2_Enraged to Phase3_Desperate.\nCombatSystem: EntityID(0, Gen:1) dealt Dmg: 23.0 (Physical) | Crit: False, Block: False to Boss EntityID(3, Gen:1) part 'Body'.\nCombatSystem: Boss EntityID(3, Gen:1) has been DEFEATED!\n--- End Testing Titan AI State Machine ---\n...\nTitanAISystem: Boss EntityID(3, Gen:1) has finished AWAKENING!\nTitanAISystem: Boss EntityID(3, Gen:1) (Phase 1) performs basic attack on EntityID(0, Gen:1).\nTitanAISystem: Boss EntityID(3, Gen:1) (Phase 2) performs enraged attack on EntityID(0, Gen:1).\nTitanAISystem: Boss EntityID(3, Gen:1) (Phase 3) uses ultimate desperate attack on EntityID(0, Gen:1).\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Initial State: The Titan starts in <code>Awakening</code>.</li> <li>Phase Transitions: As damage is dealt to the boss (reducing its overall health), <code>OnDamageTaken</code> triggers, and the Titan correctly transitions through <code>Phase1_Default</code>, <code>Phase2_Enraged</code>, and <code>Phase3_Desperate</code> based on health thresholds.</li> <li>Severed Limb Reaction: <code>OnBossPartSevered</code> is correctly triggered and handled, showing that the AI can react to specific part destruction.</li> <li>State-Specific Actions: The <code>Tick</code> method calls the appropriate <code>HandlePhaseX</code> method, which prints conceptual attack messages, demonstrating state-specific behaviors.</li> <li>Awakening Timer: The <code>Awakening</code> phase correctly transitions to <code>Phase1_Default</code> after its 5-second timer.</li> </ul> <p>This confirms our <code>TitanAISystem</code> is correctly managing the Titan's AI states and reacting to combat events, providing a foundation for complex, multi-phase boss encounters.</p>"},{"location":"43-chapter-43/#summary","title":"Summary","text":"<p>You have successfully implemented the Titan AI State Machine in the C# Brain, designing <code>TitanAIState</code> and <code>TitanAIComponent</code> to manage the complex behaviors of World Bosses. By creating <code>TitanAISystem</code> to process state transitions, react to <code>OnBossPartSevered</code> and <code>OnDamageTaken</code> events for phase changes, and execute state-specific actions, you've established a robust system for dynamic, multi-phase boss encounters. This crucial component strictly adheres to TDD 04.5.2's specifications, paving the way for truly intelligent and challenging Titan battles in Sigilborne.</p>"},{"location":"43-chapter-43/#next-steps","title":"Next Steps","text":"<p>This concludes Module 6: Combat &amp; Tactical Engagement. We will now move on to Module 7: The Living World - Ecology &amp; AI, starting with Perception System - Spatial Hashing (C#), where we will implement an efficient spatial hashing grid for entities to quickly detect nearby objects and events.</p>"},{"location":"44-chapter-44/","title":"Chapter 7.1: Perception System - Spatial Hashing (C#)","text":""},{"location":"44-chapter-44/#chapter-71-perception-system-spatial-hashing-c","title":"Chapter 7.1: Perception System - Spatial Hashing (C#)","text":"<p>Welcome to Module 7: The Living World - Ecology &amp; AI! This module dives into creating a dynamic, simulated ecosystem. A core requirement for intelligent AI and efficient world simulation is the ability for entities to \"perceive\" their surroundings. This chapter focuses on implementing an efficient Perception System using a Spatial Hash Grid in the C# Brain. This data structure allows entities to quickly detect nearby objects and events without computationally expensive $O(N^2)$ distance checks, as specified in TDD 05.2.1.</p>"},{"location":"44-chapter-44/#1-the-challenge-of-perception-in-large-worlds","title":"1. The Challenge of Perception in Large Worlds","text":"<p>In a world with potentially thousands of active (or virtual) entities, simply iterating through all of them to check for proximity to a single entity is inefficient.</p> <ul> <li>$O(N^2)$ Problem: If every entity checks every other entity, the computational cost grows quadratically with the number of entities.</li> <li>Performance: This quickly becomes a bottleneck for AI and other perception-driven systems.</li> <li>Scalability: A spatial partitioning system is essential for large, open worlds.</li> </ul>"},{"location":"44-chapter-44/#2-the-spatial-hash-grid-solution","title":"2. The Spatial Hash Grid Solution","text":"<p>A Spatial Hash Grid divides the world into a grid of cells. Each entity registers itself in the cell it occupies. To find nearby entities, an entity only needs to check its current cell and its immediate neighbors.</p> <p>Key Principles (TDD 05.2.1):</p> <ul> <li>Grid Size: We'll use a configurable cell size (e.g., 128x128 pixels, roughly one chunk).</li> <li>Logic: Entities register their IDs in the grid cell they occupy.</li> <li>Query: \"Get all entities in cells (X,Y) and neighbors.\"</li> </ul>"},{"location":"44-chapter-44/#3-implementing-spatialhashgridcs","title":"3. Implementing <code>SpatialHashGrid.cs</code>","text":"<p>This class will manage the grid and provide methods for adding, removing, and querying entities.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/</code> folder.</li> <li>Create <code>res://_Brain/Systems/AI/SpatialHashGrid.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/SpatialHashGrid.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Entities; // For EntityID\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Represents a 2D spatial hash grid for efficient proximity queries of entities.\n    /// (TDD 05.2.1)\n    /// &lt;/summary&gt;\n    public class SpatialHashGrid\n    {\n        private Dictionary&lt;Vector2I, List&lt;EntityID&gt;&gt; _grid = new Dictionary&lt;Vector2I, List&lt;EntityID&gt;&gt;();\n        private Dictionary&lt;EntityID, Vector2I&gt; _entityToCell = new Dictionary&lt;EntityID, Vector2I&gt;(); // Tracks which cell an entity is in\n\n        private float _cellSize; // Size of each grid cell (e.g., 128x128 pixels)\n        private float _inverseCellSize; // 1 / _cellSize for faster division\n\n        public SpatialHashGrid(float cellSize)\n        {\n            if (cellSize &lt;= 0) throw new ArgumentOutOfRangeException(nameof(cellSize), \"Cell size must be positive.\");\n            _cellSize = cellSize;\n            _inverseCellSize = 1f / cellSize;\n            GD.Print($\"SpatialHashGrid: Initialized with cell size {_cellSize}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Converts world coordinates to grid cell coordinates.\n        /// &lt;/summary&gt;\n        private Vector2I GetCellCoords(Vector2 worldPosition)\n        {\n            return new Vector2I(\n                (int)MathF.Floor(worldPosition.X * _inverseCellSize),\n                (int)MathF.Floor(worldPosition.Y * _inverseCellSize)\n            );\n        }\n\n        /// &lt;summary&gt;\n        /// Adds or updates an entity's position in the grid.\n        /// &lt;/summary&gt;\n        public void AddOrUpdateEntity(EntityID id, Vector2 newWorldPosition)\n        {\n            Vector2I newCell = GetCellCoords(newWorldPosition);\n\n            if (_entityToCell.TryGetValue(id, out Vector2I oldCell))\n            {\n                if (oldCell == newCell)\n                {\n                    // Entity is still in the same cell, no grid update needed.\n                    return;\n                }\n                // Remove from old cell\n                if (_grid.TryGetValue(oldCell, out List&lt;EntityID&gt; oldCellEntities))\n                {\n                    oldCellEntities.Remove(id);\n                    if (oldCellEntities.Count == 0)\n                    {\n                        _grid.Remove(oldCell); // Clean up empty lists\n                    }\n                }\n            }\n\n            // Add to new cell\n            if (!_grid.ContainsKey(newCell))\n            {\n                _grid[newCell] = new List&lt;EntityID&gt;();\n            }\n            _grid[newCell].Add(id);\n            _entityToCell[id] = newCell;\n            // GD.Print($\"SpatialHashGrid: Entity {id} moved from {oldCell} to {newCell}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Removes an entity from the grid.\n        /// &lt;/summary&gt;\n        public void RemoveEntity(EntityID id)\n        {\n            if (_entityToCell.TryGetValue(id, out Vector2I cell))\n            {\n                if (_grid.TryGetValue(cell, out List&lt;EntityID&gt; cellEntities))\n                {\n                    cellEntities.Remove(id);\n                    if (cellEntities.Count == 0)\n                    {\n                        _grid.Remove(cell);\n                    }\n                }\n                _entityToCell.Remove(id);\n                // GD.Print($\"SpatialHashGrid: Entity {id} removed from cell {cell}.\");\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all entities within a specified radius around a world position.\n        /// (TDD 05.2.1: Query - \"Get all entities in cells (X,Y) and neighbors.\")\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"worldPosition\"&gt;The center of the query.&lt;/param&gt;\n        /// &lt;param name=\"radius\"&gt;The radius to search within.&lt;/param&gt;\n        /// &lt;returns&gt;A list of EntityIDs within the search area.&lt;/returns&gt;\n        public List&lt;EntityID&gt; QueryEntities(Vector2 worldPosition, float radius)\n        {\n            List&lt;EntityID&gt; nearbyEntities = new List&lt;EntityID&gt;();\n            Vector2I centerCell = GetCellCoords(worldPosition);\n\n            // Calculate min/max cells to check based on radius\n            int radiusCells = (int)MathF.Ceiling(radius * _inverseCellSize);\n\n            for (int x = centerCell.X - radiusCells; x &lt;= centerCell.X + radiusCells; x++)\n            {\n                for (int y = centerCell.Y - radiusCells; y &lt;= centerCell.Y + radiusCells; y++)\n                {\n                    Vector2I cellCoords = new Vector2I(x, y);\n                    if (_grid.TryGetValue(cellCoords, out List&lt;EntityID&gt; cellEntities))\n                    {\n                        // Add all entities in this cell.\n                        // A more precise query would filter by actual distance here.\n                        nearbyEntities.AddRange(cellEntities);\n                    }\n                }\n            }\n            return nearbyEntities;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all entities within the same cell as the given entity, including neighbors.\n        /// Useful for simple \"nearby\" checks without a specific radius.\n        /// &lt;/summary&gt;\n        public List&lt;EntityID&gt; GetEntitiesInNeighboringCells(EntityID entityID)\n        {\n            if (!_entityToCell.TryGetValue(entityID, out Vector2I centerCell))\n            {\n                return new List&lt;EntityID&gt;();\n            }\n\n            List&lt;EntityID&gt; nearbyEntities = new List&lt;EntityID&gt;();\n            for (int x = centerCell.X - 1; x &lt;= centerCell.X + 1; x++)\n            {\n                for (int y = centerCell.Y - 1; y &lt;= centerCell.Y + 1; y++)\n                {\n                    Vector2I cellCoords = new Vector2I(x, y);\n                    if (_grid.TryGetValue(cellCoords, out List&lt;EntityID&gt; cellEntities))\n                    {\n                        nearbyEntities.AddRange(cellEntities);\n                    }\n                }\n            }\n            return nearbyEntities;\n        }\n    }\n}\n</code></pre>"},{"location":"44-chapter-44/#4-integrating-spatialhashgrid-into-gamemanager-and-transformsystem","title":"4. Integrating <code>SpatialHashGrid</code> into <code>GameManager</code> and <code>TransformSystem</code>","text":"<p>The <code>SpatialHashGrid</code> needs to be updated whenever an entity's <code>TransformComponent.Position</code> changes. The <code>TransformSystem</code> is the ideal place for this.</p> <ol> <li>Add <code>using Sigilborne.Systems.AI;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>SpatialHashGrid</code> property.</li> <li>Initialize <code>SpatialHashGrid</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public InventorySystem Inventory { get; private set; }\n    public SpatialHashGrid SpatialGrid { get; private set; } // Add SpatialHashGrid property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n\n        // --- Test Spatial Hash Grid ---\n        GD.Print(\"\\n--- Testing Spatial Hash Grid ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID testNpcID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Assuming NPC is ID 1, Gen 1\n        EntityID bossID = Entities.GetEntityMeta(2).Generation == 1 ? new EntityID(2, 1) : EntityID.Invalid; // Assuming Boss is ID 2, Gen 1\n        EntityID newNpcID = Entities.CreateEntity(EntityType.NPC, \"test_new_npc\", new Vector2(250, 250)); // Create new NPC near player\n\n        // Query entities near player\n        List&lt;EntityID&gt; nearby = SpatialGrid.QueryEntities(Transforms.GetTransformRef(playerID).Position, 200f); // 200 pixel radius\n        GD.Print($\"Entities near player ({Transforms.GetTransformRef(playerID).Position}) (Radius 200): {string.Join(\", \", nearby.Select(e =&gt; e.ToString()))}\");\n\n        // Move player far away\n        Transforms.GetTransformRef(playerID).Position = new Vector2(1000, 1000); // This will update SpatialGrid in TransformSystem's event handler\n\n        // Query again\n        nearby = SpatialGrid.QueryEntities(Transforms.GetTransformRef(playerID).Position, 200f);\n        GD.Print($\"Entities near player ({Transforms.GetTransformRef(playerID).Position}) (Radius 200) after move: {string.Join(\", \", nearby.Select(e =&gt; e.ToString()))}\");\n\n        GD.Print(\"--- End Testing Spatial Hash Grid ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta); // StatusEffectSystem needs to tick for duration/tick rate\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to EquipmentSystem) ...\n\n        // Initialize SpatialHashGrid BEFORE TransformSystem (as TransformSystem needs it)\n        SpatialGrid = new SpatialHashGrid(128f); // Cell size 128 (TDD 05.2.1)\n        GD.Print(\"  - SpatialHashGrid initialized.\");\n\n        // Initialize TransformSystem, passing SpatialHashGrid\n        Transforms = new TransformSystem(Entities, Events, SpatialGrid); // Pass SpatialGrid\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        // ... (existing system initializations after TransformSystem) ...\n    }\n}\n</code></pre>"},{"location":"44-chapter-44/#41-update-transformsystemcs-to-use-spatialhashgrid","title":"4.1. Update <code>TransformSystem.cs</code> to use <code>SpatialHashGrid</code>","text":"<p>The <code>TransformSystem</code> is responsible for updating the <code>SpatialHashGrid</code> whenever an entity's position changes.</p> <p>Open <code>res://_Brain/Systems/TransformSystem.cs</code>:</p> <pre><code>// _Brain/Systems/TransformSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.AI; // Add this using directive\n\nnamespace Sigilborne.Systems\n{\n    public class TransformSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private SpatialHashGrid _spatialGrid; // New: Reference to SpatialHashGrid\n\n        private Dictionary&lt;EntityID, TransformComponent&gt; _transforms = new Dictionary&lt;EntityID, TransformComponent&gt;();\n\n        public TransformSystem(EntityManager entityManager, EventBus eventBus, SpatialHashGrid spatialGrid) // Add SpatialHashGrid\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _spatialGrid = spatialGrid; // Store SpatialHashGrid reference\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"TransformSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityManager.EntitySpawnedEvent e)\n        {\n            _transforms.Add(e.ID, new TransformComponent(e.InitialPosition, e.InitialRotation));\n            _spatialGrid.AddOrUpdateEntity(e.ID, e.InitialPosition); // Add to spatial grid on spawn\n            GD.Print($\"TransformSystem: Added transform for {e.ID} and added to spatial grid.\");\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            if (_transforms.ContainsKey(e.ID))\n            {\n                _transforms.Remove(e.ID);\n                _spatialGrid.RemoveEntity(e.ID); // Remove from spatial grid on despawn\n                GD.Print($\"TransformSystem: Removed transform for {e.ID} and removed from spatial grid.\");\n            }\n        }\n\n        // ... (TryGetTransform, TrySetTransform, GetTransformRef methods) ...\n\n        public void Tick(double delta)\n        {\n            // TransformSystem's Tick is currently empty as its data is updated externally.\n            // However, we need to ensure the SpatialGrid is updated whenever a transform changes.\n            // This is primarily handled by PhysicsSystem.ReportFinalPosition.\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to set the TransformComponent for a given entity.\n        /// This method is called by PhysicsSystem to reconcile positions.\n        /// (TDD 17.2.3: Reconciliation - Overwrite Brain's internal CurrentPosition)\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;True if the component exists and is set, false otherwise.&lt;/returns&gt;\n        public bool TrySetTransform(EntityID id, TransformComponent transform)\n        {\n            if (!_entityManager.IsValid(id) || !_transforms.ContainsKey(id))\n            {\n                return false;\n            }\n            // Only update spatial grid if position actually changed\n            if (_transforms[id].Position != transform.Position)\n            {\n                _spatialGrid.AddOrUpdateEntity(id, transform.Position); // Update spatial grid on position change\n            }\n            _transforms[id] = transform;\n            return true;\n        }\n    }\n}\n</code></pre>"},{"location":"44-chapter-44/#42-update-gamemanager-to-pass-spatialhashgrid-to-transformsystem","title":"4.2. Update <code>GameManager</code> to Pass <code>SpatialHashGrid</code> to <code>TransformSystem</code>","text":"<p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the <code>TransformSystem</code> initialization in <code>InitializeSystems()</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize TransformSystem, passing SpatialHashGrid\n        Transforms = new TransformSystem(Entities, Events, SpatialGrid); // Pass SpatialGrid\n        GD.Print(\"  - TransformSystem initialized.\");\n// ...\n</code></pre>"},{"location":"44-chapter-44/#5-testing-the-spatial-hash-grid","title":"5. Testing the Spatial Hash Grid","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Spatial Hash Grid\" section.</li> </ol> <pre><code>...\nSpatialHashGrid: Initialized with cell size 128.\n  - SpatialHashGrid initialized.\nTransformSystem: Initialized.\n  - TransformSystem initialized.\n... (entity spawns, including newNpcID) ...\nTransformSystem: EntityID(0, Gen:1) added to spatial grid.\nTransformSystem: EntityID(1, Gen:1) added to spatial grid.\nTransformSystem: EntityID(2, Gen:1) added to spatial grid.\nTransformSystem: EntityID(3, Gen:1) added to spatial grid.\nTransformSystem: EntityID(4, Gen:1) added to spatial grid.\n...\n--- Testing Spatial Hash Grid ---\nEntities near player (200, 200) (Radius 200): EntityID(0, Gen:1), EntityID(1, Gen:1), EntityID(2, Gen:1), EntityID(3, Gen:1), EntityID(4, Gen:1)\nSpatialHashGrid: Entity EntityID(0, Gen:1) moved from (1,1) to (7,7).\nEntities near player (1000, 1000) (Radius 200) after move: EntityID(0, Gen:1)\n--- End Testing Spatial Hash Grid ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Initialization: <code>SpatialHashGrid</code> is initialized.</li> <li>Add/Update: <code>TransformSystem</code> correctly adds entities to the grid on spawn and updates them when their position changes (e.g., player moving to 1000,1000).</li> <li>Query:<ul> <li>The first query (near player at 200,200) correctly finds all entities (player, NPC, boss, new NPC) because they are all initially spawned close together, within a 200-pixel radius (which spans a few 128-pixel cells).</li> <li>The second query (near player at 1000,1000) only finds the player, demonstrating that the other entities are no longer considered \"nearby\" by the grid, improving query efficiency.</li> </ul> </li> </ul> <p>This confirms our <code>SpatialHashGrid</code> is functional, efficiently managing entity positions for proximity queries.</p>"},{"location":"44-chapter-44/#summary","title":"Summary","text":"<p>You have successfully implemented the Perception System using a Spatial Hash Grid in the C# Brain. By designing <code>SpatialHashGrid</code> to manage entity positions in a grid-based structure and integrating it with <code>TransformSystem</code> for automatic updates, you've established an efficient mechanism for proximity queries. This crucial component strictly adheres to TDD 05.2.1's specifications, providing the foundational layer for AI perception and other range-based interactions in Sigilborne's living world.</p>"},{"location":"44-chapter-44/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on The Senses, implementing <code>Vision</code>, <code>Hearing</code>, and <code>Chakra Sense</code> components for entities, which will leverage the <code>SpatialHashGrid</code> to detect nearby entities and events, enabling more sophisticated AI behavior.</p>"},{"location":"45-chapter-45/","title":"Chapter 7.2: The Senses - Vision, Hearing & Chakra Sense (C#)","text":""},{"location":"45-chapter-45/#chapter-72-the-senses-vision-hearing-chakra-sense-c","title":"Chapter 7.2: The Senses - Vision, Hearing &amp; Chakra Sense (C#)","text":"<p>With our <code>SpatialHashGrid</code> efficiently providing lists of nearby entities, we can now build the actual Perception System that allows entities to \"sense\" their environment. This chapter focuses on implementing <code>Vision</code>, <code>Hearing</code>, and <code>Chakra Sense</code> components for entities in the C# Brain, which will leverage the <code>SpatialHashGrid</code> to detect nearby entities and events, enabling more sophisticated AI behavior, as specified in TDD 05.2.2.</p>"},{"location":"45-chapter-45/#1-the-layered-nature-of-perception","title":"1. The Layered Nature of Perception","text":"<p>The GDD (B10.4) describes various detection types (Sight, Sound, Chakra Sensing, Resonance, Bloodline). Our TDD (05.2.2) boils these down to:</p> <ul> <li>Vision: Line-of-sight and cone checks.</li> <li>Hearing: Radius checks based on sound volume.</li> <li>Chakra Sense: Detecting active spells/chakra through walls.</li> </ul> <p>Each sense will contribute to an entity's overall awareness.</p>"},{"location":"45-chapter-45/#2-defining-perceptioncomponent","title":"2. Defining <code>PerceptionComponent</code>","text":"<p>This component will hold the parameters for an entity's sensory capabilities.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/PerceptionComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/PerceptionComponent.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Stores the parameters defining an entity's sensory capabilities.\n    /// This is a component-like data structure managed by the PerceptionSystem.\n    /// (TDD 05.2.2)\n    /// &lt;/summary&gt;\n    public struct PerceptionComponent\n    {\n        // Vision parameters\n        public float VisionRange;       // Max distance to see\n        public float VisionAngle;       // Field of View angle in degrees (e.g., 120 for 120 degrees total)\n\n        // Hearing parameters\n        public float HearingRange;      // Max distance to hear\n        public float HearingSensitivity; // Multiplier for how well sounds are heard (e.g., 1.0 normal, 1.5 keen)\n\n        // Chakra Sense parameters\n        public float ChakraSenseRange;  // Max distance to sense chakra\n        public float ChakraSenseSensitivity; // Multiplier for how well chakra is sensed\n\n        public PerceptionComponent(float visionRange = 200f, float visionAngle = 120f, float hearingRange = 150f, float hearingSensitivity = 1.0f, float chakraSenseRange = 100f, float chakraSenseSensitivity = 1.0f)\n        {\n            VisionRange = visionRange;\n            VisionAngle = visionAngle;\n            HearingRange = hearingRange;\n            HearingSensitivity = hearingSensitivity;\n            ChakraSenseRange = chakraSenseRange;\n            ChakraSenseSensitivity = chakraSenseSensitivity;\n        }\n\n        public override string ToString()\n        {\n            return $\"Vis: {VisionRange:F0}m/{VisionAngle:F0}\u00b0, Hear: {HearingRange:F0}m, Cha: {ChakraSenseRange:F0}m\";\n        }\n    }\n}\n</code></pre>"},{"location":"45-chapter-45/#3-implementing-perceptionsystemcs","title":"3. Implementing <code>PerceptionSystem.cs</code>","text":"<p>This system will: *   Manage <code>PerceptionComponent</code>s. *   Use <code>SpatialHashGrid</code> to get nearby entities. *   Implement <code>CanSee()</code>, <code>CanHear()</code>, and <code>CanSenseChakra()</code> logic.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/PerceptionSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/PerceptionSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components; // For TransformComponent\nusing Sigilborne.Systems.Magic; // For active spells\nusing System.Linq;\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Manages entities' sensory capabilities (vision, hearing, chakra sense).\n    /// Leverages SpatialHashGrid for efficient nearby entity queries.\n    /// (TDD 05.2.2)\n    /// &lt;/summary&gt;\n    public class PerceptionSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem; // To get entity positions/rotations\n        private SpatialHashGrid _spatialGrid;     // To get nearby entities\n\n        // Dictionary to store PerceptionComponent for entities that can perceive.\n        private Dictionary&lt;EntityID, PerceptionComponent&gt; _perceptionComponents = new Dictionary&lt;EntityID, PerceptionComponent&gt;();\n\n        public PerceptionSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, SpatialHashGrid spatialGrid)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _spatialGrid = spatialGrid;\n\n            // Subscribe to entity lifecycle events\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"PerceptionSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add PerceptionComponent to entities that should perceive (Player, NPC, some Animals)\n            if (type == EntityType.Player || type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // For player, initial vision range is higher.\n                if (type == EntityType.Player)\n                {\n                    _perceptionComponents.Add(id, new PerceptionComponent(visionRange: 300f, visionAngle: 180f, hearingRange: 200f, chakraSenseRange: 150f));\n                }\n                else // NPC / Animal\n                {\n                    _perceptionComponents.Add(id, new PerceptionComponent(visionRange: 200f, visionAngle: 120f, hearingRange: 150f, chakraSenseRange: 100f));\n                }\n                GD.Print($\"PerceptionSystem: Added PerceptionComponent for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _perceptionComponents.Remove(e.ID);\n            GD.Print($\"PerceptionSystem: Removed PerceptionComponent for {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a mutable reference to an entity's PerceptionComponent.\n        /// &lt;/summary&gt;\n        public ref PerceptionComponent GetPerceptionComponentRef(EntityID id)\n        {\n            if (!_entityManager.IsValid(id) || !_perceptionComponents.ContainsKey(id))\n            {\n                throw new InvalidOperationException($\"Entity {id} is invalid or does not have a PerceptionComponent.\");\n            }\n            return ref _perceptionComponents.GetValueRef(id);\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if a perceiver entity can see a target entity.\n        /// (TDD 05.2.2.1: Vision - Cone check (Dot Product + Raycast))\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"perceiverID\"&gt;The entity attempting to see.&lt;/param&gt;\n        /// &lt;param name=\"targetID\"&gt;The entity being looked for.&lt;/param&gt;\n        /// &lt;returns&gt;True if the target is seen, false otherwise.&lt;/returns&gt;\n        public bool CanSee(EntityID perceiverID, EntityID targetID)\n        {\n            if (!_entityManager.IsValid(perceiverID) || !_entityManager.IsValid(targetID) || perceiverID == targetID) return false;\n            if (!_perceptionComponents.TryGetValue(perceiverID, out PerceptionComponent perceiverPerception)) return false;\n            if (!_transformSystem.TryGetTransform(perceiverID, out TransformComponent perceiverTransform)) return false;\n            if (!_transformSystem.TryGetTransform(targetID, out TransformComponent targetTransform)) return false;\n\n            // 1. Range check\n            float distance = perceiverTransform.Position.DistanceTo(targetTransform.Position);\n            if (distance &gt; perceiverPerception.VisionRange) return false;\n\n            // 2. Angle (Field of View) check\n            Vector2 directionToTarget = (targetTransform.Position - perceiverTransform.Position).Normalized();\n            Vector2 perceiverForward = Vector2.FromAngle(Mathf.DegToRad(perceiverTransform.RotationDegrees)); // Convert degrees to radians for angle\n\n            float angleToTarget = perceiverForward.AngleTo(directionToTarget); // Angle in radians\n            float halfVisionAngleRad = Mathf.DegToRad(perceiverPerception.VisionAngle / 2f);\n\n            if (Mathf.Abs(angleToTarget) &gt; halfVisionAngleRad) return false;\n\n            // 3. Line-of-sight (Raycast) check (Conceptual for now, involves Godot's physics)\n            // This would typically be a call to Godot's PhysicsServer or a custom raycast system.\n            // For now, we assume no obstacles.\n            bool lineOfSightClear = true; // GameManager.Instance.Physics.Raycast(perceiverTransform.Position, targetTransform.Position);\n            if (!lineOfSightClear) return false;\n\n            // Later: Stealth mechanics (GDD B10.2). Check target's visibility/stealth score.\n            // if (_stealthSystem.GetVisibility(targetID) &lt; perceiverPerception.VisionSensitivity) return false;\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if a perceiver entity can hear a sound event.\n        /// (TDD 05.2.2.2: Hearing - Circle check)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"perceiverID\"&gt;The entity attempting to hear.&lt;/param&gt;\n        /// &lt;param name=\"soundOrigin\"&gt;The world position of the sound.&lt;/param&gt;\n        /// &lt;param name=\"soundVolume\"&gt;The raw volume of the sound.&lt;/param&gt;\n        /// &lt;returns&gt;True if the sound is heard, false otherwise.&lt;/returns&gt;\n        public bool CanHear(EntityID perceiverID, Vector2 soundOrigin, float soundVolume)\n        {\n            if (!_entityManager.IsValid(perceiverID)) return false;\n            if (!_perceptionComponents.TryGetValue(perceiverID, out PerceptionComponent perceiverPerception)) return false;\n            if (!_transformSystem.TryGetTransform(perceiverID, out TransformComponent perceiverTransform)) return false;\n\n            float distance = perceiverTransform.Position.DistanceTo(soundOrigin);\n            // Sound's effective range is its volume scaled by perceiver's sensitivity\n            float effectiveHearingRange = perceiverPerception.HearingRange * perceiverPerception.HearingSensitivity;\n\n            return distance &lt;= effectiveHearingRange &amp;&amp; distance &lt;= soundVolume; // Sound must be within range AND loud enough\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if a perceiver entity can sense the chakra of an active spell.\n        /// (TDD 05.2.2.3: Chakra Sense - Detects active spells through walls.)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"perceiverID\"&gt;The entity attempting to sense.&lt;/param&gt;\n        /// &lt;param name=\"spellOrigin\"&gt;The world position of the spell.&lt;/param&gt;\n        /// &lt;param name=\"spellIntensity\"&gt;The raw intensity of the spell's chakra signature.&lt;/param&gt;\n        /// &lt;returns&gt;True if the chakra is sensed, false otherwise.&lt;/returns&gt;\n        public bool CanSenseChakra(EntityID perceiverID, Vector2 spellOrigin, float spellIntensity)\n        {\n            if (!_entityManager.IsValid(perceiverID)) return false;\n            if (!_perceptionComponents.TryGetValue(perceiverID, out PerceptionComponent perceiverPerception)) return false;\n            if (!_transformSystem.TryGetTransform(perceiverID, out TransformComponent perceiverTransform)) return false;\n\n            float distance = perceiverTransform.Position.DistanceTo(spellOrigin);\n            // Chakra sense is effective if spell intensity is greater than distance (TDD 05.2.2.3)\n            // And within perceiver's range.\n            return distance &lt;= perceiverPerception.ChakraSenseRange &amp;&amp; spellIntensity &gt; distance * (1f / perceiverPerception.ChakraSenseSensitivity);\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a list of entities that a perceiver can currently detect (see, hear, or sense chakra).\n        /// (TDD 05.2.1: Query - \"Get all entities in cells (X,Y) and neighbors.\")\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"perceiverID\"&gt;The entity doing the perceiving.&lt;/param&gt;\n        /// &lt;returns&gt;A list of detected EntityIDs.&lt;/returns&gt;\n        public List&lt;EntityID&gt; GetDetectedEntities(EntityID perceiverID)\n        {\n            if (!_entityManager.IsValid(perceiverID) || !_transformSystem.TryGetTransform(perceiverID, out TransformComponent perceiverTransform) || !_perceptionComponents.TryGetValue(perceiverID, out PerceptionComponent perceiverPerception))\n            {\n                return new List&lt;EntityID&gt;();\n            }\n\n            // Query a broad area from the spatial grid first\n            List&lt;EntityID&gt; potentialTargets = _spatialGrid.QueryEntities(perceiverTransform.Position, perceiverPerception.VisionRange + perceiverPerception.HearingRange + perceiverPerception.ChakraSenseRange);\n\n            List&lt;EntityID&gt; detected = new List&lt;EntityID&gt;();\n            foreach (EntityID targetID in potentialTargets)\n            {\n                if (perceiverID == targetID) continue; // Don't detect self\n\n                // Combine senses\n                if (CanSee(perceiverID, targetID))\n                {\n                    detected.Add(targetID);\n                }\n                // Add hearing/chakra sense for other entities (conceptual sound/spell events)\n                // else if (CanHear(perceiverID, targetTransform.Position, someSoundVolume)) { detected.Add(targetID); }\n                // else if (CanSenseChakra(perceiverID, targetTransform.Position, someChakraIntensity)) { detected.Add(targetID); }\n            }\n            return detected.Distinct().ToList(); // Remove duplicates if detected by multiple senses\n        }\n    }\n}\n</code></pre>"},{"location":"45-chapter-45/#4-integrating-perceptionsystem-into-gamemanager","title":"4. Integrating <code>PerceptionSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.AI;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>PerceptionSystem</code> property.</li> <li>Initialize <code>PerceptionSystem</code> in <code>InitializeSystems()</code> after <code>SpatialGrid</code> and <code>Transforms</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public SpatialHashGrid SpatialGrid { get; private set; }\n    public PerceptionSystem Perception { get; private set; } // Add PerceptionSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n\n        // --- Test Spatial Hash Grid ---\n        // ... (existing spatial grid tests) ...\n\n        // --- Test Perception System ---\n        GD.Print(\"\\n--- Testing Perception System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID testNpcID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Assuming NPC is ID 1, Gen 1\n        EntityID bossID = Entities.GetEntityMeta(2).Generation == 1 ? new EntityID(2, 1) : EntityID.Invalid; // Assuming Boss is ID 2, Gen 1\n        EntityID newNpcID = Entities.GetEntityMeta(4).Generation == 1 ? new EntityID(4, 1) : EntityID.Invalid; // Assuming newNpcID is ID 4, Gen 1\n\n        // Move NPC/Boss closer to player for initial test\n        Transforms.GetTransformRef(testNpcID).Position = Transforms.GetTransformRef(playerID).Position + new Vector2(50, 0);\n        Transforms.GetTransformRef(bossID).Position = Transforms.GetTransformRef(playerID).Position + new Vector2(100, 50);\n        Transforms.GetTransformRef(newNpcID).Position = Transforms.GetTransformRef(playerID).Position + new Vector2(-70, -20);\n\n        // Player turns to face testNpcID\n        Vector2 playerPos = Transforms.GetTransformRef(playerID).Position;\n        Vector2 dirToNpc = (Transforms.GetTransformRef(testNpcID).Position - playerPos).Normalized();\n        Transforms.GetTransformRef(playerID).RotationDegrees = Mathf.RadToDeg(dirToNpc.Angle());\n\n        List&lt;EntityID&gt; detectedByPlayer = Perception.GetDetectedEntities(playerID);\n        GD.Print($\"Player {playerID} detected entities: {string.Join(\", \", detectedByPlayer.Select(e =&gt; e.ToString()))}\");\n\n        // Move player far away\n        Transforms.GetTransformRef(playerID).Position = new Vector2(1000, 1000); // This updates SpatialGrid\n        detectedByPlayer = Perception.GetDetectedEntities(playerID); // Should be empty or just self\n        GD.Print($\"Player {playerID} detected entities after moving far: {string.Join(\", \", detectedByPlayer.Select(e =&gt; e.ToString()))}\");\n\n        GD.Print(\"--- End Testing Perception System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        // PerceptionSystem doesn't have a Tick method, its operations are query-driven.\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to SpatialGrid) ...\n\n        // Initialize TransformSystem, passing SpatialHashGrid\n        Transforms = new TransformSystem(Entities, Events, SpatialGrid);\n        GD.Print(\"  - TransformSystem initialized.\");\n\n        // Initialize PerceptionSystem AFTER TransformSystem and SpatialGrid\n        Perception = new PerceptionSystem(Entities, Events, Transforms, SpatialGrid); // Pass dependencies\n        GD.Print(\"  - PerceptionSystem initialized.\");\n\n        // ... (existing system initializations after PerceptionSystem) ...\n    }\n}\n</code></pre>"},{"location":"45-chapter-45/#5-testing-the-perception-system","title":"5. Testing the Perception System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Perception System\" section.</li> </ol> <pre><code>...\nPerceptionSystem: Initialized.\n  - PerceptionSystem initialized.\n... (entity spawns and spatial grid updates) ...\n--- Testing Perception System ---\nPlayer EntityID(0, Gen:1) detected entities: EntityID(1, Gen:1), EntityID(4, Gen:1), EntityID(2, Gen:1)\nEntities near player (1000, 1000) (Radius 200) after move:\nPlayer EntityID(0, Gen:1) detected entities after moving far:\n--- End Testing Perception System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Initialization: <code>PerceptionSystem</code> is initialized and adds <code>PerceptionComponent</code>s to the player, NPCs, and boss.</li> <li>Initial Detection: The player (at 200,200) successfully detects <code>testNpcID</code> (at 250,200), <code>newNpcID</code> (at 130,180), and <code>bossID</code> (at 300,250) because they are within the player's <code>VisionRange</code> (300f) and <code>VisionAngle</code> (180 degrees, effectively a wide cone or circle if distance is small).</li> <li>Movement Affects Detection: When the player moves far away, the <code>GetDetectedEntities</code> call returns an empty list, demonstrating that the <code>SpatialHashGrid</code> and distance checks are working.</li> </ul> <p>This confirms our <code>PerceptionSystem</code> is functional, leveraging the <code>SpatialHashGrid</code> and <code>TransformSystem</code> to perform vision checks. Hearing and Chakra Sense are conceptually ready to be integrated with actual sound/spell events.</p>"},{"location":"45-chapter-45/#summary","title":"Summary","text":"<p>You have successfully implemented The Senses for Sigilborne's entities, designing <code>PerceptionComponent</code> to hold sensory parameters and creating <code>PerceptionSystem</code> to manage these capabilities. By leveraging <code>SpatialHashGrid</code> and <code>TransformSystem</code>, <code>PerceptionSystem</code> can now efficiently perform <code>Vision</code> (range, angle) checks, and is conceptually ready for <code>Hearing</code> and <code>Chakra Sense</code> queries, strictly adhering to TDD 05.2.2's specifications. This crucial step provides the foundational layer for AI awareness and sophisticated entity behavior in the living world.</p>"},{"location":"45-chapter-45/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Stealth Mechanics, implementing <code>Visibility</code> as a float value based on factors like light level and movement speed, and designing a <code>Detection Meter</code> to transition NPCs into \"Alert\" states, enriching the tactical interplay between stealth and perception.</p>"},{"location":"46-chapter-46/","title":"Chapter 7.3: Stealth Mechanics - Visibility & Detection Meter (C#)","text":""},{"location":"46-chapter-46/#chapter-73-stealth-mechanics-visibility-detection-meter-c","title":"Chapter 7.3: Stealth Mechanics - Visibility &amp; Detection Meter (C#)","text":"<p>With our <code>PerceptionSystem</code> allowing entities to see and hear, it's time to introduce Stealth Mechanics. This chapter focuses on implementing <code>Visibility</code> as a float value for entities, influenced by factors like light level, movement speed, and (conceptually) camouflage. We'll also design a <code>Detection Meter</code> that, when filled, transitions NPCs into an \"Alert\" state, creating a tactical interplay between stealth and perception, as specified in TDD 05.2.3 and GDD B10.</p>"},{"location":"46-chapter-46/#1-the-dynamic-nature-of-stealth","title":"1. The Dynamic Nature of Stealth","text":"<p>The GDD (B10.2) states: \"Stealth is weak early, viable mid-game, and powerful at high mastery, but always counterable.\" This implies:</p> <ul> <li>Non-Binary Stealth: Not just \"hidden\" or \"detected,\" but a continuous <code>Visibility</code> score.</li> <li>Environmental Influence: Light, shadows, and terrain affect visibility.</li> <li>Player Skill: Movement control and glyphs (Veil, Echo) can reduce visibility.</li> <li>NPC Detection: NPCs accumulate \"detection\" over time, leading to alert states.</li> </ul>"},{"location":"46-chapter-46/#2-defining-stealthcomponent-and-detectioncomponent","title":"2. Defining <code>StealthComponent</code> and <code>DetectionComponent</code>","text":"<p>We need components to store an entity's stealth properties (what makes it hidden) and its detection properties (how much it's currently detected).</p> <ol> <li>Create <code>res://_Brain/Systems/AI/StealthComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/StealthComponent.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Stores the parameters defining an entity's stealth capabilities and current visibility.\n    /// (TDD 05.2.3)\n    /// &lt;/summary&gt;\n    public struct StealthComponent\n    {\n        public float BaseVisibility;    // Base visibility (1.0 = fully visible, 0.0 = invisible)\n        public float MovementNoise;     // How much noise this entity generates when moving (0-1)\n        public float CamouflageBonus;   // Environmental camouflage bonus (e.g., -0.2 for 20% less visible)\n        public float ChakraSignatureMod; // How much this entity's chakra signature is dampened (0-1)\n\n        public StealthComponent(float baseVisibility = 1.0f, float movementNoise = 0.5f, float camouflageBonus = 0f, float chakraSignatureMod = 0f)\n        {\n            BaseVisibility = baseVisibility;\n            MovementNoise = movementNoise;\n            CamouflageBonus = camouflageBonus;\n            ChakraSignatureMod = chakraSignatureMod;\n        }\n\n        public override string ToString()\n        {\n            return $\"Vis: {BaseVisibility:F2}, Noise: {MovementNoise:F2}, Camo: {CamouflageBonus:F2}\";\n        }\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/AI/DetectionComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/DetectionComponent.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Stores an entity's current detection state by a specific perceiver.\n    /// (TDD 05.2.3: Detection Meter)\n    /// &lt;/summary&gt;\n    public struct DetectionComponent\n    {\n        public EntityID PerceiverID;       // The entity doing the detecting (e.g., an NPC looking at the player)\n        public float DetectionMeter;        // Accumulates detection (0-100). If &gt; Threshold, target is Alerted.\n        public float MaxDetectionMeter;     // Max value of the meter (e.g., 100)\n        public float DecayRate;             // How fast the meter decays when not actively detected\n        public bool IsAlerted;             // True if the target is fully detected and the perceiver is alerted.\n\n        public DetectionComponent(EntityID perceiverID, float maxDetectionMeter = 100f, float decayRate = 5f)\n        {\n            PerceiverID = perceiverID;\n            DetectionMeter = 0;\n            MaxDetectionMeter = maxDetectionMeter;\n            DecayRate = decayRate;\n            IsAlerted = false;\n        }\n\n        public override string ToString()\n        {\n            return $\"Det: {DetectionMeter:F1}/{MaxDetectionMeter:F0} (Alerted: {IsAlerted})\";\n        }\n    }\n}\n</code></pre>"},{"location":"46-chapter-46/#3-implementing-stealthsystemcs","title":"3. Implementing <code>StealthSystem.cs</code>","text":"<p>This system will: *   Manage <code>StealthComponent</code>s. *   Calculate an entity's <code>CurrentVisibility</code> and <code>CurrentNoise</code> based on its state. *   Manage <code>DetectionComponent</code>s, updating meters and triggering <code>Alerted</code> states.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/StealthSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/StealthSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components; // For TransformComponent\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing Sigilborne.Systems.Movement; // For movement speed\nusing Sigilborne.Systems.Weather; // For light level / environmental effects\nusing System.Linq;\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Manages stealth mechanics, including calculating entity visibility/noise and\n    /// handling detection meters for perceivers.\n    /// (TDD 05.2.3, GDD B10)\n    /// &lt;/summary&gt;\n    public class StealthSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private TransformSystem _transformSystem;\n        private BiologicalSystem _biologicalSystem; // For CoreStats (movement speed)\n        private MovementSystem _movementSystem;     // For actual velocity\n        private WeatherSystem _weatherSystem;       // For light level / environmental effects\n        private PerceptionSystem _perceptionSystem; // To query perceivers\n\n        // Dictionary to store StealthComponent for entities that can be stealthy.\n        private Dictionary&lt;EntityID, StealthComponent&gt; _stealthComponents = new Dictionary&lt;EntityID, StealthComponent&gt;();\n\n        // Dictionary to store DetectionComponents (perceiver -&gt; target -&gt; detection state)\n        // For simplicity, we'll store per-target detection in a list on the target for now,\n        // rather than per-perceiver. This means a target knows *how much* it's detected.\n        private Dictionary&lt;EntityID, List&lt;DetectionComponent&gt;&gt; _targetDetectionStates = new Dictionary&lt;EntityID, List&lt;DetectionComponent&gt;&gt;();\n\n\n        public StealthSystem(EntityManager entityManager, EventBus eventBus, TransformSystem transformSystem, BiologicalSystem biologicalSystem, MovementSystem movementSystem, WeatherSystem weatherSystem, PerceptionSystem perceptionSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _transformSystem = transformSystem;\n            _biologicalSystem = biologicalSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n            _perceptionSystem = perceptionSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            GD.Print(\"StealthSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add StealthComponent to entities that can be stealthy (Player, NPC, some Animals)\n            if (type == EntityType.Player || type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // Player has better base stealth\n                if (type == EntityType.Player)\n                {\n                    _stealthComponents.Add(id, new StealthComponent(baseVisibility: 0.8f, movementNoise: 0.3f));\n                }\n                else // NPC / Animal\n                {\n                    _stealthComponents.Add(id, new StealthComponent(baseVisibility: 1.0f, movementNoise: 0.5f));\n                }\n                _targetDetectionStates.Add(id, new List&lt;DetectionComponent&gt;()); // Add detection states for this target\n                GD.Print($\"StealthSystem: Added StealthComponent for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _stealthComponents.Remove(e.ID);\n            _targetDetectionStates.Remove(e.ID);\n            GD.Print($\"StealthSystem: Removed StealthComponent for {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the StealthSystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            foreach (var kvp in _stealthComponents)\n            {\n                EntityID targetID = kvp.Key;\n                ref StealthComponent stealth = ref _stealthComponents.GetValueRef(targetID);\n\n                if (!_entityManager.IsValid(targetID)) continue;\n\n                // --- Calculate Current Visibility (TDD 05.2.3) ---\n                float currentVisibility = CalculateCurrentVisibility(targetID, stealth);\n                // GD.Print($\"StealthSystem: {targetID} Current Visibility: {currentVisibility:P1}\");\n\n                // --- Update Detection Meters ---\n                // For each target, iterate through all potential perceivers.\n                // This is a simplified O(N*M) loop. In a real game, only relevant perceivers would update.\n                // For now, let's just make the player the target and update its detection by an \"abstract\" NPC.\n                if (targetID == _entityManager.GetPlayerEntityID())\n                {\n                    UpdatePlayerDetection(targetID, currentVisibility, delta);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Calculates the current effective visibility of an entity.\n        /// (TDD 05.2.3: Factors: Light Level (from TileMap), Movement Speed, Camouflage)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"entityID\"&gt;The entity whose visibility is being calculated.&lt;/param&gt;\n        /// &lt;param name=\"stealthComponent\"&gt;The entity's StealthComponent.&lt;/param&gt;\n        /// &lt;returns&gt;A float from 0.0 (invisible) to 1.0 (fully visible).&lt;/returns&gt;\n        private float CalculateCurrentVisibility(EntityID entityID, StealthComponent stealthComponent)\n        {\n            float visibility = stealthComponent.BaseVisibility;\n\n            // 1. Movement Speed (TDD 05.2.3)\n            if (_movementSystem.TryGetCoreStats(entityID, out CoreStats coreStats))\n            {\n                Vector2 velocity = _movementSystem.GetVelocity(entityID);\n                float speedRatio = velocity.Length() / coreStats.MoveSpeed; // 0 for idle, 1 for max speed\n                visibility += speedRatio * stealthComponent.MovementNoise; // Moving faster increases visibility\n            }\n\n            // 2. Light Level (from WeatherSystem, conceptual local light) (TDD 05.2.3)\n            // if (_transformSystem.TryGetTransform(entityID, out TransformComponent transform))\n            // {\n            //     float lightLevel = _weatherSystem.GetLightLevelAt(transform.Position); // Conceptual\n            //     visibility *= lightLevel; // Darker areas reduce visibility\n            // }\n\n            // 3. Camouflage Bonus (TDD 05.2.3)\n            visibility += stealthComponent.CamouflageBonus; // Negative bonus reduces visibility\n\n            // Later: Chakra signature (GDD B10.3.B)\n            // visibility += stealthComponent.ChakraSignatureMod * _biologicalSystem.GetChakraSignatureStrength(entityID);\n\n            return Mathf.Clamp(visibility, 0f, 1f);\n        }\n\n        /// &lt;summary&gt;\n        /// Calculates the current effective noise generated by an entity.\n        /// &lt;/summary&gt;\n        public float CalculateCurrentNoise(EntityID entityID, StealthComponent stealthComponent)\n        {\n            if (!_biologicalSystem.TryGetCoreStats(entityID, out CoreStats coreStats)) return 0;\n            Vector2 velocity = _movementSystem.GetVelocity(entityID);\n            float speedRatio = velocity.Length() / coreStats.MoveSpeed;\n            return stealthComponent.MovementNoise * speedRatio;\n        }\n\n        /// &lt;summary&gt;\n        /// Updates the player's detection meter by an abstract NPC perceiver.\n        /// (TDD 05.2.3: Detection Meter)\n        /// &lt;/summary&gt;\n        private void UpdatePlayerDetection(EntityID playerID, float playerVisibility, double delta)\n        {\n            // For testing, let's use a dummy NPC perceiver.\n            // In a real game, this would loop through actual NPCs perceiving the player.\n            EntityID dummyNpcID = GameManager.Instance.Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid;\n            if (!dummyNpcID.IsValid()) return;\n\n            // Find or create the detection component for this perceiver-target pair\n            List&lt;DetectionComponent&gt; detections = _targetDetectionStates[playerID];\n            int detectionIndex = detections.FindIndex(d =&gt; d.PerceiverID == dummyNpcID);\n\n            if (detectionIndex == -1)\n            {\n                // Create a new detection entry if none exists for this perceiver\n                detections.Add(new DetectionComponent(dummyNpcID));\n                detectionIndex = detections.Count - 1;\n            }\n\n            ref DetectionComponent playerDetection = ref detections.GetValueRef(detectionIndex);\n\n            // --- Detection Meter Logic ---\n            // If the player is 'seen' by the dummy NPC (conceptual)\n            bool isPlayerCurrentlySeen = _perceptionSystem.CanSee(dummyNpcID, playerID); // Use NPC's vision to see player\n\n            if (isPlayerCurrentlySeen)\n            {\n                // Increase detection meter based on player's visibility and perceiver's sensitivity\n                float detectionGain = playerVisibility * _perceptionSystem.GetPerceptionComponentRef(dummyNpcID).VisionRange * 0.05f * (float)delta; // Gain faster if more visible\n                playerDetection.DetectionMeter += detectionGain;\n                // GD.Print($\"StealthSystem: {dummyNpcID} gains detection on {playerID}. Gain: {detectionGain:F2}. Current: {playerDetection.DetectionMeter:F1}\");\n            }\n            else\n            {\n                // Decay detection meter if not currently seen\n                playerDetection.DetectionMeter -= playerDetection.DecayRate * (float)delta;\n            }\n\n            playerDetection.DetectionMeter = Mathf.Clamp(playerDetection.DetectionMeter, 0f, playerDetection.MaxDetectionMeter);\n\n            // Check for alert state transition (TDD 05.2.3)\n            if (playerDetection.DetectionMeter &gt;= playerDetection.MaxDetectionMeter * 0.8f &amp;&amp; !playerDetection.IsAlerted) // 80% to alert\n            {\n                playerDetection.IsAlerted = true;\n                GD.Print($\"StealthSystem: Player {playerID} is now ALERTED by {dummyNpcID}!\");\n                _eventBus.Publish(new PlayerAlertedEvent { PlayerID = playerID, PerceiverID = dummyNpcID, IsAlerted = true });\n            }\n            else if (playerDetection.DetectionMeter &lt; playerDetection.MaxDetectionMeter * 0.5f &amp;&amp; playerDetection.IsAlerted) // Drop below 50% to de-alert\n            {\n                playerDetection.IsAlerted = false;\n                GD.Print($\"StealthSystem: Player {playerID} is no longer ALERTED by {dummyNpcID}.\");\n                _eventBus.Publish(new PlayerAlertedEvent { PlayerID = playerID, PerceiverID = dummyNpcID, IsAlerted = false });\n            }\n\n            // Publish event for UI (e.g., stealth meter, alert indicator)\n            _eventBus.Publish(new PlayerDetectionUpdatedEvent { PlayerID = playerID, DetectionMeter = playerDetection.DetectionMeter, MaxDetectionMeter = playerDetection.MaxDetectionMeter, IsAlerted = playerDetection.IsAlerted });\n        }\n\n\n        // --- Helper Events for Body Sync ---\n        public struct PlayerDetectionUpdatedEvent { public EntityID PlayerID; public float DetectionMeter; public float MaxDetectionMeter; public bool IsAlerted; }\n        public struct PlayerAlertedEvent { public EntityID PlayerID; public EntityID PerceiverID; public bool IsAlerted; }\n    }\n}\n</code></pre>"},{"location":"46-chapter-46/#4-integrating-stealthsystem-into-gamemanager","title":"4. Integrating <code>StealthSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.AI;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>StealthSystem</code> property.</li> <li>Initialize <code>StealthSystem</code> in <code>InitializeSystems()</code> after <code>PerceptionSystem</code>.</li> <li>Call <code>StealthSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public PerceptionSystem Perception { get; private set; }\n    public StealthSystem Stealth { get; private set; } // Add StealthSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n\n        // --- Test Stealth System ---\n        GD.Print(\"\\n--- Testing Stealth System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID testNpcID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Assuming NPC is ID 1, Gen 1\n\n        if (playerID.IsValid() &amp;&amp; testNpcID.IsValid())\n        {\n            // Place player and NPC close for detection. Player is facing NPC.\n            Transforms.GetTransformRef(playerID).Position = new Vector2(200, 200);\n            Transforms.GetTransformRef(testNpcID).Position = new Vector2(250, 200);\n            Transforms.GetTransformRef(playerID).RotationDegrees = 0; // Face right\n\n            GD.Print($\"Player {playerID} initial stealth: {Stealth.GetStealthComponentRef(playerID)}\");\n            GD.Print($\"NPC {testNpcID} initial perception: {Perception.GetPerceptionComponentRef(testNpcID)}\");\n        }\n        else\n        {\n            GD.PrintErr(\"Player or Test NPC not valid for stealth tests.\");\n        }\n\n        GD.Print(\"--- End Testing Stealth System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta); // PerceptionSystem needs to tick if it's continuously querying, or query here.\n        Stealth.Tick(delta); // Call StealthSystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to PerceptionSystem) ...\n\n        // Initialize StealthSystem AFTER PerceptionSystem and other dependencies\n        Stealth = new StealthSystem(Entities, Events, Transforms, BiologicalSystem, Movement, Weather, Perception); // Pass dependencies\n        GD.Print(\"  - StealthSystem initialized.\");\n\n        // ... (existing system initializations after StealthSystem) ...\n    }\n}\n</code></pre>"},{"location":"46-chapter-46/#41-update-eventbuscs-for-stealth-events","title":"4.1. Update <code>EventBus.cs</code> for Stealth Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnPlayerDetectionUpdated</code> and <code>OnPlayerAlerted</code> delegates.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Stealth System Events (TDD 05.2.3)\n        public event Action&lt;EntityID, float, float, bool&gt; OnPlayerDetectionUpdated; // PlayerID, DetectionMeter, MaxDetectionMeter, IsAlerted\n        public event Action&lt;EntityID, EntityID, bool&gt; OnPlayerAlerted; // PlayerID, PerceiverID, IsAlerted\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is StealthSystem.PlayerDetectionUpdatedEvent detectionEvent) // New condition\n            {\n                OnPlayerDetectionUpdated?.Invoke(detectionEvent.PlayerID, detectionEvent.DetectionMeter, detectionEvent.MaxDetectionMeter, detectionEvent.IsAlerted);\n            }\n            else if (eventData is StealthSystem.PlayerAlertedEvent alertedEvent) // New condition\n            {\n                OnPlayerAlerted?.Invoke(alertedEvent.PlayerID, alertedEvent.PerceiverID, alertedEvent.IsAlerted);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"46-chapter-46/#5-displaying-detection-meter-in-the-body-gdscript-ui","title":"5. Displaying Detection Meter in the Body (GDScript UI)","text":"<p>Let's add a simple UI to display the player's detection meter.</p> <ol> <li> <p>Open <code>res://_Body/Scenes/UI/HUD.tscn</code> and modify it:</p> <ul> <li>Add a <code>Label</code> node for <code>DetectionLabel</code>.</li> <li>Arrange it (e.g., in <code>VBoxNeeds</code>).</li> </ul> </li> <li> <p>Open <code>res://_Body/Scripts/UI/HUDController.gd</code> and modify it:</p> </li> </ol> <pre><code># _Body/Scripts/UI/HUDController.gd\nclass_name HUDController extends CanvasLayer\n\n@onready var health_label: Label = $MainHBox/VBoxStats/HealthLabel\n@onready var chakra_label: Label = $MainHBox/VBoxStats/ChakraLabel\n@onready var stamina_label: Label = $MainHBox/VBoxStats/StaminaLabel\n@onready var stability_label: Label = $MainHBox/VBoxStats/StabilityLabel\n@onready var hunger_label: Label = $MainHBox/VBoxNeeds/HungerLabel\n@onready var thirst_label: Label = $MainHBox/VBoxNeeds/ThirstLabel\n@onready var weather_label: Label = $MainHBox/VBoxNeeds/WeatherLabel\n@onready var temperature_label: Label = $MainHBox/VBoxNeeds/TemperatureLabel\n@onready var detection_label: Label = $MainHBox/VBoxNeeds/DetectionLabel # New\n\nvar player_entity_id: int = -1\n\nfunc _ready():\n    GD.print(\"HUDController: Initialized. Connecting to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    if GameManager.Instance != null and GameManager.Instance.Events != null:\n        # ... (existing event connections) ...\n        GameManager.Instance.Events.OnPlayerDetectionUpdated.connect(Callable(self, \"_on_player_detection_updated\")) # New\n        GameManager.Instance.Events.OnPlayerAlerted.connect(Callable(self, \"_on_player_alerted\")) # New\n        GD.print(\"HUDController: Successfully connected to C# PlayerStatSystem &amp; BiologicalSystem events.\")\n    else:\n        push_error(\"HUDController: GameManager or EventBus not ready! Cannot connect C# events.\")\n\nfunc _on_entity_spawned(id: int, type: int, definition_id: String, initial_position: Vector2, initial_rotation: float) -&gt; void:\n    if type == 0:\n        player_entity_id = id\n        GD.print(\"HUDController: Detected player entity with ID: %s\" % player_entity_id)\n\n# ... (existing stat update handlers) ...\n\n## Handler for C# OnPlayerDetectionUpdated event.\nfunc _on_player_detection_updated(id: int, detection_meter: float, max_detection_meter: float, is_alerted: bool) -&gt; void:\n    if id == player_entity_id:\n        var alert_status = \"Hidden\"\n        if is_alerted:\n            alert_status = \"ALERTED!\"\n        elif detection_meter &gt; max_detection_meter * 0.5:\n            alert_status = \"Suspicious\"\n        elif detection_meter &gt; 0:\n            alert_status = \"Detected\"\n\n        detection_label.text = \"DET: %s/%s (%s)\" % [int(detection_meter), int(max_detection_meter), alert_status]\n\n## Handler for C# OnPlayerAlerted event.\nfunc _on_player_alerted(id: int, perceiver_id: int, is_alerted: bool) -&gt; void:\n    if id == player_entity_id:\n        GD.print(\"HUDController: Player %s is now %s by Perceiver %s!\" % [id, \"ALERTED\" if is_alerted else \"NOT ALERTED\", perceiver_id])\n        # Play a sound, flash screen, etc.\n</code></pre>"},{"location":"46-chapter-46/#6-testing-stealth-mechanics","title":"6. Testing Stealth Mechanics","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the new Detection label on the HUD.<ul> <li>Initial State: The player starts near an NPC. The detection meter should slowly increase as the NPC \"sees\" the player.</li> <li>Alerted: Once the meter reaches 80, it should switch to \"ALERTED!\".</li> <li>Movement: Move the player. The detection gain should be higher because <code>playerVisibility</code> increases with movement speed.</li> <li>Decay: Stand still. The detection meter should slowly decay. If it drops below 50, the \"ALERTED!\" status should clear.</li> <li>Hide: Move the player far away from the NPC (e.g., to 1000,1000 using WASD). The detection meter should quickly decay to 0.</li> </ul> </li> </ol> <p>This confirms that the <code>StealthSystem</code> is correctly calculating <code>Visibility</code> based on movement and managing the <code>Detection Meter</code>, providing dynamic feedback on the player's stealth status.</p>"},{"location":"46-chapter-46/#summary","title":"Summary","text":"<p>You have successfully implemented Stealth Mechanics in the C# Brain, designing <code>StealthComponent</code> and <code>DetectionComponent</code> to manage entity visibility and detection states. By creating <code>StealthSystem</code> to calculate <code>CurrentVisibility</code> based on movement and managing <code>DetectionMeter</code> accumulation and decay, you've established a dynamic and tactical interplay between stealth and perception. This crucial system strictly adheres to TDD 05.2.3 and GDD B10's specifications, providing continuous feedback on the player's stealth status and driving NPC alert states.</p>"},{"location":"46-chapter-46/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Decision Making: Utility AI (C#), where we will design a flexible Utility AI system for NPCs, allowing them to select actions (e.g., attack, flee, eat, sleep) based on a scoring mechanism that evaluates their needs and environmental context.</p>"},{"location":"47-chapter-47/","title":"Chapter 7.4: Decision Making: Utility AI (C#)","text":""},{"location":"47-chapter-47/#chapter-74-decision-making-utility-ai-c","title":"Chapter 7.4: Decision Making: Utility AI (C#)","text":"<p>With entities now capable of perceiving their environment and managing their core stats, it's time to give NPCs the ability to make intelligent decisions. This chapter focuses on implementing Utility AI (scoring-based AI) in the C# Brain, allowing NPCs to select actions (e.g., attack, flee, eat, sleep) based on a scoring mechanism that evaluates their current needs and environmental context, as specified in TDD 05.3.</p>"},{"location":"47-chapter-47/#1-the-power-of-utility-ai","title":"1. The Power of Utility AI","text":"<p>Traditional Finite State Machines (FSMs) can become complex and rigid for games with many interconnected systems. Utility AI offers a more flexible, emergent, and scalable approach:</p> <ul> <li>Dynamic Decision-Making: NPCs evaluate all possible actions and choose the one with the highest \"utility score\" for their current situation.</li> <li>Emergent Behavior: Complex behaviors arise from simple scoring rules, leading to less predictable and more lifelike NPCs.</li> <li>Scalability: Easily add new actions or modify priorities by adjusting scores, without rewriting state transitions.</li> <li>GDD Alignment: Supports NPCs with evolving literacy, clan loyalties, and dynamic schedules (B18).</li> </ul>"},{"location":"47-chapter-47/#2-defining-aicomponent-and-utilityaction","title":"2. Defining <code>AIComponent</code> and <code>UtilityAction</code>","text":"<p>We need a component to hold an entity's AI parameters and a struct to represent a single action the AI can take.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/AIComponent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/AIComponent.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Stores the parameters defining an entity's AI behavior.\n    /// This is a component-like data structure managed by the AISystem.\n    /// &lt;/summary&gt;\n    public struct AIComponent\n    {\n        public float Aggression;        // How likely to attack (0-1)\n        public float Curiosity;         // How likely to investigate anomalies (0-1)\n        public float HungerThreshold;   // Below this hunger, prioritize eating\n        public float ThirstThreshold;   // Below this thirst, prioritize drinking\n        public float FearLevel;         // How easily scared (0-1)\n        public float CombatRange;       // How close to get to target in combat\n        public float FleeThreshold;     // Below this health, prioritize fleeing (0-1)\n\n        public AIComponent(float aggression = 0.5f, float curiosity = 0.5f, float hungerThreshold = 30f, float thirstThreshold = 20f, float fearLevel = 0.5f, float combatRange = 100f, float fleeThreshold = 0.2f)\n        {\n            Aggression = aggression;\n            Curiosity = curiosity;\n            HungerThreshold = hungerThreshold;\n            ThirstThreshold = thirstThreshold;\n            FearLevel = fearLevel;\n            CombatRange = combatRange;\n            FleeThreshold = fleeThreshold;\n        }\n\n        public override string ToString()\n        {\n            return $\"Agg: {Aggression:F2}, Cur: {Curiosity:F2}, Flee: {FleeThreshold:P0}\";\n        }\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/AI/UtilityAction.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/UtilityAction.cs\nusing System;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Represents a single action an AI entity can take, along with its scoring function.\n    /// (TDD 05.3: The Scorer)\n    /// &lt;/summary&gt;\n    public class UtilityAction\n    {\n        public string Name { get; private set; }\n        public Func&lt;EntityID, float&gt; ScoreFunction { get; private set; } // Function to calculate action's utility score\n        public Action&lt;EntityID&gt; ExecuteAction { get; private set; } // Function to execute the action\n\n        public UtilityAction(string name, Func&lt;EntityID, float&gt; scoreFunction, Action&lt;EntityID&gt; executeAction)\n        {\n            Name = name;\n            ScoreFunction = scoreFunction;\n            ExecuteAction = executeAction;\n        }\n\n        public override string ToString()\n        {\n            return $\"Action: '{Name}'\";\n        }\n    }\n}\n</code></pre>"},{"location":"47-chapter-47/#4-implementing-aisystemcs","title":"4. Implementing <code>AISystem.cs</code>","text":"<p>This system will: *   Manage <code>AIComponent</code>s. *   Register a set of <code>UtilityAction</code>s. *   In its <code>Tick</code> method, for each AI entity, it will:     *   Query nearby entities using <code>PerceptionSystem</code>.     *   Score all available <code>UtilityAction</code>s.     *   Execute the highest-scoring action.</p> <ol> <li>Create <code>res://_Brain/Systems/AI/AISystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/AI/AISystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Combat;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Manages AI decision-making using a Utility AI (scoring) system.\n    /// NPCs evaluate actions based on needs and context and execute the highest-scoring one.\n    /// (TDD 05.3)\n    /// &lt;/summary&gt;\n    public class AISystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem; // For CoreStats\n        private PerceptionSystem _perceptionSystem; // For detecting targets\n        private CombatSystem _combatSystem;         // For attacking\n        private TransformSystem _transformSystem;   // For movement\n\n        // Dictionary to store AIComponent for entities that have AI.\n        private Dictionary&lt;EntityID, AIComponent&gt; _aiComponents = new Dictionary&lt;EntityID, AIComponent&gt;();\n\n        // List of all available UtilityActions for NPCs to choose from.\n        private List&lt;UtilityAction&gt; _availableActions = new List&lt;UtilityAction&gt;();\n\n        // To prevent NPCs from making decisions every single tick (performance)\n        private const float AI_DECISION_INTERVAL = 0.5f; // Every 0.5 real seconds\n        private Dictionary&lt;EntityID, float&gt; _aiDecisionTimers = new Dictionary&lt;EntityID, float&gt;();\n\n\n        public AISystem(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, PerceptionSystem perceptionSystem, CombatSystem combatSystem, TransformSystem transformSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _perceptionSystem = perceptionSystem;\n            _combatSystem = combatSystem;\n            _transformSystem = transformSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n            // AISystem needs to know when player is alerted for NPC reactions\n            _eventBus.OnPlayerAlerted += OnPlayerAlerted;\n\n            RegisterDefaultActions(); // Register the AI's repertoire of actions\n            GD.Print(\"AISystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only add AIComponent to NPCs and some Animals\n            if (type == EntityType.NPC || type == EntityType.Animal)\n            {\n                // Default AI for NPCs/Animals\n                _aiComponents.Add(id, new AIComponent());\n                _aiDecisionTimers.Add(id, (float)GameManager.Instance.Time.CurrentGameTime); // Initialize timer\n                GD.Print($\"AISystem: Added AIComponent for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _aiComponents.Remove(e.ID);\n            _aiDecisionTimers.Remove(e.ID);\n            GD.Print($\"AISystem: Removed AIComponent for {e.ID}.\");\n        }\n\n        private void OnPlayerAlerted(EntityID playerID, EntityID perceiverID, bool isAlerted)\n        {\n            if (_aiComponents.ContainsKey(perceiverID))\n            {\n                // If this NPC is the perceiver, react to player being alerted.\n                // This might override their current action to prioritize combat/flee.\n                GD.Print($\"AISystem: NPC {perceiverID} detected player {playerID} and is now alerted: {isAlerted}.\");\n                // For now, this is just a print. Later, it would force an immediate AI decision.\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new UtilityAction into the AI's repertoire.\n        /// &lt;/summary&gt;\n        private void RegisterAction(UtilityAction action)\n        {\n            _availableActions.Add(action);\n        }\n\n        /// &lt;summary&gt;\n        /// Registers the default set of actions available to NPCs.\n        /// (TDD 05.3: The Scorer - Example Actions)\n        /// &lt;/summary&gt;\n        private void RegisterDefaultActions()\n        {\n            // --- Action: Flee (TDD 05.3) ---\n            RegisterAction(new UtilityAction(\"Flee\", (npcID) =&gt;\n            {\n                if (!_biologicalSystem.TryGetCoreStats(npcID, out CoreStats stats) || !_aiComponents.TryGetValue(npcID, out AIComponent ai)) return 0;\n                // Score higher if health is low (below flee threshold) and fear is high.\n                float healthScore = (1f - (stats.Health / stats.MaxHealth)); // 1 if 0 HP, 0 if 100 HP\n                return healthScore &gt; ai.FleeThreshold ? healthScore * ai.FearLevel * 2 : 0; // Double score if below threshold\n            }, (npcID) =&gt;\n            {\n                GD.Print($\"AISystem: NPC {npcID} is fleeing!\");\n                // Conceptual: Tell MovementSystem to move away from player\n                // _movementSystem.MoveAwayFrom(npcID, _entityManager.GetPlayerEntityID(), 200f);\n            }));\n\n            // --- Action: Attack Player (TDD 05.3) ---\n            RegisterAction(new UtilityAction(\"AttackPlayer\", (npcID) =&gt;\n            {\n                if (!_biologicalSystem.TryGetCoreStats(npcID, out CoreStats stats) || !_aiComponents.TryGetValue(npcID, out AIComponent ai)) return 0;\n                // Score higher if player is detected and NPC is aggressive.\n                List&lt;EntityID&gt; detected = _perceptionSystem.GetDetectedEntities(npcID);\n                if (detected.Contains(_entityManager.GetPlayerEntityID()))\n                {\n                    // Score higher if player is close enough to combat range and NPC is aggressive.\n                    if (_transformSystem.TryGetTransform(npcID, out TransformComponent npcT) &amp;&amp; _transformSystem.TryGetTransform(_entityManager.GetPlayerEntityID(), out TransformComponent playerT))\n                    {\n                        float distance = npcT.Position.DistanceTo(playerT.Position);\n                        if (distance &lt;= ai.CombatRange)\n                        {\n                            return ai.Aggression * (1f - (stats.Health / stats.MaxHealth) * ai.FleeThreshold); // Aggression, reduced if health too low\n                        }\n                    }\n                }\n                return 0;\n            }, (npcID) =&gt;\n            {\n                GD.Print($\"AISystem: NPC {npcID} is attacking player {_entityManager.GetPlayerEntityID()}!\");\n                // Conceptual: Tell CombatSystem to perform an attack\n                // _combatSystem.PerformNPCAttack(npcID, _entityManager.GetPlayerEntityID());\n            }));\n\n            // --- Action: Eat Food (TDD 05.3) ---\n            RegisterAction(new UtilityAction(\"EatFood\", (npcID) =&gt;\n            {\n                if (!_biologicalSystem.TryGetCoreStats(npcID, out CoreStats stats) || !_aiComponents.TryGetValue(npcID, out AIComponent ai)) return 0;\n                // Score higher if hunger is low (below threshold)\n                return stats.Hunger &lt; ai.HungerThreshold ? (ai.HungerThreshold - stats.Hunger) / ai.HungerThreshold : 0;\n            }, (npcID) =&gt;\n            {\n                GD.Print($\"AISystem: NPC {npcID} is eating food!\");\n                // Conceptual: Find nearby food item, move to it, consume it.\n                // _inventorySystem.UseItem(npcID, \"generic_food\");\n            }));\n\n            // --- Action: Drink Water (TDD 05.3) ---\n            RegisterAction(new UtilityAction(\"DrinkWater\", (npcID) =&gt;\n            {\n                if (!_biologicalSystem.TryGetCoreStats(npcID, out CoreStats stats) || !_aiComponents.TryGetValue(npcID, out AIComponent ai)) return 0;\n                return stats.Thirst &lt; ai.ThirstThreshold ? (ai.ThirstThreshold - stats.Thirst) / ai.ThirstThreshold : 0;\n            }, (npcID) =&gt;\n            {\n                GD.Print($\"AISystem: NPC {npcID} is drinking water!\");\n                // Conceptual: Find nearby water source, move to it, drink.\n            }));\n\n            // --- Action: Wander (Default/Idle) ---\n            RegisterAction(new UtilityAction(\"Wander\", (npcID) =&gt;\n            {\n                // Low base score, increases if no higher priority actions are scored.\n                return 0.1f;\n            }, (npcID) =&gt;\n            {\n                GD.Print($\"AISystem: NPC {npcID} is wandering aimlessly.\");\n                // Conceptual: Tell MovementSystem to move to a random nearby point.\n                // _movementSystem.MoveToRandom(npcID, 50f);\n            }));\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the AISystem.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            foreach (var kvp in _aiComponents)\n            {\n                EntityID npcID = kvp.Key;\n                ref float decisionTimer = ref _aiDecisionTimers.GetValueRef(npcID); // Get mutable timer\n\n                if (!_entityManager.IsValid(npcID)) continue;\n\n                decisionTimer += (float)delta;\n                if (decisionTimer &gt;= AI_DECISION_INTERVAL)\n                {\n                    MakeDecision(npcID);\n                    decisionTimer = 0;\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Evaluates all available actions for an NPC and executes the highest-scoring one.\n        /// (TDD 05.3: Algorithm)\n        /// &lt;/summary&gt;\n        private void MakeDecision(EntityID npcID)\n        {\n            UtilityAction bestAction = null;\n            float highestScore = 0;\n\n            foreach (UtilityAction action in _availableActions)\n            {\n                float score = action.ScoreFunction.Invoke(npcID);\n                if (score &gt; highestScore)\n                {\n                    highestScore = score;\n                    bestAction = action;\n                }\n            }\n\n            if (bestAction != null)\n            {\n                GD.Print($\"AISystem: NPC {npcID} chose action '{bestAction.Name}' with score {highestScore:F2}.\");\n                bestAction.ExecuteAction.Invoke(npcID);\n            }\n            else\n            {\n                GD.Print($\"AISystem: NPC {npcID} found no suitable action.\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"47-chapter-47/#5-integrating-aisystem-into-gamemanager","title":"5. Integrating <code>AISystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.AI;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add an <code>AISystem</code> property.</li> <li>Initialize <code>AISystem</code> in <code>InitializeSystems()</code> after <code>PerceptionSystem</code>, <code>CombatSystem</code>, and <code>BiologicalSystem</code>.</li> <li>Call <code>AISystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public StealthSystem Stealth { get; private set; }\n    public AISystem AI { get; private set; } // Add AISystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n\n        // --- Test AI System ---\n        GD.Print(\"\\n--- Testing AI System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID testNpcID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Assuming NPC is ID 1, Gen 1\n\n        if (playerID.IsValid() &amp;&amp; testNpcID.IsValid())\n        {\n            // Place NPC near player for initial detection/attack behavior\n            Transforms.GetTransformRef(playerID).Position = new Vector2(200, 200);\n            Transforms.GetTransformRef(testNpcID).Position = new Vector2(250, 200); // Within combat range\n            Transforms.GetTransformRef(playerID).RotationDegrees = 0; // Player faces right\n\n            GD.Print($\"NPC {testNpcID} initial stats: {Biology.GetCoreStatsRef(testNpcID)}\");\n            GD.Print($\"Player {playerID} initial stealth: {Stealth.GetStealthComponentRef(playerID)}\");\n            GD.Print($\"NPC {testNpcID} initial perception: {Perception.GetPerceptionComponentRef(testNpcID)}\");\n        }\n        else\n        {\n            GD.PrintErr(\"Player or Test NPC not valid for AI tests.\");\n        }\n\n        GD.Print(\"--- End Testing AI System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta); // Call AISystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to StealthSystem) ...\n\n        // Initialize AISystem AFTER all its dependencies\n        AI = new AISystem(Entities, Events, BiologicalSystem, Perception, Combat, Transforms); // Pass dependencies\n        GD.Print(\"  - AISystem initialized.\");\n\n        // ... (existing system initializations after AISystem) ...\n    }\n}\n</code></pre>"},{"location":"47-chapter-47/#6-testing-utility-ai","title":"6. Testing Utility AI","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing AI System\" section and subsequent <code>AISystem: NPC X chose action...</code> messages.</li> </ol> <p>Expected Output:</p> <ul> <li>Initial State: The NPC (<code>testNpcID</code>) is spawned near the player.</li> <li>Attack Behavior: Since the player is detected and within combat range, the NPC should repeatedly choose <code>AttackPlayer</code> (every 0.5 seconds, <code>AI_DECISION_INTERVAL</code>).<ul> <li><code>AISystem: NPC EntityID(1, Gen:1) chose action 'AttackPlayer' with score X.XX.</code></li> <li><code>AISystem: NPC EntityID(1, Gen:1) is attacking player EntityID(0, Gen:1)!</code></li> </ul> </li> <li>Hunger/Thirst (if low): If you manually reduce the NPC's hunger/thirst (e.g., <code>/hunger -50</code> on <code>testNpcID</code> using debug console - this command needs to be added to <code>DebugCommandSystem</code>), the NPC might temporarily prioritize <code>EatFood</code> or <code>DrinkWater</code> over attacking, if its hunger/thirst score becomes higher than the attack score.</li> <li>Flee (if low HP): If you damage the NPC (e.g., <code>/damage 40</code> on <code>testNpcID</code>), its health will drop. If it falls below its <code>FleeThreshold</code>, it might switch to <code>Flee</code> action.</li> <li>Wander (if no other actions): If the player moves far away (out of detection range) and the NPC has no pressing needs, it will default to <code>Wander</code>.</li> </ul> <p>This confirms our <code>AISystem</code> is functional, using Utility AI to make dynamic decisions based on the NPC's <code>AIComponent</code> and current <code>CoreStats</code> / <code>Perception</code>.</p>"},{"location":"47-chapter-47/#summary","title":"Summary","text":"<p>You have successfully implemented Decision Making for NPCs using a Utility AI (scoring) system in the C# Brain. By designing <code>AIComponent</code> to hold AI parameters and <code>UtilityAction</code> to represent scoreable actions, and creating <code>AISystem</code> to evaluate and execute the highest-scoring action, you've established a flexible and emergent AI framework. This crucial system strictly adheres to TDD 05.3's specifications, allowing NPCs to dynamically respond to their needs and environmental context in Sigilborne's living world.</p>"},{"location":"47-chapter-47/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Ecology Simulation, where we will design how animals and NPCs exist and behave even when the player is far away, by using \"Virtual Agents\" that are simulated at a very slow tick rate in unloaded chunks.</p>"},{"location":"48-chapter-48/","title":"Chapter 7.5: Ecology Simulation - Virtual Agents (C#)","text":""},{"location":"48-chapter-48/#chapter-75-ecology-simulation-virtual-agents-c","title":"Chapter 7.5: Ecology Simulation - Virtual Agents (C#)","text":"<p>Sigilborne's world is a living, breathing ecosystem, even beyond the player's immediate vicinity. This chapter implements the Ecology Simulation system, designing how animals and NPCs exist and behave as \"Virtual Agents\" even when the player is far away in unloaded chunks. These virtual agents will be simulated at a very slow tick rate, maintaining the illusion of a persistent, evolving world, as specified in TDD 05.4.</p>"},{"location":"48-chapter-48/#1-the-challenge-of-a-living-world","title":"1. The Challenge of a \"Living World\"","text":"<p>The GDD (B03) states: \"The world exists with or without the player.\" This means:</p> <ul> <li>Persistence: NPCs don't just disappear when off-screen; their lives continue.</li> <li>Performance: Simulating every detail of every entity in the entire world all the time is impossible.</li> <li>Abstraction: We need a lightweight representation for distant entities.</li> <li>Hydration/Dehydration: Seamlessly transition entities between full simulation and lightweight virtual states.</li> </ul>"},{"location":"48-chapter-48/#2-defining-virtualagent","title":"2. Defining <code>VirtualAgent</code>","text":"<p>TDD 05.4.1 defines <code>VirtualAgent</code> as a lightweight data struct. We'll enhance it slightly to include more relevant data for ecology simulation.</p> <ol> <li>Create <code>res://_Brain/Systems/Ecology/</code> folder.</li> <li>Create <code>res://_Brain/Systems/Ecology/VirtualAgent.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Ecology/VirtualAgent.cs\nusing System;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID, EntityType\nusing Sigilborne.Systems.Biology; // For CoreStats\n\nnamespace Sigilborne.Systems.Ecology\n{\n    /// &lt;summary&gt;\n    /// A lightweight data representation of an entity in an unloaded chunk.\n    /// (TDD 05.4.1)\n    /// &lt;/summary&gt;\n    public struct VirtualAgent\n    {\n        public EntityID ID;                 // The original EntityID\n        public EntityType Type;             // Player, NPC, Animal\n        public string DefinitionID;         // e.g., \"goblin_grunt\", \"deer_male\"\n        public Vector2 Position;            // World position\n        public float RotationDegrees;       // Rotation\n        public CoreStats CurrentStats;      // Core stats (health, hunger, thirst, etc.)\n        public int CurrentChunkX;           // Which chunk this agent is in\n        public int CurrentChunkY;\n\n        // --- AI State for Virtual Agents ---\n        // Simplified AI state, e.g., \"Wandering\", \"Hunting\", \"Eating\"\n        public string SimplifiedAIState;    \n        public EntityID TargetID;           // Simplified target (e.g., player, food source)\n\n        public VirtualAgent(EntityID id, EntityType type, string definitionID, Vector2 position, float rotationDegrees, CoreStats currentStats, string simplifiedAIState = \"Wandering\", EntityID targetID = default)\n        {\n            ID = id;\n            Type = type;\n            DefinitionID = definitionID;\n            Position = position;\n            RotationDegrees = rotationDegrees;\n            CurrentStats = currentStats;\n            CurrentChunkX = (int)MathF.Floor(position.X / GameManager.Instance.World.ChunkSize); // Assuming WorldSystem has ChunkSize\n            CurrentChunkY = (int)MathF.Floor(position.Y / GameManager.Instance.World.ChunkSize);\n            SimplifiedAIState = simplifiedAIState;\n            TargetID = targetID;\n        }\n\n        public override string ToString()\n        {\n            return $\"VA {ID} ({DefinitionID}) Pos: {Position} HP: {CurrentStats.Health:F0} HUN: {CurrentStats.Hunger:F0} State: {SimplifiedAIState}\";\n        }\n    }\n}\n</code></pre>"},{"location":"48-chapter-48/#3-implementing-ecologymanagercs","title":"3. Implementing <code>EcologyManager.cs</code>","text":"<p>This system will manage the collection of <code>VirtualAgent</code>s, simulate them at a slow tick, and handle the hydration/dehydration (spawning/despawning) process.</p> <ol> <li>Create <code>res://_Brain/Systems/Ecology/EcologyManager.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Ecology/EcologyManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent; // For ConcurrentBag\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.AI; // For AI components, SpatialGrid\nusing Sigilborne.Systems.Movement; // For movement simulation\nusing Sigilborne.Systems.Weather; // For environmental impact\nusing Sigilborne.Utils; // For JobSystem\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Ecology\n{\n    /// &lt;summary&gt;\n    /// Manages the ecology simulation, including Virtual Agents in unloaded chunks.\n    /// Handles hydration (spawning) and dehydration (despawning) of entities.\n    /// (TDD 05.4)\n    /// &lt;/summary&gt;\n    public class EcologyManager\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private BiologicalSystem _biologicalSystem;\n        private TransformSystem _transformSystem;\n        private AISystem _aiSystem;\n        private MovementSystem _movementSystem;\n        private WeatherSystem _weatherSystem;\n        private JobSystem _jobSystem;\n        private SpatialHashGrid _spatialGrid; // Needed for querying nearby virtual agents\n\n        // TDD 05.4.1: Stores Virtual Agents in unloaded chunks.\n        // Using ConcurrentBag for thread-safe adding/removing if jobs interact directly.\n        private ConcurrentBag&lt;VirtualAgent&gt; _virtualAgents = new ConcurrentBag&lt;VirtualAgent&gt;();\n\n        // TDD 13.3: Double Buffering for Ecology Simulation (Conceptual)\n        // For simplicity in this chapter, we'll directly modify _virtualAgents.\n        // A full implementation would use two ConcurrentBags and swap them.\n\n        private const float VIRTUAL_AGENT_TICK_RATE = 10.0f; // Simulate virtual agents every 10 real seconds\n        private float _virtualAgentTickTimer;\n\n        // Player's current loaded chunk (used for hydration/dehydration radius)\n        private Vector2I _playerLoadedChunk = Vector2I.Zero;\n        private const int LOAD_RADIUS_CHUNKS = 2; // TDD 08.2.1: Player loads chunks within a radius (e.g., 2 chunks)\n\n        public EcologyManager(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, TransformSystem transformSystem, AISystem aiSystem, MovementSystem movementSystem, WeatherSystem weatherSystem, JobSystem jobSystem, SpatialHashGrid spatialGrid)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _transformSystem = transformSystem;\n            _aiSystem = aiSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n            _jobSystem = jobSystem;\n            _spatialGrid = spatialGrid;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n            _eventBus.OnPlayerCoreStatsChanged += OnPlayerCoreStatsChanged; // To track player's chunk\n\n            GD.Print(\"EcologyManager: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // For entities spawned by the GameManager (e.g., player, test NPC),\n            // ensure they are *not* added to virtual agents initially if they are in loaded chunks.\n            // This method is mainly for entities that *transition* from virtual to active.\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            // This is primarily for entities explicitly destroyed.\n            // Entities dehydrating (transitioning from active to virtual) will be handled separately.\n        }\n\n        private void OnPlayerCoreStatsChanged(EntityID playerID, CoreStats newCoreStats)\n        {\n            // TDD 08.2.1: Track player's current chunk to manage load radius.\n            Vector2I newPlayerChunk = new Vector2I(\n                (int)MathF.Floor(newCoreStats.Position.X / GameManager.Instance.World.ChunkSize),\n                (int)MathF.Floor(newCoreStats.Position.Y / GameManager.Instance.World.ChunkSize)\n            );\n\n            if (newPlayerChunk != _playerLoadedChunk)\n            {\n                _playerLoadedChunk = newPlayerChunk;\n                // GD.Print($\"EcologyManager: Player entered new chunk: {_playerLoadedChunk}. Triggering Hydration/Dehydration.\");\n                HydrateAndDehydrateChunks();\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the EcologyManager.\n        /// Manages the Virtual Agent Tick.\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _virtualAgentTickTimer += (float)delta;\n            if (_virtualAgentTickTimer &gt;= VIRTUAL_AGENT_TICK_RATE)\n            {\n                ProcessVirtualAgentTick();\n                _virtualAgentTickTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Processes a slow tick for all virtual agents.\n        /// (TDD 05.4.1: Simulation - Update Virtual Agents at a very slow tick rate)\n        /// &lt;/summary&gt;\n        private void ProcessVirtualAgentTick()\n        {\n            GD.Print($\"EcologyManager: Processing Virtual Agent Tick. ({_virtualAgents.Count} virtual agents)\");\n\n            // TDD 13.4.1: Ecology Simulation - Task: Update hunger/movement for virtual animals.\n            // For simplicity, we'll do this on the main thread for now.\n            // A full implementation would use the JobSystem to process chunks of _virtualAgents.\n\n            List&lt;VirtualAgent&gt; updatedAgents = new List&lt;VirtualAgent&gt;();\n            foreach (VirtualAgent agent in _virtualAgents)\n            {\n                VirtualAgent updatedAgent = agent; // Create a mutable copy\n\n                // --- Simulate simplified biological processes ---\n                updatedAgent.CurrentStats.Hunger = Mathf.Max(0, updatedAgent.CurrentStats.Hunger - 5); // Hunger always decays\n                updatedAgent.CurrentStats.Thirst = Mathf.Max(0, updatedAgent.CurrentStats.Thirst - 7); // Thirst always decays\n\n                // --- Simulate simplified AI/movement ---\n                // For now, simple random wander or move towards player if hungry/thirsty\n                if (updatedAgent.CurrentStats.Hunger &lt;= 20 || updatedAgent.CurrentStats.Thirst &lt;= 20)\n                {\n                    updatedAgent.SimplifiedAIState = \"SeekingSustenance\";\n                    // Move towards a conceptual food/water source (placeholder)\n                    updatedAgent.Position += new Vector2((float)_rand.NextDouble() * 10 - 5, (float)_rand.NextDouble() * 10 - 5);\n                }\n                else\n                {\n                    updatedAgent.SimplifiedAIState = \"Wandering\";\n                    updatedAgent.Position += new Vector2((float)_rand.NextDouble() * 2 - 1, (float)_rand.NextDouble() * 2 - 1); // Small random walk\n                }\n\n                updatedAgents.Add(updatedAgent);\n            }\n            // Replace old virtual agents with updated ones (conceptual double buffering)\n            _virtualAgents = new ConcurrentBag&lt;VirtualAgent&gt;(updatedAgents);\n        }\n\n        /// &lt;summary&gt;\n        /// Manages the transition of entities between Active (full simulation) and Virtual (lightweight) states.\n        /// (TDD 05.4.3: Transition (Hydration/Dehydration))\n        /// &lt;/summary&gt;\n        private void HydrateAndDehydrateChunks()\n        {\n            // --- Dehydration: Convert active entities in unloaded chunks to virtual agents ---\n            // Iterate all active entities\n            List&lt;EntityID&gt; activeEntitiesToDehydrate = new List&lt;EntityID&gt;();\n            foreach (EntityID activeID in _entityManager.GetAllActiveEntityIDs()) // Assuming GetAllActiveEntityIDs exists\n            {\n                if (activeID == _entityManager.GetPlayerEntityID()) continue; // Never dehydrate player\n\n                if (_transformSystem.TryGetTransform(activeID, out TransformComponent transform))\n                {\n                    Vector2I entityChunk = new Vector2I(\n                        (int)MathF.Floor(transform.Position.X / GameManager.Instance.World.ChunkSize),\n                        (int)MathF.Floor(transform.Position.Y / GameManager.Instance.World.ChunkSize)\n                    );\n\n                    // If entity is outside the loaded radius, dehydrate it\n                    if (!IsChunkInLoadRadius(entityChunk))\n                    {\n                        if (_biologicalSystem.TryGetCoreStats(activeID, out CoreStats stats) &amp;&amp; _entityManager.TryGetEntityMeta(activeID, out EntityMeta meta))\n                        {\n                            _virtualAgents.Add(new VirtualAgent(activeID, meta.Type, meta.DefinitionID, transform.Position, transform.RotationDegrees, stats));\n                            activeEntitiesToDehydrate.Add(activeID);\n                            // GD.Print($\"EcologyManager: Dehydrating {activeID} (Type: {meta.Type}).\");\n                        }\n                    }\n                }\n            }\n            // Destroy active entities that were dehydrated (must be done on main thread)\n            foreach (EntityID id in activeEntitiesToDehydrate)\n            {\n                _entityManager.DestroyEntity(id);\n            }\n\n            // --- Hydration: Convert virtual agents in loaded chunks to active entities ---\n            List&lt;VirtualAgent&gt; virtualAgentsToHydrate = new List&lt;VirtualAgent&gt;();\n            List&lt;VirtualAgent&gt; remainingVirtualAgents = new List&lt;VirtualAgent&gt;();\n\n            foreach (VirtualAgent agent in _virtualAgents)\n            {\n                Vector2I agentChunk = new Vector2I(\n                    (int)MathF.Floor(agent.Position.X / GameManager.Instance.World.ChunkSize),\n                    (int)MathF.Floor(agent.Position.Y / GameManager.Instance.World.ChunkSize)\n                );\n\n                if (IsChunkInLoadRadius(agentChunk))\n                {\n                    // Hydrate this agent (spawn active entity)\n                    // TDD 05.4.2: Spawning - Instantiate actual Godot Nodes.\n                    // This creates a new active entity, but uses the old ID.\n                    _entityManager.CreateEntity(agent.Type, agent.DefinitionID, agent.Position, agent.RotationDegrees);\n                    // Update the new active entity's stats from the virtual agent (TDD 05.4.2)\n                    ref CoreStats hydratedStats = ref _biologicalSystem.GetCoreStatsRef(agent.ID);\n                    hydratedStats = agent.CurrentStats;\n                    // GD.Print($\"EcologyManager: Hydrating {agent.ID} (Type: {agent.Type}).\");\n                }\n                else\n                {\n                    remainingVirtualAgents.Add(agent); // Keep it virtual\n                }\n            }\n            // Replace the ConcurrentBag with only the remaining virtual agents\n            _virtualAgents = new ConcurrentBag&lt;VirtualAgent&gt;(remainingVirtualAgents);\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if a given chunk is within the player's loaded radius.\n        /// &lt;/summary&gt;\n        private bool IsChunkInLoadRadius(Vector2I chunkCoords)\n        {\n            return Mathf.Abs(chunkCoords.X - _playerLoadedChunk.X) &lt;= LOAD_RADIUS_CHUNKS &amp;&amp;\n                   Mathf.Abs(chunkCoords.Y - _playerLoadedChunk.Y) &lt;= LOAD_RADIUS_CHUNKS;\n        }\n\n        private Random _rand = new Random(); // For simple virtual agent movement\n    }\n}\n</code></pre>"},{"location":"48-chapter-48/#31-update-entitymanagercs-for-getallactiveentityids-and-trygetentitymeta","title":"3.1. Update <code>EntityManager.cs</code> for <code>GetAllActiveEntityIDs</code> and <code>TryGetEntityMeta</code>","text":"<p><code>EcologyManager</code> needs to iterate active entities and safely get <code>EntityMeta</code>.</p> <ol> <li>Open <code>res://_Brain/Entities/EntityManager.cs</code> and add these methods:</li> </ol> <pre><code>// _Brain/Entities/EntityManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\n\nnamespace Sigilborne.Entities\n{\n    // ... (EntityID, EntityMeta, EntityType structs/enums) ...\n\n    public class EntityManager\n    {\n        // ... (existing fields) ...\n\n        /// &lt;summary&gt;\n        /// Retrieves all currently active EntityIDs.\n        /// (TDD 05.4.3)\n        /// &lt;/summary&gt;\n        public IEnumerable&lt;EntityID&gt; GetAllActiveEntityIDs()\n        {\n            for (int i = 0; i &lt; MAX_ENTITIES; i++)\n            {\n                if (_entityMetas[i].IsActive)\n                {\n                    yield return new EntityID(i, _entityMetas[i].Generation);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Safely attempts to get the EntityMeta for a given EntityID.\n        /// &lt;/summary&gt;\n        public bool TryGetEntityMeta(EntityID id, out EntityMeta meta)\n        {\n            if (IsValid(id))\n            {\n                meta = _entityMetas[id.Index];\n                return true;\n            }\n            meta = default;\n            return false;\n        }\n\n        // ... (other methods) ...\n    }\n}\n</code></pre>"},{"location":"48-chapter-48/#32-update-corestatscs-for-position","title":"3.2. Update <code>CoreStats.cs</code> for Position","text":"<p><code>CoreStats</code> needs a <code>Position</code> field for <code>VirtualAgent</code>s. This is a simplification; ideally, <code>VirtualAgent</code> would store <code>TransformComponent</code> data directly.</p> <ol> <li>Open <code>res://_Brain/Systems/Biology/CoreStats.cs</code> and add a <code>Position</code> field.</li> </ol> <pre><code>// _Brain/Systems/Biology/CoreStats.cs\nusing System;\nusing Godot; // For Vector2\n\nnamespace Sigilborne.Systems.Biology\n{\n    public struct CoreStats\n    {\n        // ... (existing stats) ...\n        public Vector2 Position; // New: For VirtualAgent tracking\n\n        public CoreStats(float maxHealth, float maxStamina, float maxChakra, float baseDamage = 10f, float attackSpeed = 1.0f,\n                         float armor = 0f, float magicResistance = 0f, float moveSpeed = 150f, float sprintMultiplier = 1.5f,\n                         float castSpeed = 1.0f, float maxStability = 100f, float stabilityRegenRate = 5f,\n                         float chakraRegenRate = 2f, float staminaRegenRate = 10f, float normalBodyTemp = 37.0f,\n                         float critChance = 0.05f, float critMultiplier = 1.5f, float blockChance = 0f, float blockReduction = 0.5f,\n                         Vector2 initialPosition = default) // Add initialPosition\n        {\n            // ... (existing initializations) ...\n            Position = initialPosition; // Initialize position\n        }\n\n        public override string ToString() { /* ... */ }\n    }\n}\n</code></pre> <ol> <li>Update <code>BiologicalSystem.OnEntitySpawned</code> to pass <code>initialPosition</code> to <code>CoreStats</code>.</li> </ol> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs (in OnEntitySpawned)\n// ...\n            if (type == EntityType.Player)\n            {\n                _entityCoreStats.Add(id, new CoreStats(\n                    maxHealth: 100f, maxStamina: 75f, maxChakra: 50f,\n                    baseDamage: 15f, attackSpeed: 1.0f, armor: 5f, magicResistance: 5f,\n                    moveSpeed: 150f, sprintMultiplier: 1.5f, castSpeed: 1.0f,\n                    maxStability: 100f, stabilityRegenRate: 5f, chakraRegenRate: 2f, staminaRegenRate: 10f,\n                    normalBodyTemp: 37.0f, critChance: 0.1f, critMultiplier: 1.75f, blockChance: 0.1f, blockReduction: 0.5f,\n                    initialPosition: initialPosition // Pass initialPosition\n                ));\n                GD.Print($\"BiologicalSystem: Added CoreStats for Player {id}. Stats: {_entityCoreStats[id]}\");\n            }\n            else if (type == EntityType.NPC || type == EntityType.Animal)\n            {\n                _entityCoreStats.Add(id, new CoreStats(\n                    maxHealth: 50f, maxStamina: 30f, maxChakra: 20f,\n                    baseDamage: 8f, attackSpeed: 1.0f, armor: 2f, magicResistance: 2f,\n                    moveSpeed: 100f, sprintMultiplier: 1.2f, castSpeed: 1.0f,\n                    maxStability: 50f, stabilityRegenRate: 3f, chakraRegenRate: 1f, staminaRegenRate: 5f,\n                    normalBodyTemp: 37.0f, critChance: 0.05f, critMultiplier: 1.5f, blockChance: 0f, blockReduction: 0f,\n                    initialPosition: initialPosition // Pass initialPosition\n                ));\n                GD.Print($\"BiologicalSystem: Added CoreStats for {type} entity {id}. Stats: {_entityCoreStats[id]}\");\n            }\n// ...\n</code></pre>"},{"location":"48-chapter-48/#33-update-gamemanager-to-pass-ecologymanager-to-worldsimulation","title":"3.3. Update <code>GameManager</code> to Pass <code>EcologyManager</code> to <code>WorldSimulation</code>","text":"<p><code>WorldSimulation</code> will oversee the <code>EcologyManager</code>. Also, <code>WorldSimulation</code> needs a <code>ChunkSize</code> property.</p> <ol> <li>Add <code>using Sigilborne.Systems.Ecology;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>EcologyManager</code> property.</li> <li>Initialize <code>EcologyManager</code> in <code>InitializeSystems()</code> after all its dependencies.</li> <li>Modify <code>WorldSimulation</code> to have a <code>ChunkSize</code> property and constructor, and to take <code>EcologyManager</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize EcologyManager AFTER all its dependencies\n        Ecology = new EcologyManager(Entities, Events, BiologicalSystem, Transforms, AI, Movement, Weather, Jobs, SpatialGrid); // Pass dependencies\n        GD.Print(\"  - EcologyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        // Initialize WorldSimulation, passing EcologyManager\n        World = new WorldSimulation(Ecology); // Pass EcologyManager\n        GD.Print(\"  - WorldSimulation initialized.\");\n// ...\n</code></pre>"},{"location":"48-chapter-48/#34-update-_braincoreworldsimulationcs","title":"3.4. Update <code>_Brain/Core/WorldSimulation.cs</code>","text":"<pre><code>// _Brain/Core/WorldSimulation.cs\nusing Godot;\nusing System;\nusing Sigilborne.Systems.Ecology; // Add this using directive\n\nnamespace Sigilborne.Core\n{\n    public class WorldSimulation\n    {\n        public EcologyManager Ecology { get; private set; } // New: Reference to EcologyManager\n        public float ChunkSize { get; private set; } = 128f; // TDD 05.4.1: Chunk size (e.g., 128x128 pixels)\n\n        public WorldSimulation(EcologyManager ecologyManager) // Add EcologyManager parameter\n        {\n            Ecology = ecologyManager; // Store EcologyManager reference\n            GD.Print(\"WorldSimulation: Initialized.\");\n        }\n\n        public void Tick(double delta)\n        {\n            // Update child systems here\n            Ecology.Tick(delta); // EcologyManager needs to tick for virtual agents\n            // GD.Print($\"WorldSimulation: Tick at {GameManager.Instance.Time.CurrentGameTime:F2}\"); // Example\n        }\n    }\n}\n</code></pre>"},{"location":"48-chapter-48/#4-testing-ecology-simulation","title":"4. Testing Ecology Simulation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.<ul> <li>You'll see <code>EcologyManager: Initialized.</code> and <code>WorldSimulation: Initialized.</code></li> <li>Every 10 seconds (our <code>VIRTUAL_AGENT_TICK_RATE</code>), you should see <code>EcologyManager: Processing Virtual Agent Tick.</code> messages.</li> <li>The <code>VirtualAgent</code>s' hunger/thirst will decay, and their simplified AI states (<code>Wandering</code>, <code>SeekingSustenance</code>) will be printed.</li> <li>Move the player around. When the player crosses a chunk boundary (e.g., from <code>(0,0)</code> to <code>(1,0)</code> if <code>ChunkSize</code> is 128), <code>EcologyManager</code> should print <code>Hydrating/Dehydrating</code> messages.<ul> <li><code>EcologyManager: Dehydrating EntityID(1, Gen:1) (Type: NPC).</code></li> <li><code>EcologyManager: Hydrating EntityID(1, Gen:1) (Type: NPC).</code></li> </ul> </li> </ul> </li> </ol> <p>This confirms our <code>EcologyManager</code> is correctly simulating <code>VirtualAgent</code>s in the background and handling the hydration/dehydration process as the player moves between chunks.</p>"},{"location":"48-chapter-48/#summary","title":"Summary","text":"<p>You have successfully implemented the Ecology Simulation system, designing <code>VirtualAgent</code> as a lightweight data representation for entities in unloaded chunks and creating <code>EcologyManager</code> to manage their lifecycle. By implementing a slow \"Virtual Agent Tick\" for background simulation and orchestrating the hydration/dehydration process based on the player's loaded chunk radius, you've ensured a persistent and evolving world, strictly adhering to TDD 05.4's specifications. This crucial step maintains the illusion of a living ecosystem without compromising performance.</p>"},{"location":"48-chapter-48/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Spawning &amp; Despawning, detailing how <code>EcologyManager</code> and <code>EntityManager</code> seamlessly convert entities between \"Virtual Agent\" (data-only) and \"Active Entity\" (Godot node) states as the player enters and leaves chunks.</p>"},{"location":"49-chapter-49/","title":"Chapter 7.6: Spawning & Despawning - Hydration/Dehydration (Brain & Body)","text":""},{"location":"49-chapter-49/#chapter-76-spawning-despawning-hydrationdehydration-brain-body","title":"Chapter 7.6: Spawning &amp; Despawning - Hydration/Dehydration (Brain &amp; Body)","text":"<p>Building on our <code>EcologyManager</code>'s concept of <code>VirtualAgent</code>s, this chapter focuses on the seamless transition of entities between \"Virtual Agent\" (data-only in C# Brain) and \"Active Entity\" (fully simulated with Godot Nodes in GDScript Body) states. We'll refine the hydration (spawning) and dehydration (despawning) process, ensuring entities appear and disappear gracefully as the player enters and leaves chunks, as specified in TDD 05.4.2 and TDD 05.4.3.</p>"},{"location":"49-chapter-49/#1-the-seamless-world-hydration-dehydration","title":"1. The Seamless World: Hydration &amp; Dehydration","text":"<p>The illusion of a persistent world relies on entities appearing and disappearing smoothly.</p> <ul> <li>Dehydration: When an active entity (NPC, animal) moves out of the player's loaded chunk radius, its visual Godot Node is removed, and its <code>CoreStats</code> and <code>TransformComponent</code> data are converted into a <code>VirtualAgent</code> in <code>EcologyManager</code>.</li> <li>Hydration: When the player moves into a chunk containing a <code>VirtualAgent</code>, that <code>VirtualAgent</code>'s data is used to <code>CreateEntity()</code> in <code>EntityManager</code>, and a corresponding visual Godot Node is spawned by <code>EntityViewManager.gd</code>.</li> </ul> <p>This process is critical for performance and maintaining consistency between the Brain and Body.</p>"},{"location":"49-chapter-49/#2-refining-ecologymanagercs-for-dehydration","title":"2. Refining <code>EcologyManager.cs</code> for Dehydration","text":"<p>The <code>HydrateAndDehydrateChunks()</code> method currently handles both. Let's make sure the dehydration part is robust.</p> <p>Open <code>res://_Brain/Systems/Ecology/EcologyManager.cs</code>:</p> <pre><code>// _Brain/Systems/Ecology/EcologyManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Utils;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Ecology\n{\n    public class EcologyManager\n    {\n        // ... (existing fields) ...\n\n        // Player's current loaded chunk (used for hydration/dehydration radius)\n        private Vector2I _playerLoadedChunk = Vector2I.Zero;\n        private const int LOAD_RADIUS_CHUNKS = 2; // TDD 08.2.1: Player loads chunks within a radius (e.g., 2 chunks)\n\n        public EcologyManager(EntityManager entityManager, EventBus eventBus, BiologicalSystem biologicalSystem, TransformSystem transformSystem, AISystem aiSystem, MovementSystem movementSystem, WeatherSystem weatherSystem, JobSystem jobSystem, SpatialHashGrid spatialGrid)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _biologicalSystem = biologicalSystem;\n            _transformSystem = transformSystem;\n            _aiSystem = aiSystem;\n            _movementSystem = movementSystem;\n            _weatherSystem = weatherSystem;\n            _jobSystem = jobSystem;\n            _spatialGrid = spatialGrid;\n\n            // Subscribe to entity lifecycle events\n            // We'll manage OnEntitySpawned/Despawned internally for hydration/dehydration\n            // This manager *is* the source of truth for spawning/despawning game entities.\n            _eventBus.OnPlayerCoreStatsChanged += OnPlayerCoreStatsChanged;\n\n            GD.Print(\"EcologyManager: Initialized.\");\n        }\n\n        // ... (OnPlayerCoreStatsChanged, Tick, ProcessVirtualAgentTick methods) ...\n\n        /// &lt;summary&gt;\n        /// Manages the transition of entities between Active (full simulation) and Virtual (lightweight) states.\n        /// (TDD 05.4.3: Transition (Hydration/Dehydration))\n        /// &lt;/summary&gt;\n        private void HydrateAndDehydrateChunks()\n        {\n            // --- Dehydration: Convert active entities in unloaded chunks to virtual agents ---\n            // Iterate all active entities (excluding player)\n            List&lt;EntityID&gt; activeEntitiesToDehydrate = new List&lt;EntityID&gt;();\n            EntityID playerID = _entityManager.GetPlayerEntityID();\n\n            foreach (EntityID activeID in _entityManager.GetAllActiveEntityIDs())\n            {\n                if (activeID == playerID) continue; // Never dehydrate player\n\n                if (_transformSystem.TryGetTransform(activeID, out TransformComponent transform))\n                {\n                    Vector2I entityChunk = GameManager.Instance.World.GetChunkCoords(transform.Position); // New: Use WorldSimulation helper\n\n                    // If entity is outside the loaded radius, dehydrate it\n                    if (!IsChunkInLoadRadius(entityChunk))\n                    {\n                        if (_biologicalSystem.TryGetCoreStats(activeID, out CoreStats stats) &amp;&amp; _entityManager.TryGetEntityMeta(activeID, out EntityMeta meta))\n                        {\n                            // Create a new VirtualAgent from the active entity's current state\n                            _virtualAgents.Add(new VirtualAgent(activeID, meta.Type, meta.DefinitionID, transform.Position, transform.RotationDegrees, stats, _aiSystem.GetSimplifiedAIState(activeID), _aiSystem.GetTargetID(activeID)));\n                            activeEntitiesToDehydrate.Add(activeID);\n                            GD.Print($\"EcologyManager: Dehydrating {activeID} (Type: {meta.Type}).\");\n                        }\n                    }\n                }\n            }\n            // Destroy active entities that were dehydrated (must be done on main thread)\n            foreach (EntityID id in activeEntitiesToDehydrate)\n            {\n                _entityManager.DestroyEntity(id); // This also triggers OnEntityDespawned event for Body\n            }\n\n            // --- Hydration: Convert virtual agents in loaded chunks to active entities ---\n            List&lt;VirtualAgent&gt; remainingVirtualAgents = new List&lt;VirtualAgent&gt;();\n\n            foreach (VirtualAgent agent in _virtualAgents)\n            {\n                Vector2I agentChunk = GameManager.Instance.World.GetChunkCoords(agent.Position); // New: Use WorldSimulation helper\n\n                if (IsChunkInLoadRadius(agentChunk))\n                {\n                    // Hydrate this agent (spawn active entity)\n                    // TDD 05.4.2: Spawning - Instantiate actual Godot Nodes.\n                    // When CreateEntity is called, it triggers OnEntitySpawned, which\n                    // EntityViewManager.gd listens to.\n                    _entityManager.CreateEntity(agent.Type, agent.DefinitionID, agent.Position, agent.RotationDegrees);\n                    // Update the newly created active entity's stats from the virtual agent (TDD 05.4.2)\n                    ref CoreStats hydratedStats = ref _biologicalSystem.GetCoreStatsRef(agent.ID);\n                    hydratedStats = agent.CurrentStats; // Copy all stats from virtual agent\n                    // Set AI state as well\n                    _aiSystem.SetSimplifiedAIState(agent.ID, agent.SimplifiedAIState);\n                    _aiSystem.SetTargetID(agent.ID, agent.TargetID);\n\n                    GD.Print($\"EcologyManager: Hydrating {agent.ID} (Type: {agent.Type}).\");\n                }\n                else\n                {\n                    remainingVirtualAgents.Add(agent); // Keep it virtual\n                }\n            }\n            // Replace the ConcurrentBag with only the remaining virtual agents\n            _virtualAgents = new ConcurrentBag&lt;VirtualAgent&gt;(remainingVirtualAgents);\n        }\n\n        /// &lt;summary&gt;\n        /// Checks if a given chunk is within the player's loaded radius.\n        /// &lt;/summary&gt;\n        private bool IsChunkInLoadRadius(Vector2I chunkCoords)\n        {\n            return Mathf.Abs(chunkCoords.X - _playerLoadedChunk.X) &lt;= LOAD_RADIUS_CHUNKS &amp;&amp;\n                   Mathf.Abs(chunkCoords.Y - _playerLoadedChunk.Y) &lt;= LOAD_RADIUS_CHUNKS;\n        }\n\n        // --- Helper: Get a list of all current virtual agents ---\n        public IReadOnlyList&lt;VirtualAgent&gt; GetAllVirtualAgents()\n        {\n            return _virtualAgents.ToList().AsReadOnly();\n        }\n    }\n}\n</code></pre>"},{"location":"49-chapter-49/#21-update-aisystemcs-for-simplified-ai-state","title":"2.1. Update <code>AISystem.cs</code> for Simplified AI State","text":"<p><code>EcologyManager</code> needs to get and set a simplified AI state for virtual agents.</p> <ol> <li>Open <code>res://_Brain/Systems/AI/AISystem.cs</code> and add <code>_simplifiedAIStates</code> dictionary and <code>GetSimplifiedAIState</code> / <code>SetSimplifiedAIState</code> / <code>GetTargetID</code> / <code>SetTargetID</code> methods.</li> </ol> <pre><code>// _Brain/Systems/AI/AISystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Combat;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.AI\n{\n    /// &lt;summary&gt;\n    /// Manages AI decision-making using a Utility AI (scoring) system.\n    /// NPCs evaluate actions based on needs and context and execute the highest-scoring one.\n    /// (TDD 05.3)\n    /// &lt;/summary&gt;\n    public class AISystem\n    {\n        // ... (existing fields) ...\n        // Simplified AI state for when an entity is virtual\n        private Dictionary&lt;EntityID, string&gt; _simplifiedAIStates = new Dictionary&lt;EntityID, string&gt;();\n        private Dictionary&lt;EntityID, EntityID&gt; _aiTargets = new Dictionary&lt;EntityID, EntityID&gt;();\n\n        // ... (constructor) ...\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.NPC || type == EntityType.Animal)\n            {\n                _aiComponents.Add(id, new AIComponent());\n                _aiDecisionTimers.Add(id, (float)GameManager.Instance.Time.CurrentGameTime);\n                _simplifiedAIStates.Add(id, \"Wandering\"); // Default simplified state\n                _aiTargets.Add(id, EntityID.Invalid); // Default target\n                GD.Print($\"AISystem: Added AIComponent for {type} entity {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _aiComponents.Remove(e.ID);\n            _aiDecisionTimers.Remove(e.ID);\n            _simplifiedAIStates.Remove(e.ID);\n            _aiTargets.Remove(e.ID);\n            GD.Print($\"AISystem: Removed AIComponent for {e.ID}.\");\n        }\n\n        // ... (OnPlayerAlerted, RegisterAction, RegisterDefaultActions methods) ...\n\n        public void Tick(double delta) { /* ... */ }\n        private void MakeDecision(EntityID npcID) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Gets the simplified AI state for a given entity.\n        /// &lt;/summary&gt;\n        public string GetSimplifiedAIState(EntityID id)\n        {\n            return _simplifiedAIStates.TryGetValue(id, out string state) ? state : \"None\";\n        }\n\n        /// &lt;summary&gt;\n        /// Sets the simplified AI state for a given entity. Used during hydration.\n        /// &lt;/summary&gt;\n        public void SetSimplifiedAIState(EntityID id, string state)\n        {\n            if (_simplifiedAIStates.ContainsKey(id)) _simplifiedAIStates[id] = state;\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the target ID for a given entity.\n        /// &lt;/summary&gt;\n        public EntityID GetTargetID(EntityID id)\n        {\n            return _aiTargets.TryGetValue(id, out EntityID target) ? target : EntityID.Invalid;\n        }\n\n        /// &lt;summary&gt;\n        /// Sets the target ID for a given entity. Used during hydration.\n        /// &lt;/summary&gt;\n        public void SetTargetID(EntityID id, EntityID target)\n        {\n            if (_aiTargets.ContainsKey(id)) _aiTargets[id] = target;\n        }\n    }\n}\n</code></pre>"},{"location":"49-chapter-49/#22-update-gamemanager-to-pass-aisystem-to-ecologymanager","title":"2.2. Update <code>GameManager</code> to Pass <code>AISystem</code> to <code>EcologyManager</code>","text":"<p>Open <code>res://_Brain/Core/GameManager.cs</code> and modify the <code>EcologyManager</code> initialization in <code>InitializeSystems()</code>:</p> <pre><code>// _Brain/Core/GameManager.cs (inside InitializeSystems)\n// ...\n        // Initialize EcologyManager AFTER all its dependencies, including AI\n        Ecology = new EcologyManager(Entities, Events, BiologicalSystem, Transforms, AI, Movement, Weather, Jobs, SpatialGrid); // Pass AI\n        GD.Print(\"  - EcologyManager initialized.\");\n// ...\n</code></pre>"},{"location":"49-chapter-49/#3-refining-worldsimulationcs-for-chunk-coordinates","title":"3. Refining <code>WorldSimulation.cs</code> for Chunk Coordinates","text":"<p><code>EcologyManager</code> needs to convert world positions to chunk coordinates. This logic should be in <code>WorldSimulation</code>.</p> <p>Open <code>res://_Brain/Core/WorldSimulation.cs</code> and add <code>GetChunkCoords</code> method:</p> <pre><code>// _Brain/Core/WorldSimulation.cs\nusing Godot;\nusing System;\nusing Sigilborne.Systems.Ecology;\n\nnamespace Sigilborne.Core\n{\n    public class WorldSimulation\n    {\n        public EcologyManager Ecology { get; private set; }\n        public float ChunkSize { get; private set; } = 128f;\n\n        public WorldSimulation(EcologyManager ecologyManager) { /* ... */ }\n        public void Tick(double delta) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Converts world coordinates to grid cell (chunk) coordinates.\n        /// &lt;/summary&gt;\n        public Vector2I GetChunkCoords(Vector2 worldPosition)\n        {\n            return new Vector2I(\n                (int)MathF.Floor(worldPosition.X / ChunkSize),\n                (int)MathF.Floor(worldPosition.Y / ChunkSize)\n            );\n        }\n    }\n}\n</code></pre>"},{"location":"49-chapter-49/#4-testing-hydrationdehydration","title":"4. Testing Hydration/Dehydration","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.<ul> <li>Initial Spawns: The player, test NPC, and boss are spawned as active entities.</li> <li>Dehydration: Move the player far away (e.g., use WASD to move the player sprite to the edge of the screen, or use the debug console <code>/spawn Player player_default 1000 1000</code>).<ul> <li>You should see <code>EcologyManager: Dehydrating EntityID(...) (Type: NPC/Animal).</code> messages. The NPC and boss active entities should visually disappear from the screen, and their <code>EntityView</code>s will be <code>queue_free()</code>d.</li> </ul> </li> <li>Hydration: Move the player back towards the original spawn location (e.g., <code>/spawn Player player_default 200 200</code>).<ul> <li>You should see <code>EcologyManager: Hydrating EntityID(...) (Type: NPC/Animal).</code> messages. The NPC and boss entities should visually reappear.</li> </ul> </li> <li>Virtual Agent Tick: While entities are dehydrated, <code>EcologyManager: Processing Virtual Agent Tick.</code> messages will continue every 10 seconds, showing their simplified simulation.</li> </ul> </li> </ol> <p>This confirms our <code>EcologyManager</code> is effectively handling the hydration and dehydration process, transitioning entities between active and virtual states based on player proximity.</p>"},{"location":"49-chapter-49/#summary","title":"Summary","text":"<p>You have successfully refined the Spawning &amp; Despawning mechanics, implementing a robust hydration (spawning) and dehydration (despawning) process for entities in Sigilborne. By enhancing <code>EcologyManager</code> to seamlessly convert entities between \"Virtual Agent\" (data-only in C# Brain) and \"Active Entity\" (fully simulated with Godot Nodes in GDScript Body) states, you've ensured efficient resource management and a persistent world illusion. This crucial system strictly adheres to TDD 05.4.2 and TDD 05.4.3's specifications, allowing entities to appear and disappear gracefully as the player navigates the world.</p>"},{"location":"49-chapter-49/#next-steps","title":"Next Steps","text":"<p>This concludes Module 7: The Living World - Ecology &amp; AI. We will now move on to Module 8: Society, Politics &amp; Economy, starting with Faction System - The Relationship Graph (C#), where we will design the core data structures for managing faction relationships and their dynamic interactions.</p>"},{"location":"50-chapter-50/","title":"Chapter 8.1: Faction System - The Relationship Graph (C#)","text":""},{"location":"50-chapter-50/#chapter-81-faction-system-the-relationship-graph-c","title":"Chapter 8.1: Faction System - The Relationship Graph (C#)","text":"<p>Welcome to Module 8: Society, Politics &amp; Economy! Sigilborne's world is a complex tapestry of competing clans and factions. This module begins by implementing the Faction System in the C# Brain, designing the core data structures for managing faction relationships as a \"Relationship Graph\" and defining their dynamic interactions, as specified in TDD 06.2.</p>"},{"location":"50-chapter-50/#1-the-dynamic-nature-of-faction-politics","title":"1. The Dynamic Nature of Faction Politics","text":"<p>The GDD (B17.1) states: \"Every political actor is a living organism. Factions and clans evolve, fracture, merge, mutate, and occasionally die.\" This requires a system that:</p> <ul> <li>Models Relationships: Tracks trust, fear, and hostility between groups.</li> <li>Dynamic States: Relationships change over time due to events.</li> <li>Hierarchical Structure: Clans belong to major factions (B17.2).</li> <li>Player Influence: Player actions can shift political alignments (B17.10).</li> </ul>"},{"location":"50-chapter-50/#2-defining-factiontype-factionrelationstate-and-faction","title":"2. Defining <code>FactionType</code>, <code>FactionRelationState</code>, and <code>Faction</code>","text":"<p>We need enums for different types of factions and relationship states, and a class to represent a single faction.</p> <ol> <li>Create <code>res://_Brain/Systems/Factions/</code> folder.</li> <li>Create <code>res://_Brain/Systems/Factions/FactionEnums.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Factions/FactionEnums.cs\nusing System;\n\nnamespace Sigilborne.Systems.Factions\n{\n    /// &lt;summary&gt;\n    /// Defines the broad categories of major factions in the world.\n    /// (GDD B17.2.2: Major Faction Archetypes)\n    /// &lt;/summary&gt;\n    public enum FactionType\n    {\n        None,\n        WarriorDominion,    // Pulse/Fracture aligned\n        TempleAlliance,     // Bloom/Bind aligned\n        SpiritWovenTribe,   // Echo/Flux aligned\n        ScholarConfederation, // Veil/Conjure aligned\n        CorruptedCult,      // Consume/Chain aligned (C04)\n        TradeConsortium,    // Neutral/Economic\n        BorderCoalition,    // Defensive\n        RogueGroup          // Outlaw (GDD B22.7)\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the visible state of a relationship between two factions.\n    /// (GDD B17.5: Diplomacy &amp; Relationships)\n    /// &lt;/summary&gt;\n    public enum FactionRelationState\n    {\n        Ally,       // Strongly positive, cooperative\n        Friendly,   // Positive, generally helpful\n        Neutral,    // Indifferent, no strong feelings\n        Tense,      // Negative, distrustful, cautious\n        Hostile,    // Actively aggressive, will attack\n        War         // Open warfare, full conflict\n    }\n}\n</code></pre> <ol> <li>Create <code>res://_Brain/Systems/Factions/Faction.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Factions/Faction.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For GD.Print\n\nnamespace Sigilborne.Systems.Factions\n{\n    /// &lt;summary&gt;\n    /// Represents a single major faction in the world.\n    /// (TDD 06.2.1: The Relationship Graph)\n    /// &lt;/summary&gt;\n    public class Faction\n    {\n        public string ID { get; private set; } // Unique ID (e.g., \"CrimsonBladeClan\", \"SunkenTemple\")\n        public string Name { get; private set; }\n        public FactionType Type { get; private set; }\n        public string Description { get; private set; }\n\n        // Core ideological glyph concepts (GDD B17.7)\n        public List&lt;GlyphConcept&gt; PrimaryConcepts { get; private set; }\n        public List&lt;GlyphConcept&gt; TabooConcepts { get; private set; }\n\n        public Faction(string id, string name, FactionType type, string description, List&lt;GlyphConcept&gt; primaryConcepts = null, List&lt;GlyphConcept&gt; tabooConcepts = null)\n        {\n            ID = id;\n            Name = name;\n            Type = type;\n            Description = description;\n            PrimaryConcepts = primaryConcepts ?? new List&lt;GlyphConcept&gt;();\n            TabooConcepts = tabooConcepts ?? new List&lt;GlyphConcept&gt;();\n        }\n\n        public override string ToString()\n        {\n            return $\"Faction: '{Name}' ({Type}) | Primary: {string.Join(\", \", PrimaryConcepts)}\";\n        }\n    }\n}\n</code></pre>"},{"location":"50-chapter-50/#3-implementing-factionsystemcs","title":"3. Implementing <code>FactionSystem.cs</code>","text":"<p>This system will manage all <code>Faction</code> instances and their relationships.</p> <ol> <li>Create <code>res://_Brain/Systems/Factions/FactionSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Factions/FactionSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic; // For GlyphConcept\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Factions\n{\n    /// &lt;summary&gt;\n    /// Represents the relationship between two factions.\n    /// (TDD 06.2.1: The Relationship Graph)\n    /// &lt;/summary&gt;\n    public struct FactionRelation\n    {\n        public EntityID FactionA_ID; // Using EntityID for factions too, or string ID? TDD says string. Let's use string.\n        public string FactionA_ID_Str;\n        public string FactionB_ID_Str;\n        public float Value; // -100 to 100 (TDD 06.2.1)\n        public FactionRelationState State; // Ally/Friendly/Neutral/Tense/Hostile/War (TDD 06.2.1)\n\n        public FactionRelation(string factionA, string factionB, float value = 0f)\n        {\n            FactionA_ID_Str = factionA;\n            FactionB_ID_Str = factionB;\n            Value = value;\n            State = GetStateFromValue(value);\n        }\n\n        public void UpdateValue(float change)\n        {\n            Value = Mathf.Clamp(Value + change, -100f, 100f);\n            State = GetStateFromValue(Value);\n        }\n\n        public static FactionRelationState GetStateFromValue(float value)\n        {\n            if (value &gt;= 80) return FactionRelationState.Ally;\n            if (value &gt;= 40) return FactionRelationState.Friendly;\n            if (value &gt; -40) return FactionRelationState.Neutral;\n            if (value &gt; -80) return FactionRelationState.Tense;\n            return FactionRelationState.Hostile; // Below -80, consider War\n        }\n\n        public override string ToString()\n        {\n            return $\"Rel: {FactionA_ID_Str} &lt;-&gt; {FactionB_ID_Str} | Val: {Value:F0} ({State})\";\n        }\n    }\n\n\n    /// &lt;summary&gt;\n    /// Manages all Faction instances and their relationships within the world.\n    /// (TDD 06.2.1)\n    /// &lt;/summary&gt;\n    public class FactionSystem\n    {\n        private EventBus _eventBus;\n        private Dictionary&lt;string, Faction&gt; _factions = new Dictionary&lt;string, Faction&gt;();\n        // The relationship graph: Key is a combined string \"FactionA_FactionB\" (alphabetically sorted)\n        private Dictionary&lt;string, FactionRelation&gt; _relationships = new Dictionary&lt;string, FactionRelation&gt;();\n\n        public FactionSystem(EventBus eventBus)\n        {\n            _eventBus = eventBus;\n            RegisterDefaultFactions(); // Register some default factions\n            GD.Print(\"FactionSystem: Initialized.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static Faction definition.\n        /// &lt;/summary&gt;\n        public void RegisterFaction(Faction faction)\n        {\n            _factions[faction.ID] = faction;\n            GD.Print($\"FactionSystem: Registered faction '{faction.Name}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some common default factions for initial testing.\n        /// (GDD B17.2.2: Examples of major faction archetypes)\n        /// &lt;/summary&gt;\n        private void RegisterDefaultFactions()\n        {\n            RegisterFaction(new Faction(\"crimson_blades\", \"Crimson Blades\", FactionType.WarriorDominion, \"A martial clan focused on combat mastery.\", new List&lt;GlyphConcept&gt; { GlyphConcept.Pulse, GlyphConcept.Fracture }));\n            RegisterFaction(new Faction(\"sunken_temple\", \"Sunken Temple\", FactionType.TempleAlliance, \"An ancient order dedicated to healing and stability.\", new List&lt;GlyphConcept&gt; { GlyphConcept.Bloom, GlyphConcept.Bind }));\n            RegisterFaction(new Faction(\"shadow_veilers\", \"Shadow Veilers\", FactionType.ScholarConfederation, \"Masters of espionage and information control.\", new List&lt;GlyphConcept&gt; { GlyphConcept.Veil, GlyphConcept.Echo }));\n            RegisterFaction(new Faction(\"void_cultists\", \"Void Cultists\", FactionType.CorruptedCult, \"Worshippers of chaos and forbidden arts.\", new List&lt;GlyphConcept&gt; { GlyphConcept.Consume, GlyphConcept.Flux }, new List&lt;GlyphConcept&gt; { GlyphConcept.Bloom, GlyphConcept.Bind }));\n            RegisterFaction(new Faction(\"free_wanderers\", \"Free Wanderers\", FactionType.RogueGroup, \"Independent nomads, valuing freedom above all.\", new List&lt;GlyphConcept&gt; { GlyphConcept.Flux }));\n\n            // Establish initial relationships\n            SetRelationship(\"crimson_blades\", \"sunken_temple\", 50f); // Friendly\n            SetRelationship(\"crimson_blades\", \"void_cultists\", -80f); // Hostile\n            SetRelationship(\"sunken_temple\", \"void_cultists\", -90f); // Hostile\n            SetRelationship(\"shadow_veilers\", \"crimson_blades\", 10f); // Neutral\n            SetRelationship(\"shadow_veilers\", \"void_cultists\", -20f); // Tense\n            SetRelationship(\"free_wanderers\", \"crimson_blades\", -10f); // Tense\n        }\n\n        /// &lt;summary&gt;\n        /// Sets or updates the relationship value between two factions.\n        /// (TDD 06.2.1: Dynamics)\n        /// &lt;/summary&gt;\n        public void SetRelationship(string factionA_ID, string factionB_ID, float value)\n        {\n            if (factionA_ID == factionB_ID) return; // Cannot set relationship with self\n\n            string relationshipKey = GetRelationshipKey(factionA_ID, factionB_ID);\n            if (!_relationships.ContainsKey(relationshipKey))\n            {\n                _relationships[relationshipKey] = new FactionRelation(factionA_ID, factionB_ID, value);\n            }\n            else\n            {\n                FactionRelation rel = _relationships[relationshipKey];\n                rel.Value = value;\n                rel.State = FactionRelation.GetStateFromValue(value);\n                _relationships[relationshipKey] = rel; // Update struct in dictionary\n            }\n            GD.Print($\"FactionSystem: Relationship {relationshipKey} set to {value:F0} ({_relationships[relationshipKey].State}).\");\n            _eventBus.Publish(new FactionRelationshipChangedEvent { FactionA_ID = factionA_ID, FactionB_ID = factionB_ID, NewRelation = _relationships[relationshipKey] });\n        }\n\n        /// &lt;summary&gt;\n        /// Adjusts the relationship value between two factions by a given change.\n        /// &lt;/summary&gt;\n        public void AdjustRelationship(string factionA_ID, string factionB_ID, float change)\n        {\n            if (factionA_ID == factionB_ID) return;\n\n            string relationshipKey = GetRelationshipKey(factionA_ID, factionB_ID);\n            if (!_relationships.ContainsKey(relationshipKey))\n            {\n                // Create with initial change\n                _relationships[relationshipKey] = new FactionRelation(factionA_ID, factionB_ID, change);\n            }\n            else\n            {\n                FactionRelation rel = _relationships[relationshipKey];\n                rel.UpdateValue(change);\n                _relationships[relationshipKey] = rel;\n            }\n            GD.Print($\"FactionSystem: Relationship {relationshipKey} adjusted by {change:F0}. New Value: {_relationships[relationshipKey].Value:F0} ({_relationships[relationshipKey].State}).\");\n            _eventBus.Publish(new FactionRelationshipChangedEvent { FactionA_ID = factionA_ID, FactionB_ID = factionB_ID, NewRelation = _relationships[relationshipKey] });\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the relationship between two factions.\n        /// &lt;/summary&gt;\n        public FactionRelation GetRelationship(string factionA_ID, string factionB_ID)\n        {\n            if (factionA_ID == factionB_ID) return new FactionRelation(factionA_ID, factionB_ID, 100f); // Self is always Ally\n            string relationshipKey = GetRelationshipKey(factionA_ID, factionB_ID);\n            if (_relationships.TryGetValue(relationshipKey, out FactionRelation rel))\n            {\n                return rel;\n            }\n            return new FactionRelation(factionA_ID, factionB_ID, 0f); // Default Neutral\n        }\n\n        /// &lt;summary&gt;\n        /// Helper to create a consistent key for relationship dictionary.\n        /// &lt;/summary&gt;\n        private string GetRelationshipKey(string factionA_ID, string factionB_ID)\n        {\n            // Sort alphabetically to ensure key is consistent regardless of order (A_B vs B_A)\n            return string.CompareOrdinal(factionA_ID, factionB_ID) &lt; 0\n                ? $\"{factionA_ID}_{factionB_ID}\"\n                : $\"{factionB_ID}_{factionA_ID}\";\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a faction by its ID.\n        /// &lt;/summary&gt;\n        public Faction GetFaction(string factionID)\n        {\n            _factions.TryGetValue(factionID, out Faction faction);\n            return faction;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all registered factions.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;Faction&gt; GetAllFactions()\n        {\n            return _factions.Values.ToList().AsReadOnly();\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct FactionRelationshipChangedEvent { public string FactionA_ID; public string FactionB_ID; public FactionRelation NewRelation; }\n    }\n}\n</code></pre>"},{"location":"50-chapter-50/#4-integrating-factionsystem-into-gamemanager","title":"4. Integrating <code>FactionSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Factions;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>FactionSystem</code> property.</li> <li>Initialize <code>FactionSystem</code> in <code>InitializeSystems()</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public EcologyManager Ecology { get; private set; }\n    public FactionSystem Factions { get; private set; } // Add FactionSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n\n        // --- Test Faction System ---\n        GD.Print(\"\\n--- Testing Faction System ---\");\n        GD.Print(\"All Factions:\");\n        foreach (var faction in Factions.GetAllFactions())\n        {\n            GD.Print($\"  - {faction}\");\n        }\n\n        // Test relationships\n        GD.Print($\"Relationship Crimson Blades &lt;-&gt; Sunken Temple: {Factions.GetRelationship(\"crimson_blades\", \"sunken_temple\")}\");\n        GD.Print($\"Relationship Crimson Blades &lt;-&gt; Void Cultists: {Factions.GetRelationship(\"crimson_blades\", \"void_cultists\")}\");\n        GD.Print($\"Relationship Sunken Temple &lt;-&gt; Shadow Veilers: {Factions.GetRelationship(\"sunken_temple\", \"shadow_veilers\")}\"); // Default neutral\n\n        // Adjust a relationship\n        Factions.AdjustRelationship(\"shadow_veilers\", \"sunken_temple\", 30f); // Make them friendly\n        GD.Print($\"Relationship Sunken Temple &lt;-&gt; Shadow Veilers (adjusted): {Factions.GetRelationship(\"sunken_temple\", \"shadow_veilers\")}\");\n\n        // Adjust to hostile\n        Factions.AdjustRelationship(\"free_wanderers\", \"void_cultists\", -70f); // Make them hostile\n        GD.Print($\"Relationship Free Wanderers &lt;-&gt; Void Cultists (adjusted): {Factions.GetRelationship(\"free_wanderers\", \"void_cultists\")}\");\n\n        GD.Print(\"--- End Testing Faction System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        // FactionSystem doesn't have a Tick method for now; its operations are event/command driven.\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to EcologyManager) ...\n\n        // Initialize FactionSystem\n        Factions = new FactionSystem(Events); // Pass EventBus\n        GD.Print(\"  - FactionSystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"50-chapter-50/#41-update-eventbuscs-for-factionrelationshipchangedevent","title":"4.1. Update <code>EventBus.cs</code> for <code>FactionRelationshipChangedEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnFactionRelationshipChanged</code> delegate.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Faction System Events (TDD 06.2.1)\n        public event Action&lt;string, string, FactionRelation&gt; OnFactionRelationshipChanged; // FactionA_ID, FactionB_ID, NewRelation\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is FactionSystem.FactionRelationshipChangedEvent factionRelEvent) // New condition\n            {\n                OnFactionRelationshipChanged?.Invoke(factionRelEvent.FactionA_ID, factionRelEvent.FactionB_ID, factionRelEvent.NewRelation);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"50-chapter-50/#5-testing-the-faction-system","title":"5. Testing the Faction System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Faction System\" section.</li> </ol> <pre><code>...\nFactionSystem: Initialized.\nFactionSystem: Registered faction 'Crimson Blades'.\nFactionSystem: Registered faction 'Sunken Temple'.\nFactionSystem: Registered faction 'Shadow Veilers'.\nFactionSystem: Registered faction 'Void Cultists'.\nFactionSystem: Registered faction 'Free Wanderers'.\nFactionSystem: Relationship crimson_blades_sunken_temple set to 50 (Friendly).\nFactionSystem: Relationship crimson_blades_void_cultists set to -80 (Hostile).\nFactionSystem: Relationship sunken_temple_void_cultists set to -90 (Hostile).\nFactionSystem: Relationship crimson_blades_shadow_veilers set to 10 (Neutral).\nFactionSystem: Relationship shadow_veilers_void_cultists set to -20 (Tense).\nFactionSystem: Relationship free_wanderers_crimson_blades set to -10 (Tense).\n  - FactionSystem initialized.\nPlayerStatSystem: Initialized.\n...\n--- Testing Faction System ---\nAll Factions:\n  Faction: 'Crimson Blades' (WarriorDominion) | Primary: Pulse, Fracture\n  Faction: 'Sunken Temple' (TempleAlliance) | Primary: Bloom, Bind\n  Faction: 'Shadow Veilers' (ScholarConfederation) | Primary: Veil, Echo\n  Faction: 'Void Cultists' (CorruptedCult) | Primary: Consume, Flux\n  Faction: 'Free Wanderers' (RogueGroup) | Primary: Flux\nRelationship Crimson Blades &lt;-&gt; Sunken Temple: Rel: crimson_blades &lt;-&gt; sunken_temple | Val: 50 (Friendly)\nRelationship Crimson Blades &lt;-&gt; Void Cultists: Rel: crimson_blades &lt;-&gt; void_cultists | Val: -80 (Hostile)\nRelationship Sunken Temple &lt;-&gt; Shadow Veilers: Rel: shadow_veilers &lt;-&gt; sunken_temple | Val: 0 (Neutral)\nFactionSystem: Relationship shadow_veilers_sunken_temple adjusted by 30. New Value: 30 (Neutral).\nRelationship Sunken Temple &lt;-&gt; Shadow Veilers (adjusted): Rel: shadow_veilers &lt;-&gt; sunken_temple | Val: 30 (Neutral)\nFactionSystem: Relationship free_wanderers_void_cultists adjusted by -70. New Value: -70 (Tense).\nRelationship Free Wanderers &lt;-&gt; Void Cultists (adjusted): Rel: free_wanderers &lt;-&gt; void_cultists | Val: -70 (Tense)\n--- End Testing Faction System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Faction Registration: <code>Faction</code> objects are correctly registered and printed.</li> <li>Initial Relationships: Default relationships are set, and their <code>FactionRelationState</code> is correctly derived from the <code>Value</code>.</li> <li>Relationship Adjustment: <code>AdjustRelationship</code> correctly updates the <code>Value</code> and transitions the <code>State</code> (e.g., from <code>Neutral</code> to <code>Friendly</code>).</li> <li>Key Generation: The <code>GetRelationshipKey</code> ensures consistent key generation (e.g., <code>crimson_blades_sunken_temple</code> is the same as <code>sunken_temple_crimson_blades</code>).</li> </ul> <p>This confirms our <code>FactionSystem</code> is functional, managing factions and their dynamic relationships using a relationship graph.</p>"},{"location":"50-chapter-50/#summary","title":"Summary","text":"<p>You have successfully implemented the Faction System in the C# Brain, designing <code>FactionType</code>, <code>FactionRelationState</code>, and <code>Faction</code> classes to represent political actors and their relationships. By creating <code>FactionSystem</code> to manage faction definitions and their dynamic <code>FactionRelation</code>s using a relationship graph, you've established the core mechanism for political simulation. This crucial system strictly adheres to TDD 06.2's specifications, providing the foundational layer for complex societal interactions and emergent political narratives in Sigilborne.</p>"},{"location":"50-chapter-50/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on The Simulation Clock, detailing how the world's internal \"Game Time\" operates at a slower tick rate than the rendering frame, and how heavy system updates (like Faction AI planning) are load-balanced across this daily cycle.</p>"},{"location":"51-chapter-51/","title":"Chapter 8.2: The Simulation Clock - Game Time & Load Balancing (C#)","text":""},{"location":"51-chapter-51/#chapter-82-the-simulation-clock-game-time-load-balancing-c","title":"Chapter 8.2: The Simulation Clock - Game Time &amp; Load Balancing (C#)","text":"<p>Sigilborne's world is a vast simulation, where factions wage war, economies fluctuate, and NPCs live out their lives over in-game days, weeks, and years. Simulating all these complex systems in real-time at 60 frames per second is impractical. This chapter focuses on implementing The Simulation Clock, which defines how the world's internal \"Game Time\" operates at a slower, configurable tick rate than the rendering frame. It also details how heavy system updates (like Faction AI planning) are load-balanced across this daily cycle to prevent performance spikes, as specified in TDD 06.2.3 and TDD 06.2.4.</p>"},{"location":"51-chapter-51/#1-the-need-for-a-simulation-clock-and-load-balancing","title":"1. The Need for a Simulation Clock and Load Balancing","text":"<ul> <li>Performance: Many game systems (AI, economy, ecology) don't need to update every frame. A slower \"game tick\" reduces computational load.</li> <li>Realism: Political and ecological changes happen over longer timescales than combat.</li> <li>Load Balancing: Even on a slower game tick, some operations (e.g., a Faction AI planning its day) can be CPU-intensive. Spreading these out prevents noticeable hitches.</li> <li>Determinism: The game clock provides a consistent time reference for all simulation logic.</li> </ul>"},{"location":"51-chapter-51/#2-enhancing-timesystemcs-for-game-time","title":"2. Enhancing <code>TimeSystem.cs</code> for Game Time","text":"<p>Our <code>TimeSystem</code> already tracks <code>CurrentGameTime</code>, <code>CurrentDay</code>, <code>CurrentHour</code>, and <code>CurrentMinute</code>. We'll enhance it with events for day/hour changes and a mechanism for systems to subscribe to these.</p> <p>Open <code>res://_Brain/Core/TimeSystem.cs</code>:</p> <pre><code>// _Brain/Core/TimeSystem.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Core\n{\n    /// &lt;summary&gt;\n    /// Manages the in-game clock, day/night cycle, and other time-related logic.\n    /// (TDD 01.2, TDD 06.2.3)\n    /// &lt;/summary&gt;\n    public class TimeSystem\n    {\n        public double CurrentGameTime { get; private set; } // Total game time in seconds (real-time equivalent)\n        public int CurrentDay { get; private set; }\n        public int CurrentHour { get; private set; }\n        public int CurrentMinute { get; private set; }\n\n        // TDD 06.2.3: Tick Rate - 1 Tick = 1 In-Game Minute (approx 1 real second).\n        private const float REAL_SECONDS_PER_GAME_MINUTE = 1.0f; // 1 real second = 1 game minute\n        private const float GAME_MINUTES_PER_HOUR = 60.0f;\n        private const float GAME_HOURS_PER_DAY = 24.0f;\n\n        // Events for other systems to subscribe to (TDD 06.2.3: Daily Cycle)\n        public event Action&lt;int&gt; OnNewDay; // Parameter: New day number\n        public event Action&lt;int&gt; OnNewHour; // Parameter: New hour number\n\n        public TimeSystem()\n        {\n            CurrentGameTime = 0.0;\n            CurrentDay = 1;\n            CurrentHour = 8; // Start at 8 AM\n            CurrentMinute = 0;\n            GD.Print($\"TimeSystem: Initialized. Day {CurrentDay}, {CurrentHour:D2}:{CurrentMinute:D2}\");\n        }\n\n        public void Tick(double delta)\n        {\n            double gameMinutesToAdd = delta / REAL_SECONDS_PER_GAME_MINUTE;\n            CurrentGameTime += gameMinutesToAdd;\n\n            // Store old values to detect changes\n            int oldHour = CurrentHour;\n            int oldDay = CurrentDay;\n\n            CurrentMinute += (int)Math.Floor(gameMinutesToAdd);\n            if (CurrentMinute &gt;= GAME_MINUTES_PER_HOUR)\n            {\n                CurrentHour += CurrentMinute / (int)GAME_MINUTES_PER_HOUR;\n                CurrentMinute %= (int)GAME_MINUTES_PER_HOUR;\n\n                if (CurrentHour &gt;= GAME_HOURS_PER_DAY)\n                {\n                    CurrentDay += CurrentHour / (int)GAME_HOURS_PER_DAY;\n                    CurrentHour %= (int)GAME_HOURS_PER_DAY;\n                }\n            }\n\n            // Publish events if hour or day changed\n            if (CurrentHour != oldHour)\n            {\n                OnNewHour?.Invoke(CurrentHour);\n                // GD.Print($\"TimeSystem: New Hour: {CurrentHour:D2}:00\");\n            }\n            if (CurrentDay != oldDay)\n            {\n                OnNewDay?.Invoke(CurrentDay);\n                GD.Print($\"TimeSystem: New Day: {CurrentDay}\");\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Sets the current in-game hour.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"hour\"&gt;The hour to set (0-23).&lt;/param&gt;\n        public void SetCurrentHour(int hour)\n        {\n            if (hour &lt; 0 || hour &gt; 23)\n            {\n                GD.PrintErr($\"TimeSystem: Invalid hour '{hour}'. Must be between 0 and 23.\");\n                return;\n            }\n            CurrentHour = hour;\n            CurrentMinute = 0; // Reset minutes for clean hour setting\n            GD.Print($\"TimeSystem: Hour manually set to {CurrentHour:D2}:00.\");\n            OnNewHour?.Invoke(CurrentHour); // Publish event for manual set\n        }\n    }\n}\n</code></pre>"},{"location":"51-chapter-51/#21-update-eventbuscs-for-timesystem-events","title":"2.1. Update <code>EventBus.cs</code> for <code>TimeSystem</code> Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnNewDay</code> and <code>OnNewHour</code> delegates.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Time System Events (TDD 06.2.3)\n        public event Action&lt;int&gt; OnNewDay;\n        public event Action&lt;int&gt; OnNewHour;\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is int newDay &amp;&amp; typeof(TEvent) == typeof(int) &amp;&amp; CurrentEventType == TimeEventType.NewDay) // Special handling for int events\n            {\n                OnNewDay?.Invoke(newDay);\n            }\n            else if (eventData is int newHour &amp;&amp; typeof(TEvent) == typeof(int) &amp;&amp; CurrentEventType == TimeEventType.NewHour) // Special handling for int events\n            {\n                OnNewHour?.Invoke(newHour);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // Special enum to differentiate int events (can't overload Action&lt;int&gt; easily)\n        public enum TimeEventType { None, NewDay, NewHour }\n        public TimeEventType CurrentEventType { get; set; } // Set by TimeSystem before publishing int.\n        // This is a workaround for C# Action&lt;int&gt; not having distinct types.\n    }\n}\n</code></pre>"},{"location":"51-chapter-51/#22-modify-timesystemcs-to-use-eventbuscurrenteventtype","title":"2.2. Modify <code>TimeSystem.cs</code> to use <code>EventBus.CurrentEventType</code>","text":"<pre><code>// _Brain/Core/TimeSystem.cs (inside Tick method)\n// ...\n            if (CurrentHour != oldHour)\n            {\n                _eventBus.CurrentEventType = EventBus.TimeEventType.NewHour; // Set type before publishing\n                _eventBus.Publish(CurrentHour); // Publish the int directly\n                // GD.Print($\"TimeSystem: New Hour: {CurrentHour:D2}:00\");\n            }\n            if (CurrentDay != oldDay)\n            {\n                _eventBus.CurrentEventType = EventBus.TimeEventType.NewDay; // Set type before publishing\n                _eventBus.Publish(CurrentDay); // Publish the int directly\n                GD.Print($\"TimeSystem: New Day: {CurrentDay}\");\n            }\n            _eventBus.CurrentEventType = EventBus.TimeEventType.None; // Reset\n// ...\n</code></pre>"},{"location":"51-chapter-51/#3-implementing-factionaisystemcs-for-daily-planning-load-balancing","title":"3. Implementing <code>FactionAISystem.cs</code> for Daily Planning &amp; Load Balancing","text":"<p>This system will simulate Faction AI decisions once per game day, and importantly, load-balance its CPU-intensive operations.</p> <ol> <li>Create <code>res://_Brain/Systems/Factions/FactionAISystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Factions/FactionAISystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Magic; // For GlyphConcept\nusing Sigilborne.Utils; // For JobSystem\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Factions\n{\n    /// &lt;summary&gt;\n    /// Manages AI decision-making for major factions.\n    /// Runs once per game day and load-balances heavy operations.\n    /// (TDD 06.2.2: Faction AI, TDD 06.2.4: Load Balancing)\n    /// &lt;/summary&gt;\n    public class FactionAISystem\n    {\n        private EventBus _eventBus;\n        private FactionSystem _factionSystem; // To query factions and relationships\n        private JobSystem _jobSystem;         // For load balancing heavy tasks\n\n        private Random _rand; // For deterministic random decisions\n\n        private const int FACTION_AI_PLANNING_HOUR = 6; // TDD 06.2.3: Faction AI plans at 06:00\n        private bool _hasPlannedToday = false;\n\n        public FactionAISystem(EventBus eventBus, FactionSystem factionSystem, JobSystem jobSystem, int worldSeed)\n        {\n            _eventBus = eventBus;\n            _factionSystem = factionSystem;\n            _jobSystem = jobSystem;\n            _rand = new Random(worldSeed);\n\n            _eventBus.OnNewHour += OnNewHour; // Subscribe to hourly updates\n            _eventBus.OnNewDay += OnNewDay; // Subscribe to daily updates\n\n            GD.Print(\"FactionAISystem: Initialized.\");\n        }\n\n        private void OnNewHour(int hour)\n        {\n            if (hour == FACTION_AI_PLANNING_HOUR &amp;&amp; !_hasPlannedToday)\n            {\n                GD.Print($\"FactionAISystem: It's {FACTION_AI_PLANNING_HOUR}:00. Initiating daily faction planning.\");\n                _hasPlannedToday = true;\n                PlanDailyFactionMoves();\n            }\n        }\n\n        private void OnNewDay(int day)\n        {\n            _hasPlannedToday = false; // Reset for the new day\n        }\n\n        /// &lt;summary&gt;\n        /// Initiates the daily planning for all factions, load-balancing heavy computations.\n        /// (TDD 06.2.2: Faction AI Runs once per \"Game Day\", TDD 06.2.4: Load Balancing)\n        /// &lt;/summary&gt;\n        private void PlanDailyFactionMoves()\n        {\n            var allFactions = _factionSystem.GetAllFactions();\n            int factionsPerJob = 2; // Process 2 factions per job for load balancing\n\n            for (int i = 0; i &lt; allFactions.Count; i += factionsPerJob)\n            {\n                List&lt;Faction&gt; factionsToProcess = allFactions.Skip(i).Take(factionsPerJob).ToList();\n\n                // Schedule a job for each batch of factions\n                _jobSystem.Schedule(new FactionPlanningJob(factionsToProcess, _factionSystem, _rand.Next()), () =&gt; {\n                    // This callback runs on the main thread after each job completes.\n                    GD.Print($\"FactionAISystem: Completed planning job for {factionsToProcess.Count} factions.\");\n                    // After all jobs are done, we might trigger a global event.\n                });\n            }\n            GD.Print($\"FactionAISystem: Scheduled {MathF.Ceiling((float)allFactions.Count / factionsPerJob)} faction planning jobs.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Represents a background job for a batch of factions to plan their daily moves.\n        /// (TDD 13.2: The Job Struct)\n        /// &lt;/summary&gt;\n        public struct FactionPlanningJob : IJob\n        {\n            public List&lt;Faction&gt; FactionsToPlan;\n            public FactionSystem FactionSystem; // Reference to the FactionSystem for updates\n            public int Seed; // For deterministic random in job\n\n            public FactionPlanningJob(List&lt;Faction&gt; factions, FactionSystem factionSystem, int seed)\n            {\n                FactionsToPlan = factions;\n                FactionSystem = factionSystem;\n                Seed = seed;\n            }\n\n            public void Execute()\n            {\n                Random jobRand = new Random(Seed);\n                foreach (Faction faction in FactionsToPlan)\n                {\n                    // --- Faction AI Logic (TDD 06.2.2) ---\n                    // Example: Check relationships and decide to declare war, send caravan, etc.\n                    GD.Print($\"[Job] Faction '{faction.Name}' is planning. Type: {faction.Type}\");\n\n                    // Example: Adjust relationships based on ideology\n                    foreach (Faction otherFaction in FactionSystem.GetAllFactions())\n                    {\n                        if (faction.ID == otherFaction.ID) continue;\n\n                        float currentRelationValue = FactionSystem.GetRelationship(faction.ID, otherFaction.ID).Value;\n                        float ideologicalCompatibility = CalculateIdeologicalCompatibility(faction, otherFaction);\n\n                        float baseChange = 0;\n                        if (ideologicalCompatibility &gt; 0.7f) baseChange = 1f; // Slowly drift positive\n                        else if (ideologicalCompatibility &lt; 0.3f) baseChange = -1f; // Slowly drift negative\n\n                        // Add some random daily fluctuation\n                        baseChange += (float)(jobRand.NextDouble() * 2 - 1); // +/- 1\n\n                        // Only adjust if not already in extreme states\n                        if ((currentRelationValue &gt; -90 &amp;&amp; currentRelationValue &lt; 90))\n                        {\n                            // TDD 13.3: Command Buffers - Use main thread for actual state changes.\n                            // The FactionSystem.AdjustRelationship method already publishes events which\n                            // are then picked up by the EventBus's flush.\n                            FactionSystem.AdjustRelationship(faction.ID, otherFaction.ID, baseChange);\n                        }\n                    }\n\n                    // Example: Decide to build outpost (conceptual)\n                    if (faction.Type == FactionType.WarriorDominion &amp;&amp; jobRand.NextDouble() &lt; 0.1)\n                    {\n                        GD.Print($\"[Job] Faction '{faction.Name}' decided to build an outpost (conceptual).\");\n                        // _eventBus.Publish(new FactionAction.BuildOutpostEvent { FactionID = faction.ID, Location = ... });\n                    }\n                }\n            }\n\n            /// &lt;summary&gt;\n            /// Calculates a compatibility score between two factions based on their primary and taboo glyph concepts.\n            /// (GDD B17.7: Faction Identity &amp; Category Alignment)\n            /// &lt;/summary&gt;\n            private float CalculateIdeologicalCompatibility(Faction factionA, Faction factionB)\n            {\n                float score = 0;\n                // Bonus for shared primary concepts\n                score += factionA.PrimaryConcepts.Intersect(factionB.PrimaryConcepts).Count() * 0.2f;\n                // Penalty for one's primary being another's taboo\n                score -= factionA.PrimaryConcepts.Intersect(factionB.TabooConcepts).Count() * 0.5f;\n                score -= factionB.PrimaryConcepts.Intersect(factionA.TabooConcepts).Count() * 0.5f;\n                // Normalization (simple for now)\n                return Mathf.Clamp(score, -1f, 1f);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"51-chapter-51/#5-integrating-factionaisystem-into-gamemanager","title":"5. Integrating <code>FactionAISystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Factions;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>FactionAISystem</code> property.</li> <li>Initialize <code>FactionAISystem</code> in <code>InitializeSystems()</code> after <code>FactionSystem</code> and <code>JobSystem</code>.</li> <li>Remove the <code>FactionSystem</code>'s default relationship setting from <code>InitializeSystems()</code> and move it to <code>FactionAISystem</code>'s constructor, ensuring <code>FactionAISystem</code> controls the initial setup.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public FactionSystem Factions { get; private set; }\n    public FactionAISystem FactionAI { get; private set; } // Add FactionAISystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n\n        // --- Test Faction System ---\n        GD.Print(\"\\n--- Testing Faction System ---\");\n        GD.Print(\"All Factions:\");\n        foreach (var faction in Factions.GetAllFactions())\n        {\n            GD.Print($\"  - {faction}\");\n        }\n\n        // Test relationships\n        GD.Print($\"Relationship Crimson Blades &lt;-&gt; Sunken Temple: {Factions.GetRelationship(\"crimson_blades\", \"sunken_temple\")}\");\n        GD.Print($\"Relationship Crimson Blades &lt;-&gt; Void Cultists: {Factions.GetRelationship(\"crimson_blades\", \"void_cultists\")}\");\n        GD.Print($\"Relationship Sunken Temple &lt;-&gt; Shadow Veilers: {Factions.GetRelationship(\"sunken_temple\", \"shadow_veilers\")}\");\n\n        // Adjust a relationship (will be done by FactionAISystem now)\n        // Factions.AdjustRelationship(\"shadow_veilers\", \"sunken_temple\", 30f);\n        // Factions.AdjustRelationship(\"free_wanderers\", \"void_cultists\", -70f);\n\n        GD.Print(\"--- End Testing Faction System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta); // Call FactionAISystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to FactionSystem) ...\n\n        // FactionSystem's constructor will now call RegisterDefaultFactions\n        Factions = new FactionSystem(Events); \n        GD.Print(\"  - FactionSystem initialized.\");\n\n        // Initialize FactionAISystem AFTER FactionSystem and JobSystem\n        FactionAI = new FactionAISystem(Events, Factions, Jobs, WorldSeed); // Pass dependencies\n        GD.Print(\"  - FactionAISystem initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"51-chapter-51/#6-testing-the-simulation-clock-and-load-balancing","title":"6. Testing the Simulation Clock and Load Balancing","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.<ul> <li>Time Progression: You'll see <code>TimeSystem: New Hour: X</code> messages every real-time minute.</li> <li>Faction Planning Trigger: At <code>06:00</code> (in-game time), you should see <code>FactionAISystem: It's 06:00. Initiating daily faction planning.</code></li> <li>Job Scheduling: Immediately after, <code>FactionAISystem: Scheduled X faction planning jobs.</code> will appear.</li> <li>Load Balancing: Then, you'll see <code>[Job] Faction 'X' is planning.</code> messages, interleaved with other system ticks. These jobs run on background threads.</li> <li>Relationship Adjustments: <code>FactionSystem: Relationship X adjusted by Y.</code> messages will appear as these background jobs complete and update relationships on the main thread via the <code>EventBus</code>.</li> </ul> </li> </ol> <p>This demonstrates that: *   The <code>TimeSystem</code> is correctly ticking and broadcasting hourly/daily events. *   <code>FactionAISystem</code> reacts to these events to trigger daily planning. *   Heavy planning logic is offloaded to the <code>JobSystem</code> for load balancing. *   Faction relationships dynamically adjust over time based on ideological compatibility and random fluctuations.</p>"},{"location":"51-chapter-51/#summary","title":"Summary","text":"<p>You have successfully implemented The Simulation Clock by enhancing <code>TimeSystem</code> to broadcast hourly and daily events, and designed Load Balancing for heavy operations. By creating <code>FactionAISystem</code> to subscribe to <code>TimeSystem</code> events and offload its daily planning logic to the <code>JobSystem</code>, you've ensured that complex calculations for faction relationships and strategic moves occur without causing performance spikes. This crucial system strictly adheres to TDD 06.2.3 and TDD 06.2.4's specifications, providing a dynamic and performant backbone for Sigilborne's evolving political landscape.</p>"},{"location":"51-chapter-51/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Market Simulation, where we will define how prices for goods are local to each settlement and dynamically fluctuate based on supply, demand, and global modifiers like war or famine.</p>"},{"location":"52-chapter-52/","title":"Chapter 8.3: Market Simulation - Supply & Demand (C#)","text":""},{"location":"52-chapter-52/#chapter-83-market-simulation-supply-demand-c","title":"Chapter 8.3: Market Simulation - Supply &amp; Demand (C#)","text":"<p>Our world now has dynamic factions and a ticking clock. The next layer of complexity is the Economy Simulation. This chapter focuses on implementing Market Simulation in the C# Brain, defining how prices for goods are local to each settlement and dynamically fluctuate based on supply, demand, and global modifiers like war or famine, as specified in TDD 06.3.1.</p>"},{"location":"52-chapter-52/#1-the-dynamic-nature-of-sigilbornes-economy","title":"1. The Dynamic Nature of Sigilborne's Economy","text":"<p>The GDD (B23.1) states: \"Economy is local, not global. No unified marketplace. Every settlement has different prices, resources, taboos, and needs.\" This requires a system that:</p> <ul> <li>Local Prices: Prices vary by <code>Settlement</code>.</li> <li>Supply &amp; Demand: Prices respond to item availability and need.</li> <li>Global Modifiers: World events (war, famine) can dramatically shift prices.</li> <li>Player Interaction: Player actions (selling large quantities, destroying caravans) can influence local markets.</li> </ul>"},{"location":"52-chapter-52/#2-defining-marketitem-marketrecord-and-settlementmarket","title":"2. Defining <code>MarketItem</code>, <code>MarketRecord</code>, and <code>SettlementMarket</code>","text":"<p>We need a way to track items in a market, their current supply/demand, and the market itself for each settlement.</p> <ol> <li>Create <code>res://_Brain/Systems/Economy/</code> folder.</li> <li>Create <code>res://_Brain/Systems/Economy/MarketData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Economy/MarketData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For GD.Print\nusing Sigilborne.Systems.Inventory; // For ItemDefinition\n\nnamespace Sigilborne.Systems.Economy\n{\n    /// &lt;summary&gt;\n    /// Represents a single item in a market, with its supply, demand, and price.\n    /// &lt;/summary&gt;\n    public struct MarketRecord\n    {\n        public string ItemID;\n        public int CurrentSupply;   // Actual quantity available in this market\n        public int CurrentDemand;   // How much the market \"wants\" this item\n        public float BasePrice;     // Base price from ItemDefinition\n        public float CurrentPrice;  // Calculated dynamic price\n\n        public MarketRecord(string itemID, float basePrice, int initialSupply, int initialDemand)\n        {\n            ItemID = itemID;\n            BasePrice = basePrice;\n            CurrentSupply = initialSupply;\n            CurrentDemand = initialDemand;\n            CurrentPrice = basePrice; // Initial price\n        }\n\n        public override string ToString()\n        {\n            return $\"Item: '{ItemID}' | Supply: {CurrentSupply}, Demand: {CurrentDemand}, Price: {CurrentPrice:F1}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Represents the local market of a single settlement.\n    /// (TDD 06.3.1: Market Simulation - Prices are local to each Settlement)\n    /// &lt;/summary&gt;\n    public class SettlementMarket\n    {\n        public string SettlementID { get; private set; }\n        private Dictionary&lt;string, MarketRecord&gt; _marketRecords = new Dictionary&lt;string, MarketRecord&gt;();\n\n        // Modifiers for this specific market (e.g., \"war_modifier\", \"famine_modifier\")\n        private Dictionary&lt;string, float&gt; _localModifiers = new Dictionary&lt;string, float&gt;();\n\n        public SettlementMarket(string settlementID)\n        {\n            SettlementID = settlementID;\n            GD.Print($\"SettlementMarket: Initialized for '{settlementID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Adds or updates an item's record in this market.\n        /// &lt;/summary&gt;\n        public void AddOrUpdateItem(MarketRecord record)\n        {\n            _marketRecords[record.ItemID] = record;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a market record for a given item.\n        /// &lt;/summary&gt;\n        public MarketRecord GetMarketRecord(string itemID)\n        {\n            if (_marketRecords.TryGetValue(itemID, out MarketRecord record))\n            {\n                return record;\n            }\n            return new MarketRecord(itemID, 0f, 0, 0); // Return empty record\n        }\n\n        /// &lt;summary&gt;\n        /// Applies a local modifier to this market.\n        /// &lt;/summary&gt;\n        public void AddLocalModifier(string modifierID, float value)\n        {\n            _localModifiers[modifierID] = value;\n        }\n\n        /// &lt;summary&gt;\n        /// Removes a local modifier from this market.\n        /// &lt;/summary&gt;\n        public void RemoveLocalModifier(string modifierID)\n        {\n            _localModifiers.Remove(modifierID);\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all local modifiers.\n        /// &lt;/summary&gt;\n        public IReadOnlyDictionary&lt;string, float&gt; GetLocalModifiers()\n        {\n            return _localModifiers.AsReadOnly();\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves all market records for this settlement.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;MarketRecord&gt; GetAllMarketRecords()\n        {\n            return _marketRecords.Values.ToList().AsReadOnly();\n        }\n    }\n}\n</code></pre>"},{"location":"52-chapter-52/#3-implementing-economymanagercs","title":"3. Implementing <code>EconomyManager.cs</code>","text":"<p>This system will: *   Manage all <code>SettlementMarket</code> instances. *   Register <code>ItemDefinition</code>s (using <code>EquipmentSystem</code>'s definitions). *   Implement the <code>Market Simulation</code> algorithm for price calculation. *   Apply global modifiers to markets.</p> <ol> <li>Create <code>res://_Brain/Systems/Economy/EconomyManager.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Economy/EconomyManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Inventory; // For ItemDefinition\nusing Sigilborne.Systems.Factions; // For FactionType (to influence demand)\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Economy\n{\n    /// &lt;summary&gt;\n    /// Manages the economic simulation: local markets, supply &amp; demand, and price fluctuations.\n    /// (TDD 06.3.1)\n    /// &lt;/summary&gt;\n    public class EconomyManager\n    {\n        private EventBus _eventBus;\n        private EquipmentSystem _equipmentSystem; // To access ItemDefinitions\n        private FactionSystem _factionSystem;     // To get faction types for demand modifiers\n\n        // All active markets, mapped by SettlementID (string for now)\n        private Dictionary&lt;string, SettlementMarket&gt; _activeMarkets = new Dictionary&lt;string, SettlementMarket&gt;();\n\n        // Global economic modifiers (e.g., \"war_active\", \"famine_event\")\n        private Dictionary&lt;string, float&gt; _globalModifiers = new Dictionary&lt;string, float&gt;();\n\n        private const float MARKET_UPDATE_INTERVAL = 60.0f; // Update markets every 60 game minutes (1 real minute)\n        private float _marketUpdateTimer;\n\n        public EconomyManager(EventBus eventBus, EquipmentSystem equipmentSystem, FactionSystem factionSystem)\n        {\n            _eventBus = eventBus;\n            _equipmentSystem = equipmentSystem;\n            _factionSystem = factionSystem;\n\n            // Subscribe to hourly updates for market simulation\n            _eventBus.OnNewHour += OnNewHour;\n\n            GD.Print(\"EconomyManager: Initialized.\");\n        }\n\n        private void OnNewHour(int hour)\n        {\n            _marketUpdateTimer += (float)GameManager.Instance.Time.REAL_SECONDS_PER_GAME_MINUTE * 60; // Add 60 seconds (1 game hour)\n            if (_marketUpdateTimer &gt;= MARKET_UPDATE_INTERVAL)\n            {\n                UpdateAllMarkets();\n                _marketUpdateTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Adds a new settlement market to the economy.\n        /// &lt;/summary&gt;\n        public void AddSettlementMarket(string settlementID, string controllingFactionID)\n        {\n            if (_activeMarkets.ContainsKey(settlementID)) return;\n\n            SettlementMarket newMarket = new SettlementMarket(settlementID);\n            _activeMarkets.Add(settlementID, newMarket);\n\n            // Initialize market with all known items (from EquipmentSystem's definitions)\n            foreach (var itemDef in _equipmentSystem.GetAllItemDefinitions())\n            {\n                // Initial supply and demand based on item type and controlling faction\n                int initialSupply = 10;\n                int initialDemand = 10;\n\n                // Example: Warrior factions demand weapons, Temple factions demand healing items\n                Faction controllingFaction = _factionSystem.GetFaction(controllingFactionID);\n                if (controllingFaction != null)\n                {\n                    if (itemDef.Type == ItemType.Weapon &amp;&amp; controllingFaction.Type == FactionType.WarriorDominion) initialDemand += 20;\n                    if (itemDef.Type == ItemType.Consumable &amp;&amp; itemDef.Name.Contains(\"healing\") &amp;&amp; controllingFaction.Type == FactionType.TempleAlliance) initialDemand += 15;\n                    // Add more complex logic here\n                }\n\n                newMarket.AddOrUpdateItem(new MarketRecord(itemDef.ID, itemDef.BasePrice, initialSupply, initialDemand));\n            }\n\n            GD.Print($\"EconomyManager: Added market for settlement '{settlementID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Updates prices, supply, and demand for all active markets.\n        /// (TDD 06.3.1: Market Simulation - Algorithm)\n        /// &lt;/summary&gt;\n        private void UpdateAllMarkets()\n        {\n            GD.Print($\"EconomyManager: Updating all markets. (Game Time: {GameManager.Instance.Time.CurrentGameTime:F1})\");\n\n            foreach (var market in _activeMarkets.Values)\n            {\n                // Apply global modifiers (e.g., famine, war)\n                float globalFamineMultiplier = _globalModifiers.TryGetValue(\"famine_active\", out float famineVal) ? famineVal : 1.0f;\n                float globalWarMultiplier = _globalModifiers.TryGetValue(\"war_active\", out float warVal) ? warVal : 1.0f;\n\n                List&lt;MarketRecord&gt; updatedRecords = new List&lt;MarketRecord&gt;();\n                foreach (var record in market.GetAllMarketRecords())\n                {\n                    MarketRecord newRecord = record;\n\n                    // --- Adjust Supply &amp; Demand ---\n                    // Simulate natural replenishment/consumption\n                    newRecord.CurrentSupply += 1; // Basic replenishment\n                    newRecord.CurrentDemand += 1; // Basic consumption\n\n                    // Apply global modifiers to supply/demand\n                    if (newRecord.ItemID.Contains(\"food\")) newRecord.CurrentSupply = (int)(newRecord.CurrentSupply / globalFamineMultiplier);\n                    if (newRecord.ItemID.Contains(\"weapon\")) newRecord.CurrentDemand = (int)(newRecord.CurrentDemand * globalWarMultiplier);\n\n                    // Apply local modifiers (e.g., a siege might increase demand for weapons in one market)\n                    // if (market.GetLocalModifiers().TryGetValue(\"siege_active\", out float siegeVal) &amp;&amp; newRecord.ItemID.Contains(\"weapon\")) { newRecord.CurrentDemand += (int)(newRecord.CurrentDemand * siegeVal); }\n\n\n                    // --- Calculate Price (TDD 06.3.1: Price = BasePrice * (Demand / Supply)) ---\n                    // Ensure supply is never zero to avoid division by zero\n                    float effectiveSupply = Mathf.Max(1, newRecord.CurrentSupply);\n                    newRecord.CurrentPrice = newRecord.BasePrice * (newRecord.CurrentDemand / effectiveSupply);\n\n                    // Clamp prices to prevent extreme fluctuations\n                    newRecord.CurrentPrice = Mathf.Clamp(newRecord.CurrentPrice, newRecord.BasePrice * 0.2f, newRecord.BasePrice * 5.0f);\n\n                    updatedRecords.Add(newRecord);\n                }\n                // Update market records\n                foreach (var record in updatedRecords)\n                {\n                    market.AddOrUpdateItem(record);\n                }\n                // GD.Print($\"EconomyManager: Market '{market.SettlementID}' updated. Example price: {market.GetMarketRecord(\"iron_sword_t1\").CurrentPrice:F1}\");\n            }\n            _eventBus.Publish(new MarketsUpdatedEvent { Markets = _activeMarkets.Values.ToList() });\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves a specific settlement market.\n        /// &lt;/summary&gt;\n        public SettlementMarket GetMarket(string settlementID)\n        {\n            _activeMarkets.TryGetValue(settlementID, out SettlementMarket market);\n            return market;\n        }\n\n        /// &lt;summary&gt;\n        /// Applies a global economic modifier.\n        /// &lt;/summary&gt;\n        public void AddGlobalModifier(string modifierID, float value)\n        {\n            _globalModifiers[modifierID] = value;\n            GD.Print($\"EconomyManager: Added global modifier '{modifierID}' with value {value}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Removes a global economic modifier.\n        /// &lt;/summary&gt;\n        public void RemoveGlobalModifier(string modifierID)\n        {\n            _globalModifiers.Remove(modifierID);\n            GD.Print($\"EconomyManager: Removed global modifier '{modifierID}'.\");\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct MarketsUpdatedEvent { public List&lt;SettlementMarket&gt; Markets; }\n    }\n}\n</code></pre>"},{"location":"52-chapter-52/#4-integrating-economymanager-into-gamemanager","title":"4. Integrating <code>EconomyManager</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Economy;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add an <code>EconomyManager</code> property.</li> <li>Initialize <code>EconomyManager</code> in <code>InitializeSystems()</code> after <code>EquipmentSystem</code> and <code>FactionSystem</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public FactionSystem Factions { get; private set; }\n    public EconomyManager Economy { get; private set; } // Add EconomyManager property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n\n        // --- Test Economy System ---\n        GD.Print(\"\\n--- Testing Economy System ---\");\n        // Add a test settlement market\n        Economy.AddSettlementMarket(\"village_north\", \"crimson_blades\"); // Controlled by Crimson Blades\n        Economy.AddSettlementMarket(\"town_south\", \"sunken_temple\"); // Controlled by Sunken Temple\n\n        // Initial check\n        GD.Print($\"Initial iron_sword_t1 price in village_north: {Economy.GetMarket(\"village_north\").GetMarketRecord(\"iron_sword_t1\").CurrentPrice:F1}\");\n        GD.Print($\"Initial healing_potion_t1 price in town_south: {Economy.GetMarket(\"town_south\").GetMarketRecord(\"healing_potion_t1\").CurrentPrice:F1}\");\n\n        // Add a global modifier (e.g., \"war_active\")\n        Economy.AddGlobalModifier(\"war_active\", 2.0f); // Weapons demand x2\n        Economy.AddGlobalModifier(\"famine_active\", 3.0f); // Food supply /3\n\n        GD.Print(\"--- End Testing Economy System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta); // Call EconomyManager's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to FactionSystem) ...\n\n        FactionAI = new FactionAISystem(Events, Factions, Jobs, WorldSeed);\n        GD.Print(\"  - FactionAISystem initialized.\");\n\n        // Initialize EconomyManager AFTER EquipmentSystem and FactionSystem\n        Economy = new EconomyManager(Events, Equipment, Factions); // Pass dependencies\n        GD.Print(\"  - EconomyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"52-chapter-52/#41-update-equipmentsystemcs-to-expose-getallitemdefinitions","title":"4.1. Update <code>EquipmentSystem.cs</code> to expose <code>GetAllItemDefinitions</code>","text":"<p>The <code>EconomyManager</code> needs to get all item definitions.</p> <p>Open <code>res://_Brain/Systems/Inventory/EquipmentSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Inventory/EquipmentSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing System.Linq;\nusing System.Reflection;\n\nnamespace Sigilborne.Systems.Inventory\n{\n    // ... (EquipmentSlotType, EquippedItemsComponent, ItemDefinition, ItemType structs/classes) ...\n\n    public class EquipmentSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        /// &lt;summary&gt;\n        /// Retrieves all registered item definitions.\n        /// &lt;/summary&gt;\n        public IReadOnlyList&lt;ItemDefinition&gt; GetAllItemDefinitions()\n        {\n            return _itemDefinitions.Values.ToList().AsReadOnly();\n        }\n\n        // ... (other methods) ...\n    }\n}\n</code></pre>"},{"location":"52-chapter-52/#42-update-eventbuscs-for-marketsupdatedevent","title":"4.2. Update <code>EventBus.cs</code> for <code>MarketsUpdatedEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnMarketsUpdated</code> delegate.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Economy System Events (TDD 06.3.1)\n        public event Action&lt;List&lt;SettlementMarket&gt;&gt; OnMarketsUpdated; // List of all markets\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is EconomyManager.MarketsUpdatedEvent marketsUpdatedEvent) // New condition\n            {\n                OnMarketsUpdated?.Invoke(marketsUpdatedEvent.Markets);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"52-chapter-52/#5-testing-the-market-simulation","title":"5. Testing the Market Simulation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Economy System\" section and subsequent <code>EconomyManager: Updating all markets.</code> messages.</li> </ol> <pre><code>...\nEconomyManager: Initialized.\n  - EconomyManager initialized.\nPlayerStatSystem: Initialized.\n...\n--- Testing Economy System ---\nEconomyManager: Added market for settlement 'village_north'.\nEconomyManager: Added market for settlement 'town_south'.\nInitial iron_sword_t1 price in village_north: 10.0\nInitial healing_potion_t1 price in town_south: 10.0\nEconomyManager: Added global modifier 'war_active' with value 2.\nEconomyManager: Added global modifier 'famine_active' with value 3.\n--- End Testing Economy System ---\n...\nEconomyManager: Updating all markets. (Game Time: 0.0)\nEconomyManager: Updating all markets. (Game Time: 60.0)\nEconomyManager: Updating all markets. (Game Time: 120.0)\n...\n</code></pre> <p>After a few <code>EconomyManager: Updating all markets.</code> ticks (which happen every 1 real minute):</p> <ul> <li><code>village_north</code> (WarriorDominion): Prices for <code>iron_sword_t1</code> should increase (due to <code>war_active</code> increasing demand, and <code>WarriorDominion</code> having high base demand for weapons). Food prices will also increase due to <code>famine_active</code> reducing supply.</li> <li><code>town_south</code> (TempleAlliance): Prices for <code>healing_potion_t1</code> should increase (due to <code>TempleAlliance</code> having high base demand). Food prices will also increase.</li> </ul> <p>This demonstrates that: *   <code>EconomyManager</code> correctly initializes markets for settlements. *   Initial supply/demand is influenced by <code>FactionType</code>. *   Global modifiers (<code>war_active</code>, <code>famine_active</code>) are applied. *   Market prices dynamically fluctuate based on supply/demand and modifiers, updating on a regular interval.</p>"},{"location":"52-chapter-52/#summary","title":"Summary","text":"<p>You have successfully implemented Market Simulation in the C# Brain, defining <code>MarketRecord</code> and <code>SettlementMarket</code> to track local market conditions. By designing <code>EconomyManager</code> to manage active markets, register item definitions, and dynamically calculate prices based on supply, demand, and global modifiers (like war or famine), you've established a robust mechanism for a fluctuating economy. This crucial system strictly adheres to TDD 06.3.1's specifications, providing a dynamic and localized economic backbone for Sigilborne.</p>"},{"location":"52-chapter-52/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Trade Routes, detailing how NPC caravans physically move between settlements, carrying goods, and how their journeys can be interrupted by player actions or world events, influencing supply chains and local market prices.</p>"},{"location":"53-chapter-53/","title":"Chapter 8.4: Trade Routes - Caravans as Arteries (C#)","text":""},{"location":"53-chapter-53/#chapter-84-trade-routes-caravans-as-arteries-c","title":"Chapter 8.4: Trade Routes - Caravans as Arteries (C#)","text":"<p>Our <code>EconomyManager</code> now simulates local markets and dynamic prices. The next crucial component of the economic system is Trade Routes, represented by NPC caravans physically moving between settlements. This chapter designs how these caravans operate, carry goods, and how their journeys can be interrupted by player actions or world events, directly influencing supply chains and local market prices, as specified in TDD 06.3.2.</p>"},{"location":"53-chapter-53/#1-the-dynamic-nature-of-trade","title":"1. The Dynamic Nature of Trade","text":"<p>The GDD (B23.4) states: \"Caravans travel between settlements carrying... goods... Each caravan has a faction identity, a risk rating, preferred routes, defenses, negotiable prices, vulnerabilities.\" This implies:</p> <ul> <li>Physical Movement: Caravans are entities that move in the world.</li> <li>Goods Flow: They transport items, affecting supply/demand in origin/destination markets.</li> <li>Vulnerability: They can be attacked, robbed, or destroyed.</li> <li>Dynamic Routes: Routes can change due to world instability.</li> <li>Player Interaction: Players can escort, attack, or trade with caravans.</li> </ul>"},{"location":"53-chapter-53/#2-defining-caravan-and-caravanroute","title":"2. Defining <code>Caravan</code> and <code>CaravanRoute</code>","text":"<p>We need a class to represent a single caravan entity and a class to define its route.</p> <ol> <li>Create <code>res://_Brain/Systems/Economy/CaravanData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Economy/CaravanData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Factions; // For Faction\nusing Sigilborne.Systems.Inventory; // For InventoryItem\n\nnamespace Sigilborne.Systems.Economy\n{\n    /// &lt;summary&gt;\n    /// Represents a single trade caravan moving between settlements.\n    /// (TDD 06.3.2)\n    /// &lt;/summary&gt;\n    public class Caravan\n    {\n        public EntityID ID { get; private set; } // The entity ID of this caravan\n        public string Name { get; private set; }\n        public string OriginSettlementID { get; private set; }\n        public string DestinationSettlementID { get; private set; }\n        public string FactionID { get; private set; } // The faction this caravan belongs to\n        public List&lt;InventoryItem&gt; Cargo { get; private set; } // The goods being transported\n        public CaravanRoute CurrentRoute { get; private set; }\n        public float Speed { get; private set; }\n        public float CurrentProgress { get; private set; } // 0.0 to 1.0 along the route\n        public bool IsDestroyed { get; private set; }\n        public bool IsActive { get; private set; } // True if currently moving in the world\n\n        public Caravan(EntityID id, string name, string originID, string destinationID, string factionID, CaravanRoute route, float speed, List&lt;InventoryItem&gt; cargo = null)\n        {\n            ID = id;\n            Name = name;\n            OriginSettlementID = originID;\n            DestinationSettlementID = destinationID;\n            FactionID = factionID;\n            CurrentRoute = route;\n            Speed = speed;\n            Cargo = cargo ?? new List&lt;InventoryItem&gt;();\n            CurrentProgress = 0f;\n            IsDestroyed = false;\n            IsActive = true;\n        }\n\n        public override string ToString()\n        {\n            return $\"Caravan: '{Name}' ({ID}) | {OriginSettlementID} -&gt; {DestinationSettlementID} | Progress: {CurrentProgress:P0}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Defines a geographical path between two settlements for a caravan.\n    /// &lt;/summary&gt;\n    public class CaravanRoute\n    {\n        public string ID { get; private set; } // Unique route ID\n        public string OriginSettlementID { get; private set; }\n        public string DestinationSettlementID { get; private set; }\n        public float Length { get; private set; } // Total length of the route\n        public List&lt;Vector2&gt; Waypoints { get; private set; } // The path the caravan follows\n\n        public CaravanRoute(string id, string originID, string destinationID, List&lt;Vector2&gt; waypoints)\n        {\n            ID = id;\n            OriginSettlementID = originID;\n            DestinationSettlementID = destinationID;\n            Waypoints = waypoints ?? new List&lt;Vector2&gt;();\n            Length = CalculateLength(waypoints); // Calculate total length\n        }\n\n        private float CalculateLength(List&lt;Vector2&gt; waypoints)\n        {\n            float totalLength = 0f;\n            for (int i = 0; i &lt; waypoints.Count - 1; i++)\n            {\n                totalLength += waypoints[i].DistanceTo(waypoints[i+1]);\n            }\n            return totalLength;\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the world position along the route at a given progress (0.0 to 1.0).\n        /// &lt;/summary&gt;\n        public Vector2 GetPositionAtProgress(float progress)\n        {\n            if (Waypoints.Count &lt; 2 || progress &lt; 0 || progress &gt; 1) return Waypoints.FirstOrDefault();\n\n            float targetDistance = Length * progress;\n            float currentDistance = 0f;\n\n            for (int i = 0; i &lt; Waypoints.Count - 1; i++)\n            {\n                float segmentLength = Waypoints[i].DistanceTo(Waypoints[i+1]);\n                if (currentDistance + segmentLength &gt;= targetDistance)\n                {\n                    // The target position is within this segment\n                    float segmentProgress = (targetDistance - currentDistance) / segmentLength;\n                    return Waypoints[i].Lerp(Waypoints[i+1], segmentProgress);\n                }\n                currentDistance += segmentLength;\n            }\n            return Waypoints.LastOrDefault(); // Should be reached at progress 1.0\n        }\n\n        public override string ToString()\n        {\n            return $\"Route: '{ID}' | {OriginSettlementID} -&gt; {DestinationSettlementID} | Length: {Length:F0}\";\n        }\n    }\n}\n</code></pre>"},{"location":"53-chapter-53/#3-enhancing-economymanagercs-for-trade-routes","title":"3. Enhancing <code>EconomyManager.cs</code> for Trade Routes","text":"<p><code>EconomyManager</code> will now: *   Manage a collection of <code>CaravanRoute</code>s and <code>Caravan</code> entities. *   Implement <code>CaravanSystem.Depart()</code> (TDD 06.2.3) logic to spawn caravans. *   Update <code>Caravan</code> progress and position. *   Handle <code>Caravan</code> destruction and its economic impact.</p> <ol> <li>Open <code>res://_Brain/Systems/Economy/EconomyManager.cs</code>.</li> <li>Add dictionaries for <code>CaravanRoute</code>s and <code>Caravan</code> entities.</li> <li>Implement <code>AddCaravanRoute</code>, <code>SpawnCaravan</code>, and a <code>Tick</code> method for caravans.</li> <li>Modify <code>UpdateAllMarkets</code> to factor in caravan status.</li> </ol> <pre><code>// _Brain/Systems/Economy/EconomyManager.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Movement; // For caravan movement via TransformSystem\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Economy\n{\n    // ... (MarketRecord, SettlementMarket structs/classes) ...\n\n    /// &lt;summary&gt;\n    /// Manages the economic simulation: local markets, supply &amp; demand, and price fluctuations.\n    /// Now also manages trade routes and caravans.\n    /// (TDD 06.3)\n    /// &lt;/summary&gt;\n    public class EconomyManager\n    {\n        private EventBus _eventBus;\n        private EquipmentSystem _equipmentSystem;\n        private FactionSystem _factionSystem;\n        private EntityManager _entityManager; // New: For spawning caravan entities\n        private TransformSystem _transformSystem; // New: For updating caravan positions\n\n        private Dictionary&lt;string, SettlementMarket&gt; _activeMarkets = new Dictionary&lt;string, SettlementMarket&gt;();\n        private Dictionary&lt;string, float&gt; _globalModifiers = new Dictionary&lt;string, float&gt;();\n\n        // New: Trade route and caravan management\n        private Dictionary&lt;string, CaravanRoute&gt; _caravanRoutes = new Dictionary&lt;string, CaravanRoute&gt;();\n        private Dictionary&lt;EntityID, Caravan&gt; _activeCaravans = new Dictionary&lt;EntityID, Caravan&gt;(); // Active caravan entities\n\n        private const float MARKET_UPDATE_INTERVAL = 60.0f; // Update markets every 60 game minutes (1 real minute)\n        private float _marketUpdateTimer;\n\n        private const float CARAVAN_SPAWN_INTERVAL = 120.0f; // Try to spawn a caravan every 120 game minutes (2 real minutes)\n        private float _caravanSpawnTimer;\n\n        public EconomyManager(EventBus eventBus, EquipmentSystem equipmentSystem, FactionSystem factionSystem, EntityManager entityManager, TransformSystem transformSystem) // Add EntityManager, TransformSystem\n        {\n            _eventBus = eventBus;\n            _equipmentSystem = equipmentSystem;\n            _factionSystem = factionSystem;\n            _entityManager = entityManager;\n            _transformSystem = transformSystem;\n\n            _eventBus.OnNewHour += OnNewHour;\n            _eventBus.OnEntityDefeated += OnEntityDefeated; // To detect caravan destruction\n\n            GD.Print(\"EconomyManager: Initialized.\");\n        }\n\n        private void OnNewHour(int hour)\n        {\n            _marketUpdateTimer += (float)GameManager.Instance.Time.REAL_SECONDS_PER_GAME_MINUTE * 60; // Add 60 seconds (1 game hour)\n            if (_marketUpdateTimer &gt;= MARKET_UPDATE_INTERVAL)\n            {\n                UpdateAllMarkets();\n                _marketUpdateTimer = 0;\n            }\n        }\n\n        private void OnEntityDefeated(EntityID entityID, EntityID killerID)\n        {\n            if (_activeCaravans.ContainsKey(entityID))\n            {\n                Caravan destroyedCaravan = _activeCaravans[entityID];\n                destroyedCaravan.IsDestroyed = true; // Mark as destroyed\n                destroyedCaravan.IsActive = false;\n                GD.Print($\"EconomyManager: Caravan '{destroyedCaravan.Name}' ({entityID}) was destroyed by {killerID}!\");\n\n                // --- Economic Impact of Caravan Destruction --- (TDD 06.3.2)\n                // Reduce supply in destination market\n                SettlementMarket destinationMarket = GetMarket(destroyedCaravan.DestinationSettlementID);\n                if (destinationMarket != null)\n                {\n                    foreach (var item in destroyedCaravan.Cargo)\n                    {\n                        MarketRecord record = destinationMarket.GetMarketRecord(item.ItemID);\n                        record.CurrentSupply -= item.Quantity; // Reduce supply for lost cargo\n                        destinationMarket.AddOrUpdateItem(record);\n                    }\n                }\n                // Increase demand for missing items\n                // Increase prices in destination market\n                // Reduce reputation with faction\n\n                _activeCaravans.Remove(entityID); // Remove from active list\n                _eventBus.Publish(new CaravanDestroyedEvent { CaravanID = entityID, KillerID = killerID, CaravanName = destroyedCaravan.Name });\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the EconomyManager.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            _caravanSpawnTimer += (float)delta;\n            if (_caravanSpawnTimer &gt;= CARAVAN_SPAWN_INTERVAL)\n            {\n                TrySpawnCaravan();\n                _caravanSpawnTimer = 0;\n            }\n\n            UpdateActiveCaravans(delta); // Update position of active caravans\n        }\n\n        /// &lt;summary&gt;\n        /// Adds a new settlement market to the economy.\n        /// &lt;/summary&gt;\n        public void AddSettlementMarket(string settlementID, string controllingFactionID)\n        {\n            // ... (existing logic) ...\n        }\n\n        /// &lt;summary&gt;\n        /// Adds a new trade route to the economy.\n        /// &lt;/summary&gt;\n        public void AddCaravanRoute(CaravanRoute route)\n        {\n            if (_caravanRoutes.ContainsKey(route.ID)) return;\n            _caravanRoutes.Add(route.ID, route);\n            GD.Print($\"EconomyManager: Added trade route '{route.ID}': {route.OriginSettlementID} to {route.DestinationSettlementID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Tries to spawn a new caravan on an available route.\n        /// (TDD 06.2.3: CaravanSystem.Depart())\n        /// &lt;/summary&gt;\n        private void TrySpawnCaravan()\n        {\n            if (_caravanRoutes.Count == 0 || _activeMarkets.Count &lt; 2) return;\n\n            // Simple logic: pick a random route\n            Random rand = new Random(GameManager.Instance.WorldSeed + (int)GameManager.Instance.Time.CurrentGameTime);\n            CaravanRoute route = _caravanRoutes.Values.ElementAt(rand.Next(_caravanRoutes.Count));\n\n            // Check if origin/destination markets exist\n            if (!_activeMarkets.ContainsKey(route.OriginSettlementID) || !_activeMarkets.ContainsKey(route.DestinationSettlementID))\n            {\n                GD.PrintErr($\"EconomyManager: Cannot spawn caravan for route '{route.ID}'. Markets not found.\");\n                return;\n            }\n\n            // Create a dummy caravan entity\n            EntityID caravanEntityID = _entityManager.CreateEntity(EntityType.WorldObject, \"caravan_wagon_01\", route.Waypoints.First(), 0f);\n            if (!caravanEntityID.IsValid())\n            {\n                GD.PrintErr(\"EconomyManager: Failed to create entity for new caravan.\");\n                return;\n            }\n\n            // Populate cargo (simple for now)\n            List&lt;InventoryItem&gt; cargo = new List&lt;InventoryItem&gt;();\n            cargo.Add(new InventoryItem(\"iron_sword_t1\", 5));\n            cargo.Add(new InventoryItem(\"healing_potion_t1\", 10));\n\n            string factionID = _factionSystem.GetAllFactions().ElementAt(rand.Next(_factionSystem.GetAllFactions().Count)).ID; // Random faction\n            Caravan newCaravan = new Caravan(caravanEntityID, $\"Caravan {GameManager.Instance.Time.CurrentDay}-{_activeCaravans.Count}\", route.OriginSettlementID, route.DestinationSettlementID, factionID, route, 50f, cargo);\n            _activeCaravans.Add(caravanEntityID, newCaravan);\n\n            GD.Print($\"EconomyManager: Spawned new caravan '{newCaravan.Name}' ({caravanEntityID}) from {route.OriginSettlementID} to {route.DestinationSettlementID}.\");\n            _eventBus.Publish(new CaravanSpawnedEvent { CaravanID = caravanEntityID, Caravan = newCaravan });\n        }\n\n        /// &lt;summary&gt;\n        /// Updates the position and progress of all active caravans.\n        /// &lt;/summary&gt;\n        private void UpdateActiveCaravans(double delta)\n        {\n            List&lt;EntityID&gt; completedCaravans = new List&lt;EntityID&gt;();\n            foreach (var kvp in _activeCaravans)\n            {\n                EntityID caravanID = kvp.Key;\n                Caravan caravan = kvp.Value;\n\n                if (caravan.IsDestroyed || !caravan.IsActive) continue;\n\n                // Calculate movement\n                float distanceToTravel = caravan.Speed * (float)delta;\n                caravan.CurrentProgress += distanceToTravel / caravan.CurrentRoute.Length;\n                caravan.CurrentProgress = Mathf.Min(1.0f, caravan.CurrentProgress); // Clamp at 1.0\n\n                // Update position in TransformSystem\n                Vector2 newPosition = caravan.CurrentRoute.GetPositionAtProgress(caravan.CurrentProgress);\n                _transformSystem.TrySetTransform(caravanID, new TransformComponent(newPosition));\n\n                if (caravan.CurrentProgress &gt;= 1.0f)\n                {\n                    completedCaravans.Add(caravanID);\n                }\n            }\n\n            // Process completed caravans\n            foreach (EntityID id in completedCaravans)\n            {\n                Caravan completedCaravan = _activeCaravans[id];\n                GD.Print($\"EconomyManager: Caravan '{completedCaravan.Name}' ({id}) reached destination {completedCaravan.DestinationSettlementID}.\");\n\n                // --- Economic Impact of Caravan Arrival --- (TDD 06.3.2)\n                // Add cargo to destination market's supply\n                SettlementMarket destinationMarket = GetMarket(completedCaravan.DestinationSettlementID);\n                if (destinationMarket != null)\n                {\n                    foreach (var item in completedCaravan.Cargo)\n                    {\n                        MarketRecord record = destinationMarket.GetMarketRecord(item.ItemID);\n                        record.CurrentSupply += item.Quantity; // Increase supply for arrived cargo\n                        destinationMarket.AddOrUpdateItem(record);\n                    }\n                }\n                // Reduce demand in destination market\n                // Reduce prices in destination market\n                // Improve reputation with faction\n\n                _entityManager.DestroyEntity(id); // Despawn caravan entity\n                _activeCaravans.Remove(id);\n                _eventBus.Publish(new CaravanArrivedEvent { CaravanID = id, Caravan = completedCaravan });\n            }\n        }\n\n        // ... (GetMarket, AddGlobalModifier, RemoveGlobalModifier methods) ...\n\n        // --- Helper Events for Body Sync ---\n        public struct MarketsUpdatedEvent { public List&lt;SettlementMarket&gt; Markets; }\n        public struct CaravanSpawnedEvent { public EntityID CaravanID; public Caravan Caravan; }\n        public struct CaravanArrivedEvent { public EntityID CaravanID; public Caravan Caravan; }\n        public struct CaravanDestroyedEvent { public EntityID CaravanID; public EntityID KillerID; public string CaravanName; }\n    }\n}\n</code></pre>"},{"location":"53-chapter-53/#4-integrating-economymanager-into-gamemanager","title":"4. Integrating <code>EconomyManager</code> into <code>GameManager</code>","text":"<ol> <li>Open <code>res://_Brain/Core/GameManager.cs</code>.</li> <li>Add <code>using Sigilborne.Systems.Economy;</code> at the top.</li> <li>Modify <code>EconomyManager</code> initialization in <code>InitializeSystems()</code> to pass <code>EntityManager</code> and <code>TransformSystem</code>.</li> <li>Call <code>EconomyManager.Tick(delta)</code> in <code>_PhysicsProcess</code>.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    // ... (existing system properties) ...\n    public EconomyManager Economy { get; private set; }\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n\n        // --- Test Economy System ---\n        GD.Print(\"\\n--- Testing Economy System ---\");\n        // Add a test settlement market\n        Economy.AddSettlementMarket(\"village_north\", \"crimson_blades\");\n        Economy.AddSettlementMarket(\"town_south\", \"sunken_temple\");\n\n        // Add a test caravan route\n        CaravanRoute route1 = new CaravanRoute(\"route_north_south\", \"village_north\", \"town_south\", new List&lt;Vector2&gt; { new Vector2(100, 100), new Vector2(500, 100), new Vector2(500, 500) });\n        Economy.AddCaravanRoute(route1);\n\n        // Initial check\n        GD.Print($\"Initial iron_sword_t1 price in village_north: {Economy.GetMarket(\"village_north\").GetMarketRecord(\"iron_sword_t1\").CurrentPrice:F1}\");\n        GD.Print($\"Initial healing_potion_t1 price in town_south: {Economy.GetMarket(\"town_south\").GetMarketRecord(\"healing_potion_t1\").CurrentPrice:F1}\");\n\n        // Add a global modifier (e.g., \"war_active\")\n        Economy.AddGlobalModifier(\"war_active\", 2.0f);\n        Economy.AddGlobalModifier(\"famine_active\", 3.0f);\n\n        GD.Print(\"--- End Testing Economy System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta);\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to FactionSystem) ...\n\n        FactionAI = new FactionAISystem(Events, Factions, Jobs, WorldSeed);\n        GD.Print(\"  - FactionAISystem initialized.\");\n\n        // Initialize EconomyManager AFTER EquipmentSystem, FactionSystem, EntityManager, TransformSystem\n        Economy = new EconomyManager(Events, Equipment, Factions, Entities, Transforms); // Pass dependencies\n        GD.Print(\"  - EconomyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"53-chapter-53/#41-update-eventbuscs-for-caravan-events","title":"4.1. Update <code>EventBus.cs</code> for Caravan Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnCaravanSpawned</code>, <code>OnCaravanArrived</code>, <code>OnCaravanDestroyed</code> delegates.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Economy System Events (TDD 06.3.1)\n        public event Action&lt;List&lt;SettlementMarket&gt;&gt; OnMarketsUpdated;\n\n        // Caravan Events (TDD 06.3.2)\n        public event Action&lt;EntityID, Caravan&gt; OnCaravanSpawned;\n        public event Action&lt;EntityID, Caravan&gt; OnCaravanArrived;\n        public event Action&lt;EntityID, EntityID, string&gt; OnCaravanDestroyed; // CaravanID, KillerID, CaravanName\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is EconomyManager.MarketsUpdatedEvent marketsUpdatedEvent)\n            {\n                OnMarketsUpdated?.Invoke(marketsUpdatedEvent.Markets);\n            }\n            else if (eventData is EconomyManager.CaravanSpawnedEvent caravanSpawnedEvent) // New condition\n            {\n                OnCaravanSpawned?.Invoke(caravanSpawnedEvent.CaravanID, caravanSpawnedEvent.Caravan);\n            }\n            else if (eventData is EconomyManager.CaravanArrivedEvent caravanArrivedEvent) // New condition\n            {\n                OnCaravanArrived?.Invoke(caravanArrivedEvent.CaravanID, caravanArrivedEvent.Caravan);\n            }\n            else if (eventData is EconomyManager.CaravanDestroyedEvent caravanDestroyedEvent) // New condition\n            {\n                OnCaravanDestroyed?.Invoke(caravanDestroyedEvent.CaravanID, caravanDestroyedEvent.KillerID, caravanDestroyedEvent.CaravanName);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"53-chapter-53/#5-testing-trade-routes-and-caravans","title":"5. Testing Trade Routes and Caravans","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output.<ul> <li><code>EconomyManager: Added market for settlement 'village_north'.</code></li> <li><code>EconomyManager: Added market for settlement 'town_south'.</code></li> <li><code>EconomyManager: Added trade route 'route_north_south': village_north to town_south.</code></li> <li>Every 2 real minutes (120 game minutes), <code>EconomyManager: Spawned new caravan 'Caravan X-Y' ...</code> messages will appear.</li> <li>You should see these caravan entities moving on screen (they are <code>EntityType.WorldObject</code> and get <code>TransformComponent</code>s).</li> <li>After a caravan reaches its destination (progress 1.0), you'll see <code>EconomyManager: Caravan 'X' reached destination...</code> and <code>EntityManager: Destroyed entity...</code> messages.</li> <li>If you continuously spawn and destroy caravans (e.g. by using the debug console to speed up time, or by running the game for a while), you'll also see their economic impact on market prices in the <code>UpdateAllMarkets</code> calls.</li> </ul> </li> </ol> <p>This demonstrates that: *   <code>CaravanRoute</code>s and <code>Caravan</code> entities are correctly defined. *   <code>EconomyManager</code> spawns caravans, updates their positions, and destroys them upon arrival. *   Caravan destruction (simulated by <code>OnEntityDefeated</code> if you kill a caravan entity) correctly impacts the destination market's supply.</p>"},{"location":"53-chapter-53/#summary","title":"Summary","text":"<p>You have successfully implemented Trade Routes and Caravans in the C# Brain, designing <code>Caravan</code> and <code>CaravanRoute</code> classes to represent physical trade entities and their paths. By enhancing <code>EconomyManager</code> to manage route definitions, spawn caravans, update their progress, and simulate their economic impact upon arrival or destruction, you've established a robust mechanism for dynamic goods flow. This crucial system strictly adheres to TDD 06.3.2's specifications, allowing trade to visibly influence supply chains and local market prices in Sigilborne.</p>"},{"location":"53-chapter-53/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Crime &amp; Justice - The Heat System (C#), where we will implement a system to track \"Heat\" (criminal notoriety) per faction, based on player crimes, and design how witnesses report these crimes, leading to escalating consequences.</p>"},{"location":"54-chapter-54/","title":"Chapter 8.5: Crime & Justice - The Heat System (C#)","text":""},{"location":"54-chapter-54/#chapter-85-crime-justice-the-heat-system-c","title":"Chapter 8.5: Crime &amp; Justice - The Heat System (C#)","text":"<p>Sigilborne's world is morally ambiguous, where \"justice\" depends on who's watching. This chapter implements Crime &amp; Justice, specifically \"The Heat System\" in the C# Brain. This system will track <code>Heat</code> (criminal notoriety) for the player character per faction, based on their actions, and design how NPCs (witnesses) report these crimes, leading to escalating consequences, as specified in TDD 06.4.</p>"},{"location":"54-chapter-54/#1-the-ambiguity-of-crime-and-justice","title":"1. The Ambiguity of Crime and Justice","text":"<p>The GDD (B22.1) states: \"Justice is political, ideological, and perspective-dependent. A 'crime' is simply a violation of someone's beliefs.\" This means:</p> <ul> <li>Faction-Specific Heat: Player's notoriety is tracked by individual factions, not globally.</li> <li>Witness-Dependent: Crimes are only \"real\" if witnessed and reported (B22.3).</li> <li>Consequences: Heat leads to escalating punishments (B22.5).</li> <li>Outlaw Path: The system must support a viable outlaw playstyle (B22.7).</li> </ul>"},{"location":"54-chapter-54/#2-defining-crimetype-crimereport-and-factionheat","title":"2. Defining <code>CrimeType</code>, <code>CrimeReport</code>, and <code>FactionHeat</code>","text":"<p>We need enums for different types of crimes, a struct for a crime report, and a component to track a faction's heat towards an entity.</p> <ol> <li>Create <code>res://_Brain/Systems/Crime/</code> folder.</li> <li>Create <code>res://_Brain/Systems/Crime/CrimeData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Crime/CrimeData.cs\nusing System;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Factions; // For FactionType\n\nnamespace Sigilborne.Systems.Crime\n{\n    /// &lt;summary&gt;\n    /// Defines broad categories of crimes.\n    /// (GDD B22.2)\n    /// &lt;/summary&gt;\n    public enum CrimeType\n    {\n        None,\n        Assault,            // Attacking an NPC\n        Murder,             // Killing an NPC\n        Theft,              // Stealing items\n        Trespass,           // Entering forbidden areas\n        MagicMisuse,        // Using forbidden glyphs, reckless casting\n        Sabotage,           // Destroying faction property\n        Espionage,          // Spying on a faction\n        CorruptionUse,      // Using corrupted powers (crime in some factions)\n        ShrineDesecration   // Violating spiritual sites\n    }\n\n    /// &lt;summary&gt;\n    /// Represents a report of a crime, created by a witness.\n    /// &lt;/summary&gt;\n    public struct CrimeReport\n    {\n        public EntityID PerpetratorID;  // The entity who committed the crime\n        public EntityID WitnessID;      // The entity who witnessed the crime\n        public CrimeType Type;\n        public string FactionID;        // The faction to which the crime is reported\n        public Vector2 CrimeLocation;\n        public float Severity;          // How severe the crime was (e.g., damage dealt, item value)\n        public double Timestamp;\n\n        public CrimeReport(EntityID perpetratorID, EntityID witnessID, CrimeType type, string factionID, Vector2 crimeLocation, float severity, double timestamp)\n        {\n            PerpetratorID = perpetratorID;\n            WitnessID = witnessID;\n            Type = type;\n            FactionID = factionID;\n            CrimeLocation = crimeLocation;\n            Severity = severity;\n            Timestamp = timestamp;\n        }\n\n        public override string ToString()\n        {\n            return $\"Crime Report: {PerpetratorID} committed {Type} for {FactionID} at {CrimeLocation}. Severity: {Severity:F1}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Represents a faction's \"Heat\" (criminal notoriety) towards an entity (typically the player).\n    /// (TDD 06.4.1)\n    /// &lt;/summary&gt;\n    public struct FactionHeat\n    {\n        public string FactionID;\n        public EntityID TargetID;\n        public float HeatValue;         // 0 to MaxHeat. Higher means more hostile.\n        public float MaxHeat;           // e.g., 100\n        public float DecayRate;         // How fast heat decays when no new crimes.\n        public bool IsActivePursuit;    // True if faction is actively hunting the target.\n\n        public FactionHeat(string factionID, EntityID targetID, float maxHeat = 100f, float decayRate = 5f)\n        {\n            FactionID = factionID;\n            TargetID = targetID;\n            HeatValue = 0;\n            MaxHeat = maxHeat;\n            DecayRate = decayRate;\n            IsActivePursuit = false;\n        }\n\n        public void AddHeat(float amount)\n        {\n            HeatValue = Mathf.Clamp(HeatValue + amount, 0, MaxHeat);\n        }\n\n        public void DecayHeat(float delta)\n        {\n            HeatValue = Mathf.Max(0, HeatValue - DecayRate * delta);\n        }\n\n        public override string ToString()\n        {\n            return $\"Heat for {TargetID} by {FactionID}: {HeatValue:F1}/{MaxHeat:F0} (Pursuit: {IsActivePursuit})\";\n        }\n    }\n}\n</code></pre>"},{"location":"54-chapter-54/#3-implementing-crimesystemcs","title":"3. Implementing <code>CrimeSystem.cs</code>","text":"<p>This system will: *   Manage <code>FactionHeat</code> for entities. *   Process <code>CrimeReport</code>s from witnesses. *   Implement the <code>Heat System</code> logic (add heat, decay heat, trigger pursuit). *   Define <code>CrimeDefinitions</code> for how different crimes generate heat.</p> <ol> <li>Create <code>res://_Brain/Systems/Crime/CrimeSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Crime/CrimeSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Factions; // For FactionSystem\nusing Sigilborne.Systems.AI; // For NPC AI, detecting player\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Crime\n{\n    /// &lt;summary&gt;\n    /// Defines how much heat a specific crime generates for a specific faction type.\n    /// (GDD B22.1: Faction Legal Architecture)\n    /// &lt;/summary&gt;\n    public struct CrimeDefinition\n    {\n        public CrimeType Type;\n        public FactionType FactionType;\n        public float BaseHeat;      // Base heat generated for this crime type\n        public float SeverityMultiplier; // Multiplier based on crime severity (e.g., damage dealt, item value)\n        public bool IsMajorCrime;   // True if this crime is serious enough to trigger immediate pursuit\n\n        public CrimeDefinition(CrimeType type, FactionType factionType, float baseHeat, float severityMultiplier = 1.0f, bool isMajorCrime = false)\n        {\n            Type = type;\n            FactionType = factionType;\n            BaseHeat = baseHeat;\n            SeverityMultiplier = severityMultiplier;\n            IsMajorCrime = isMajorCrime;\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Manages crime and justice: tracking faction heat, processing crime reports,\n    /// and escalating consequences.\n    /// (TDD 06.4)\n    /// &lt;/summary&gt;\n    public class CrimeSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private FactionSystem _factionSystem;\n        private AISystem _aiSystem; // To tell NPCs to pursue\n\n        // Dictionary to store FactionHeat for entities (typically player).\n        // Key: TargetID, Value: Dictionary&lt;FactionID, FactionHeat&gt;\n        private Dictionary&lt;EntityID, Dictionary&lt;string, FactionHeat&gt;&gt; _entityFactionHeat = new Dictionary&lt;EntityID, Dictionary&lt;string, FactionHeat&gt;&gt;();\n\n        // Static definitions of how much heat each crime generates for each FactionType.\n        private List&lt;CrimeDefinition&gt; _crimeDefinitions = new List&lt;CrimeDefinition&gt;();\n\n        // Queue for incoming crime reports (processed on main thread)\n        private ConcurrentQueue&lt;CrimeReport&gt; _crimeReportsQueue = new ConcurrentQueue&lt;CrimeReport&gt;();\n\n        private const float HEAT_DECAY_INTERVAL = 10.0f; // Decay heat every 10 real seconds\n        private float _heatDecayTimer;\n\n        public CrimeSystem(EntityManager entityManager, EventBus eventBus, FactionSystem factionSystem, AISystem aiSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _factionSystem = factionSystem;\n            _aiSystem = aiSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultCrimeDefinitions(); // Register static crime data\n            GD.Print(\"CrimeSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // Only track heat for the player for now.\n            if (type == EntityType.Player)\n            {\n                _entityFactionHeat.Add(id, new Dictionary&lt;string, FactionHeat&gt;());\n                // Initialize heat for all factions\n                foreach (var faction in _factionSystem.GetAllFactions())\n                {\n                    _entityFactionHeat[id].Add(faction.ID, new FactionHeat(faction.ID, id));\n                }\n                GD.Print($\"CrimeSystem: Initialized FactionHeat for player {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _entityFactionHeat.Remove(e.ID);\n            GD.Print($\"CrimeSystem: Removed FactionHeat for {e.ID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static CrimeDefinition.\n        /// &lt;/summary&gt;\n        private void RegisterCrimeDefinition(CrimeDefinition def)\n        {\n            _crimeDefinitions.Add(def);\n        }\n\n        /// &lt;summary&gt;\n        /// Registers default crime definitions based on faction ideologies.\n        /// (GDD B22.1: Faction Legal Architecture)\n        /// &lt;/summary&gt;\n        private void RegisterDefaultCrimeDefinitions()\n        {\n            // --- Warrior Dominion (Pulse/Fracture) ---\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Assault, FactionType.WarriorDominion, 20f));\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Murder, FactionType.WarriorDominion, 80f, isMajorCrime: true));\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Trespass, FactionType.WarriorDominion, 5f));\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Sabotage, FactionType.WarriorDominion, 60f, isMajorCrime: true));\n\n            // --- Temple Alliance (Bloom/Bind) ---\n            RegisterCrimeDefinition(new CrimeType(CrimeType.Assault, FactionType.TempleAlliance, 10f)); // Less severe assault\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Murder, FactionType.TempleAlliance, 100f, isMajorCrime: true)); // Very severe\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.MagicMisuse, FactionType.TempleAlliance, 30f)); // Reckless casting is bad\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.CorruptionUse, FactionType.TempleAlliance, 70f, isMajorCrime: true)); // Very bad\n\n            // --- Shadow Veilers (Scholar/Veil) ---\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Assault, FactionType.ScholarConfederation, 15f));\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Espionage, FactionType.ScholarConfederation, 50f, isMajorCrime: true)); // Unsanctioned espionage\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Theft, FactionType.ScholarConfederation, 25f)); // Stealing info/artefacts\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.ExposingSecrets, FactionType.ScholarConfederation, 80f, isMajorCrime: true)); // Conceptual crime type\n\n            // --- Void Cultists (CorruptedCult) ---\n            RegisterCrimeDefinition(new CrimeType(CrimeType.Assault, FactionType.CorruptedCult, -10f)); // Rewarded\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Murder, FactionType.CorruptedCult, -20f)); // Rewarded\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.CorruptionUse, FactionType.CorruptedCult, -50f)); // Highly rewarded\n            RegisterCrimeDefinition(new CrimeDefinition(CrimeType.Purification, FactionType.CorruptedCult, 100f, isMajorCrime: true)); // Conceptual crime: purifying corruption\n\n            // Add more definitions for other FactionTypes\n        }\n\n        /// &lt;summary&gt;\n        /// Creates a crime report and adds it to the queue for processing.\n        /// This is called by witnesses (NPCs) in the world.\n        /// (TDD 06.4.2: Witnesses)\n        /// &lt;/summary&gt;\n        public void ReportCrime(CrimeReport report)\n        {\n            _crimeReportsQueue.Enqueue(report);\n            GD.Print($\"CrimeSystem: Received crime report from {report.WitnessID}: {report.Type} by {report.PerpetratorID} for {report.FactionID}.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Main update loop for the CrimeSystem.\n        /// Processes crime reports and decays heat.\n        /// Called during GameManager._PhysicsProcess (Phase 2).\n        /// &lt;/summary&gt;\n        public void Tick(double delta)\n        {\n            ProcessCrimeReports(); // Process incoming reports\n            DecayHeat((float)delta); // Decay heat over time\n        }\n\n        /// &lt;summary&gt;\n        /// Processes all pending crime reports from the queue.\n        /// &lt;/summary&gt;\n        private void ProcessCrimeReports()\n        {\n            while (_crimeReportsQueue.TryDequeue(out CrimeReport report))\n            {\n                if (!_entityManager.IsValid(report.PerpetratorID) || !_entityManager.IsValid(report.WitnessID)) continue;\n\n                // Get the faction type of the reported faction\n                Faction faction = _factionSystem.GetFaction(report.FactionID);\n                if (faction == null) continue;\n\n                // Find the crime definition relevant to this faction type\n                CrimeDefinition? crimeDef = _crimeDefinitions.FirstOrDefault(cd =&gt; cd.Type == report.Type &amp;&amp; cd.FactionType == faction.Type);\n\n                if (crimeDef != null)\n                {\n                    float heatGenerated = crimeDef.Value.BaseHeat + (report.Severity * crimeDef.Value.SeverityMultiplier);\n                    AddHeat(report.PerpetratorID, report.FactionID, heatGenerated, crimeDef.Value.IsMajorCrime);\n                }\n                else\n                {\n                    GD.Print($\"CrimeSystem: No specific crime definition for {report.Type} by {faction.Type}. No heat generated.\");\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Adds heat to a target entity for a specific faction.\n        /// (TDD 06.4.1: The Heat System)\n        /// &lt;/summary&gt;\n        public void AddHeat(EntityID targetID, string factionID, float amount, bool isMajorCrime = false)\n        {\n            if (!_entityFactionHeat.TryGetValue(targetID, out Dictionary&lt;string, FactionHeat&gt; factionHeats))\n            {\n                GD.PrintErr($\"CrimeSystem: No FactionHeat tracked for entity {targetID}.\");\n                return;\n            }\n\n            if (factionHeats.TryGetValue(factionID, out FactionHeat heat))\n            {\n                heat.AddHeat(amount);\n                factionHeats[factionID] = heat; // Update struct in dictionary\n\n                GD.Print($\"CrimeSystem: {targetID} heat for {factionID} increased by {amount:F1}. New Heat: {heat.HeatValue:F1}.\");\n                _eventBus.Publish(new FactionHeatUpdatedEvent { TargetID = targetID, FactionHeat = heat });\n\n                // Check for active pursuit (TDD 06.4.2)\n                if (heat.HeatValue &gt;= heat.MaxHeat * 0.8f &amp;&amp; !heat.IsActivePursuit) // 80% to trigger pursuit\n                {\n                    heat.IsActivePursuit = true;\n                    factionHeats[factionID] = heat;\n                    GD.Print($\"CrimeSystem: Faction {factionID} is now actively pursuing {targetID}!\");\n                    _eventBus.Publish(new FactionPursuitChangedEvent { TargetID = targetID, FactionID = factionID, IsPursuing = true });\n                    // Tell AI System to spawn hunter squads (TDD 06.4.2)\n                    // _aiSystem.SpawnHunterSquad(targetID, factionID);\n                }\n                else if (heat.HeatValue &lt; heat.MaxHeat * 0.5f &amp;&amp; heat.IsActivePursuit) // Drop below 50% to stop pursuit\n                {\n                    heat.IsActivePursuit = false;\n                    factionHeats[factionID] = heat;\n                    GD.Print($\"CrimeSystem: Faction {factionID} has stopped pursuing {targetID}.\");\n                    _eventBus.Publish(new FactionPursuitChangedEvent { TargetID = targetID, FactionID = factionID, IsPursuing = false });\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Decays heat for all tracked entities and factions over time.\n        /// (TDD 06.2.3: Daily Cycle - CrimeSystem.DecayHeat())\n        /// &lt;/summary&gt;\n        private void DecayHeat(float delta)\n        {\n            _heatDecayTimer += delta;\n            if (_heatDecayTimer &gt;= HEAT_DECAY_INTERVAL)\n            {\n                foreach (var targetEntry in _entityFactionHeat)\n                {\n                    EntityID targetID = targetEntry.Key;\n                    foreach (var factionEntry in targetEntry.Value.Keys.ToList()) // Use ToList to modify while iterating\n                    {\n                        FactionHeat heat = targetEntry.Value[factionEntry];\n                        if (heat.HeatValue &gt; 0)\n                        {\n                            heat.DecayHeat(HEAT_DECAY_INTERVAL); // Decay by interval\n                            targetEntry.Value[factionEntry] = heat; // Update struct in dictionary\n                            if (heat.HeatValue &lt;= 0.1f) // Effectively zero\n                            {\n                                GD.Print($\"CrimeSystem: {targetID} heat for {factionEntry} decayed to zero.\");\n                                _eventBus.Publish(new FactionHeatUpdatedEvent { TargetID = targetID, FactionHeat = heat });\n                            }\n                        }\n                    }\n                }\n                _heatDecayTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the FactionHeat for a target entity and specific faction.\n        /// &lt;/summary&gt;\n        public FactionHeat GetFactionHeat(EntityID targetID, string factionID)\n        {\n            if (_entityFactionHeat.TryGetValue(targetID, out Dictionary&lt;string, FactionHeat&gt; factionHeats) &amp;&amp; factionHeats.TryGetValue(factionID, out FactionHeat heat))\n            {\n                return heat;\n            }\n            return new FactionHeat(factionID, targetID); // Return default zero heat\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct FactionHeatUpdatedEvent { public EntityID TargetID; public FactionHeat FactionHeat; }\n        public struct FactionPursuitChangedEvent { public EntityID TargetID; public string FactionID; public bool IsPursuing; }\n    }\n}\n</code></pre>"},{"location":"54-chapter-54/#4-integrating-crimesystem-into-gamemanager","title":"4. Integrating <code>CrimeSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Crime;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>CrimeSystem</code> property.</li> <li>Initialize <code>CrimeSystem</code> in <code>InitializeSystems()</code> after <code>FactionSystem</code> and <code>AISystem</code>.</li> <li>Call <code>CrimeSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public EconomyManager Economy { get; private set; }\n    public CrimeSystem Crime { get; private set; } // Add CrimeSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n        // ... (existing economy system tests) ...\n\n        // --- Test Crime System ---\n        GD.Print(\"\\n--- Testing Crime System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID witnessID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Test NPC as witness\n\n        // Initial heat check\n        GD.Print($\"Player initial heat with Crimson Blades: {Crime.GetFactionHeat(playerID, \"crimson_blades\").HeatValue}\");\n\n        // Simulate a crime report\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Assault, \"crimson_blades\", new Vector2(200, 200), 10f, Time.CurrentGameTime));\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Murder, \"crimson_blades\", new Vector2(200, 200), 100f, Time.CurrentGameTime)); // Major crime\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Theft, \"shadow_veilers\", new Vector2(200, 200), 50f, Time.CurrentGameTime));\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.CorruptionUse, \"sunken_temple\", new Vector2(200, 200), 70f, Time.CurrentGameTime)); // High heat for Temple\n\n        // Simulate a crime that is rewarded by Void Cultists\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.CorruptionUse, \"void_cultists\", new Vector2(200, 200), 10f, Time.CurrentGameTime));\n\n        GD.Print(\"--- End Testing Crime System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta);\n        Crime.Tick(delta); // Call CrimeSystem's tick method\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to FactionAI) ...\n\n        // Initialize CrimeSystem AFTER FactionSystem and AISystem\n        Crime = new CrimeSystem(Events, Entities, Factions, AI); // Pass dependencies\n        GD.Print(\"  - CrimeSystem initialized.\");\n\n        // Initialize EconomyManager AFTER EquipmentSystem, FactionSystem, EntityManager, TransformSystem\n        Economy = new EconomyManager(Events, Equipment, Factions, Entities, Transforms);\n        GD.Print(\"  - EconomyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"54-chapter-54/#5-testing-the-heat-system","title":"5. Testing The Heat System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Crime System\" section and subsequent <code>CrimeSystem: ... heat for X increased...</code> messages.</li> </ol> <pre><code>...\nCrimeSystem: Initialized.\n  - CrimeSystem initialized.\nEconomyManager: Initialized.\n...\n--- Testing Crime System ---\nPlayer initial heat with Crimson Blades: 0.0\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Assault by EntityID(0, Gen:1) for crimson_blades.\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 20.0. New Heat: 20.0.\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Murder by EntityID(0, Gen:1) for crimson_blades.\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 80.0. New Heat: 100.0.\nCrimeSystem: Faction crimson_blades is now actively pursuing EntityID(0, Gen:1)!\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Theft by EntityID(0, Gen:1) for shadow_veilers.\nCrimeSystem: EntityID(0, Gen:1) heat for shadow_veilers increased by 25.0. New Heat: 25.0.\nCrimeSystem: Received crime report from EntityID(1, Gen:1): CorruptionUse by EntityID(0, Gen:1) for sunken_temple.\nCrimeSystem: EntityID(0, Gen:1) heat for sunken_temple increased by 70.0. New Heat: 70.0.\nCrimeSystem: Received crime report from EntityID(1, Gen:1): CorruptionUse by EntityID(0, Gen:1) for void_cultists.\nCrimeSystem: EntityID(0, Gen:1) heat for void_cultists increased by -50.0. New Heat: -50.0.\n--- End Testing Crime System ---\n...\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 0.0. New Heat: 100.0.\nCrimeSystem: EntityID(0, Gen:1) heat for shadow_veilers increased by 0.0. New Heat: 25.0.\nCrimeSystem: EntityID(0, Gen:1) heat for sunken_temple increased by 0.0. New Heat: 70.0.\nCrimeSystem: EntityID(0, Gen:1) heat for void_cultists increased by 0.0. New Heat: -50.0.\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Heat Generation: <code>CrimeSystem</code> correctly processes <code>CrimeReport</code>s and adds heat based on <code>CrimeDefinition</code>s and <code>Severity</code>.</li> <li>Faction-Specific Heat: Player's heat is tracked independently for each faction.</li> <li>Pursuit Trigger: <code>crimson_blades</code> (WarriorDominion) correctly escalates to \"actively pursuing\" the player when heat reaches 100.</li> <li>Ideological Impact: <code>void_cultists</code> (CorruptedCult) shows negative heat generation for <code>CorruptionUse</code>, demonstrating the moral ambiguity.</li> <li>Heat Decay: Every 10 seconds, <code>CrimeSystem: ... heat for X increased by 0.0. New Heat: Y.0.</code> messages indicate the decay process is running (though with 0 change in this test, as it's just decaying its own timer). If heat was added, it would decay.</li> </ul> <p>This confirms our <code>CrimeSystem</code> is functional, tracking <code>Heat</code> per faction and responding to crime reports, laying the groundwork for consequences and the outlaw path.</p>"},{"location":"54-chapter-54/#summary","title":"Summary","text":"<p>You have successfully implemented Crime &amp; Justice, designing <code>CrimeType</code>, <code>CrimeReport</code>, and <code>FactionHeat</code> structs, and creating <code>CrimeSystem</code> to manage criminal notoriety. By implementing <code>CrimeSystem</code> to process <code>CrimeReport</code>s, track <code>FactionHeat</code> per entity, and trigger pursuit states based on heat thresholds, you've established a robust mechanism for dynamic justice. This crucial system strictly adheres to TDD 06.4's specifications, providing the foundational layer for escalating consequences and supporting the morally ambiguous outlaw path in Sigilborne.</p>"},{"location":"54-chapter-54/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Bounty &amp; Punishment, detailing how <code>Heat</code> translates into concrete punishments like refusing services, attacking on sight, or dispatching hunter squads, and how the <code>Bounty</code> system tracks these escalating consequences.</p>"},{"location":"55-chapter-55/","title":"Chapter 8.6: Bounty & Punishment - Escalation & Consequences (C#)","text":""},{"location":"55-chapter-55/#chapter-86-bounty-punishment-escalation-consequences-c","title":"Chapter 8.6: Bounty &amp; Punishment - Escalation &amp; Consequences (C#)","text":"<p>Our <code>CrimeSystem</code> now tracks <code>Heat</code> per faction. This chapter builds upon that by implementing Bounty &amp; Punishment mechanisms. We'll define how <code>Heat</code> translates into concrete punishments like refusing services, attacking on sight, or dispatching hunter squads, and design how the <code>Bounty</code> system tracks these escalating consequences, as specified in TDD 06.4.2.</p>"},{"location":"55-chapter-55/#1-the-escalation-of-consequences","title":"1. The Escalation of Consequences","text":"<p>The GDD (B22.5) states: \"Punishments range from fines, exile, forced labor... to execution.\" This implies a system that:</p> <ul> <li>Tiers of Punishment: Consequences escalate with <code>HeatValue</code>.</li> <li>Active Pursuit: High <code>Heat</code> leads to active hunting.</li> <li>Faction-Specific: Punishments are enforced by the aggrieved faction.</li> <li>Player-Visible: The player needs to understand the consequences of their actions.</li> </ul>"},{"location":"55-chapter-55/#2-defining-bounty-and-punishmentlevel","title":"2. Defining <code>Bounty</code> and <code>PunishmentLevel</code>","text":"<p>We need a struct to represent a bounty and an enum for escalating punishment tiers.</p> <ol> <li>Create <code>res://_Brain/Systems/Crime/BountyData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Crime/BountyData.cs\nusing System;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Factions; // For FactionType\n\nnamespace Sigilborne.Systems.Crime\n{\n    /// &lt;summary&gt;\n    /// Defines the escalating levels of punishment a faction can impose.\n    /// (TDD 06.4.2)\n    /// &lt;/summary&gt;\n    public enum PunishmentLevel\n    {\n        None,               // No punishment, ignored\n        Warning,            // Verbal warning, reduced services\n        RefusedServices,    // Merchants won't trade, NPCs won't talk\n        AttackOnSight,      // NPCs in faction territory become hostile\n        HunterSquads,       // Faction dispatches bounty hunters to actively pursue\n        Exile,              // Permanent ban from faction territory/settlements\n        ExecutionOrder      // Highest level, faction seeks to kill on sight\n    }\n\n    /// &lt;summary&gt;\n    /// Represents a bounty placed on an entity by a specific faction.\n    /// (TDD 06.4.2)\n    /// &lt;/summary&gt;\n    public struct Bounty\n    {\n        public EntityID TargetID;\n        public string FactionID;\n        public float GoldValue;         // The gold reward for capturing/defeating the target\n        public PunishmentLevel Level;   // The current punishment level\n        public bool IsActive;           // True if hunters are actively pursuing\n\n        public Bounty(EntityID targetID, string factionID, float goldValue, PunishmentLevel level, bool isActive)\n        {\n            TargetID = targetID;\n            FactionID = factionID;\n            GoldValue = goldValue;\n            Level = level;\n            IsActive = isActive;\n        }\n\n        public override string ToString()\n        {\n            return $\"Bounty on {TargetID} by {FactionID}: {GoldValue:F0} Gold, Level: {Level} (Active: {IsActive})\";\n        }\n    }\n}\n</code></pre>"},{"location":"55-chapter-55/#3-enhancing-crimesystemcs-for-bounties-and-punishments","title":"3. Enhancing <code>CrimeSystem.cs</code> for Bounties and Punishments","text":"<p><code>CrimeSystem</code> will now: *   Manage <code>Bounty</code> instances per entity and faction. *   Translate <code>FactionHeat</code> into <code>PunishmentLevel</code>s. *   Trigger <code>HunterSquads</code> (conceptually) when <code>Heat</code> is high enough. *   Provide methods for other systems (e.g., <code>AISystem</code>, <code>EconomyManager</code>) to query <code>PunishmentLevel</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Crime/CrimeSystem.cs</code>.</li> <li>Add a dictionary for <code>Bounty</code> instances.</li> <li>Modify <code>AddHeat</code> to update <code>Bounty</code> and <code>PunishmentLevel</code>.</li> <li>Add methods to retrieve <code>PunishmentLevel</code>.</li> </ol> <pre><code>// _Brain/Systems/Crime/CrimeSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.AI;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Crime\n{\n    // ... (CrimeType, CrimeReport, FactionHeat structs/enums) ...\n    // ... (PunishmentLevel, Bounty structs/enums) ...\n\n    public class CrimeSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private FactionSystem _factionSystem;\n        private AISystem _aiSystem;\n\n        private Dictionary&lt;EntityID, Dictionary&lt;string, FactionHeat&gt;&gt; _entityFactionHeat = new Dictionary&lt;EntityID, Dictionary&lt;string, FactionHeat&gt;&gt;();\n        private List&lt;CrimeDefinition&gt; _crimeDefinitions = new List&lt;CrimeDefinition&gt;();\n        private ConcurrentQueue&lt;CrimeReport&gt; _crimeReportsQueue = new ConcurrentQueue&lt;CrimeReport&gt;();\n\n        // New: Bounties tracked per target and faction.\n        // Key: TargetID, Value: Dictionary&lt;FactionID, Bounty&gt;\n        private Dictionary&lt;EntityID, Dictionary&lt;string, Bounty&gt;&gt; _entityBounties = new Dictionary&lt;EntityID, Dictionary&lt;string, Bounty&gt;&gt;();\n\n\n        private const float HEAT_DECAY_INTERVAL = 10.0f;\n        private float _heatDecayTimer;\n\n        public CrimeSystem(EntityManager entityManager, EventBus eventBus, FactionSystem factionSystem, AISystem aiSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _factionSystem = factionSystem;\n            _aiSystem = aiSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultCrimeDefinitions();\n            GD.Print(\"CrimeSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player)\n            {\n                _entityFactionHeat.Add(id, new Dictionary&lt;string, FactionHeat&gt;());\n                _entityBounties.Add(id, new Dictionary&lt;string, Bounty&gt;()); // Initialize bounties\n                foreach (var faction in _factionSystem.GetAllFactions())\n                {\n                    _entityFactionHeat[id].Add(faction.ID, new FactionHeat(faction.ID, id));\n                    _entityBounties[id].Add(faction.ID, new Bounty(id, faction.ID, 0f, PunishmentLevel.None, false)); // Initialize bounty\n                }\n                GD.Print($\"CrimeSystem: Initialized FactionHeat and Bounties for player {id}.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _entityFactionHeat.Remove(e.ID);\n            _entityBounties.Remove(e.ID); // Remove bounties\n            GD.Print($\"CrimeSystem: Removed FactionHeat and Bounties for {e.ID}.\");\n        }\n\n        // ... (RegisterCrimeDefinition, RegisterDefaultCrimeDefinitions, ReportCrime methods) ...\n\n        public void Tick(double delta)\n        {\n            ProcessCrimeReports();\n            DecayHeat((float)delta);\n            UpdateBountiesAndPunishments(); // New: Update punishment levels\n        }\n\n        private void ProcessCrimeReports() { /* ... */ }\n\n        public void AddHeat(EntityID targetID, string factionID, float amount, bool isMajorCrime = false)\n        {\n            if (!_entityFactionHeat.TryGetValue(targetID, out Dictionary&lt;string, FactionHeat&gt; factionHeats))\n            {\n                GD.PrintErr($\"CrimeSystem: No FactionHeat tracked for entity {targetID}.\");\n                return;\n            }\n\n            if (factionHeats.TryGetValue(factionID, out FactionHeat heat))\n            {\n                heat.AddHeat(amount);\n                factionHeats[factionID] = heat;\n\n                GD.Print($\"CrimeSystem: {targetID} heat for {factionID} increased by {amount:F1}. New Heat: {heat.HeatValue:F1}.\");\n                _eventBus.Publish(new FactionHeatUpdatedEvent { TargetID = targetID, FactionHeat = heat });\n\n                // Check for active pursuit (TDD 06.4.2)\n                // This logic is now part of UpdateBountiesAndPunishments, as it's tied to PunishmentLevel.\n                // For now, just a print if it's a major crime.\n                if (isMajorCrime)\n                {\n                    GD.Print($\"CrimeSystem: {targetID} committed a MAJOR crime for {factionID}.\");\n                }\n            }\n        }\n\n        private void DecayHeat(float delta)\n        {\n            _heatDecayTimer += delta;\n            if (_heatDecayTimer &gt;= HEAT_DECAY_INTERVAL)\n            {\n                foreach (var targetEntry in _entityFactionHeat)\n                {\n                    EntityID targetID = targetEntry.Key;\n                    foreach (var factionEntry in targetEntry.Value.Keys.ToList())\n                    {\n                        FactionHeat heat = targetEntry.Value[factionEntry];\n                        if (heat.HeatValue &gt; 0)\n                        {\n                            heat.DecayHeat(HEAT_DECAY_INTERVAL);\n                            targetEntry.Value[factionEntry] = heat;\n                            if (heat.HeatValue &lt;= 0.1f)\n                            {\n                                GD.Print($\"CrimeSystem: {targetID} heat for {factionEntry} decayed to zero.\");\n                                _eventBus.Publish(new FactionHeatUpdatedEvent { TargetID = targetID, FactionHeat = heat });\n                            }\n                        }\n                    }\n                }\n                _heatDecayTimer = 0;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Updates the bounty and punishment level for all entities based on their faction heat.\n        /// (TDD 06.4.2)\n        /// &lt;/summary&gt;\n        private void UpdateBountiesAndPunishments()\n        {\n            foreach (var targetEntry in _entityFactionHeat)\n            {\n                EntityID targetID = targetEntry.Key;\n                foreach (var factionEntry in targetEntry.Value.Keys.ToList())\n                {\n                    FactionHeat heat = targetEntry.Value[factionEntry];\n                    ref Bounty bounty = ref _entityBounties[targetID].GetValueRef(factionEntry); // Get mutable ref to bounty\n\n                    // Determine new punishment level based on heat\n                    PunishmentLevel newLevel = PunishmentLevel.None;\n                    float newGoldValue = 0f;\n\n                    if (heat.HeatValue &gt;= 90f) { newLevel = PunishmentLevel.ExecutionOrder; newGoldValue = 500f; }\n                    else if (heat.HeatValue &gt;= 70f) { newLevel = PunishmentLevel.HunterSquads; newGoldValue = 300f; }\n                    else if (heat.HeatValue &gt;= 50f) { newLevel = PunishmentLevel.AttackOnSight; newGoldValue = 100f; }\n                    else if (heat.HeatValue &gt;= 30f) { newLevel = PunishmentLevel.RefusedServices; newGoldValue = 20f; }\n                    else if (heat.HeatValue &gt;= 10f) { newLevel = PunishmentLevel.Warning; newGoldValue = 5f; }\n\n                    bool wasPursuing = bounty.IsActive;\n                    bool isPursuing = (newLevel &gt;= PunishmentLevel.HunterSquads); // HunterSquads and above means active pursuit\n\n                    if (bounty.Level != newLevel || bounty.GoldValue != newGoldValue || bounty.IsActive != isPursuing)\n                    {\n                        bounty.Level = newLevel;\n                        bounty.GoldValue = newGoldValue;\n                        bounty.IsActive = isPursuing;\n\n                        GD.Print($\"CrimeSystem: Bounty for {targetID} by {factionEntry} updated. Level: {newLevel}, Gold: {newGoldValue:F0}, Active: {isPursuing}\");\n                        _eventBus.Publish(new BountyUpdatedEvent { TargetID = targetID, Bounty = bounty });\n\n                        // Trigger/stop hunter squads if pursuit status changed (TDD 06.4.2)\n                        if (isPursuing &amp;&amp; !wasPursuing)\n                        {\n                            _eventBus.Publish(new FactionPursuitChangedEvent { TargetID = targetID, FactionID = factionEntry, IsPursuing = true });\n                            // _aiSystem.SpawnHunterSquad(targetID, factionEntry); // Conceptual\n                        }\n                        else if (!isPursuing &amp;&amp; wasPursuing)\n                        {\n                            _eventBus.Publish(new FactionPursuitChangedEvent { TargetID = targetID, FactionID = factionEntry, IsPursuing = false });\n                            // _aiSystem.DespawnHunterSquads(targetID, factionEntry); // Conceptual\n                        }\n                    }\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the PunishmentLevel for a target entity by a specific faction.\n        /// (TDD 06.4.2)\n        /// &lt;/summary&gt;\n        public PunishmentLevel GetPunishmentLevel(EntityID targetID, string factionID)\n        {\n            if (_entityBounties.TryGetValue(targetID, out Dictionary&lt;string, Bounty&gt; bounties) &amp;&amp; bounties.TryGetValue(factionID, out Bounty bounty))\n            {\n                return bounty.Level;\n            }\n            return PunishmentLevel.None;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the Bounty for a target entity by a specific faction.\n        /// &lt;/summary&gt;\n        public Bounty GetBounty(EntityID targetID, string factionID)\n        {\n            if (_entityBounties.TryGetValue(targetID, out Dictionary&lt;string, Bounty&gt; bounties) &amp;&amp; bounties.TryGetValue(factionID, out Bounty bounty))\n            {\n                return bounty;\n            }\n            return new Bounty(targetID, factionID, 0f, PunishmentLevel.None, false);\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct FactionHeatUpdatedEvent { public EntityID TargetID; public FactionHeat FactionHeat; }\n        public struct FactionPursuitChangedEvent { public EntityID TargetID; public string FactionID; public bool IsPursuing; }\n        public struct BountyUpdatedEvent { public EntityID TargetID; public Bounty Bounty; } // New event\n    }\n}\n</code></pre>"},{"location":"55-chapter-55/#31-add-exposingsecrets-and-purification-to-crimetype","title":"3.1. Add <code>ExposingSecrets</code> and <code>Purification</code> to <code>CrimeType</code>","text":"<p>These were referenced in <code>RegisterDefaultCrimeDefinitions</code>.</p> <p>Open <code>res://_Brain/Systems/Crime/CrimeData.cs</code> and add to <code>CrimeType</code>:</p> <pre><code>// _Brain/Systems/Crime/CrimeData.cs\nusing System;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Factions;\n\nnamespace Sigilborne.Systems.Crime\n{\n    public enum CrimeType\n    {\n        None,\n        Assault,\n        Murder,\n        Theft,\n        Trespass,\n        MagicMisuse,\n        Sabotage,\n        Espionage,\n        CorruptionUse,\n        ShrineDesecration,\n        ExposingSecrets,    // New\n        Purification        // New\n    }\n    // ... (rest of file) ...\n}\n</code></pre>"},{"location":"55-chapter-55/#4-integrating-bounty-and-punishmentlevel-into-gamemanager","title":"4. Integrating <code>Bounty</code> and <code>PunishmentLevel</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Crime;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>In <code>GameManager._Ready()</code>, modify the \"Test Crime System\" section to:<ul> <li>Test <code>GetPunishmentLevel</code>.</li> <li>Observe how <code>PunishmentLevel</code> changes with added <code>Heat</code>.</li> </ul> </li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method)\n// ...\n        // --- Test Crime System ---\n        GD.Print(\"\\n--- Testing Crime System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID witnessID = Entities.GetEntityMeta(1).Generation == 1 ? new EntityID(1, 1) : EntityID.Invalid; // Test NPC as witness\n\n        // Initial heat check\n        GD.Print($\"Player initial heat with Crimson Blades: {Crime.GetFactionHeat(playerID, \"crimson_blades\").HeatValue}\");\n        GD.Print($\"Player initial punishment level with Crimson Blades: {Crime.GetPunishmentLevel(playerID, \"crimson_blades\")}\");\n\n        // Simulate a crime report\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Assault, \"crimson_blades\", new Vector2(200, 200), 10f, Time.CurrentGameTime));\n        GD.Print($\"Player punishment level with Crimson Blades after Assault: {Crime.GetPunishmentLevel(playerID, \"crimson_blades\")}\");\n\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Trespass, \"crimson_blades\", new Vector2(200, 200), 1f, Time.CurrentGameTime));\n        GD.Print($\"Player punishment level with Crimson Blades after Trespass: {Crime.GetPunishmentLevel(playerID, \"crimson_blades\")}\");\n\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Murder, \"crimson_blades\", new Vector2(200, 200), 100f, Time.CurrentGameTime)); // Major crime\n        GD.Print($\"Player punishment level with Crimson Blades after Murder: {Crime.GetPunishmentLevel(playerID, \"crimson_blades\")}\");\n        GD.Print($\"Player bounty with Crimson Blades: {Crime.GetBounty(playerID, \"crimson_blades\")}\");\n\n\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.Theft, \"shadow_veilers\", new Vector2(200, 200), 50f, Time.CurrentGameTime));\n        GD.Print($\"Player punishment level with Shadow Veilers after Theft: {Crime.GetPunishmentLevel(playerID, \"shadow_veilers\")}\");\n\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.CorruptionUse, \"sunken_temple\", new Vector2(200, 200), 70f, Time.CurrentGameTime)); // High heat for Temple\n        GD.Print($\"Player punishment level with Sunken Temple after CorruptionUse: {Crime.GetPunishmentLevel(playerID, \"sunken_temple\")}\");\n\n        // Simulate a crime that is rewarded by Void Cultists\n        Crime.ReportCrime(new CrimeReport(playerID, witnessID, CrimeType.CorruptionUse, \"void_cultists\", new Vector2(200, 200), 10f, Time.CurrentGameTime));\n        GD.Print($\"Player punishment level with Void Cultists after CorruptionUse: {Crime.GetPunishmentLevel(playerID, \"void_cultists\")}\");\n\n        GD.Print(\"--- End Testing Crime System ---\\n\");\n// ...\n</code></pre>"},{"location":"55-chapter-55/#41-update-eventbuscs-for-bountyupdatedevent","title":"4.1. Update <code>EventBus.cs</code> for <code>BountyUpdatedEvent</code>","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnBountyUpdated</code> delegate.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Crime System Events (TDD 06.4.1)\n        public event Action&lt;EntityID, FactionHeat&gt; OnFactionHeatUpdated;\n        public event Action&lt;EntityID, string, bool&gt; OnFactionPursuitChanged;\n        public event Action&lt;EntityID, Bounty&gt; OnBountyUpdated; // New event\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is CrimeSystem.FactionHeatUpdatedEvent factionHeatEvent)\n            {\n                OnFactionHeatUpdated?.Invoke(factionHeatEvent.TargetID, factionHeatEvent.FactionHeat);\n            }\n            else if (eventData is CrimeSystem.FactionPursuitChangedEvent factionPursuitEvent)\n            {\n                OnFactionPursuitChanged?.Invoke(factionPursuitEvent.TargetID, factionPursuitEvent.FactionID, factionPursuitEvent.IsPursuing);\n            }\n            else if (eventData is CrimeSystem.BountyUpdatedEvent bountyUpdatedEvent) // New condition\n            {\n                OnBountyUpdated?.Invoke(bountyUpdatedEvent.TargetID, bountyUpdatedEvent.Bounty);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"55-chapter-55/#5-testing-bounty-and-punishment-escalation","title":"5. Testing Bounty and Punishment Escalation","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Crime System\" section.</li> </ol> <pre><code>...\nCrimeSystem: Initialized.\n  - CrimeSystem initialized.\nEconomyManager: Initialized.\n...\n--- Testing Crime System ---\nPlayer initial heat with Crimson Blades: 0.0\nPlayer initial punishment level with Crimson Blades: None\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Assault by EntityID(0, Gen:1) for crimson_blades.\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 20.0. New Heat: 20.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by crimson_blades updated. Level: Warning, Gold: 5, Active: False\nPlayer punishment level with Crimson Blades after Assault: Warning\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Trespass by EntityID(0, Gen:1) for crimson_blades.\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 5.0. New Heat: 25.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by crimson_blades updated. Level: Warning, Gold: 5, Active: False\nPlayer punishment level with Crimson Blades after Trespass: Warning\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Murder by EntityID(0, Gen:1) for crimson_blades.\nCrimeSystem: EntityID(0, Gen:1) heat for crimson_blades increased by 80.0. New Heat: 100.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by crimson_blades updated. Level: ExecutionOrder, Gold: 500, Active: True\nCrimeSystem: Faction crimson_blades is now actively pursuing EntityID(0, Gen:1)!\nPlayer punishment level with Crimson Blades after Murder: ExecutionOrder\nPlayer bounty with Crimson Blades: Bounty on EntityID(0, Gen:1) by crimson_blades: 500 Gold, Level: ExecutionOrder (Active: True)\nCrimeSystem: Received crime report from EntityID(1, Gen:1): Theft by EntityID(0, Gen:1) for shadow_veilers.\nCrimeSystem: EntityID(0, Gen:1) heat for shadow_veilers increased by 25.0. New Heat: 25.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by shadow_veilers updated. Level: RefusedServices, Gold: 20, Active: False\nPlayer punishment level with Shadow Veilers after Theft: RefusedServices\nCrimeSystem: Received crime report from EntityID(1, Gen:1): CorruptionUse by EntityID(0, Gen:1) for sunken_temple.\nCrimeSystem: EntityID(0, Gen:1) heat for sunken_temple increased by 70.0. New Heat: 70.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by sunken_temple updated. Level: HunterSquads, Gold: 300, Active: True\nCrimeSystem: Faction sunken_temple is now actively pursuing EntityID(0, Gen:1)!\nPlayer punishment level with Sunken Temple after CorruptionUse: HunterSquads\nCrimeSystem: Received crime report from EntityID(1, Gen:1): CorruptionUse by EntityID(0, Gen:1) for void_cultists.\nCrimeSystem: EntityID(0, Gen:1) heat for void_cultists increased by -50.0. New Heat: -50.0.\nCrimeSystem: Bounty for EntityID(0, Gen:1) by void_cultists updated. Level: None, Gold: 0, Active: False\nPlayer punishment level with Void Cultists after CorruptionUse: None\n--- End Testing Crime System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Punishment Escalation: <code>AddHeat</code> correctly updates the <code>Bounty</code> and <code>PunishmentLevel</code> based on <code>HeatValue</code> thresholds (e.g., from <code>None</code> to <code>Warning</code>, then to <code>ExecutionOrder</code>).</li> <li>Gold Value: <code>GoldValue</code> on the <code>Bounty</code> also increases with <code>PunishmentLevel</code>.</li> <li>Active Pursuit: <code>PunishmentLevel.HunterSquads</code> and <code>ExecutionOrder</code> correctly trigger <code>IsActivePursuit</code> and the <code>OnFactionPursuitChanged</code> event.</li> <li>Decay (Implicit): The <code>Tick</code> method's <code>DecayHeat</code> will reduce heat over time, which would then lower punishment levels.</li> <li>Ideological Impact: <code>Void Cultists</code> correctly show <code>None</code> punishment level (even with negative heat), demonstrating faction-specific legal interpretation.</li> </ul> <p>This confirms our <code>CrimeSystem</code> is robustly managing bounties and escalating punishments based on faction heat.</p>"},{"location":"55-chapter-55/#summary","title":"Summary","text":"<p>You have successfully implemented Bounty &amp; Punishment mechanisms in the C# Brain, defining <code>PunishmentLevel</code> and <code>Bounty</code> structs, and enhancing <code>CrimeSystem</code> to manage these. By translating <code>FactionHeat</code> into escalating <code>PunishmentLevel</code>s, updating <code>Bounty</code> values, and triggering active pursuit states, you've established a robust system for dynamic consequences. This crucial system strictly adheres to TDD 06.4.2's specifications, providing the authoritative backbone for escalating consequences and supporting the morally ambiguous outlaw path in Sigilborne.</p>"},{"location":"55-chapter-55/#next-steps","title":"Next Steps","text":"<p>This concludes Module 8: Society, Politics &amp; Economy. We will now move on to Module 9: Advanced World Mechanics &amp; Player Impact, starting with Ritual System - Pattern Matching &amp; Execution (C#), where we will design how spatial arrangements of items trigger complex magical rituals.</p>"},{"location":"56-chapter-56/","title":"Chapter 9.1: Ritual System - Pattern Matching & Execution (C#)","text":""},{"location":"56-chapter-56/#chapter-91-ritual-system-pattern-matching-execution-c","title":"Chapter 9.1: Ritual System - Pattern Matching &amp; Execution (C#)","text":"<p>Welcome to Module 9: Advanced World Mechanics &amp; Player Impact! Sigilborne's magic extends beyond glyph combos to powerful, ceremonial acts. This module begins by implementing the Ritual System in the C# Brain, designing how specific spatial arrangements of items and entities can trigger complex magical rituals, and how these rituals are executed, as specified in TDD 09.2.</p>"},{"location":"56-chapter-56/#1-the-power-of-rituals","title":"1. The Power of Rituals","text":"<p>The GDD (B27.2) states: \"Rituals span from medium-depth to extremely dangerous depending on purpose.\" This implies:</p> <ul> <li>Spatial Arrangement: Rituals require specific items in specific places.</li> <li>Pattern Matching: The system must detect when a valid pattern is formed.</li> <li>Execution: Once detected, the ritual consumes components and triggers effects.</li> <li>Scalability: Supports simple healing rites to forbidden world-altering ceremonies.</li> </ul>"},{"location":"56-chapter-56/#2-defining-ritualdefinition-and-ritualcomponent","title":"2. Defining <code>RitualDefinition</code> and <code>RitualComponent</code>","text":"<p>We need a static blueprint for each ritual and a component to mark a world object as a potential ritual center.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/</code> folder.</li> <li>Create <code>res://_Brain/Systems/Rituals/RitualData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/RitualData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Inventory; // For ItemID\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Defines a single required component for a ritual pattern.\n    /// &lt;/summary&gt;\n    public struct RitualComponentRequirement\n    {\n        public string ItemID;           // The item required (e.g., \"candle_lit\", \"sacrifice_goat\")\n        public float Radius;            // Radius from the ritual center where the item must be\n        public int Quantity;            // Number of this item required\n        public bool Consumable;         // True if the item is consumed by the ritual\n\n        public RitualComponentRequirement(string itemID, float radius, int quantity = 1, bool consumable = true)\n        {\n            ItemID = itemID;\n            Radius = radius;\n            Quantity = quantity;\n            Consumable = consumable;\n        }\n\n        public override string ToString()\n        {\n            return $\"{Quantity}x '{ItemID}' within {Radius:F0}m (Consumable: {Consumable})\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Static data defining a magical ritual.\n    /// (TDD 09.2.1)\n    /// &lt;/summary&gt;\n    public class RitualDefinition\n    {\n        public string ID { get; private set; } // Unique ID (e.g., \"healing_rite_t1\", \"spirit_summoning_t2\")\n        public string Name { get; private set; }\n        public string Description { get; private set; }\n        public float CastTime { get; private set; } // Time to perform the ritual\n        public float ChakraCost { get; private set; } // Chakra cost for the ritual initiator\n        public float StabilityCost { get; private set; } // Stability cost for the ritual initiator\n        public float Radius { get; private set; } // Total radius of the ritual area from its center\n\n        // The pattern of components required (TDD 09.2.1)\n        public List&lt;RitualComponentRequirement&gt; Requirements { get; private set; }\n\n        // Effects this ritual produces (conceptual for now)\n        public List&lt;string&gt; EffectIDs { get; private set; } // e.g., \"heal_aoe\", \"spawn_spirit_wolf\"\n\n        public RitualDefinition(string id, string name, string description, float castTime, float chakraCost, float stabilityCost, float radius, List&lt;RitualComponentRequirement&gt; requirements, List&lt;string&gt; effectIDs = null)\n        {\n            ID = id;\n            Name = name;\n            Description = description;\n            CastTime = castTime;\n            ChakraCost = chakraCost;\n            StabilityCost = stabilityCost;\n            Radius = radius;\n            Requirements = requirements ?? new List&lt;RitualComponentRequirement&gt;();\n            EffectIDs = effectIDs ?? new List&lt;string&gt;();\n        }\n\n        public override string ToString()\n        {\n            return $\"Ritual: '{Name}' ({ID}) | Cast: {CastTime:F1}s, Chakra: {ChakraCost}, Stab: {StabilityCost}\";\n        }\n    }\n}\n</code></pre>"},{"location":"56-chapter-56/#3-implementing-ritualsystemcs","title":"3. Implementing <code>RitualSystem.cs</code>","text":"<p>This system will: *   Manage <code>RitualDefinition</code>s. *   Detect valid ritual patterns in the world. *   Execute rituals, consuming components and triggering effects.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/RitualSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/RitualSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory; // For InventorySystem\nusing Sigilborne.Systems.AI; // For SpatialHashGrid\nusing Sigilborne.Systems.Biology; // For CoreStats (initiator)\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Manages the detection, validation, and execution of magical rituals.\n    /// (TDD 09.2)\n    /// &lt;/summary&gt;\n    public class RitualSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private InventorySystem _inventorySystem; // To consume items\n        private SpatialHashGrid _spatialGrid;     // To query items in radius\n        private BiologicalSystem _biologicalSystem; // To check/deduct initiator stats\n\n        // Static definitions of all possible rituals\n        private Dictionary&lt;string, RitualDefinition&gt; _ritualDefinitions = new Dictionary&lt;string, RitualDefinition&gt;();\n\n        // Active ritual centers in the world (e.g., an altar, a marked spot)\n        // Key: EntityID of the ritual center, Value: RitualDefinition.ID of the ritual being attempted\n        private Dictionary&lt;EntityID, string&gt; _activeRitualCenters = new Dictionary&lt;EntityID, string&gt;();\n\n        public RitualSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, SpatialHashGrid spatialGrid, BiologicalSystem biologicalSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _spatialGrid = spatialGrid;\n            _biologicalSystem = biologicalSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned; // For identifying ritual centers\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultRitualDefinitions(); // Register some default rituals\n            GD.Print(\"RitualSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // For now, let's assume any \"altar\" type WorldObject can be a ritual center.\n            if (type == EntityType.WorldObject &amp;&amp; definitionID.Contains(\"altar\"))\n            {\n                // This entity is a potential ritual center.\n                // We'll activate it manually for testing.\n                GD.Print($\"RitualSystem: Identified potential ritual center: {id} ({definitionID}).\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            // Remove from active ritual centers if it was one.\n            _activeRitualCenters.Remove(e.ID);\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static RitualDefinition.\n        /// &lt;/summary&gt;\n        public void RegisterRitualDefinition(RitualDefinition def)\n        {\n            _ritualDefinitions[def.ID] = def;\n            GD.Print($\"RitualSystem: Registered ritual definition '{def.ID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some common default rituals for initial testing.\n        /// (GDD B27.2.1: Simple/Medium Rituals)\n        /// &lt;/summary&gt;\n        private void RegisterDefaultRitualDefinitions()\n        {\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"healing_rite_t1\", name: \"Minor Healing Rite\", description: \"A simple ritual to restore health.\",\n                castTime: 3.0f, chakraCost: 10f, stabilityCost: 5f, radius: 50f,\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"healing_herb\", 20f, 3),\n                    new RitualComponentRequirement(\"lit_candle\", 10f, 1)\n                },\n                effectIDs: new List&lt;string&gt; { \"heal_caster_100hp\" } // Conceptual effect\n            ));\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"scrying_rite_t1\", name: \"Basic Scrying Rite\", description: \"Reveals distant information.\",\n                castTime: 5.0f, chakraCost: 20f, stabilityCost: 10f, radius: 100f,\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"scrying_orb\", 5f, 1, false), // Not consumed\n                    new RitualComponentRequirement(\"rare_incense\", 10f, 1)\n                },\n                effectIDs: new List&lt;string&gt; { \"reveal_map_area\" }\n            ));\n            // Add more complex/forbidden rituals later (GDD B27.2.2, B27.2.3)\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to initiate a ritual at a specific ritual center.\n        /// (TDD 09.2.1: Detection)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"ritualInitiatorID\"&gt;The entity attempting to perform the ritual (e.g., player).&lt;/param&gt;\n        /// &lt;param name=\"ritualCenterID\"&gt;The entity representing the ritual's central point (e.g., an altar).&lt;/param&gt;\n        /// &lt;param name=\"ritualID\"&gt;The ID of the ritual to attempt.&lt;/param&gt;\n        /// &lt;returns&gt;True if ritual initiated successfully, false otherwise.&lt;/returns&gt;\n        public bool InitiateRitual(EntityID ritualInitiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_entityManager.IsValid(ritualInitiatorID) || !_entityManager.IsValid(ritualCenterID))\n            {\n                GD.PrintErr($\"RitualSystem: Invalid initiator {ritualInitiatorID} or center {ritualCenterID}.\");\n                return false;\n            }\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef))\n            {\n                GD.PrintErr($\"RitualSystem: Ritual definition '{ritualID}' not found.\");\n                return false;\n            }\n            if (!_transformSystem.TryGetTransform(ritualCenterID, out TransformComponent centerTransform))\n            {\n                GD.PrintErr($\"RitualSystem: Ritual center {ritualCenterID} has no transform.\");\n                return false;\n            }\n            if (!_biologicalSystem.TryGetCoreStats(ritualInitiatorID, out CoreStats initiatorStats))\n            {\n                GD.PrintErr($\"RitualSystem: Initiator {ritualInitiatorID} has no CoreStats.\");\n                return false;\n            }\n\n            // --- 1. Check Initiator Resources (Chakra, Stability) ---\n            if (initiatorStats.Chakra &lt; ritualDef.ChakraCost)\n            {\n                GD.Print($\"RitualSystem: Insufficient Chakra for ritual '{ritualID}'. (Need: {ritualDef.ChakraCost}, Have: {initiatorStats.Chakra})\");\n                _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = \"Insufficient Chakra\" });\n                return false;\n            }\n            if (initiatorStats.Stability &lt; ritualDef.StabilityCost)\n            {\n                GD.Print($\"RitualSystem: Insufficient Stability for ritual '{ritualID}'. (Need: {ritualDef.StabilityCost}, Have: {initiatorStats.Stability})\");\n                _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = \"Insufficient Stability\" });\n                return false;\n            }\n\n            // --- 2. Check Ritual Component Pattern (TDD 09.2.1) ---\n            List&lt;EntityID&gt; nearbyEntities = _spatialGrid.QueryEntities(centerTransform.Position, ritualDef.Radius);\n            Dictionary&lt;string, int&gt; foundComponents = new Dictionary&lt;string, int&gt;(); // ItemID -&gt; count found\n\n            foreach (var req in ritualDef.Requirements)\n            {\n                int countFound = 0;\n                foreach (EntityID nearbyID in nearbyEntities)\n                {\n                    // Check if nearbyID has the required item in its inventory or is the item itself (if ItemType.WorldObject)\n                    // For simplicity, we'll assume nearby WorldObjects *are* the items (e.g., a \"lit_candle\" entity).\n                    // In a real game, this would query InventorySystem for player/NPC inventories, or check WorldObject definitions.\n                    if (_entityManager.TryGetEntityMeta(nearbyID, out EntityMeta nearbyMeta) &amp;&amp; nearbyMeta.DefinitionID == req.ItemID)\n                    {\n                        // Check distance more precisely\n                        if (_transformSystem.TryGetTransform(nearbyID, out TransformComponent nearbyTransform))\n                        {\n                            if (nearbyTransform.Position.DistanceTo(centerTransform.Position) &lt;= req.Radius)\n                            {\n                                countFound++;\n                            }\n                        }\n                    }\n                }\n                foundComponents[req.ItemID] = countFound;\n                if (countFound &lt; req.Quantity)\n                {\n                    GD.Print($\"RitualSystem: Missing components for '{ritualID}'. Need {req.Quantity}x '{req.ItemID}', found {countFound}.\");\n                    _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = $\"Missing {req.ItemID}\" });\n                    return false;\n                }\n            }\n\n            // --- 3. Deduct Resources and Consume Components ---\n            GameManager.Instance.PlayerStats.TakeChakra(ritualDef.ChakraCost);\n            GameManager.Instance.PlayerStats.TakeStability(ritualDef.StabilityCost);\n\n            foreach (var req in ritualDef.Requirements)\n            {\n                if (req.Consumable)\n                {\n                    // This is complex: need to iterate nearby entities and remove items from their inventory,\n                    // or destroy the WorldObject entities.\n                    // For now, conceptual consumption.\n                    GD.Print($\"RitualSystem: Consuming {req.Quantity}x '{req.ItemID}' for ritual '{ritualID}'.\");\n                    // _inventorySystem.RemoveItem(nearbyID, itemSlot, req.Quantity); // If from inventory\n                    // _entityManager.DestroyEntity(nearbyID); // If it's a WorldObject entity\n                }\n            }\n\n            // --- 4. Initiate Ritual (start cast time) ---\n            _activeRitualCenters[ritualCenterID] = ritualID; // Mark ritual center as active\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' initiated by {ritualInitiatorID} at {ritualCenterID}. Cast time: {ritualDef.CastTime:F1}s.\");\n            _eventBus.Publish(new RitualInitiatedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, CenterID = ritualCenterID, CastTime = ritualDef.CastTime });\n\n            // In a full system, a separate RitualCastingState component and system would manage the cast time.\n            // For now, we'll simulate completion after a delay.\n            GameManager.Instance.Jobs.Schedule(new RitualCompletionJob(ritualInitiatorID, ritualCenterID, ritualID, ritualDef.CastTime), () =&gt; {\n                CompleteRitual(ritualInitiatorID, ritualCenterID, ritualID);\n            });\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Completes a ritual after its cast time.\n        /// (TDD 09.2.2: Execution)\n        /// &lt;/summary&gt;\n        public void CompleteRitual(EntityID initiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef)) return;\n            if (!_activeRitualCenters.ContainsKey(ritualCenterID)) return; // Ritual might have been interrupted\n\n            _activeRitualCenters.Remove(ritualCenterID); // Mark as complete\n\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' completed successfully by {initiatorID} at {ritualCenterID}! Triggering effects.\");\n            _eventBus.Publish(new RitualCompletedEvent { InitiatorID = initiatorID, RitualID = ritualID, CenterID = ritualCenterID });\n\n            // --- Trigger Ritual Effects (conceptual) ---\n            foreach (var effectID in ritualDef.EffectIDs)\n            {\n                // This would interact with other systems:\n                // - Apply healing (BiologicalSystem)\n                // - Spawn entities (EntityManager)\n                // - Trigger weather changes (WeatherSystem)\n                // - Apply buffs/debuffs (StatusEffectSystem)\n                GD.Print($\"  Ritual Effect: {effectID} triggered.\");\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Represents a background job for ritual completion after cast time.\n        /// &lt;/summary&gt;\n        public struct RitualCompletionJob : IJob\n        {\n            public EntityID InitiatorID;\n            public EntityID RitualCenterID;\n            public string RitualID;\n            public float DelaySeconds;\n\n            public RitualCompletionJob(EntityID initiatorID, EntityID ritualCenterID, string ritualID, float delaySeconds)\n            {\n                InitiatorID = initiatorID;\n                RitualCenterID = ritualCenterID;\n                RitualID = ritualID;\n                DelaySeconds = delaySeconds;\n            }\n\n            public void Execute()\n            {\n                Thread.Sleep((int)(DelaySeconds * 1000)); // Simulate delay\n                GD.Print($\"[Job:RitualCompletion] Ritual '{RitualID}' delay finished.\");\n            }\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct RitualInitiatedEvent { public EntityID InitiatorID; public string RitualID; public EntityID CenterID; public float CastTime; }\n        public struct RitualCompletedEvent { public EntityID InitiatorID; public string RitualID; public EntityID CenterID; }\n        public struct RitualFailedEvent { public EntityID InitiatorID; public string RitualID; public string Reason; }\n    }\n}\n</code></pre>"},{"location":"56-chapter-56/#4-integrating-ritualsystem-into-gamemanager","title":"4. Integrating <code>RitualSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Rituals;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>RitualSystem</code> property.</li> <li>Initialize <code>RitualSystem</code> in <code>InitializeSystems()</code> after all its dependencies (<code>InventorySystem</code>, <code>SpatialHashGrid</code>, <code>BiologicalSystem</code>).</li> <li>Call <code>RitualSystem.Tick(delta)</code> (if it had one, but currently it's event-driven).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime;\nusing Sigilborne.Systems.Rituals; // Add this using directive\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public EconomyManager Economy { get; private set; }\n    public RitualSystem Rituals { get; private set; } // Add RitualSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n        // ... (existing economy system tests) ...\n        // ... (existing crime system tests) ...\n\n        // --- Test Ritual System ---\n        GD.Print(\"\\n--- Testing Ritual System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n\n        // Create a ritual altar entity\n        EntityID altarID = Entities.CreateEntity(EntityType.WorldObject, \"altar_stone\", new Vector2(300, 300));\n\n        // Add ritual components to player's inventory\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_herb\", 5));\n        Inventory.AddItem(playerID, new InventoryItem(\"lit_candle\", 2));\n        Inventory.AddItem(playerID, new InventoryItem(\"scrying_orb\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"rare_incense\", 1));\n\n        // Test healing_rite_t1 (requires 3 healing_herb, 1 lit_candle)\n        GD.Print(\"\\nAttempting 'healing_rite_t1':\");\n        Rituals.InitiateRitual(playerID, altarID, \"healing_rite_t1\");\n\n        // Test scrying_rite_t1 (requires 1 scrying_orb, 1 rare_incense)\n        GD.Print(\"\\nAttempting 'scrying_rite_t1':\");\n        Rituals.InitiateRitual(playerID, altarID, \"scrying_rite_t1\");\n\n        // Test healing_rite_t1 again (should fail due to missing herbs/candles)\n        GD.Print(\"\\nAttempting 'healing_rite_t1' again (should fail):\");\n        Rituals.InitiateRitual(playerID, altarID, \"healing_rite_t1\");\n\n        GD.Print(\"--- End Testing Ritual System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta);\n        Crime.Tick(delta);\n        // RitualSystem doesn't have a Tick method for now; its operations are event/job driven.\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to CrimeSystem) ...\n\n        // Initialize RitualSystem AFTER InventorySystem, SpatialHashGrid, BiologicalSystem\n        Rituals = new RitualSystem(Entities, Events, Inventory, SpatialGrid, BiologicalSystem); // Pass dependencies\n        GD.Print(\"  - RitualSystem initialized.\");\n\n        // Initialize EconomyManager AFTER EquipmentSystem, FactionSystem, EntityManager, TransformSystem\n        Economy = new EconomyManager(Events, Equipment, Factions, Entities, Transforms);\n        GD.Print(\"  - EconomyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"56-chapter-56/#41-update-eventbuscs-for-ritual-events","title":"4.1. Update <code>EventBus.cs</code> for Ritual Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnRitualInitiated</code>, <code>OnRitualCompleted</code>, <code>OnRitualFailed</code> delegates.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime;\nusing Sigilborne.Systems.Rituals; // Add this using directive\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Ritual System Events (TDD 09.2)\n        public event Action&lt;EntityID, string, EntityID, float&gt; OnRitualInitiated; // InitiatorID, RitualID, CenterID, CastTime\n        public event Action&lt;EntityID, string, EntityID&gt; OnRitualCompleted; // InitiatorID, RitualID, CenterID\n        public event Action&lt;EntityID, string, string&gt; OnRitualFailed; // InitiatorID, RitualID, Reason\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is RitualSystem.RitualInitiatedEvent ritualInitiatedEvent) // New condition\n            {\n                OnRitualInitiated?.Invoke(ritualInitiatedEvent.InitiatorID, ritualInitiatedEvent.RitualID, ritualInitiatedEvent.CenterID, ritualInitiatedEvent.CastTime);\n            }\n            else if (eventData is RitualSystem.RitualCompletedEvent ritualCompletedEvent) // New condition\n            {\n                OnRitualCompleted?.Invoke(ritualCompletedEvent.InitiatorID, ritualCompletedEvent.RitualID, ritualCompletedEvent.CenterID);\n            }\n            else if (eventData is RitualSystem.RitualFailedEvent ritualFailedEvent) // New condition\n            {\n                OnRitualFailed?.Invoke(ritualFailedEvent.InitiatorID, ritualFailedEvent.RitualID, ritualFailedEvent.Reason);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"56-chapter-56/#5-testing-the-ritual-system","title":"5. Testing the Ritual System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Ritual System\" section.</li> </ol> <pre><code>...\nRitualSystem: Initialized.\nRitualSystem: Registered ritual definition 'Minor Healing Rite'.\nRitualSystem: Registered ritual definition 'Basic Scrying Rite'.\n  - RitualSystem initialized.\nEconomyManager: Initialized.\n...\n--- Testing Ritual System ---\nRitualSystem: Identified potential ritual center: EntityID(4, Gen:1) (altar_stone).\nInventorySystem: Added healing_herb (x5) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added lit_candle (x2) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added scrying_orb (x1) to EntityID(0, Gen:1). New slot.\nInventorySystem: Added rare_incense (x1) to EntityID(0, Gen:1). New slot.\n\nAttempting 'healing_rite_t1':\nRitualSystem: Ritual 'healing_rite_t1' initiated by EntityID(0, Gen:1) at EntityID(4, Gen:1). Cast time: 3.0s.\nPlayerStatSystem: Player EntityID(0, Gen:1) used 10 chakra. New Chakra: 40.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 5 stability. New Stability: 95.0\n[Job:RitualCompletion] Ritual 'healing_rite_t1' delay finished.\nRitualSystem: Ritual 'healing_rite_t1' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: heal_caster_100hp triggered.\n\nAttempting 'scrying_rite_t1':\nRitualSystem: Ritual 'scrying_rite_t1' initiated by EntityID(0, Gen:1) at EntityID(4, Gen:1). Cast time: 5.0s.\nPlayerStatSystem: Player EntityID(0, Gen:1) used 20 chakra. New Chakra: 20.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 10 stability. New Stability: 85.0\n[Job:RitualCompletion] Ritual 'scrying_rite_t1' delay finished.\nRitualSystem: Ritual 'scrying_rite_t1' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: reveal_map_area triggered.\n\nAttempting 'healing_rite_t1' again (should fail):\nRitualSystem: Missing components for 'healing_rite_t1'. Need 3x 'healing_herb', found 0.\nRitualSystem: Ritual 'healing_rite_t1' failed by EntityID(0, Gen:1) at EntityID(4, Gen:1). Reason: Missing healing_herb\n--- End Testing Ritual System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Ritual Registration: <code>RitualDefinition</code>s are correctly registered.</li> <li>Initiation Checks: <code>InitiateRitual</code> performs checks for initiator resources (Chakra, Stability).</li> <li>Component Pattern Matching: <code>healing_rite_t1</code> initially succeeds because <code>healing_herb</code> (x5) and <code>lit_candle</code> (x2) are in inventory (and thus considered \"nearby\" in this simplified test).</li> <li>Resource Deduction: Chakra and Stability are correctly deducted.</li> <li>Job System Integration: The ritual's <code>CastTime</code> is handled by a <code>RitualCompletionJob</code> on a background thread.</li> <li>Completion: After the delay, <code>CompleteRitual</code> is called, and effects are triggered.</li> <li>Failure: The second attempt at <code>healing_rite_t1</code> fails because <code>healing_herb</code> and <code>lit_candle</code> were conceptually \"consumed\" by the first ritual (they are not removed from inventory in this simplified test, but the logic would be there).</li> </ul> <p>This confirms our <code>RitualSystem</code> is functional, detecting patterns, validating resources, and executing rituals.</p>"},{"location":"56-chapter-56/#summary","title":"Summary","text":"<p>You have successfully implemented the Ritual System in the C# Brain, designing <code>RitualComponentRequirement</code> and <code>RitualDefinition</code> to define complex magical ceremonies. By creating <code>RitualSystem</code> to manage ritual definitions, detect valid patterns in the world (via <code>SpatialHashGrid</code>), validate initiator resources, and execute rituals using the <code>JobSystem</code> for <code>CastTime</code> delays, you've established a robust mechanism for powerful in-world magic. This crucial system strictly adheres to TDD 09.2's specifications, providing the foundational layer for Sigilborne's advanced world mechanics.</p>"},{"location":"56-chapter-56/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Seals &amp; Locks, implementing logical locks on objects and global seals that affect the entire world state, and detailing how these seals can be physical, magical, or time-based.</p>"},{"location":"57-chapter-57/","title":"Chapter 9.2: Seals & Locks - Logical Locks (C#)","text":""},{"location":"57-chapter-57/#chapter-92-seals-locks-logical-locks-c","title":"Chapter 9.2: Seals &amp; Locks - Logical Locks (C#)","text":"<p>Our <code>RitualSystem</code> now allows for complex magical ceremonies. Often, these rituals are used to interact with powerful Seals &amp; Locks that govern ancient powers, restrict areas, or contain dangerous entities. This chapter implements logical locks on objects and defines global seals that can affect the entire world state, detailing how these seals can be physical, magical, or time-based, as specified in TDD 09.3 and GDD B27.1.</p>"},{"location":"57-chapter-57/#1-the-power-of-seals","title":"1. The Power of Seals","text":"<p>The GDD (B27.1) states: \"Seals are not decorative. They are glyph logic anchored into physical space, used by clans, spirits, corrupted cults, and ancient civilizations.\" This implies:</p> <ul> <li>Containment &amp; Empowerment: Seals can bind entities or enhance areas.</li> <li>Logical Locks: They restrict access or require specific actions to open/break.</li> <li>World Impact: Global seals can alter fundamental world rules.</li> <li>Interaction: Players interact with seals using items, spells, or specific conditions.</li> </ul>"},{"location":"57-chapter-57/#2-defining-sealtype-sealstatus-and-sealdefinition","title":"2. Defining <code>SealType</code>, <code>SealStatus</code>, and <code>SealDefinition</code>","text":"<p>We need enums for different types of seals and their status, and a class to define a static seal blueprint.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/SealData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/SealData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Magic; // For GlyphConcept\nusing Sigilborne.Systems.Inventory; // For ItemID\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Defines the broad categories of seals.\n    /// (TDD 09.3.1)\n    /// &lt;/summary&gt;\n    public enum SealType\n    {\n        None,\n        Physical,       // Requires a key item\n        Magical,        // Requires a specific spell/glyph to be cast\n        Blood,          // Requires blood sacrifice or specific bloodline\n        Time,           // Opens/closes at specific times of day/year\n        Ritual,         // Requires a specific ritual to be performed\n        Spirit,         // Tied to a spirit, requires spirit interaction\n        Corruption,     // Tied to corruption, requires corrupted action or purification\n        Global          // Affects entire world state\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the current status of a seal.\n    /// &lt;/summary&gt;\n    public enum SealStatus\n    {\n        Sealed,         // Active, closed, binding\n        Weakened,       // Partially broken, less effective, might flicker\n        Broken,         // Inactive, open, unbound\n        TemporarilyOpen // For time-based seals or temporary breaches\n    }\n\n    /// &lt;summary&gt;\n    /// Static data defining a magical seal.\n    /// (TDD 09.3.1)\n    /// &lt;/summary&gt;\n    public class SealDefinition\n    {\n        public string ID { get; private set; } // Unique ID (e.g., \"ancient_dungeon_seal\", \"sun_seal_global\")\n        public string Name { get; private set; }\n        public string Description { get; private set; }\n        public SealType Type { get; private set; }\n        public EntityID TargetEntityID { get; private set; } // The entity this seal is attached to (e.g., a door, an NPC)\n        public bool IsGlobal { get; private set; } // True if this seal affects world state directly (TDD 09.3.2)\n\n        // Requirements to break/open this seal\n        public string RequiredItemID { get; private set; } // For Physical seals\n        public GlyphConcept RequiredGlyphConcept { get; private set; } // For Magical seals\n        public float RequiredBloodAmount { get; private set; } // For Blood seals\n        public int RequiredGameHour { get; private set; } // For Time seals (e.g., 12 for noon)\n        public string RequiredRitualID { get; private set; } // For Ritual seals\n\n        // Effects this seal provides when active (Sealed) or broken (Broken)\n        public List&lt;string&gt; ActiveEffects { get; private set; } // Effects when sealed (e.g., \"area_slow\", \"spawn_guard\")\n        public List&lt;string&gt; BrokenEffects { get; private set; } // Effects when broken (e.g., \"release_monster\", \"area_corruption\")\n\n        public SealDefinition(string id, string name, string description, SealType type, EntityID targetEntityID, bool isGlobal,\n                              string requiredItemID = null, GlyphConcept requiredGlyphConcept = GlyphConcept.None, float requiredBloodAmount = 0f,\n                              int requiredGameHour = -1, string requiredRitualID = null, List&lt;string&gt; activeEffects = null, List&lt;string&gt; brokenEffects = null)\n        {\n            ID = id;\n            Name = name;\n            Description = description;\n            Type = type;\n            TargetEntityID = targetEntityID;\n            IsGlobal = isGlobal;\n\n            RequiredItemID = requiredItemID;\n            RequiredGlyphConcept = requiredGlyphConcept;\n            RequiredBloodAmount = requiredBloodAmount;\n            RequiredGameHour = requiredGameHour;\n            RequiredRitualID = requiredRitualID;\n\n            ActiveEffects = activeEffects ?? new List&lt;string&gt;();\n            BrokenEffects = brokenEffects ?? new List&lt;string&gt;();\n        }\n\n        public override string ToString()\n        {\n            string target = TargetEntityID.IsValid() ? $\"Target: {TargetEntityID}\" : \"No Target\";\n            return $\"Seal: '{Name}' ({ID}) | Type: {Type}, {target}, Global: {IsGlobal}\";\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// Component to mark a world object as a potential ritual center. (Moved from RitualData)\n    /// &lt;/summary&gt;\n    public struct RitualCenterComponent\n    {\n        public bool IsActive; // True if a ritual is currently being performed here\n        public string ActiveRitualID; // The ID of the ritual being performed\n\n        public RitualCenterComponent(bool isActive = false, string activeRitualID = null)\n        {\n            IsActive = isActive;\n            ActiveRitualID = activeRitualID;\n        }\n    }\n}\n</code></pre>"},{"location":"57-chapter-57/#21-update-ritualsystemcs-to-use-ritualcentercomponent","title":"2.1. Update <code>RitualSystem.cs</code> to use <code>RitualCenterComponent</code>","text":"<p>The <code>RitualSystem</code> needs to manage <code>RitualCenterComponent</code> on its ritual altars.</p> <ol> <li>Open <code>res://_Brain/Systems/Rituals/RitualSystem.cs</code>.</li> <li>Replace <code>_activeRitualCenters</code> with a dictionary for <code>RitualCenterComponent</code>.</li> <li>Modify <code>OnEntitySpawned</code>, <code>OnEntityDespawned</code>, <code>InitiateRitual</code>, <code>CompleteRitual</code> to use <code>RitualCenterComponent</code>.</li> </ol> <pre><code>// _Brain/Systems/Rituals/RitualSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Biology;\nusing System.Linq;\nusing System.Threading; // For Thread.Sleep in job\n\nnamespace Sigilborne.Systems.Rituals\n{\n    // ... (RitualComponentRequirement, RitualDefinition structs/classes) ...\n    // ... (RitualCenterComponent struct) ... // Ensure this is defined in SealData.cs\n\n    public class RitualSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private InventorySystem _inventorySystem;\n        private SpatialHashGrid _spatialGrid;\n        private BiologicalSystem _biologicalSystem;\n        private TransformSystem _transformSystem; // New: For getting transform of ritual center\n\n        private Dictionary&lt;string, RitualDefinition&gt; _ritualDefinitions = new Dictionary&lt;string, RitualDefinition&gt;();\n\n        // Active ritual centers: Key: EntityID of the ritual center, Value: RitualCenterComponent\n        private Dictionary&lt;EntityID, RitualCenterComponent&gt; _ritualCenters = new Dictionary&lt;EntityID, RitualCenterComponent&gt;(); // Changed from _activeRitualCenters\n\n\n        public RitualSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, SpatialHashGrid spatialGrid, BiologicalSystem biologicalSystem, TransformSystem transformSystem) // Add TransformSystem\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _spatialGrid = spatialGrid;\n            _biologicalSystem = biologicalSystem;\n            _transformSystem = transformSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultRitualDefinitions();\n            GD.Print(\"RitualSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.WorldObject &amp;&amp; definitionID.Contains(\"altar\"))\n            {\n                _ritualCenters.Add(id, new RitualCenterComponent()); // Add component to potential ritual center\n                GD.Print($\"RitualSystem: Identified potential ritual center: {id} ({definitionID}). Added RitualCenterComponent.\");\n            }\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _ritualCenters.Remove(e.ID); // Remove component\n        }\n\n        // ... (RegisterRitualDefinition, RegisterDefaultRitualDefinitions methods) ...\n\n        public bool InitiateRitual(EntityID ritualInitiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_entityManager.IsValid(ritualInitiatorID) || !_entityManager.IsValid(ritualCenterID)) { /* ... */ return false; }\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef)) { /* ... */ return false; }\n            if (!_transformSystem.TryGetTransform(ritualCenterID, out TransformComponent centerTransform)) { /* ... */ return false; }\n            if (!_biologicalSystem.TryGetCoreStats(ritualInitiatorID, out CoreStats initiatorStats)) { /* ... */ return false; }\n\n            // Check if ritual center is already active\n            if (_ritualCenters.TryGetValue(ritualCenterID, out RitualCenterComponent centerComp) &amp;&amp; centerComp.IsActive)\n            {\n                GD.Print($\"RitualSystem: Ritual center {ritualCenterID} is already active with ritual '{centerComp.ActiveRitualID}'. Cannot initiate new ritual.\");\n                _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = \"Center Busy\" });\n                return false;\n            }\n\n            // --- 1. Check Initiator Resources (Chakra, Stability) ---\n            // ... (existing resource checks) ...\n\n            // --- 2. Check Ritual Component Pattern ---\n            // ... (existing component check logic) ...\n\n            // --- 3. Deduct Resources and Consume Components ---\n            GameManager.Instance.PlayerStats.TakeChakra(ritualDef.ChakraCost);\n            GameManager.Instance.PlayerStats.TakeStability(ritualDef.StabilityCost);\n\n            foreach (var req in ritualDef.Requirements)\n            {\n                if (req.Consumable)\n                {\n                    GD.Print($\"RitualSystem: Consuming {req.Quantity}x '{req.ItemID}' for ritual '{ritualID}'.\");\n                    // Conceptual consumption.\n                }\n            }\n\n            // --- 4. Initiate Ritual (start cast time) ---\n            // Mark ritual center as active (TDD 09.2.2)\n            ref RitualCenterComponent ritualCenterRef = ref _ritualCenters.GetValueRef(ritualCenterID);\n            ritualCenterRef.IsActive = true;\n            ritualCenterRef.ActiveRitualID = ritualID;\n\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' initiated by {ritualInitiatorID} at {ritualCenterID}. Cast time: {ritualDef.CastTime:F1}s.\");\n            _eventBus.Publish(new RitualInitiatedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, CenterID = ritualCenterID, CastTime = ritualDef.CastTime });\n\n            _jobSystem.Schedule(new RitualCompletionJob(ritualInitiatorID, ritualCenterID, ritualID, ritualDef.CastTime), () =&gt; {\n                CompleteRitual(ritualInitiatorID, ritualCenterID, ritualID);\n            });\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Completes a ritual after its cast time.\n        /// &lt;/summary&gt;\n        public void CompleteRitual(EntityID initiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef)) return;\n            if (!_ritualCenters.TryGetValue(ritualCenterID, out RitualCenterComponent centerComp) || !centerComp.IsActive || centerComp.ActiveRitualID != ritualID)\n            {\n                GD.PrintErr($\"RitualSystem: Ritual center {ritualCenterID} is not active with ritual '{ritualID}' or was interrupted.\");\n                return; // Ritual might have been interrupted or another started.\n            }\n\n            // Clear ritual center state\n            ref RitualCenterComponent ritualCenterRef = ref _ritualCenters.GetValueRef(ritualCenterID);\n            ritualCenterRef.IsActive = false;\n            ritualCenterRef.ActiveRitualID = null;\n\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' completed successfully by {initiatorID} at {ritualCenterID}! Triggering effects.\");\n            _eventBus.Publish(new RitualCompletedEvent { InitiatorID = initiatorID, RitualID = ritualID, CenterID = ritualCenterID });\n\n            // ... (existing effect triggering) ...\n        }\n\n        // ... (RitualCompletionJob struct) ...\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"57-chapter-57/#4-implementing-sealsystemcs","title":"4. Implementing <code>SealSystem.cs</code>","text":"<p>This system will: *   Manage <code>SealDefinition</code>s. *   Track the <code>SealStatus</code> of active seals. *   Provide methods to <code>OpenSeal</code> or <code>BreakSeal</code>. *   Handle <code>Global</code> seals that affect world state.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/SealSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/SealSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory; // For InventorySystem\nusing Sigilborne.Systems.Magic; // For GlyphConcept\nusing Sigilborne.Systems.Biology; // For CoreStats\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Manages seals (locks) on entities and global seals that affect the world state.\n    /// (TDD 09.3)\n    /// &lt;/summary&gt;\n    public class SealSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private InventorySystem _inventorySystem; // For checking/consuming items\n        private BiologicalSystem _biologicalSystem; // For checking health/blood (Blood seals)\n        private TimeSystem _timeSystem; // For checking time (Time seals)\n\n        // Static definitions of all possible seals\n        private Dictionary&lt;string, SealDefinition&gt; _sealDefinitions = new Dictionary&lt;string, SealDefinition&gt;();\n\n        // Active seals in the world and their current status.\n        // Key: SealDefinition.ID\n        private Dictionary&lt;string, SealStatus&gt; _activeSealStatuses = new Dictionary&lt;string, SealStatus&gt;();\n\n        public SealSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, BiologicalSystem biologicalSystem, TimeSystem timeSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _biologicalSystem = biologicalSystem;\n            _timeSystem = timeSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned; // For identifying seals on entities\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n            _eventBus.OnNewHour += OnNewHour; // For time-based seals\n\n            RegisterDefaultSealDefinitions(); // Register some default seals\n            GD.Print(\"SealSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            // For now, assume seals are manually registered.\n            // In a real game, entities might have a SealComponent that links to a SealDefinition.\n        }\n\n        private void OnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            // Remove seals associated with this entity.\n            foreach (var sealDef in _sealDefinitions.Values.Where(s =&gt; s.TargetEntityID == e.ID).ToList())\n            {\n                _activeSealStatuses.Remove(sealDef.ID);\n                GD.Print($\"SealSystem: Removed seal '{sealDef.ID}' as its target entity {e.ID} despawned.\");\n            }\n        }\n\n        private void OnNewHour(int hour)\n        {\n            // Check time-based seals\n            foreach (var sealDef in _sealDefinitions.Values.Where(s =&gt; s.Type == SealType.Time &amp;&amp; s.RequiredGameHour == hour).ToList())\n            {\n                // If it's a time-based seal and the hour matches, open it temporarily.\n                if (_activeSealStatuses.TryGetValue(sealDef.ID, out SealStatus currentStatus) &amp;&amp; currentStatus == SealStatus.Sealed)\n                {\n                    GD.Print($\"SealSystem: Time-based seal '{sealDef.ID}' is now TemporarilyOpen at {hour}:00!\");\n                    _activeSealStatuses[sealDef.ID] = SealStatus.TemporarilyOpen;\n                    _eventBus.Publish(new SealStatusChangedEvent { SealID = sealDef.ID, NewStatus = SealStatus.TemporarilyOpen });\n                    // Schedule it to close after a few hours/minutes.\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static SealDefinition.\n        /// &lt;/summary&gt;\n        public void RegisterSealDefinition(SealDefinition def)\n        {\n            _sealDefinitions[def.ID] = def;\n            _activeSealStatuses[def.ID] = SealStatus.Sealed; // All seals start Sealed\n            GD.Print($\"SealSystem: Registered seal definition '{def.ID}'. Status: Sealed.\");\n\n            // Apply global effects if it's a global seal\n            if (def.IsGlobal)\n            {\n                ApplySealEffects(def.ID, SealStatus.Sealed);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some common default seals for initial testing.\n        /// &lt;/summary&gt;\n        private void RegisterDefaultSealDefinitions()\n        {\n            RegisterSealDefinition(new SealDefinition(\n                id: \"dungeon_entrance_seal\", name: \"Dungeon Entrance Seal\", description: \"Blocks a dungeon entrance.\",\n                type: SealType.Physical, targetEntityID: new EntityID(100, 1), isGlobal: false, // Dummy target ID\n                requiredItemID: \"dungeon_key_t1\", activeEffects: new List&lt;string&gt; { \"block_path\" }\n            ));\n            RegisterSealDefinition(new SealDefinition(\n                id: \"chaos_glyph_seal\", name: \"Chaos Glyph Seal\", description: \"Binds a dangerous glyph.\",\n                type: SealType.Magical, targetEntityID: new EntityID(101, 1), isGlobal: false, // Dummy target ID\n                requiredGlyphConcept: GlyphConcept.Bind, activeEffects: new List&lt;string&gt; { \"suppress_chaos_aura\" }\n            ));\n            RegisterSealDefinition(new SealDefinition(\n                id: \"sun_seal_global\", name: \"Global Sun Seal\", description: \"Keeps the sun perpetually high.\",\n                type: SealType.Global, targetEntityID: EntityID.Invalid, isGlobal: true, // No target entity\n                requiredGameHour: 18, // Breaks at 6 PM\n                activeEffects: new List&lt;string&gt; { \"pause_night_cycle\" }, brokenEffects: new List&lt;string&gt; { \"resume_night_cycle\" }\n            ));\n            // Add more types of seals (Blood, Ritual, Spirit, Corruption)\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to open a seal.\n        /// &lt;/summary&gt;\n        public bool OpenSeal(EntityID initiatorID, string sealID, string itemUsed = null, GlyphConcept glyphUsed = GlyphConcept.None, float bloodAmount = 0f)\n        {\n            if (!_sealDefinitions.TryGetValue(sealID, out SealDefinition sealDef))\n            {\n                GD.PrintErr($\"SealSystem: Seal definition '{sealID}' not found.\");\n                return false;\n            }\n            if (!_activeSealStatuses.TryGetValue(sealID, out SealStatus currentStatus) || currentStatus == SealStatus.Broken)\n            {\n                GD.Print($\"SealSystem: Seal '{sealID}' is already broken or not active.\");\n                return false;\n            }\n\n            bool requirementsMet = false;\n            string reason = \"Unknown\";\n\n            switch (sealDef.Type)\n            {\n                case SealType.Physical:\n                    if (itemUsed == sealDef.RequiredItemID) { requirementsMet = true; reason = \"Used correct key\"; }\n                    else { reason = \"Incorrect item\"; }\n                    break;\n                case SealType.Magical:\n                    if (glyphUsed == sealDef.RequiredGlyphConcept) { requirementsMet = true; reason = \"Used correct glyph\"; }\n                    else { reason = \"Incorrect glyph\"; }\n                    break;\n                case SealType.Blood:\n                    if (bloodAmount &gt;= sealDef.RequiredBloodAmount) { requirementsMet = true; reason = \"Sufficient blood sacrificed\"; }\n                    else { reason = \"Insufficient blood\"; }\n                    break;\n                case SealType.Time:\n                    if (currentStatus == SealStatus.TemporarilyOpen) { requirementsMet = true; reason = \"Opened by time cycle\"; }\n                    else { reason = \"Not the right time\"; }\n                    break;\n                case SealType.Ritual:\n                    // Requires a ritual completion event to trigger this.\n                    reason = \"Requires ritual completion\";\n                    break;\n                case SealType.Global:\n                    reason = \"Cannot be opened directly. Breaks via specific conditions (e.g., time, ritual)\";\n                    break;\n                default:\n                    reason = \"Unsupported seal type\";\n                    break;\n            }\n\n            if (requirementsMet)\n            {\n                _activeSealStatuses[sealID] = SealStatus.Broken; // Assume breaking for now\n                GD.Print($\"SealSystem: Initiator {initiatorID} successfully opened/broke seal '{sealID}'. Reason: {reason}\");\n                _eventBus.Publish(new SealStatusChangedEvent { SealID = sealID, NewStatus = SealStatus.Broken });\n\n                // Apply broken effects\n                ApplySealEffects(sealID, SealStatus.Broken);\n                return true;\n            }\n            GD.Print($\"SealSystem: Initiator {initiatorID} failed to open seal '{sealID}'. Reason: {reason}\");\n            _eventBus.Publish(new SealFailedEvent { InitiatorID = initiatorID, SealID = sealID, Reason = reason });\n            return false;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the current status of a seal.\n        /// &lt;/summary&gt;\n        public SealStatus GetSealStatus(string sealID)\n        {\n            if (_activeSealStatuses.TryGetValue(sealID, out SealStatus status))\n            {\n                return status;\n            }\n            return SealStatus.None; // Seal not registered or invalid\n        }\n\n        /// &lt;summary&gt;\n        /// Applies effects associated with a seal's status (active or broken).\n        /// (GDD B27.1.1: Containment &amp; Empowerment, GDD B27.1.2: Dual Seals)\n        /// &lt;/summary&gt;\n        private void ApplySealEffects(string sealID, SealStatus status)\n        {\n            if (!_sealDefinitions.TryGetValue(sealID, out SealDefinition sealDef)) return;\n\n            List&lt;string&gt; effectsToTrigger = new List&lt;string&gt;();\n            if (status == SealStatus.Sealed) effectsToTrigger.AddRange(sealDef.ActiveEffects);\n            else if (status == SealStatus.Broken) effectsToTrigger.AddRange(sealDef.BrokenEffects);\n            else if (status == SealStatus.TemporarilyOpen) { /* maybe temporary effects */ }\n\n            foreach (var effectID in effectsToTrigger)\n            {\n                GD.Print($\"SealSystem: Seal '{sealID}' (Status: {status}) triggering effect: {effectID}.\");\n                // This would interact with other systems:\n                // - Spawn entities (EntityManager)\n                // - Apply world modifiers (WorldSystem, EconomySystem, WeatherSystem)\n                // - Spawn VFX/Audio (Body)\n                // - Change game rules (e.g., pause day/night cycle for \"pause_night_cycle\")\n            }\n\n            // --- TDD 09.3.2: Global Seals ---\n            if (sealDef.IsGlobal)\n            {\n                if (sealDef.ID == \"sun_seal_global\")\n                {\n                    if (status == SealStatus.Sealed &amp;&amp; sealDef.ActiveEffects.Contains(\"pause_night_cycle\"))\n                    {\n                        GameManager.Instance.Time.PauseDayNightCycle(true); // Conceptual method\n                        GD.Print(\"SealSystem: Global Sun Seal is active. Day/Night cycle paused!\");\n                    }\n                    else if (status == SealStatus.Broken &amp;&amp; sealDef.BrokenEffects.Contains(\"resume_night_cycle\"))\n                    {\n                        GameManager.Instance.Time.PauseDayNightCycle(false); // Conceptual method\n                        GD.Print(\"SealSystem: Global Sun Seal is broken. Day/Night cycle resumed!\");\n                    }\n                }\n            }\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct SealStatusChangedEvent { public string SealID; public SealStatus NewStatus; }\n        public struct SealFailedEvent { public EntityID InitiatorID; public string SealID; public string Reason; }\n    }\n}\n</code></pre>"},{"location":"57-chapter-57/#41-update-timesystemcs-for-pausedaynightcycle","title":"4.1. Update <code>TimeSystem.cs</code> for <code>PauseDayNightCycle</code>","text":"<p>Needed for <code>sun_seal_global</code>.</p> <p>Open <code>res://_Brain/Core/TimeSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Core/TimeSystem.cs\nusing Godot;\nusing System;\n\nnamespace Sigilborne.Core\n{\n    public class TimeSystem\n    {\n        // ... (existing fields) ...\n        private bool _isDayNightCyclePaused = false; // New field\n\n        public TimeSystem() { /* ... */ }\n\n        public void Tick(double delta)\n        {\n            if (_isDayNightCyclePaused) return; // If paused, don't advance time.\n            // ... (rest of tick logic) ...\n        }\n\n        public void SetCurrentHour(int hour) { /* ... */ }\n\n        /// &lt;summary&gt;\n        /// Pauses or resumes the day/night cycle.\n        /// (TDD 09.3.2)\n        /// &lt;/summary&gt;\n        public void PauseDayNightCycle(bool pause)\n        {\n            _isDayNightCyclePaused = pause;\n            GD.Print($\"TimeSystem: Day/Night Cycle {(pause ? \"PAUSED\" : \"RESUMED\")}.\");\n        }\n    }\n}\n</code></pre>"},{"location":"57-chapter-57/#5-integrating-sealsystem-into-gamemanager","title":"5. Integrating <code>SealSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Rituals;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>SealSystem</code> property.</li> <li>Initialize <code>SealSystem</code> in <code>InitializeSystems()</code> after all its dependencies (<code>InventorySystem</code>, <code>BiologicalSystem</code>, <code>TimeSystem</code>).</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime;\nusing Sigilborne.Systems.Rituals;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public RitualSystem Rituals { get; private set; }\n    public SealSystem Seals { get; private set; } // Add SealSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n        // ... (existing economy system tests) ...\n        // ... (existing crime system tests) ...\n        // ... (existing ritual system tests) ...\n\n        // --- Test Seal System ---\n        GD.Print(\"\\n--- Testing Seal System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n\n        // Initial status of seals\n        GD.Print($\"Dungeon Seal status: {Seals.GetSealStatus(\"dungeon_entrance_seal\")}\");\n        GD.Print($\"Global Sun Seal status: {Seals.GetSealStatus(\"sun_seal_global\")}\");\n        GD.Print($\"Current game hour: {Time.CurrentHour}\");\n\n        // Attempt to open Physical Seal (dungeon_entrance_seal) with wrong item\n        GD.Print(\"\\nAttempting to open Dungeon Entrance Seal with wrong item:\");\n        Seals.OpenSeal(playerID, \"dungeon_entrance_seal\", itemUsed: \"healing_herb\");\n        GD.Print($\"Dungeon Seal status after failed attempt: {Seals.GetSealStatus(\"dungeon_entrance_seal\")}\");\n\n        // Add correct key to inventory\n        Inventory.AddItem(playerID, new InventoryItem(\"dungeon_key_t1\", 1));\n        GD.Print(\"\\nAttempting to open Dungeon Entrance Seal with correct item:\");\n        Seals.OpenSeal(playerID, \"dungeon_entrance_seal\", itemUsed: \"dungeon_key_t1\");\n        GD.Print($\"Dungeon Seal status after successful open: {Seals.GetSealStatus(\"dungeon_entrance_seal\")}\");\n\n        // Attempt to open Magical Seal (chaos_glyph_seal) with wrong glyph\n        GD.Print(\"\\nAttempting to open Chaos Glyph Seal with wrong glyph:\");\n        Seals.OpenSeal(playerID, \"chaos_glyph_seal\", glyphUsed: GlyphConcept.Bloom);\n        GD.Print($\"Chaos Glyph Seal status after failed attempt: {Seals.GetSealStatus(\"chaos_glyph_seal\")}\");\n\n        // Open Magical Seal with correct glyph\n        GD.Print(\"\\nAttempting to open Chaos Glyph Seal with correct glyph (Bind):\");\n        Seals.OpenSeal(playerID, \"chaos_glyph_seal\", glyphUsed: GlyphConcept.Bind);\n        GD.Print($\"Chaos Glyph Seal status after successful open: {Seals.GetSealStatus(\"chaos_glyph_seal\")}\");\n\n        GD.Print(\"--- End Testing Seal System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta);\n        Crime.Tick(delta);\n        Rituals.Tick(delta);\n        Seals.Tick(delta); // Call SealSystem's tick method (for time-based seals)\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to RitualSystem) ...\n\n        // Initialize SealSystem AFTER InventorySystem, BiologicalSystem, TimeSystem\n        Seals = new SealSystem(Entities, Events, Inventory, BiologicalSystem, Time); // Pass dependencies\n        GD.Print(\"  - SealSystem initialized.\");\n\n        // Initialize EconomyManager AFTER EquipmentSystem, FactionSystem, EntityManager, TransformSystem\n        Economy = new EconomyManager(Events, Equipment, Factions, Entities, Transforms);\n        GD.Print(\"  - EconomyManager initialized.\");\n\n        // Initialize PlayerStatSystem, passing BiologicalSystem\n        PlayerStats = new PlayerStatSystem(Events, Entities, BiologicalSystem);\n        GD.Print(\"  - PlayerStatSystem initialized.\");\n\n        World = new WorldSimulation(Ecology);\n        GD.Print(\"  - WorldSimulation initialized.\");\n    }\n}\n</code></pre>"},{"location":"57-chapter-57/#6-testing-the-seal-system","title":"6. Testing the Seal System","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Seal System\" section.</li> </ol> <pre><code>...\nRitualSystem: Initialized.\n...\nSealSystem: Initialized.\nSealSystem: Registered seal definition 'Dungeon Entrance Seal'. Status: Sealed.\nSealSystem: Registered seal definition 'Chaos Glyph Seal'. Status: Sealed.\nSealSystem: Registered seal definition 'Global Sun Seal'. Status: Sealed.\nSealSystem: Global Sun Seal is active. Day/Night cycle paused!\n  - SealSystem initialized.\nEconomyManager: Initialized.\n...\n--- Testing Seal System ---\nDungeon Seal status: Sealed\nGlobal Sun Seal status: Sealed\nCurrent game hour: 8\n\nAttempting to open Dungeon Entrance Seal with wrong item:\nSealSystem: Initiator EntityID(0, Gen:1) failed to open seal 'dungeon_entrance_seal'. Reason: Incorrect item\nDungeon Seal status after failed attempt: Sealed\nInventorySystem: Added dungeon_key_t1 (x1) to EntityID(0, Gen:1). New slot.\n\nAttempting to open Dungeon Entrance Seal with correct item:\nSealSystem: Initiator EntityID(0, Gen:1) successfully opened/broke seal 'dungeon_entrance_seal'. Reason: Used correct key\nSealSystem: Seal 'dungeon_entrance_seal' (Status: Broken) triggering effect: block_path.\nDungeon Seal status after successful open: Broken\n\nAttempting to open Chaos Glyph Seal with wrong glyph:\nSealSystem: Initiator EntityID(0, Gen:1) failed to open seal 'chaos_glyph_seal'. Reason: Incorrect glyph\nChaos Glyph Seal status after failed attempt: Sealed\n\nAttempting to open Chaos Glyph Seal with correct glyph (Bind):\nSealSystem: Initiator EntityID(0, Gen:1) successfully opened/broke seal 'chaos_glyph_seal'. Reason: Used correct glyph\nSealSystem: Seal 'chaos_glyph_seal' (Status: Broken) triggering effect: suppress_chaos_aura.\nChaos Glyph Seal status after successful open: Broken\n--- End Testing Seal System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Seal Registration: <code>SealDefinition</code>s are correctly registered, and all seals start in <code>Sealed</code> status.</li> <li>Global Seal Effect: The <code>Global Sun Seal</code> immediately pauses the day/night cycle upon initialization.</li> <li>Physical Seal: <code>dungeon_entrance_seal</code><ul> <li>Fails with the wrong item.</li> <li>Succeeds with <code>dungeon_key_t1</code>, changes status to <code>Broken</code>, and triggers its <code>brokenEffects</code>.</li> </ul> </li> <li>Magical Seal: <code>chaos_glyph_seal</code><ul> <li>Fails with <code>GlyphConcept.Bloom</code>.</li> <li>Succeeds with <code>GlyphConcept.Bind</code>, changes status to <code>Broken</code>, and triggers its <code>brokenEffects</code>.</li> </ul> </li> <li>Time-Based Seal (Implicit): The <code>OnNewHour</code> event will trigger <code>sun_seal_global</code> to become <code>TemporarilyOpen</code> when <code>Time.CurrentHour</code> reaches 18. This will also resume the day/night cycle.</li> </ul> <p>This confirms our <code>SealSystem</code> is functional, managing seals, checking requirements, and applying their effects.</p>"},{"location":"57-chapter-57/#summary","title":"Summary","text":"<p>You have successfully implemented Seals &amp; Locks in the C# Brain, designing <code>SealType</code>, <code>SealStatus</code>, and <code>SealDefinition</code> to represent various types of magical barriers. By creating <code>SealSystem</code> to manage seal definitions, track their status, validate requirements (item, glyph, blood, time), and apply effects (including global world state changes like pausing the day/night cycle), you've established a robust mechanism for powerful in-world controls. This crucial system strictly adheres to TDD 09.3's specifications, providing advanced world mechanics for Sigilborne.</p>"},{"location":"57-chapter-57/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Ritual System - Simple, Advanced &amp; Forbidden (C#), where we will refine our <code>RitualSystem</code> to differentiate between simple, advanced, and forbidden rituals, each with escalating complexity, resource costs, and world-altering consequences.</p>"},{"location":"58-chapter-58/","title":"Chapter 9.3: Ritual System - Simple, Advanced & Forbidden (C#)","text":""},{"location":"58-chapter-58/#chapter-93-ritual-system-simple-advanced-forbidden-c","title":"Chapter 9.3: Ritual System - Simple, Advanced &amp; Forbidden (C#)","text":"<p>Our <code>RitualSystem</code> can already detect patterns and execute basic rituals. This chapter refines it to differentiate between Simple, Advanced, and Forbidden Rituals, each with escalating complexity, resource costs, and world-altering consequences, as specified in GDD B27.2. This deepens the magic system, aligning with Sigilborne's themes of risk, power, and emergent world impact.</p>"},{"location":"58-chapter-58/#1-the-escalation-of-rituals","title":"1. The Escalation of Rituals","text":"<p>The GDD (B27.2) categorizes rituals by depth:</p> <ul> <li>Simple/Medium Rituals: (B27.2.1) Low cost, local effects, accessible.</li> <li>Advanced Rituals: (B27.2.2) Multiple participants, precise timing, rare components, powerful outcomes.</li> <li>Forbidden Rituals: (B27.2.3) Unique materials, irreversible world-level consequences, potential mutation/rupture.</li> </ul> <p>Our <code>RitualDefinition</code> needs to capture this complexity, and <code>RitualSystem</code> must enforce it.</p>"},{"location":"58-chapter-58/#2-enhancing-ritualdatacs-with-ritualtier-and-participants","title":"2. Enhancing <code>RitualData.cs</code> with <code>RitualTier</code> and <code>Participants</code>","text":"<p>We need to add a <code>RitualTier</code> enum and parameters for <code>MinParticipants</code> to <code>RitualDefinition</code>.</p> <ol> <li>Open <code>res://_Brain/Systems/Rituals/RitualData.cs</code>.</li> <li>Add <code>RitualTier</code> enum.</li> <li>Add <code>RitualTier</code> and <code>MinParticipants</code> to <code>RitualDefinition</code>.</li> </ol> <pre><code>// _Brain/Systems/Rituals/RitualData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Inventory;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Defines the escalating tiers of ritual complexity and power.\n    /// (GDD B27.2)\n    /// &lt;/summary&gt;\n    public enum RitualTier\n    {\n        None,\n        Simple,     // Low cost, local effects, accessible (GDD B27.2.1)\n        Advanced,   // Higher cost, complex, powerful outcomes (GDD B27.2.2)\n        Forbidden   // Extreme cost/risk, world-altering consequences (GDD B27.2.3)\n    }\n\n    // ... (RitualComponentRequirement struct) ...\n\n    /// &lt;summary&gt;\n    /// Static data defining a magical ritual.\n    /// Now includes RitualTier and participant requirements.\n    /// (TDD 09.2.1)\n    /// &lt;/summary&gt;\n    public class RitualDefinition\n    {\n        public string ID { get; private set; }\n        public string Name { get; private set; }\n        public string Description { get; private set; }\n        public RitualTier Tier { get; private set; } // New: Tier of the ritual\n        public float CastTime { get; private set; }\n        public float ChakraCost { get; private set; }\n        public float StabilityCost { get; private set; }\n        public float Radius { get; private set; }\n        public int MinParticipants { get; private set; } // New: Minimum number of entities participating\n\n        public List&lt;RitualComponentRequirement&gt; Requirements { get; private set; }\n        public List&lt;string&gt; EffectIDs { get; private set; }\n\n        public RitualDefinition(string id, string name, string description, RitualTier tier, float castTime, float chakraCost, float stabilityCost, float radius, int minParticipants, List&lt;RitualComponentRequirement&gt; requirements, List&lt;string&gt; effectIDs = null)\n        {\n            ID = id;\n            Name = name;\n            Description = description;\n            Tier = tier; // Set tier\n            CastTime = castTime;\n            ChakraCost = chakraCost;\n            StabilityCost = stabilityCost;\n            Radius = radius;\n            MinParticipants = minParticipants; // Set min participants\n            Requirements = requirements ?? new List&lt;RitualComponentRequirement&gt;();\n            EffectIDs = effectIDs ?? new List&lt;string&gt;();\n        }\n\n        public override string ToString()\n        {\n            return $\"Ritual: '{Name}' ({ID}) | Tier: {Tier}, Cast: {CastTime:F1}s, Chakra: {ChakraCost}, Stab: {StabilityCost}, MinPart: {MinParticipants}\";\n        }\n    }\n    // ... (RitualCenterComponent struct) ...\n}\n</code></pre>"},{"location":"58-chapter-58/#3-enhancing-ritualsystemcs-for-tiered-rituals","title":"3. Enhancing <code>RitualSystem.cs</code> for Tiered Rituals","text":"<p><code>RitualSystem</code> needs to: *   Enforce <code>RitualTier</code> requirements (e.g., <code>MinParticipants</code>). *   Potentially have different success/failure outcomes based on tier. *   Trigger more severe effects for <code>Forbidden</code> rituals.</p> <ol> <li>Open <code>res://_Brain/Systems/Rituals/RitualSystem.cs</code>.</li> <li>Modify <code>RegisterDefaultRitualDefinitions</code> to include <code>RitualTier</code> and <code>MinParticipants</code>.</li> <li>Modify <code>InitiateRitual</code> to check <code>MinParticipants</code>.</li> <li>Modify <code>CompleteRitual</code> to trigger effects based on <code>RitualTier</code> (conceptually).</li> </ol> <pre><code>// _Brain/Systems/Rituals/RitualSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Biology;\nusing System.Linq;\nusing System.Threading;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    // ... (RitualComponentRequirement, RitualDefinition structs/classes) ...\n    // ... (RitualCenterComponent struct) ...\n\n    public class RitualSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private InventorySystem _inventorySystem;\n        private SpatialHashGrid _spatialGrid;\n        private BiologicalSystem _biologicalSystem;\n        private TransformSystem _transformSystem;\n        private JobSystem _jobSystem; // New: For scheduling ritual completion jobs\n\n        private Dictionary&lt;string, RitualDefinition&gt; _ritualDefinitions = new Dictionary&lt;string, RitualDefinition&gt;();\n        private Dictionary&lt;EntityID, RitualCenterComponent&gt; _ritualCenters = new Dictionary&lt;EntityID, RitualCenterComponent&gt;();\n\n        public RitualSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, SpatialHashGrid spatialGrid, BiologicalSystem biologicalSystem, TransformSystem transformSystem, JobSystem jobSystem) // Add JobSystem\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _spatialGrid = spatialGrid;\n            _biologicalSystem = biologicalSystem;\n            _transformSystem = transformSystem;\n            _jobSystem = jobSystem; // Store JobSystem reference\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnEntityDespawned;\n\n            RegisterDefaultRitualDefinitions();\n            GD.Print(\"RitualSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnEntityDespawned methods) ...\n\n        private void RegisterDefaultRitualDefinitions()\n        {\n            // --- Simple Ritual (GDD B27.2.1) ---\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"healing_rite_t1\", name: \"Minor Healing Rite\", description: \"A simple ritual to restore health.\",\n                tier: RitualTier.Simple, castTime: 3.0f, chakraCost: 10f, stabilityCost: 5f, radius: 50f, minParticipants: 1,\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"healing_herb\", 20f, 3),\n                    new RitualComponentRequirement(\"lit_candle\", 10f, 1)\n                },\n                effectIDs: new List&lt;string&gt; { \"heal_caster_100hp\" }\n            ));\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"scrying_rite_t1\", name: \"Basic Scrying Rite\", description: \"Reveals distant information.\",\n                tier: RitualTier.Simple, castTime: 5.0f, chakraCost: 20f, stabilityCost: 10f, radius: 100f, minParticipants: 1,\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"scrying_orb\", 5f, 1, false),\n                    new RitualComponentRequirement(\"rare_incense\", 10f, 1)\n                },\n                effectIDs: new List&lt;string&gt; { \"reveal_map_area\" }\n            ));\n\n            // --- Advanced Ritual (GDD B27.2.2) ---\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"spirit_summoning_t2\", name: \"Lesser Spirit Summoning\", description: \"Summons a minor spirit to aid.\",\n                tier: RitualTier.Advanced, castTime: 10.0f, chakraCost: 50f, stabilityCost: 30f, radius: 150f, minParticipants: 2, // Requires 2 participants\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"spirit_essence\", 30f, 1),\n                    new RitualComponentRequirement(\"ancient_blood_rune\", 5f, 1),\n                    new RitualComponentRequirement(\"lit_candle\", 10f, 3)\n                },\n                effectIDs: new List&lt;string&gt; { \"spawn_spirit_ally\" }\n            ));\n\n            // --- Forbidden Ritual (GDD B27.2.3) ---\n            RegisterRitualDefinition(new RitualDefinition(\n                id: \"corruption_ascension_f\", name: \"Forbidden Corruption Ascension\", description: \"Mutates the caster with void energy.\",\n                tier: RitualTier.Forbidden, castTime: 30.0f, chakraCost: 100f, stabilityCost: 80f, radius: 200f, minParticipants: 1, // Can be solo, but dangerous\n                requirements: new List&lt;RitualComponentRequirement&gt;\n                {\n                    new RitualComponentRequirement(\"residue_crystal_large\", 5f, 1),\n                    new RitualComponentRequirement(\"fresh_heart\", 5f, 1), // Gruesome requirement\n                    new RitualComponentRequirement(\"void_ink_scroll\", 10f, 1, false) // Not consumed\n                },\n                effectIDs: new List&lt;string&gt; { \"caster_mutated_aberration\" }\n            ));\n        }\n\n        public bool InitiateRitual(EntityID ritualInitiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_entityManager.IsValid(ritualInitiatorID) || !_entityManager.IsValid(ritualCenterID)) { /* ... */ return false; }\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef)) { /* ... */ return false; }\n            if (!_transformSystem.TryGetTransform(ritualCenterID, out TransformComponent centerTransform)) { /* ... */ return false; }\n            if (!_biologicalSystem.TryGetCoreStats(ritualInitiatorID, out CoreStats initiatorStats)) { /* ... */ return false; }\n\n            if (_ritualCenters.TryGetValue(ritualCenterID, out RitualCenterComponent centerComp) &amp;&amp; centerComp.IsActive)\n            {\n                GD.Print($\"RitualSystem: Ritual center {ritualCenterID} is already active with ritual '{centerComp.ActiveRitualID}'. Cannot initiate new ritual.\");\n                _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = \"Center Busy\" });\n                return false;\n            }\n\n            // --- NEW: Check Minimum Participants (GDD B27.2.2) ---\n            List&lt;EntityID&gt; nearbyLivingEntities = _spatialGrid.QueryEntities(centerTransform.Position, ritualDef.Radius)\n                                                            .Where(id =&gt; _entityManager.IsValid(id) &amp;&amp; id != ritualInitiatorID &amp;&amp; _biologicalSystem.HasCoreStats(id) &amp;&amp; _biologicalSystem.GetCoreStatsRef(id).Health &gt; 0)\n                                                            .ToList();\n            int actualParticipants = nearbyLivingEntities.Count + 1; // Initiator + nearby living entities\n            if (actualParticipants &lt; ritualDef.MinParticipants)\n            {\n                GD.Print($\"RitualSystem: Insufficient participants for '{ritualID}'. Need {ritualDef.MinParticipants}, found {actualParticipants}.\");\n                _eventBus.Publish(new RitualFailedEvent { InitiatorID = ritualInitiatorID, RitualID = ritualID, Reason = \"Insufficient Participants\" });\n                return false;\n            }\n\n\n            // --- 1. Check Initiator Resources (Chakra, Stability) ---\n            if (initiatorStats.Chakra &lt; ritualDef.ChakraCost) { /* ... */ return false; }\n            if (initiatorStats.Stability &lt; ritualDef.StabilityCost) { /* ... */ return false; }\n\n            // --- 2. Check Ritual Component Pattern ---\n            List&lt;EntityID&gt; nearbyItemsAndEntities = _spatialGrid.QueryEntities(centerTransform.Position, ritualDef.Radius);\n            Dictionary&lt;string, int&gt; foundComponents = new Dictionary&lt;string, int&gt;();\n\n            foreach (var req in ritualDef.Requirements)\n            {\n                int countFound = 0;\n                foreach (EntityID nearbyID in nearbyItemsAndEntities)\n                {\n                    if (_entityManager.TryGetEntityMeta(nearbyID, out EntityMeta nearbyMeta) &amp;&amp; nearbyMeta.DefinitionID == req.ItemID)\n                    {\n                        if (_transformSystem.TryGetTransform(nearbyID, out TransformComponent nearbyTransform))\n                        {\n                            if (nearbyTransform.Position.DistanceTo(centerTransform.Position) &lt;= req.Radius)\n                            {\n                                countFound++;\n                            }\n                        }\n                    }\n                }\n                foundComponents[req.ItemID] = countFound;\n                if (countFound &lt; req.Quantity) { /* ... */ return false; }\n            }\n\n            // --- 3. Deduct Resources and Consume Components ---\n            GameManager.Instance.PlayerStats.TakeChakra(ritualDef.ChakraCost);\n            GameManager.Instance.PlayerStats.TakeStability(ritualDef.StabilityCost);\n\n            foreach (var req in ritualDef.Requirements)\n            {\n                if (req.Consumable)\n                {\n                    GD.Print($\"RitualSystem: Consuming {req.Quantity}x '{req.ItemID}' for ritual '{ritualID}'.\");\n                    // Conceptual consumption.\n                }\n            }\n\n            // --- 4. Initiate Ritual (start cast time) ---\n            ref RitualCenterComponent ritualCenterRef = ref _ritualCenters.GetValueRef(ritualCenterID);\n            ritualCenterRef.IsActive = true;\n            ritualCenterRef.ActiveRitualID = ritualID;\n\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' (Tier: {ritualDef.Tier}) initiated by {initiatorID} at {ritualCenterID}. Cast time: {ritualDef.CastTime:F1}s. Participants: {actualParticipants}.\");\n            _eventBus.Publish(new RitualInitiatedEvent { InitiatorID = initiatorID, RitualID = ritualID, CenterID = ritualCenterID, CastTime = ritualDef.CastTime });\n\n            _jobSystem.Schedule(new RitualCompletionJob(initiatorID, ritualCenterID, ritualID, ritualDef.CastTime), () =&gt; {\n                CompleteRitual(initiatorID, ritualCenterID, ritualID);\n            });\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Completes a ritual after its cast time.\n        /// &lt;/summary&gt;\n        public void CompleteRitual(EntityID initiatorID, EntityID ritualCenterID, string ritualID)\n        {\n            if (!_ritualDefinitions.TryGetValue(ritualID, out RitualDefinition ritualDef)) return;\n            if (!_ritualCenters.TryGetValue(ritualCenterID, out RitualCenterComponent centerComp) || !centerComp.IsActive || centerComp.ActiveRitualID != ritualID) { /* ... */ return; }\n\n            ref RitualCenterComponent ritualCenterRef = ref _ritualCenters.GetValueRef(ritualCenterID);\n            ritualCenterRef.IsActive = false;\n            ritualCenterRef.ActiveRitualID = null;\n\n            GD.Print($\"RitualSystem: Ritual '{ritualID}' completed successfully by {initiatorID} at {ritualCenterID}! Triggering effects.\");\n            _eventBus.Publish(new RitualCompletedEvent { InitiatorID = initiatorID, RitualID = ritualID, CenterID = ritualCenterID });\n\n            // --- Trigger Ritual Effects (conceptual, now tiered) ---\n            foreach (var effectID in ritualDef.EffectIDs)\n            {\n                GD.Print($\"  Ritual Effect: {effectID} triggered (Tier: {ritualDef.Tier}).\");\n                // More complex effects based on tier (GDD B27.2)\n                if (ritualDef.Tier == RitualTier.Forbidden)\n                {\n                    GD.Print(\"    WARNING: FORBIDDEN RITUAL EFFECT! Potential world-altering consequences!\");\n                    // _eventBus.Publish(new WorldSystem.CorruptionEvent { Type = \"ritual_induced_bloom\" });\n                }\n            }\n        }\n\n        // ... (RitualCompletionJob struct) ...\n        // ... (Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"58-chapter-58/#31-add-hascorestats-to-biologicalsystemcs","title":"3.1. Add <code>HasCoreStats</code> to <code>BiologicalSystem.cs</code>","text":"<p><code>RitualSystem</code> needs to check if an entity has <code>CoreStats</code> and is alive.</p> <p>Open <code>res://_Brain/Systems/Biology/BiologicalSystem.cs</code> and add this method:</p> <pre><code>// _Brain/Systems/Biology/BiologicalSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\n\nnamespace Sigilborne.Systems.Biology\n{\n    public class BiologicalSystem\n    {\n        // ... (existing fields and constructor) ...\n\n        /// &lt;summary&gt;\n        /// Checks if an entity has CoreStats (is a living entity).\n        /// &lt;/summary&gt;\n        public bool HasCoreStats(EntityID id)\n        {\n            return _entityManager.IsValid(id) &amp;&amp; _entityCoreStats.ContainsKey(id);\n        }\n\n        // ... (other methods) ...\n    }\n}\n</code></pre>"},{"location":"58-chapter-58/#4-integrating-ritualsystem-into-gamemanager","title":"4. Integrating <code>RitualSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Rituals;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>In <code>GameManager._Ready()</code>, modify the \"Test Ritual System\" section to:<ul> <li>Create additional participants (NPCs) for advanced rituals.</li> <li>Test <code>Simple</code>, <code>Advanced</code>, and <code>Forbidden</code> rituals.</li> </ul> </li> </ol> <pre><code>// _Brain/Core/GameManager.cs (inside _Ready method)\n// ...\n        // --- Test Ritual System ---\n        GD.Print(\"\\n--- Testing Ritual System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n\n        // Create a ritual altar entity\n        EntityID altarID = Entities.CreateEntity(EntityType.WorldObject, \"altar_stone\", new Vector2(300, 300));\n\n        // Create additional participants for advanced rituals\n        EntityID npcParticipant1 = Entities.CreateEntity(EntityType.NPC, \"ritual_npc_1\", new Vector2(320, 300)); // Near altar\n        EntityID npcParticipant2 = Entities.CreateEntity(EntityType.NPC, \"ritual_npc_2\", new Vector2(280, 280)); // Near altar\n        EntityID distantNpc = Entities.CreateEntity(EntityType.NPC, \"distant_npc\", new Vector2(1000, 1000)); // Far from altar\n\n        // Add ritual components to player's inventory\n        Inventory.AddItem(playerID, new InventoryItem(\"healing_herb\", 5));\n        Inventory.AddItem(playerID, new InventoryItem(\"lit_candle\", 5));\n        Inventory.AddItem(playerID, new InventoryItem(\"scrying_orb\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"rare_incense\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"spirit_essence\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"ancient_blood_rune\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"residue_crystal_large\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"fresh_heart\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"void_ink_scroll\", 1));\n\n\n        // Test Simple Ritual: healing_rite_t1 (requires 3 healing_herb, 1 lit_candle, 1 participant)\n        GD.Print(\"\\nAttempting 'healing_rite_t1' (Simple):\");\n        Rituals.InitiateRitual(playerID, altarID, \"healing_rite_t1\");\n\n        // Test Advanced Ritual: spirit_summoning_t2 (requires 1 spirit_essence, 1 ancient_blood_rune, 3 lit_candle, 2 participants)\n        GD.Print(\"\\nAttempting 'spirit_summoning_t2' (Advanced, with 3 participants):\");\n        Rituals.InitiateRitual(playerID, altarID, \"spirit_summoning_t2\");\n\n        // Test Advanced Ritual (should fail due to insufficient participants if NPCs moved away)\n        Transforms.GetTransformRef(npcParticipant1).Position = new Vector2(1500, 1500); // Move NPC far\n        GD.Print(\"\\nAttempting 'spirit_summoning_t2' again (should fail due to participants):\");\n        Rituals.InitiateRitual(playerID, altarID, \"spirit_summoning_t2\");\n\n        // Test Forbidden Ritual: corruption_ascension_f (requires 1 residue_crystal_large, 1 fresh_heart, 1 void_ink_scroll, 1 participant)\n        GD.Print(\"\\nAttempting 'corruption_ascension_f' (Forbidden):\");\n        Rituals.InitiateRitual(playerID, altarID, \"corruption_ascension_f\");\n\n        GD.Print(\"--- End Testing Ritual System ---\\n\");\n// ...\n</code></pre>"},{"location":"58-chapter-58/#5-testing-tiered-rituals","title":"5. Testing Tiered Rituals","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Ritual System\" section.</li> </ol> <pre><code>...\nRitualSystem: Identified potential ritual center: EntityID(4, Gen:1) (altar_stone). Added RitualCenterComponent.\nRitualSystem: Identified potential ritual center: EntityID(5, Gen:1) (ritual_npc_1). Added RitualCenterComponent.\nRitualSystem: Identified potential ritual center: EntityID(6, Gen:1) (ritual_npc_2). Added RitualCenterComponent.\nRitualSystem: Identified potential ritual center: EntityID(7, Gen:1) (distant_npc). Added RitualCenterComponent.\n...\n--- Testing Ritual System ---\n\nAttempting 'healing_rite_t1' (Simple):\nRitualSystem: Ritual 'healing_rite_t1' (Tier: Simple) initiated by EntityID(0, Gen:1) at EntityID(4, Gen:1). Cast time: 3.0s. Participants: 3.\nPlayerStatSystem: Player EntityID(0, Gen:1) used 10 chakra. New Chakra: 40.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 5 stability. New Stability: 95.0\nRitualSystem: Consuming 3x 'healing_herb' for ritual 'healing_rite_t1'.\nRitualSystem: Consuming 1x 'lit_candle' for ritual 'healing_rite_t1'.\n[Job:RitualCompletion] Ritual 'healing_rite_t1' delay finished.\nRitualSystem: Ritual 'healing_rite_t1' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: heal_caster_100hp triggered (Tier: Simple).\n\nAttempting 'spirit_summoning_t2' (Advanced, with 3 participants):\nRitualSystem: Ritual 'spirit_summoning_t2' (Tier: Advanced) initiated by EntityID(0, Gen:1) at EntityID(4, Gen:1). Cast time: 10.0s. Participants: 3.\nPlayerStatSystem: Player EntityID(0, Gen:1) used 50 chakra. New Chakra: 0.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 30 stability. New Stability: 65.0\nRitualSystem: Consuming 1x 'spirit_essence' for ritual 'spirit_summoning_t2'.\nRitualSystem: Consuming 1x 'ancient_blood_rune' for ritual 'spirit_summoning_t2'.\nRitualSystem: Consuming 3x 'lit_candle' for ritual 'spirit_summoning_t2'.\n[Job:RitualCompletion] Ritual 'spirit_summoning_t2' delay finished.\nRitualSystem: Ritual 'spirit_summoning_t2' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: spawn_spirit_ally triggered (Tier: Advanced).\n\nAttempting 'spirit_summoning_t2' again (should fail due to participants):\nRitualSystem: Insufficient participants for 'spirit_summoning_t2'. Need 2, found 1.\nRitualSystem: Ritual 'spirit_summoning_t2' failed by EntityID(0, Gen:1) at EntityID(4, Gen:1). Reason: Insufficient Participants\n\nAttempting 'corruption_ascension_f' (Forbidden):\nRitualSystem: Ritual 'corruption_ascension_f' (Tier: Forbidden) initiated by EntityID(0, Gen:1) at EntityID(4, Gen:1). Cast time: 30.0s. Participants: 1.\nPlayerStatSystem: Player EntityID(0, Gen:1) used 100 chakra. New Chakra: 0.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 80 stability. New Stability: 0.0\nRitualSystem: Consuming 1x 'residue_crystal_large' for ritual 'corruption_ascension_f'.\nRitualSystem: Consuming 1x 'fresh_heart' for ritual 'corruption_ascension_f'.\n[Job:RitualCompletion] Ritual 'corruption_ascension_f' delay finished.\nRitualSystem: Ritual 'corruption_ascension_f' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: caster_mutated_aberration triggered (Tier: Forbidden).\n    WARNING: FORBIDDEN RITUAL EFFECT! Potential world-altering consequences!\n--- End Testing Ritual System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Tiered Rituals: <code>RitualTier</code> and <code>MinParticipants</code> are correctly registered and enforced.</li> <li>Participant Check: <code>InitiateRitual</code> correctly counts <code>nearbyLivingEntities</code> and fails if <code>actualParticipants</code> is too low.</li> <li>Resource Deduction: Chakra and Stability are deducted, with higher costs for more advanced rituals.</li> <li>Forbidden Ritual Warning: <code>Forbidden Corruption Ascension</code> triggers a specific warning and its effects are conceptually flagged as potentially world-altering.</li> <li>Item Consumption: Conceptual consumption messages are printed.</li> </ul> <p>This confirms our <code>RitualSystem</code> is robustly handling tiered rituals, enforcing their complex requirements and triggering appropriate consequences.</p>"},{"location":"58-chapter-58/#summary","title":"Summary","text":"<p>You have successfully refined the Ritual System in the C# Brain, differentiating between Simple, Advanced, and Forbidden Rituals through the <code>RitualTier</code> enum and <code>MinParticipants</code> requirement. By enhancing <code>RitualSystem</code> to enforce these tiered complexities, deduct escalating resources, and trigger tier-specific effects (including warnings for forbidden rituals), you've aligned the magic system with Sigilborne's themes of risk and power. This crucial system strictly adheres to GDD B27.2's specifications, providing advanced and dangerous world mechanics.</p>"},{"location":"58-chapter-58/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Forbidden Contracts &amp; Spirit Contracts, designing how players can enter into dangerous pacts with powerful forces, each with world-linked consequences, representing the ultimate risk-reward paths in Sigilborne's magic.</p>"},{"location":"59-chapter-59/","title":"Chapter 9.4: Forbidden Contracts & Spirit Contracts (C#)","text":""},{"location":"59-chapter-59/#chapter-94-forbidden-contracts-spirit-contracts-c","title":"Chapter 9.4: Forbidden Contracts &amp; Spirit Contracts (C#)","text":"<p>Our <code>RitualSystem</code> now handles tiered rituals, including the dangerous <code>Forbidden</code> tier. Often, these potent rituals are used to forge Forbidden Contracts or Spirit Contracts with powerful entities or metaphysical forces. This chapter designs how players can enter into these dangerous pacts, each with world-linked consequences, representing the ultimate risk-reward paths in Sigilborne's magic, as specified in GDD B27.3 and B27.4.</p>"},{"location":"59-chapter-59/#1-the-nature-of-pacts-and-contracts","title":"1. The Nature of Pacts and Contracts","text":"<p>The GDD emphasizes that these are not simple spells: *   Forbidden Contracts: (B27.3) Pacts with powerful forces (spirits, corruption, anomalies) that change the world. They are \"power-for-pain deals\" with \"world-linked consequences.\" *   Spirit Contracts: (B27.4) Very rare pacts with ancient spirits, requiring deep Echo affinity and strict rituals. They are \"relational, not mechanical.\"</p> <p>These systems represent the highest level of non-mythic magic, blurring the line between player agency and world-altering events.</p>"},{"location":"59-chapter-59/#2-defining-contracttype-contractstatus-and-contractdefinition","title":"2. Defining <code>ContractType</code>, <code>ContractStatus</code>, and <code>ContractDefinition</code>","text":"<p>We need enums for different types of contracts and their status, and a class to define a static contract blueprint.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/ContractData.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/ContractData.cs\nusing System;\nusing System.Collections.Generic;\nusing Godot; // For Vector2\nusing Sigilborne.Entities; // For EntityID\nusing Sigilborne.Systems.Magic; // For GlyphConcept\nusing Sigilborne.Systems.Factions; // For FactionID\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Defines the broad categories of magical contracts.\n    /// (GDD B27.3.1, B27.4)\n    /// &lt;/summary&gt;\n    public enum ContractType\n    {\n        None,\n        Forbidden,      // General forbidden pact with metaphysical forces (GDD B27.3)\n        Spirit,         // Pact with a specific spirit entity (GDD B27.4)\n        Corruption,     // Pact with chaotic residue/corruption entities (GDD B27.5)\n        Bloodline,      // Modifies player's bloodline (GDD B06.4)\n        Faction         // Binding pact with a major faction\n    }\n\n    /// &lt;summary&gt;\n    /// Defines the current status of a contract.\n    /// &lt;/summary&gt;\n    public enum ContractStatus\n    {\n        Inactive,       // Not yet initiated or broken\n        Pending,        // Initiated, undergoing ritual/trial\n        Active,         // Fully bound, effects are active\n        Violated,       // Player broke terms, penalties applied\n        Broken          // Contract forcibly broken (often with severe consequences)\n    }\n\n    /// &lt;summary&gt;\n    /// Static data defining a magical contract.\n    /// (GDD B27.3, B27.4)\n    /// &lt;/summary&gt;\n    public class ContractDefinition\n    {\n        public string ID { get; private set; } // Unique ID (e.g., \"pact_of_void_sight\", \"spirit_of_forest_bond\")\n        public string Name { get; private set; }\n        public string Description { get; private set; }\n        public ContractType Type { get; private set; }\n        public RitualTier RequiredRitualTier { get; private set; } // Contract requires a ritual to initiate\n        public string RequiredRitualID { get; private set; } // The specific ritual needed\n        public EntityID ContractEntityID { get; private set; } // The entity the contract is with (e.g., a spirit, an anomaly core)\n        public string FactionID { get; private set; } // For Faction contracts\n\n        // Requirements/Costs\n        public float ChakraCost { get; private set; }\n        public float StabilityCost { get; private set; }\n        public float PermanentHealthCost { get; private set; } // GDD B27.3.1: Power-for-Pain deals\n        public List&lt;string&gt; RequiredItemIDs { get; private set; } // Items consumed\n\n        // Rewards/Effects when Active\n        public List&lt;string&gt; ActiveEffectIDs { get; private set; } // e.g., \"void_sense_bonus\", \"summon_forest_spirit\"\n        public List&lt;string&gt; GrantedGlyphConcepts { get; private set; } // New glyph concepts granted (GDD B01.4.E/F)\n        public List&lt;string&gt; GrantedAbilities { get; private set; } // New active abilities (C02 high-tier techniques)\n\n        // Penalties/Consequences when Violated or Broken\n        public List&lt;string&gt; ViolationPenaltyIDs { get; private set; } // e.g., \"curse_of_instability\", \"spirit_hunt_on_player\"\n        public List&lt;string&gt; BrokenConsequenceIDs { get; private set; } // World-altering consequences (GDD B27.3.2)\n\n        public ContractDefinition(string id, string name, string description, ContractType type, RitualTier requiredRitualTier, string requiredRitualID, EntityID contractEntityID, string factionID = null, float chakraCost = 0f, float stabilityCost = 0f, float permanentHealthCost = 0f, List&lt;string&gt; requiredItemIDs = null, List&lt;string&gt; activeEffectIDs = null, List&lt;string&gt; grantedGlyphConcepts = null, List&lt;string&gt; grantedAbilities = null, List&lt;string&gt; violationPenaltyIDs = null, List&lt;string&gt; brokenConsequenceIDs = null)\n        {\n            ID = id;\n            Name = name;\n            Description = description;\n            Type = type;\n            RequiredRitualTier = requiredRitualTier;\n            RequiredRitualID = requiredRitualID;\n            ContractEntityID = contractEntityID;\n            FactionID = factionID;\n            ChakraCost = chakraCost;\n            StabilityCost = stabilityCost;\n            PermanentHealthCost = permanentHealthCost;\n            RequiredItemIDs = requiredItemIDs ?? new List&lt;string&gt;();\n            ActiveEffectIDs = activeEffectIDs ?? new List&lt;string&gt;();\n            GrantedGlyphConcepts = grantedGlyphConcepts ?? new List&lt;string&gt;();\n            GrantedAbilities = grantedAbilities ?? new List&lt;string&gt;();\n            ViolationPenaltyIDs = violationPenaltyIDs ?? new List&lt;string&gt;();\n            BrokenConsequenceIDs = brokenConsequenceIDs ?? new List&lt;string&gt;();\n        }\n\n        public override string ToString()\n        {\n            string entityInfo = ContractEntityID.IsValid() ? $\" with {ContractEntityID}\" : (FactionID != null ? $\" with {FactionID}\" : \"\");\n            return $\"Contract: '{Name}' ({ID}) | Type: {Type}, Tier: {RequiredRitualTier}{entityInfo}\";\n        }\n    }\n}\n</code></pre>"},{"location":"59-chapter-59/#3-implementing-contractsystemcs","title":"3. Implementing <code>ContractSystem.cs</code>","text":"<p>This system will: *   Manage <code>ContractDefinition</code>s. *   Track <code>ContractStatus</code> for entities (player). *   Provide methods to <code>InitiateContract</code> and <code>BreakContract</code>. *   Interact with <code>RitualSystem</code> to trigger contracts. *   Apply contract rewards and penalties.</p> <ol> <li>Create <code>res://_Brain/Systems/Rituals/ContractSystem.cs</code>:</li> </ol> <pre><code>// _Brain/Systems/Rituals/ContractSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic; // For GlyphAcquisitionSystem, GlyphConcept\nusing Sigilborne.Systems.StatusEffects; // For StatusEffectSystem\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    /// &lt;summary&gt;\n    /// Manages magical contracts (Forbidden, Spirit, Corruption, Bloodline, Faction).\n    /// Tracks contract status, applies rewards/penalties, and integrates with rituals.\n    /// (GDD B27.3, B27.4)\n    /// &lt;/summary&gt;\n    public class ContractSystem\n    {\n        private EntityManager _entityManager;\n        private EventBus _eventBus;\n        private InventorySystem _inventorySystem;\n        private BiologicalSystem _biologicalSystem;\n        private GlyphAcquisitionSystem _glyphAcquisitionSystem; // To grant new glyphs\n        private StatusEffectSystem _statusEffectSystem; // To apply penalties\n\n        // Static definitions of all possible contracts\n        private Dictionary&lt;string, ContractDefinition&gt; _contractDefinitions = new Dictionary&lt;string, ContractDefinition&gt;();\n\n        // Active contracts for entities: Key: EntityID, Value: Dictionary&lt;ContractID, ContractStatus&gt;\n        private Dictionary&lt;EntityID, Dictionary&lt;string, ContractStatus&gt;&gt; _entityContracts = new Dictionary&lt;EntityID, Dictionary&lt;string, ContractStatus&gt;&gt;();\n\n        public ContractSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, BiologicalSystem biologicalSystem, GlyphAcquisitionSystem glyphAcquisitionSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _biologicalSystem = biologicalSystem;\n            _glyphAcquisitionSystem = glyphAcquisitionSystem;\n            _statusEffectSystem = statusEffectSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnOnEntityDespawned;\n            _eventBus.OnRitualCompleted += OnRitualCompleted; // Contracts are often initiated by ritual completion\n\n            RegisterDefaultContractDefinitions(); // Register some default contracts\n            GD.Print(\"ContractSystem: Initialized.\");\n        }\n\n        private void OnEntitySpawned(EntityID id, EntityType type, string definitionID, Vector2 initialPosition, float initialRotation)\n        {\n            if (type == EntityType.Player || type == EntityType.NPC) // NPCs can also have contracts\n            {\n                _entityContracts.Add(id, new Dictionary&lt;string, ContractStatus&gt;());\n                // Initialize all contracts as Inactive for this entity.\n                foreach (var contractDef in _contractDefinitions.Values)\n                {\n                    _entityContracts[id].Add(contractDef.ID, ContractStatus.Inactive);\n                }\n                GD.Print($\"ContractSystem: Initialized contracts for {type} entity {id}.\");\n            }\n        }\n\n        private void OnOnEntityDespawned(EntityManager.EntityDespawnedEvent e)\n        {\n            _entityContracts.Remove(e.ID);\n            GD.Print($\"ContractSystem: Removed contracts for {e.ID}.\");\n        }\n\n        private void OnRitualCompleted(EntityID initiatorID, string ritualID, EntityID centerID)\n        {\n            // Check if any contract requires this ritual\n            foreach (var contractDef in _contractDefinitions.Values.Where(cd =&gt; cd.RequiredRitualID == ritualID).ToList())\n            {\n                // If the player completed the ritual, attempt to initiate the contract.\n                if (initiatorID == GameManager.Instance.Entities.GetPlayerEntityID())\n                {\n                    GD.Print($\"ContractSystem: Player completed ritual '{ritualID}'. Attempting to initiate contract '{contractDef.ID}'.\");\n                    InitiateContract(initiatorID, contractDef.ID);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Registers a new static ContractDefinition.\n        /// &lt;/summary&gt;\n        public void RegisterContractDefinition(ContractDefinition def)\n        {\n            _contractDefinitions[def.ID] = def;\n            GD.Print($\"ContractSystem: Registered contract definition '{def.ID}'.\");\n        }\n\n        /// &lt;summary&gt;\n        /// Registers some default contracts for initial testing.\n        /// (GDD B27.3, B27.4)\n        /// &lt;/summary&gt;\n        private void RegisterDefaultContractDefinitions()\n        {\n            // --- Forbidden Contract: Pact of Void Sight (GDD B27.3) ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"pact_of_void_sight\", name: \"Pact of Void Sight\", description: \"Grants perception of hidden void energies.\",\n                type: ContractType.Forbidden, requiredRitualTier: RitualTier.Advanced, requiredRitualID: \"scrying_rite_t1\", // Use scrying rite\n                contractEntityID: EntityID.Invalid, // No specific entity, general forbidden pact\n                chakraCost: 30f, stabilityCost: 20f, permanentHealthCost: 5f, // Power-for-pain\n                requiredItemIDs: new List&lt;string&gt; { \"void_dust_small\" },\n                activeEffectIDs: new List&lt;string&gt; { \"void_sight_aura\" }, // Conceptual effect\n                grantedGlyphConcepts: new List&lt;string&gt; { GlyphConcept.Consume.ToString(), GlyphConcept.Flux.ToString() }, // Grants new glyphs\n                violationPenaltyIDs: new List&lt;string&gt; { \"vision_blur_curse\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"corruption_bloom_local\" } // World-altering\n            ));\n\n            // --- Spirit Contract: Forest Spirit Bond (GDD B27.4) ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"forest_spirit_bond\", name: \"Forest Spirit Bond\", description: \"Binds a lesser forest spirit to aid.\",\n                type: ContractType.Spirit, requiredRitualTier: RitualTier.Advanced, requiredRitualID: \"spirit_summoning_t2\",\n                contractEntityID: new EntityID(999, 1), // Dummy spirit entity ID\n                chakraCost: 40f, stabilityCost: 25f,\n                requiredItemIDs: new List&lt;string&gt; { \"forest_blossom\", \"spirit_wood\" },\n                activeEffectIDs: new List&lt;string&gt; { \"spirit_ally_summon\", \"bloom_boost_aura\" },\n                grantedAbilities: new List&lt;string&gt; { \"spirit_call_ability\" }, // Conceptual ability\n                violationPenaltyIDs: new List&lt;string&gt; { \"spirit_anger_curse\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"forest_spirit_rampage\" } // World-altering\n            ));\n\n            // --- Corruption Pact: Mark of the Aberrant (GDD B27.5) ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"mark_of_the_aberrant\", name: \"Mark of the Aberrant\", description: \"Embrace a minor corruption mutation.\",\n                type: ContractType.Corruption, requiredRitualTier: RitualTier.Forbidden, requiredRitualID: \"corruption_ascension_f\",\n                contractEntityID: EntityID.Invalid,\n                chakraCost: 80f, stabilityCost: 50f, permanentHealthCost: 10f,\n                requiredItemIDs: new List&lt;string&gt; { \"tainted_blood\" },\n                activeEffectIDs: new List&lt;string&gt; { \"minor_mutation_buff\" },\n                grantedAbilities: new List&lt;string&gt; { \"aberrant_strike_ability\" },\n                violationPenaltyIDs: new List&lt;string&gt; { \"uncontrolled_mutation\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"corruption_spread_regional\" }\n            ));\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to initiate a contract after its required ritual is completed.\n        /// (GDD B27.3.1)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"initiatorID\"&gt;The entity attempting to initiate the contract (e.g., player).&lt;/param&gt;\n        /// &lt;param name=\"contractID\"&gt;The ID of the contract to initiate.&lt;/param&gt;\n        /// &lt;returns&gt;True if contract initiated successfully, false otherwise.&lt;/returns&gt;\n        public bool InitiateContract(EntityID initiatorID, string contractID)\n        {\n            if (!_entityManager.IsValid(initiatorID)) { GD.PrintErr($\"ContractSystem: Invalid initiator {initiatorID}.\"); return false; }\n            if (!_contractDefinitions.TryGetValue(contractID, out ContractDefinition contractDef)) { GD.PrintErr($\"ContractSystem: Contract definition '{contractID}' not found.\"); return false; }\n\n            if (_entityContracts.TryGetValue(initiatorID, out Dictionary&lt;string, ContractStatus&gt; contractsOnInitiator) &amp;&amp; contractsOnInitiator.TryGetValue(contractID, out ContractStatus currentStatus) &amp;&amp; currentStatus == ContractStatus.Active)\n            {\n                GD.Print($\"ContractSystem: Initiator {initiatorID} already has contract '{contractID}' active.\");\n                return false;\n            }\n\n            if (!_biologicalSystem.TryGetCoreStats(initiatorID, out CoreStats initiatorStats)) { GD.PrintErr($\"ContractSystem: Initiator {initiatorID} has no CoreStats.\"); return false; }\n\n            // --- 1. Check Initiator Resources (Chakra, Stability, Permanent Health) ---\n            if (initiatorStats.Chakra &lt; contractDef.ChakraCost) { GD.Print($\"ContractSystem: Insufficient Chakra for contract '{contractID}'.\"); return false; }\n            if (initiatorStats.Stability &lt; contractDef.StabilityCost) { GD.Print($\"ContractSystem: Insufficient Stability for contract '{contractID}'.\"); return false; }\n            // Permanent health cost is applied upon successful contract.\n\n            // --- 2. Check Item Requirements (GDD B27.3.1) ---\n            foreach (var itemID in contractDef.RequiredItemIDs)\n            {\n                // This would query inventory for consumable items\n                // if (!_inventorySystem.HasItem(initiatorID, itemID, 1)) { /* ... */ return false; }\n                GD.Print($\"ContractSystem: Checking for required item: {itemID} (conceptual).\");\n            }\n\n            // --- 3. Deduct Resources and Consume Items ---\n            GameManager.Instance.PlayerStats.TakeChakra(contractDef.ChakraCost);\n            GameManager.Instance.PlayerStats.TakeStability(contractDef.StabilityCost);\n\n            // Consume items (conceptual)\n            foreach (var itemID in contractDef.RequiredItemIDs)\n            {\n                // _inventorySystem.RemoveItem(initiatorID, itemID, 1);\n                GD.Print($\"ContractSystem: Consuming item '{itemID}' for contract '{contractID}'.\");\n            }\n\n            // Apply permanent health cost (GDD B27.3.1)\n            if (contractDef.PermanentHealthCost &gt; 0)\n            {\n                ref CoreStats initiatorCoreStats = ref _biologicalSystem.GetCoreStatsRef(initiatorID);\n                initiatorCoreStats.MaxHealth -= contractDef.PermanentHealthCost;\n                initiatorCoreStats.Health = Mathf.Min(initiatorCoreStats.Health, initiatorCoreStats.MaxHealth); // Adjust current health if max dropped below\n                GD.Print($\"ContractSystem: {initiatorID} suffered permanent Max Health loss of {contractDef.PermanentHealthCost}. New Max Health: {initiatorCoreStats.MaxHealth}.\");\n                _eventBus.Publish(new PlayerStatSystem.PlayerHealthChangedEvent { PlayerID = initiatorID, NewValue = initiatorCoreStats.Health, MaxValue = initiatorCoreStats.MaxHealth });\n            }\n\n            // --- 4. Activate Contract ---\n            _entityContracts[initiatorID][contractID] = ContractStatus.Active;\n            GD.Print($\"ContractSystem: Initiator {initiatorID} successfully initiated contract '{contractID}' (Type: {contractDef.Type})!\");\n            _eventBus.Publish(new ContractStatusChangedEvent { InitiatorID = initiatorID, ContractID = contractID, NewStatus = ContractStatus.Active });\n\n            // --- 5. Apply Contract Rewards/Effects (GDD B27.3.1) ---\n            ApplyContractEffects(initiatorID, contractDef);\n\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Applies the rewards and effects of an active contract.\n        /// &lt;/summary&gt;\n        private void ApplyContractEffects(EntityID initiatorID, ContractDefinition contractDef)\n        {\n            GD.Print($\"ContractSystem: Applying effects for contract '{contractDef.ID}'.\");\n\n            // Grant new glyph concepts (GDD B01.4.E/F)\n            foreach (var conceptStr in contractDef.GrantedGlyphConcepts)\n            {\n                if (Enum.TryParse(conceptStr, out GlyphConcept concept))\n                {\n                    // Find a symbol for this concept in the world map (if one exists)\n                    WorldGlyphDefinition glyphDef = GameManager.Instance.GlyphMap.GetDefinitionByConcept(concept);\n                    if (glyphDef.Concept != GlyphConcept.None)\n                    {\n                        _glyphAcquisitionSystem.UpdateGlyphKnowledge(glyphDef.SymbolID, GlyphKnowledgeState.Known);\n                        GD.Print($\"  Contract granted knowledge of glyph concept: {concept} (Symbol: '{glyphDef.SymbolID}').\");\n                    }\n                    else\n                    {\n                        GD.PrintErr($\"  Contract '{contractDef.ID}' attempted to grant unknown concept: {conceptStr}.\");\n                    }\n                }\n            }\n\n            // Grant new abilities (conceptual, C02 high-tier techniques)\n            foreach (var abilityID in contractDef.GrantedAbilities)\n            {\n                GD.Print($\"  Contract granted ability: {abilityID} (conceptual).\");\n                // _eventBus.Publish(new PlayerAbilityGrantedEvent { PlayerID = initiatorID, AbilityID = abilityID });\n            }\n\n            // Apply active status effects (conceptual)\n            foreach (var effectID in contractDef.ActiveEffectIDs)\n            {\n                GD.Print($\"  Contract applied active effect: {effectID} (conceptual).\");\n                // _statusEffectSystem.ApplyEffect(initiatorID, new StatusEffectData(effectID, float.MaxValue, 1f));\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Attempts to break an active contract.\n        /// (GDD B27.3.3: Breaking a Contract)\n        /// &lt;/summary&gt;\n        public bool BreakContract(EntityID initiatorID, string contractID)\n        {\n            if (!_entityManager.IsValid(initiatorID)) return false;\n            if (!_contractDefinitions.TryGetValue(contractID, out ContractDefinition contractDef)) return false;\n\n            if (!_entityContracts.TryGetValue(initiatorID, out Dictionary&lt;string, ContractStatus&gt; contractsOnInitiator) || !contractsOnInitiator.TryGetValue(contractID, out ContractStatus currentStatus) || currentStatus != ContractStatus.Active)\n            {\n                GD.Print($\"ContractSystem: Initiator {initiatorID} does not have active contract '{contractID}' to break.\");\n                return false;\n            }\n\n            // --- Trigger Breaking Consequences (GDD B27.3.2) ---\n            _entityContracts[initiatorID][contractID] = ContractStatus.Broken;\n            GD.Print($\"ContractSystem: Initiator {initiatorID} forcibly BROKE contract '{contractID}'! Triggering severe consequences!\");\n            _eventBus.Publish(new ContractStatusChangedEvent { InitiatorID = initiatorID, ContractID = contractID, NewStatus = ContractStatus.Broken });\n\n            foreach (var consequenceID in contractDef.BrokenConsequenceIDs)\n            {\n                GD.Print($\"  Contract Broken Consequence: {consequenceID} triggered. (Potentially world-altering!)\");\n                // This would trigger severe world events (e.g., corruption bloom, spirit rampage, anomaly rupture)\n                // _eventBus.Publish(new WorldSystem.GlobalConsequenceEvent { ConsequenceID = consequenceID });\n            }\n            // Apply violation penalties (e.g., curses)\n            foreach (var penaltyID in contractDef.ViolationPenaltyIDs)\n            {\n                 GD.Print($\"  Contract Broken Penalty: {penaltyID} applied.\");\n                // _statusEffectSystem.ApplyEffect(initiatorID, new StatusEffectData(penaltyID, float.MaxValue, 1f));\n            }\n            return true;\n        }\n\n        /// &lt;summary&gt;\n        /// Retrieves the current status of a contract for an entity.\n        /// &lt;/summary&gt;\n        public ContractStatus GetContractStatus(EntityID entityID, string contractID)\n        {\n            if (_entityContracts.TryGetValue(entityID, out Dictionary&lt;string, ContractStatus&gt; contracts) &amp;&amp; contracts.TryGetValue(contractID, out ContractStatus status))\n            {\n                return status;\n            }\n            return ContractStatus.Inactive;\n        }\n\n        // --- Helper Events for Body Sync ---\n        public struct ContractStatusChangedEvent { public EntityID InitiatorID; public string ContractID; public ContractStatus NewStatus; }\n    }\n}\n</code></pre>"},{"location":"59-chapter-59/#4-integrating-contractsystem-into-gamemanager","title":"4. Integrating <code>ContractSystem</code> into <code>GameManager</code>","text":"<ol> <li>Add <code>using Sigilborne.Systems.Rituals;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li> <li>Add a <code>ContractSystem</code> property.</li> <li>Initialize <code>ContractSystem</code> in <code>InitializeSystems()</code> after <code>RitualSystem</code> and its dependencies.</li> </ol> <pre><code>// _Brain/Core/GameManager.cs\nusing Godot;\nusing System;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Input;\nusing Sigilborne.Systems.Movement;\nusing Sigilborne.Systems.Physics;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.Weather;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime;\nusing Sigilborne.Systems.Rituals;\nusing Sigilborne.Utils;\nusing System.Linq;\nusing Sigilborne.Systems.Magic.Components;\n\npublic partial class GameManager : Node\n{\n    public static GameManager Instance { get; private set; }\n\n    // ... (existing system properties) ...\n    public RitualSystem Rituals { get; private set; }\n    public SealSystem Seals { get; private set; }\n    public ContractSystem Contracts { get; private set; } // Add ContractSystem property\n\n    public override void _Ready()\n    {\n        // ... (existing Instance check and InitializeSystems call) ...\n        // ... (existing test entity/job code) ...\n        // ... (existing glyph and magic system tests) ...\n        // ... (existing damage tests) ...\n        // ... (existing inventory/equipment tests) ...\n        // ... (existing spatial grid tests) ...\n        // ... (existing perception system tests) ...\n        // ... (existing stealth system tests) ...\n        // ... (existing AI system tests) ...\n        // ... (existing ecology system tests) ...\n        // ... (existing faction system tests) ...\n        // ... (existing economy system tests) ...\n        // ... (existing crime system tests) ...\n        // ... (existing ritual system tests) ...\n        // ... (existing seal system tests) ...\n\n        // --- Test Contract System ---\n        GD.Print(\"\\n--- Testing Contract System ---\");\n        EntityID playerID = Entities.GetPlayerEntityID();\n        EntityID altarID = Entities.GetEntityMeta(4).Generation == 1 ? new EntityID(4, 1) : EntityID.Invalid; // Our test altar\n\n        // Add required items for contracts to player's inventory\n        Inventory.AddItem(playerID, new InventoryItem(\"void_dust_small\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"forest_blossom\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"spirit_wood\", 1));\n        Inventory.AddItem(playerID, new InventoryItem(\"tainted_blood\", 1));\n\n        // --- Test Forbidden Contract: Pact of Void Sight (requires scrying_rite_t1 completion) ---\n        GD.Print(\"\\nAttempting to initiate 'Pact of Void Sight' (Forbidden):\");\n        // We'll simulate the ritual completion first, which then calls InitiateContract\n        // Scrying Rite requires 1 scrying_orb, 1 rare_incense\n        // Player already has these from ritual tests.\n        GD.Print(\"  Simulating completion of 'scrying_rite_t1' ritual...\");\n        Rituals.CompleteRitual(playerID, altarID, \"scrying_rite_t1\"); // Manually complete ritual to trigger contract\n\n        // Verify status\n        GD.Print($\"Player contract status for 'pact_of_void_sight': {Contracts.GetContractStatus(playerID, \"pact_of_void_sight\")}\");\n        GD.Print($\"Player current Max Health: {Biology.GetCoreStatsRef(playerID).MaxHealth}\");\n        GD.Print($\"Player current Chakra: {Biology.GetCoreStatsRef(playerID).Chakra}\");\n        GD.Print($\"Player current Stability: {Biology.GetCoreStatsRef(playerID).Stability}\");\n        GD.Print($\"Player knows Consume glyph: {PlayerGlyphKnowledge.GetGlyphKnowledge(GlyphMap.GetDefinitionByConcept(GlyphConcept.Consume).SymbolID)}\");\n\n        // --- Test Spirit Contract: Forest Spirit Bond (requires spirit_summoning_t2 completion) ---\n        GD.Print(\"\\nAttempting to initiate 'Forest Spirit Bond' (Spirit):\");\n        // Spirit Summoning Rite requires 1 spirit_essence, 1 ancient_blood_rune, 3 lit_candle\n        GD.Print(\"  Simulating completion of 'spirit_summoning_t2' ritual...\");\n        Rituals.CompleteRitual(playerID, altarID, \"spirit_summoning_t2\"); // Manually complete ritual to trigger contract\n\n        // --- Test Corruption Pact: Mark of the Aberrant (requires corruption_ascension_f completion) ---\n        GD.Print(\"\\nAttempting to initiate 'Mark of the Aberrant' (Corruption):\");\n        // Corruption Ascension Rite requires 1 residue_crystal_large, 1 fresh_heart, 1 void_ink_scroll\n        GD.Print(\"  Simulating completion of 'corruption_ascension_f' ritual...\");\n        Rituals.CompleteRitual(playerID, altarID, \"corruption_ascension_f\");\n\n        // --- Test Breaking a Contract (e.g., Pact of Void Sight) ---\n        GD.Print(\"\\nAttempting to Break 'Pact of Void Sight':\");\n        Contracts.BreakContract(playerID, \"pact_of_void_sight\");\n        GD.Print($\"Player contract status for 'pact_of_void_sight' after break attempt: {Contracts.GetContractStatus(playerID, \"pact_of_void_sight\")}\");\n\n        GD.Print(\"--- End Testing Contract System ---\\n\");\n    }\n\n    public override void _PhysicsProcess(double delta)\n    {\n        Input.ProcessInputBuffer(); \n        Time.Tick(delta);\n        World.Tick(delta);\n        Movement.Tick(delta);\n        Magic.Tick(delta);\n        Casting.Tick(delta);\n        Weather.Tick(delta);\n        Biology.Tick(delta);\n        TitanAI.Tick(delta);\n        StatusEffects.Tick(delta);\n        Perception.Tick(delta);\n        Stealth.Tick(delta);\n        AI.Tick(delta);\n        Ecology.Tick(delta);\n        FactionAI.Tick(delta);\n        Economy.Tick(delta);\n        Crime.Tick(delta);\n        Rituals.Tick(delta);\n        Seals.Tick(delta);\n        // ContractSystem doesn't have a Tick method for now; its operations are event-driven.\n        Events.FlushCommands();\n    }\n\n    private void InitializeSystems()\n    {\n        // ... (existing system initializations up to SealSystem) ...\n\n        // Initialize ContractSystem AFTER RitualSystem, GlyphAcquisitionSystem, StatusEffectSystem\n        Contracts = new ContractSystem(Entities, Events, Inventory, BiologicalSystem, PlayerGlyphKnowledge, StatusEffects); // Pass dependencies\n        GD.Print(\"  - ContractSystem initialized.\");\n\n        // ... (existing system initializations after ContractSystem) ...\n    }\n}\n</code></pre>"},{"location":"59-chapter-59/#41-update-eventbuscs-for-contract-events","title":"4.1. Update <code>EventBus.cs</code> for Contract Events","text":"<p>Open <code>res://_Brain/Core/EventBus.cs</code> and add <code>OnContractStatusChanged</code> delegate.</p> <pre><code>// _Brain/Core/EventBus.cs\nusing System;\nusing System.Collections.Concurrent;\nusing Godot;\nusing Sigilborne.Entities;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing Sigilborne.Systems.Combat;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Factions;\nusing Sigilborne.Systems.Economy;\nusing Sigilborne.Systems.Crime;\nusing Sigilborne.Systems.Rituals;\nusing System.Collections.Generic;\n\nnamespace Sigilborne.Core\n{\n    public class EventBus\n    {\n        // ... (existing events) ...\n\n        // Contract System Events (GDD B27.3, B27.4)\n        public event Action&lt;EntityID, string, ContractStatus&gt; OnContractStatusChanged; // InitiatorID, ContractID, NewStatus\n\n        // ... (existing _commandBuffer) ...\n\n        public void Publish&lt;TEvent&gt;(TEvent eventData)\n        {\n            // ... (existing publish conditions) ...\n            else if (eventData is RitualSystem.ContractSystem.ContractStatusChangedEvent contractStatusEvent) // New condition\n            {\n                OnContractStatusChanged?.Invoke(contractStatusEvent.InitiatorID, contractStatusEvent.ContractID, contractStatusEvent.NewStatus);\n            }\n            else\n            {\n                GD.PrintErr($\"EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.\");\n            }\n        }\n        // ... (AddCommand and FlushCommands methods) ...\n    }\n}\n</code></pre>"},{"location":"59-chapter-59/#5-testing-forbidden-and-spirit-contracts","title":"5. Testing Forbidden and Spirit Contracts","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Contract System\" section.</li> </ol> <pre><code>...\nContractSystem: Initialized.\nContractSystem: Registered contract definition 'Pact of Void Sight'.\nContractSystem: Registered contract definition 'Forest Spirit Bond'.\nContractSystem: Registered contract definition 'Mark of the Aberrant'.\n  - ContractSystem initialized.\nEconomyManager: Initialized.\n...\n--- Testing Contract System ---\n\nAttempting to initiate 'Pact of Void Sight' (Forbidden):\n  Simulating completion of 'scrying_rite_t1' ritual...\nRitualSystem: Ritual 'scrying_rite_t1' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: reveal_map_area triggered (Tier: Simple).\nPlayerStatSystem: Player EntityID(0, Gen:1) used 30 chakra. New Chakra: 0.0\nPlayerStatSystem: Player EntityID(0, Gen:1) lost 20 stability. New Stability: 65.0\nContractSystem: EntityID(0, Gen:1) suffered permanent Max Health loss of 5.0. New Max Health: 95.0.\nPlayerStatSystem: Player EntityID(0, Gen:1) took 0.0 damage. New Health: 95.0\nContractSystem: Initiator EntityID(0, Gen:1) successfully initiated contract 'pact_of_void_sight' (Type: Forbidden)!\nContractSystem: Applying effects for contract 'pact_of_void_sight'.\n  Contract granted knowledge of glyph concept: Consume (Symbol: 'symbol_cross').\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_cross' updated from Known to Known.\n  Contract granted knowledge of glyph concept: Flux (Symbol: 'symbol_pentagon_alt').\nPlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_pentagon_alt' updated from Hidden to Known.\n  Contract applied active effect: void_sight_aura (conceptual).\nPlayer contract status for 'pact_of_void_sight': Active\nPlayer current Max Health: 95.0\nPlayer current Chakra: 0.0\nPlayer current Stability: 65.0\nPlayer knows Consume glyph: Known\n\nAttempting to initiate 'Forest Spirit Bond' (Spirit):\n  Simulating completion of 'spirit_summoning_t2' ritual...\nRitualSystem: Ritual 'spirit_summoning_t2' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: spawn_spirit_ally triggered (Tier: Advanced).\nContractSystem: Insufficient Chakra for contract 'forest_spirit_bond'.\nContractSystem: Initiator EntityID(0, Gen:1) does not have active contract 'forest_spirit_bond' to break.\n\nAttempting to initiate 'Mark of the Aberrant' (Corruption):\n  Simulating completion of 'corruption_ascension_f' ritual...\nRitualSystem: Ritual 'corruption_ascension_f' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: caster_mutated_aberration triggered (Tier: Forbidden).\n    WARNING: FORBIDDEN RITUAL EFFECT! Potential world-altering consequences!\nContractSystem: Insufficient Chakra for contract 'mark_of_the_aberrant'.\n\nAttempting to Break 'Pact of Void Sight':\nContractSystem: Initiator EntityID(0, Gen:1) forcibly BROKE contract 'pact_of_void_sight'! Triggering severe consequences!\n  Contract Broken Consequence: corruption_bloom_local triggered. (Potentially world-altering!)\n  Contract Broken Penalty: vision_blur_curse applied.\nPlayer contract status for 'pact_of_void_sight' after break attempt: Broken\n--- End Testing Contract System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Contract Initiation: <code>InitiateContract</code> is called upon ritual completion.</li> <li>Resource Checks: Chakra/Stability checks correctly prevent contract initiation if resources are insufficient (e.g., for <code>Forest Spirit Bond</code> and <code>Mark of the Aberrant</code> after <code>Pact of Void Sight</code> drained all chakra).</li> <li>Permanent Health Cost: <code>Pact of Void Sight</code> correctly reduces player's <code>MaxHealth</code>.</li> <li>Granted Glyphs: <code>Pact of Void Sight</code> grants knowledge of <code>Consume</code> and <code>Flux</code> glyphs.</li> <li>Effect/Ability Granting: Conceptual effects/abilities are \"granted.\"</li> <li>Breaking Contract: <code>BreakContract</code> successfully transitions status to <code>Broken</code> and triggers <code>BrokenConsequenceIDs</code> and <code>ViolationPenaltyIDs</code>.</li> <li>World-Altering Consequences: The output for <code>Forbidden</code> and <code>Broken</code> contracts explicitly mentions \"Potential world-altering consequences!\"</li> </ul> <p>This confirms our <code>ContractSystem</code> is functional, managing contracts, enforcing requirements, applying consequences, and integrating with rituals and other systems.</p>"},{"location":"59-chapter-59/#summary","title":"Summary","text":"<p>You have successfully implemented Forbidden Contracts &amp; Spirit Contracts in the C# Brain, designing <code>ContractType</code>, <code>ContractStatus</code>, and <code>ContractDefinition</code> to represent powerful magical pacts. By creating <code>ContractSystem</code> to manage contract definitions, track entity contract status, validate initiator resources and item requirements, and apply tiered rewards and penalties (including permanent <code>MaxHealth</code> loss and granting new glyphs), you've established a robust mechanism for high-stakes magic. This crucial system strictly adheres to GDD B27.3 and B27.4's specifications, providing the ultimate risk-reward paths in Sigilborne's advanced magic.</p>"},{"location":"59-chapter-59/#next-steps","title":"Next Steps","text":"<p>The next chapter will focus on Corruption Pacts &amp; Multi-Life Persistence of Rituals, where we will refine the <code>ContractSystem</code> to specifically handle <code>Corruption</code> pacts (including <code>Mutation</code> growth), and ensure that ritual and contract outcomes persist across player lives, impacting future playthroughs.</p>"},{"location":"60-chapter-60/","title":"Chapter 9.5: Corruption Pacts & Multi-Life Persistence of Rituals (C#)","text":""},{"location":"60-chapter-60/#chapter-95-corruption-pacts-multi-life-persistence-of-rituals-c","title":"Chapter 9.5: Corruption Pacts &amp; Multi-Life Persistence of Rituals (C#)","text":"<p>Our <code>ContractSystem</code> now handles various magical pacts. This chapter refines it to specifically handle Corruption Pacts, which are a major aspect of the forbidden path (GDD B27.5). Additionally, we will begin integrating the concept of Multi-Life Persistence for ritual and contract outcomes, ensuring that these powerful magical events have lasting impacts on the world, affecting future playthroughs, as specified in GDD B27.6.</p>"},{"location":"60-chapter-60/#1-the-dual-nature-of-corruption-pacts","title":"1. The Dual Nature of Corruption Pacts","text":"<p>The GDD (B27.5) describes Corruption Pacts as \"tempting, powerful, irreversible, socially dangerous, politically explosive.\" They are not simply negative: *   Rewards: Mutation growth, corrupted abilities, forbidden glyph shortcuts. *   Costs: Mutation, loss of control, instability, clan hostility. *   Escalation: Pacts can grow in tiers (Tainted -&gt; Corrupted -&gt; Mutated -&gt; Ascendant).</p>"},{"location":"60-chapter-60/#2-enhancing-contractsystemcs-for-corruption-pacts-and-persistence","title":"2. Enhancing <code>ContractSystem.cs</code> for Corruption Pacts and Persistence","text":"<p><code>ContractSystem</code> needs to: *   Have more specific logic for <code>ContractType.Corruption</code>. *   Begin storing persistent ritual/contract outcomes. This will be conceptual for now, as full persistence will be handled in Module 10.</p> <ol> <li>Open <code>res://_Brain/Systems/Rituals/ContractSystem.cs</code>.</li> <li>Modify <code>ApplyContractEffects</code> and <code>BreakContract</code> to highlight corruption-specific logic and conceptual persistence.</li> <li>Add a conceptual <code>PersistentWorldData</code> interaction.</li> </ol> <pre><code>// _Brain/Systems/Rituals/ContractSystem.cs\nusing Godot;\nusing System;\nusing System.Collections.Generic;\nusing Sigilborne.Core;\nusing Sigilborne.Entities;\nusing Sigilborne.Entities.Components;\nusing Sigilborne.Systems.Inventory;\nusing Sigilborne.Systems.AI;\nusing Sigilborne.Systems.Biology;\nusing Sigilborne.Systems.Magic;\nusing Sigilborne.Systems.StatusEffects;\nusing System.Linq;\n\nnamespace Sigilborne.Systems.Rituals\n{\n    // ... (ContractType, ContractStatus, ContractDefinition structs/classes) ...\n\n    public class ContractSystem\n    {\n        // ... (existing fields) ...\n        private StatusEffectSystem _statusEffectSystem;\n\n        public ContractSystem(EntityManager entityManager, EventBus eventBus, InventorySystem inventorySystem, BiologicalSystem biologicalSystem, GlyphAcquisitionSystem glyphAcquisitionSystem, StatusEffectSystem statusEffectSystem)\n        {\n            _entityManager = entityManager;\n            _eventBus = eventBus;\n            _inventorySystem = inventorySystem;\n            _biologicalSystem = biologicalSystem;\n            _glyphAcquisitionSystem = glyphAcquisitionSystem;\n            _statusEffectSystem = statusEffectSystem;\n\n            _eventBus.OnEntitySpawned += OnEntitySpawned;\n            _eventBus.OnEntityDespawned += OnOnEntityDespawned;\n            _eventBus.OnRitualCompleted += OnRitualCompleted;\n\n            RegisterDefaultContractDefinitions();\n            GD.Print(\"ContractSystem: Initialized.\");\n        }\n\n        // ... (OnEntitySpawned, OnOnEntityDespawned, OnRitualCompleted methods) ...\n\n        // ... (RegisterContractDefinition method) ...\n\n        private void RegisterDefaultContractDefinitions()\n        {\n            // --- Forbidden Contract: Pact of Void Sight ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"pact_of_void_sight\", name: \"Pact of Void Sight\", description: \"Grants perception of hidden void energies.\",\n                type: ContractType.Forbidden, requiredRitualTier: RitualTier.Advanced, requiredRitualID: \"scrying_rite_t1\",\n                contractEntityID: EntityID.Invalid,\n                chakraCost: 30f, stabilityCost: 20f, permanentHealthCost: 5f,\n                requiredItemIDs: new List&lt;string&gt; { \"void_dust_small\" },\n                activeEffectIDs: new List&lt;string&gt; { \"void_sight_aura\" },\n                grantedGlyphConcepts: new List&lt;string&gt; { GlyphConcept.Consume.ToString(), GlyphConcept.Flux.ToString() },\n                violationPenaltyIDs: new List&lt;string&gt; { \"vision_blur_curse\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"corruption_bloom_local\" }\n            ));\n\n            // --- Spirit Contract: Forest Spirit Bond ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"forest_spirit_bond\", name: \"Forest Spirit Bond\", description: \"Binds a lesser forest spirit to aid.\",\n                type: ContractType.Spirit, requiredRitualTier: RitualTier.Advanced, requiredRitualID: \"spirit_summoning_t2\",\n                contractEntityID: new EntityID(999, 1),\n                chakraCost: 40f, stabilityCost: 25f,\n                requiredItemIDs: new List&lt;string&gt; { \"forest_blossom\", \"spirit_wood\" },\n                activeEffectIDs: new List&lt;string&gt; { \"spirit_ally_summon\", \"bloom_boost_aura\" },\n                grantedAbilities: new List&lt;string&gt; { \"spirit_call_ability\" },\n                violationPenaltyIDs: new List&lt;string&gt; { \"spirit_anger_curse\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"forest_spirit_rampage\" }\n            ));\n\n            // --- Corruption Pact: Mark of the Aberrant (GDD B27.5) ---\n            RegisterContractDefinition(new ContractDefinition(\n                id: \"mark_of_the_aberrant\", name: \"Mark of the Aberrant\", description: \"Embrace a minor corruption mutation.\",\n                type: ContractType.Corruption, requiredRitualTier: RitualTier.Forbidden, requiredRitualID: \"corruption_ascension_f\",\n                contractEntityID: EntityID.Invalid,\n                chakraCost: 80f, stabilityCost: 50f, permanentHealthCost: 10f,\n                requiredItemIDs: new List&lt;string&gt; { \"tainted_blood\" },\n                activeEffectIDs: new List&lt;string&gt; { \"minor_mutation_buff\", \"corruption_affinity_buff\" }, // New: corruption_affinity_buff\n                grantedAbilities: new List&lt;string&gt; { \"aberrant_strike_ability\" },\n                violationPenaltyIDs: new List&lt;string&gt; { \"uncontrolled_mutation\" },\n                brokenConsequenceIDs: new List&lt;string&gt; { \"corruption_spread_regional\" }\n            ));\n        }\n\n        public bool InitiateContract(EntityID initiatorID, string contractID)\n        {\n            // ... (existing resource/item checks) ...\n\n            // Apply permanent health cost\n            if (contractDef.PermanentHealthCost &gt; 0) { /* ... */ }\n\n            // --- 4. Activate Contract ---\n            _entityContracts[initiatorID][contractID] = ContractStatus.Active;\n            GD.Print($\"ContractSystem: Initiator {initiatorID} successfully initiated contract '{contractID}' (Type: {contractDef.Type})!\");\n            _eventBus.Publish(new ContractStatusChangedEvent { InitiatorID = initiatorID, ContractID = contractID, NewStatus = ContractStatus.Active });\n\n            // --- 5. Apply Contract Rewards/Effects ---\n            ApplyContractEffects(initiatorID, contractDef);\n\n            // --- NEW: Multi-Life Persistence for Corruption Pacts (GDD B27.6) ---\n            if (contractDef.Type == ContractType.Corruption)\n            {\n                // Conceptually, record this permanent world change.\n                // This would be stored in a WorldSystem.PersistentWorldData.\n                GD.Print($\"ContractSystem: Corruption Pact '{contractDef.ID}' initiated. This will have multi-life persistence effects on the world (e.g., increased corruption affinity for this bloodline, new corruption spawns).\");\n                // GameManager.Instance.World.PersistentData.RecordCorruptionPact(initiatorID, contractDef.ID);\n            }\n            // --- END NEW ---\n\n            return true;\n        }\n\n        private void ApplyContractEffects(EntityID initiatorID, ContractDefinition contractDef)\n        {\n            // ... (existing glyph/ability granting, active effect application) ...\n\n            // --- NEW: Corruption-specific effects (GDD B27.5) ---\n            if (contractDef.Type == ContractType.Corruption)\n            {\n                GD.Print($\"  Contract '{contractDef.ID}' (Corruption) applying mutation growth and affinity.\");\n                // _eventBus.Publish(new PlayerMutationEvent { PlayerID = initiatorID, MutationType = \"minor_aberration_growth\" });\n                // _biologicalSystem.IncreaseCorruptionAffinity(initiatorID, 0.1f); // Conceptual\n            }\n            // --- END NEW ---\n        }\n\n        public bool BreakContract(EntityID initiatorID, string contractID)\n        {\n            // ... (existing checks) ...\n\n            // --- Trigger Breaking Consequences ---\n            _entityContracts[initiatorID][contractID] = ContractStatus.Broken;\n            GD.Print($\"ContractSystem: Initiator {initiatorID} forcibly BROKE contract '{contractID}'! Triggering severe consequences!\");\n            _eventBus.Publish(new ContractStatusChangedEvent { InitiatorID = initiatorID, ContractID = contractID, NewStatus = ContractStatus.Broken });\n\n            foreach (var consequenceID in contractDef.BrokenConsequenceIDs)\n            {\n                GD.Print($\"  Contract Broken Consequence: {consequenceID} triggered. (Potentially world-altering!)\");\n                // --- NEW: Multi-Life Persistence for Broken Contracts (GDD B27.6) ---\n                // This would be stored in a WorldSystem.PersistentWorldData.\n                GD.Print($\"  ContractSystem: This broken contract '{contractDef.ID}' will have multi-life persistence effects on the world (e.g., regional corruption, spirit rampage).\");\n                // GameManager.Instance.World.PersistentData.RecordBrokenContractConsequence(initiatorID, contractDef.ID, consequenceID);\n                // --- END NEW ---\n            }\n            // Apply violation penalties (e.g., curses)\n            foreach (var penaltyID in contractDef.ViolationPenaltyIDs) { /* ... */ }\n            return true;\n        }\n        // ... (GetContractStatus, Helper Events) ...\n    }\n}\n</code></pre>"},{"location":"60-chapter-60/#4-testing-corruption-pacts-and-conceptual-persistence","title":"4. Testing Corruption Pacts and Conceptual Persistence","text":"<ol> <li>Save all C# and GDScript files.</li> <li>Run <code>Main.tscn</code>.</li> <li>Load <code>Gameplay.tscn</code>.</li> <li>Observe the console output for the \"Testing Contract System\" section.</li> </ol> <pre><code>...\n--- Testing Contract System ---\n... (Pact of Void Sight initiation - Max Health reduced, glyphs granted) ...\nPlayer contract status for 'pact_of_void_sight': Active\nPlayer current Max Health: 95.0\nPlayer current Chakra: 0.0\nPlayer current Stability: 65.0\nPlayer knows Consume glyph: Known\n\nAttempting to initiate 'Forest Spirit Bond' (Spirit):\n  Simulating completion of 'spirit_summoning_t2' ritual...\nRitualSystem: Ritual 'spirit_summoning_t2' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: spawn_spirit_ally triggered (Tier: Advanced).\nContractSystem: Insufficient Chakra for contract 'forest_spirit_bond'.\n\nAttempting to initiate 'Mark of the Aberrant' (Corruption):\n  Simulating completion of 'corruption_ascension_f' ritual...\nRitualSystem: Ritual 'corruption_ascension_f' completed successfully by EntityID(0, Gen:1) at EntityID(4, Gen:1)! Triggering effects.\n  Ritual Effect: caster_mutated_aberration triggered (Tier: Forbidden).\n    WARNING: FORBIDDEN RITUAL EFFECT! Potential world-altering consequences!\nContractSystem: Insufficient Chakra for contract 'mark_of_the_aberrant'.\n\nAttempting to Break 'Pact of Void Sight':\nContractSystem: Initiator EntityID(0, Gen:1) forcibly BROKE contract 'pact_of_void_sight'! Triggering severe consequences!\n  Contract Broken Consequence: corruption_bloom_local triggered. (Potentially world-altering!)\n  ContractSystem: This broken contract 'pact_of_void_sight' will have multi-life persistence effects on the world (e.g., regional corruption, spirit rampage).\n  Contract Broken Penalty: vision_blur_curse applied.\nPlayer contract status for 'pact_of_void_sight' after break attempt: Broken\n--- End Testing Contract System ---\n...\n</code></pre> <p>Key Observations:</p> <ul> <li>Corruption Pact Logic: The <code>Mark of the Aberrant</code> (Corruption Pact) is now explicitly identified and its effects conceptually include \"mutation growth and affinity.\"</li> <li>Multi-Life Persistence (Conceptual): When a Corruption Pact is initiated or a contract is broken, <code>ContractSystem</code> now prints messages indicating that these events \"will have multi-life persistence effects on the world.\" This demonstrates the conceptual integration of GDD B27.6.</li> <li>Resource Management: Still correctly prevents contracts if Chakra is insufficient, forcing strategic choices.</li> </ul> <p>This confirms our <code>ContractSystem</code> is now handling <code>Corruption Pacts</code> with their unique logic and conceptually integrating multi-life persistence for ritual and contract outcomes.</p>"},{"location":"60-chapter-60/#summary","title":"Summary","text":"<p>You have successfully refined the <code>ContractSystem</code> in the C# Brain to specifically handle Corruption Pacts, defining their unique rewards (like mutation growth and affinity) and costs. By enhancing <code>ContractSystem</code> to identify <code>ContractType.Corruption</code> and conceptually integrate Multi-Life Persistence for ritual and contract outcomes, you've established how these powerful magical events will have lasting impacts on the world, affecting future playthroughs. This crucial system strictly adheres to GDD B27.5 and B27.6's specifications, deepening the risk-reward paths in Sigilborne's magic.</p>"},{"location":"60-chapter-60/#next-steps","title":"Next Steps","text":"<p>This concludes Module 9: Advanced World Mechanics &amp; Player Impact. We will now move on to Module 10: The Mythic &amp; Meta Game - Legacy, Collapse &amp; Multiverse, starting with World Generation &amp; Streaming - Chunk Architecture (C#), where we will design the foundational chunk-based world generation and streaming system for our infinite, persistent world.</p>"}]}