
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../27-chapter-27/">
      
      
        <link rel="next" href="../29-chapter-29/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Chapter 4.4: Casting State Machine - Player Casting Flow (C#) - Mastering Sigilborne: Building a Generational Ninja Life Simulator</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="sky" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-44-casting-state-machine-player-casting-flow-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-header__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mastering Sigilborne: Building a Generational Ninja Life Simulator
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-nav__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Mastering Sigilborne: Building a Generational Ninja Life Simulator
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-chapter-1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.1: Project Setup for Godot 4.5 with C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-chapter-2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.2: The Brain (C#) - Headless Simulation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-chapter-3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-chapter-4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.4: Directory Structure - Enforcing Separation of Concerns
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-chapter-5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.5: Entity Model - Lightweight ECS-lite in C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../06-chapter-6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.6: Component Architecture - Composition over Inheritance
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07-chapter-7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.7: Job System & Concurrency - Multithreaded Processing
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../08-chapter-8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.8: Thread Safety - Command Buffers & Double Buffering
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../09-chapter-9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.9: Scene Composition - Standardizing Godot Scenes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../10-chapter-10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.10: Naming Conventions & Scene Interfaces
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../11-chapter-11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.11: Animation Event Protocol - Syncing Brain & Body
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../12-chapter-12/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.12: Interop Layer - C# to GDScript Communication
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../13-chapter-13/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.13: Global State Management - Data Ownership
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../14-chapter-14/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.14: Debugging Tools - Console & State Inspector
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../15-chapter-15/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.15: Main Loop Execution Order - Tick vs. Frame
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../16-chapter-16/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../17-chapter-17/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.2: Standard Movement Logic - Velocity & Friction (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../18-chapter-18/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../19-chapter-19/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.4: Physics Layer - Hybrid Movement Pipeline
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../20-chapter-20/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../21-chapter-21/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../22-chapter-22/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../23-chapter-23/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.4: Subtypes & Modifiers - Procedural Nuance for Glyphs (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../24-chapter-24/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.5: Glyph Acquisition - Teachers & Scrolls (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../25-chapter-25/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../26-chapter-26/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../27-chapter-27/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-44-casting-state-machine-player-casting-flow-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4.4: Casting State Machine - Player Casting Flow (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-importance-of-a-casting-state-machine" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Importance of a Casting State Machine
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-defining-caststate-and-playercastingstate" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Defining CastState and PlayerCastingState
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-implementing-castingsystemcs" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Implementing CastingSystem.cs
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Implementing CastingSystem.cs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-update-playerstatsystemcs-with-takechakra" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1. Update PlayerStatSystem.cs with TakeChakra
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-castingsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating CastingSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Integrating CastingSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-update-magicsystemcs-to-pass-castingsystem" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1. Update MagicSystem.cs to Pass CastingSystem
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-update-eventbuscs-for-castingsystem-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.2. Update EventBus.cs for CastingSystem Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-testing-the-casting-state-machine" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Testing the Casting State Machine
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../29-chapter-29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.5: Visual Feedback - Particles & Animations (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../30-chapter-30/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.1: Biological Simulation - The Bio-Tick (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../31-chapter-31/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.2: Core Stats (Struct)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../32-chapter-32/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../33-chapter-33/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.4: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../34-chapter-34/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.5: Damage & Recovery Pipeline - Wounds & Status Effects (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../35-chapter-35/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../36-chapter-36/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../37-chapter-37/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.8: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../38-chapter-38/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.1: Physics Layer - Hitbox & Hurtbox Detection (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../39-chapter-39/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.2: The Math Layer - Damage Calculator (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../40-chapter-40/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.3: Equipment & Inventory - Inventory Data Structure (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../41-chapter-41/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.4: Equipment Logic - Recalculating Stats (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../42-chapter-42/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../43-chapter-43/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.6: Titan AI State - Specialized State Machine (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../44-chapter-44/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.1: Perception System - Spatial Hashing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../45-chapter-45/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.2: The Senses - Vision, Hearing & Chakra Sense (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../46-chapter-46/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.3: Stealth Mechanics - Visibility & Detection Meter (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../47-chapter-47/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.4: Decision Making: Utility AI (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../48-chapter-48/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.5: Ecology Simulation - Virtual Agents (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../49-chapter-49/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.6: Spawning & Despawning - Hydration/Dehydration (Brain & Body)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../50-chapter-50/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.1: Faction System - The Relationship Graph (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../51-chapter-51/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.2: The Simulation Clock - Game Time & Load Balancing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../52-chapter-52/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.3: Market Simulation - Supply & Demand (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../53-chapter-53/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.4: Trade Routes - Caravans as Arteries (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../54-chapter-54/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.5: Crime & Justice - The Heat System (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../55-chapter-55/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.6: Bounty & Punishment - Escalation & Consequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../56-chapter-56/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.1: Ritual System - Pattern Matching & Execution (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../57-chapter-57/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.2: Seals & Locks - Logical Locks (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../58-chapter-58/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.3: Ritual System - Simple, Advanced & Forbidden (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../59-chapter-59/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.4: Forbidden Contracts & Spirit Contracts (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../60-chapter-60/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.5: Corruption Pacts & Multi-Life Persistence of Rituals (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-44-casting-state-machine-player-casting-flow-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4.4: Casting State Machine - Player Casting Flow (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-importance-of-a-casting-state-machine" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Importance of a Casting State Machine
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-defining-caststate-and-playercastingstate" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Defining CastState and PlayerCastingState
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-implementing-castingsystemcs" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Implementing CastingSystem.cs
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Implementing CastingSystem.cs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-update-playerstatsystemcs-with-takechakra" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1. Update PlayerStatSystem.cs with TakeChakra
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-castingsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating CastingSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Integrating CastingSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-update-magicsystemcs-to-pass-castingsystem" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1. Update MagicSystem.cs to Pass CastingSystem
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-update-eventbuscs-for-castingsystem-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.2. Update EventBus.cs for CastingSystem Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-testing-the-casting-state-machine" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Testing the Casting State Machine
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Chapter 4.4: Casting State Machine - Player Casting Flow (C#)</h1>

<h2 id="chapter-44-casting-state-machine-player-casting-flow-c">Chapter 4.4: Casting State Machine - Player Casting Flow (C#)</h2>
<p>Our <code>ComboResolver</code> can now identify a <code>SpellDefinition</code> from player input. However, casting a spell isn't instantaneous; it involves a sequence of states: preparing the glyphs, channeling energy, and then executing the technique. This chapter implements a <strong>Casting State Machine</strong> in the C# Brain to manage the player's casting flow (Idle, Channeling, Casting, Recovery), governing when spells can be input, executed, and how chakra costs and stability are managed, as specified in TDD 02.4.</p>
<h3 id="1-the-importance-of-a-casting-state-machine">1. The Importance of a Casting State Machine</h3>
<p>The GDD (B05.6) describes dynamic timing windows, and (B03.2) details chakra strain. A state machine provides:</p>
<ul>
<li><strong>Clear State Management</strong>: Precisely define what the player can do in each phase of casting.</li>
<li><strong>Timing Control</strong>: Enforce <code>CastTime</code> and <code>Recovery</code> periods.</li>
<li><strong>Resource Management</strong>: Deduct <code>ChakraCost</code> and <code>StabilityCost</code> at the appropriate time.</li>
<li><strong>Feedback</strong>: Emit events for the Body (UI, animations) to react to casting states.</li>
<li><strong>Interruptibility</strong>: Define when a cast can be interrupted (covered later).</li>
</ul>
<h3 id="2-defining-caststate-and-playercastingstate">2. Defining <code>CastState</code> and <code>PlayerCastingState</code></h3>
<p>We need an enum for the casting states and a component-like struct to hold the player's current casting data.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/PlayerCastingState.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/PlayerCastingState.cs
using System;
using Godot; // For Vector2 if needed

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Defines the possible states of a player's spellcasting flow.
    /// (TDD 02.4)
    /// &lt;/summary&gt;
    public enum CastState
    {
        Idle,           // Not casting, ready for new input.
        Channeling,     // Glyph sequence started, waiting for more inputs within combo window.
        CastStart,      // Sequence complete, spell identified, resources deducted, preparing to execute.
        Casting,        // Spell is actively being cast (e.g., projectile traveling, AoE active).
        Recovery,       // Post-cast delay, player is briefly unable to act.
        Interrupted     // Cast was interrupted (e.g., by damage, status effect).
    }

    /// &lt;summary&gt;
    /// Stores the player's current casting state and related data.
    /// This is a component-like data structure managed by the CastingSystem.
    /// &lt;/summary&gt;
    public struct PlayerCastingState
    {
        public CastState CurrentState;
        public SpellDefinition CurrentSpell; // The spell being cast.
        public double StateTimer;           // How long we've been in the current state.
        public EntityID CasterID;           // The entity performing the cast.

        public PlayerCastingState(EntityID casterID)
        {
            CasterID = casterID;
            CurrentState = CastState.Idle;
            CurrentSpell = null;
            StateTimer = 0;
        }

        public override string ToString()
        {
            return $&quot;State: {CurrentState}, Spell: {CurrentSpell?.ID ?? &quot;None&quot;}, Timer: {StateTimer:F2}&quot;;
        }
    }
}
</code></pre>
<h3 id="3-implementing-castingsystemcs">3. Implementing <code>CastingSystem.cs</code></h3>
<p>This system will manage the <code>PlayerCastingState</code> struct, process state transitions, deduct resources, and interact with other systems.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/CastingSystem.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/CastingSystem.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems.Biology; // For PlayerStatSystem
using Sigilborne.Systems.Magic.Components; // For ProjectileData, AoEData etc.

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Manages the player's spellcasting state machine and executes spell effects.
    /// (TDD 02.4)
    /// &lt;/summary&gt;
    public class CastingSystem
    {
        private EntityManager _entityManager;
        private EventBus _eventBus;
        private PlayerStatSystem _playerStatSystem; // To deduct chakra/stability
        private TransformSystem _transformSystem;   // To get caster position for effects

        private EntityID _playerEntityID;
        private PlayerCastingState _playerCastingState; // The player's casting state machine

        // Recovery time after a spell cast (GDD B05.5)
        private const float DEFAULT_RECOVERY_TIME = 0.3f; // Small default recovery

        public CastingSystem(EntityManager entityManager, EventBus eventBus, PlayerStatSystem playerStatSystem, TransformSystem transformSystem)
        {
            _entityManager = entityManager;
            _eventBus = eventBus;
            _playerStatSystem = playerStatSystem;
            _transformSystem = transformSystem;

            _playerEntityID = _entityManager.GetPlayerEntityID();
            _playerCastingState = new PlayerCastingState(_playerEntityID); // Initialize casting state

            GD.Print(&quot;CastingSystem: Initialized.&quot;);
        }

        /// &lt;summary&gt;
        /// Main update loop for the CastingSystem.
        /// Called during GameManager._PhysicsProcess (Phase 2).
        /// (TDD 02.4: Update(double delta) logic)
        /// &lt;/summary&gt;
        public void Tick(double delta)
        {
            _playerCastingState.StateTimer += delta; // Increment timer for current state

            switch (_playerCastingState.CurrentState)
            {
                case CastState.Idle:
                    // Do nothing, waiting for MagicSystem to initiate Channeling
                    break;

                case CastState.Channeling:
                    // Channeling is managed by MagicSystem (combo delay window)
                    // If MagicSystem doesn't transition to CastStart, it will fizzle.
                    break;

                case CastState.CastStart:
                    // Resources deducted, now waiting for CastTime to elapse
                    if (_playerCastingState.StateTimer &gt;= _playerCastingState.CurrentSpell.CastTime)
                    {
                        ExecuteSpellEffect(_playerCastingState.CurrentSpell);
                        TransitionToState(CastState.Recovery, DEFAULT_RECOVERY_TIME); // Enter recovery after execution
                    }
                    break;

                case CastState.Casting:
                    // For instant spells, this state might be very short or skipped.
                    // For sustained spells (e.g., beam), this state would persist.
                    // For now, most spells are instant or have effects triggered in CastStart.
                    break;

                case CastState.Recovery:
                    // TDD 02.4: The &quot;End Lag&quot;. Player cannot move/act.
                    if (_playerCastingState.StateTimer &gt;= DEFAULT_RECOVERY_TIME)
                    {
                        TransitionToState(CastState.Idle); // Back to idle after recovery
                    }
                    break;

                case CastState.Interrupted:
                    // Stays in interrupted state until reset (e.g., player input, timer).
                    // For now, it will transition to Idle after a short delay.
                    if (_playerCastingState.StateTimer &gt;= 0.5f) // Short interruption recovery
                    {
                        TransitionToState(CastState.Idle);
                    }
                    break;
            }
        }

        /// &lt;summary&gt;
        /// Initiates a spell cast. Called by MagicSystem when a combo is resolved.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;spell&quot;&gt;The resolved spell to cast.&lt;/param&gt;
        /// &lt;returns&gt;True if cast initiated, false if resources insufficient or not in Idle state.&lt;/returns&gt;
        public bool InitiateCast(SpellDefinition spell)
        {
            if (_playerCastingState.CurrentState != CastState.Idle)
            {
                GD.Print($&quot;CastingSystem: Cannot cast spell '{spell.ID}', not in Idle state ({_playerCastingState.CurrentState}).&quot;);
                return false;
            }

            PlayerStats currentStats = _playerStatSystem.GetPlayerStats();
            if (currentStats.Chakra &lt; spell.ChakraCost)
            {
                GD.Print($&quot;CastingSystem: Insufficient Chakra to cast '{spell.ID}'. (Need: {spell.ChakraCost}, Have: {currentStats.Chakra})&quot;);
                // Emit event for UI feedback (e.g., &quot;Not enough Chakra&quot;)
                _eventBus.Publish(new CastFailedEvent { PlayerID = _playerEntityID, Reason = &quot;Insufficient Chakra&quot; });
                return false;
            }
            // Add stability check here (GDD B03.2)
            // If currentStats.Stability &lt; spell.StabilityCost... fail or miscast.

            // Deduct resources immediately (TDD 02.4: Mana deducted)
            _playerStatSystem.TakeChakra(spell.ChakraCost); // We'll add TakeChakra to PlayerStatSystem
            // Deduct stability (GDD B03.2)
            // _playerStatSystem.TakeStability(spell.StabilityCost);

            _playerCastingState.CurrentSpell = spell;
            TransitionToState(CastState.CastStart, spell.CastTime); // Transition to CastStart, timer is CastTime

            GD.Print($&quot;CastingSystem: Initiated cast for '{spell.ID}'. Chakra cost: {spell.ChakraCost}.&quot;);
            _eventBus.Publish(new CastStateChangedEvent { PlayerID = _playerEntityID, NewState = CastState.CastStart, SpellID = spell.ID });

            return true;
        }

        /// &lt;summary&gt;
        /// Transitions the casting state machine to a new state.
        /// &lt;/summary&gt;
        private void TransitionToState(CastState newState, double timerDuration = 0)
        {
            _playerCastingState.CurrentState = newState;
            _playerCastingState.StateTimer = 0; // Reset timer for the new state
            GD.Print($&quot;CastingSystem: Player {_playerEntityID} transitioned to state: {newState}.&quot;);
            _eventBus.Publish(new CastStateChangedEvent { PlayerID = _playerEntityID, NewState = newState, SpellID = _playerCastingState.CurrentSpell?.ID });
        }

        /// &lt;summary&gt;
        /// Executes the actual effects of the spell.
        /// (TDD 02.4: Casting: The &quot;Active Frames&quot;. Projectile spawns or effect applies.)
        /// &lt;/summary&gt;
        private void ExecuteSpellEffect(SpellDefinition spell)
        {
            GD.Print($&quot;CastingSystem: Executing effect for spell '{spell.ID}'!&quot;);
            _eventBus.Publish(new SpellEffectExecutedEvent { PlayerID = _playerEntityID, Spell = spell });

            // --- Placeholder for actual effect logic ---
            // In later chapters, this would interact with other systems:
            // - Spawn projectile entities (ProjectileSystem)
            // - Apply AoE effects (AoESystem)
            // - Apply status effects (StatusEffectSystem)
            // - Play specific VFX/Audio (Body via EventBus)

            // For now, let's just use the TransformSystem to get the caster's position for context.
            if (_transformSystem.TryGetTransform(_playerEntityID, out TransformComponent casterTransform))
            {
                GD.Print($&quot;  Caster Position: {casterTransform.Position}&quot;);
                if (spell.Projectile.HasValue)
                {
                    GD.Print($&quot;  Spawn Projectile: {spell.Projectile.Value}&quot;);
                    // _eventBus.Publish(new SpawnProjectileEvent { CasterID = _playerEntityID, ProjectileData = spell.Projectile.Value, SpawnPosition = casterTransform.Position });
                }
                if (spell.Explosion.HasValue)
                {
                    GD.Print($&quot;  Apply AoE: {spell.Explosion.Value}&quot;);
                    // _eventBus.Publish(new ApplyAoEEvent { CasterID = _playerEntityID, AoEData = spell.Explosion.Value, CenterPosition = casterTransform.Position });
                }
                if (spell.Effects.Any())
                {
                    GD.Print($&quot;  Apply Effects: {string.Join(&quot;, &quot;, spell.Effects)}&quot;);
                    // _eventBus.Publish(new ApplyStatusEffectsEvent { CasterID = _playerEntityID, TargetID = ..., Effects = spell.Effects });
                }
            }
        }

        /// &lt;summary&gt;
        /// Gets the player's current casting state.
        /// &lt;/summary&gt;
        public PlayerCastingState GetPlayerCastingState()
        {
            return _playerCastingState;
        }

        // --- Helper Events for Body Sync ---
        public struct CastStateChangedEvent { public EntityID PlayerID; public CastState NewState; public string SpellID; }
        public struct SpellEffectExecutedEvent { public EntityID PlayerID; public SpellDefinition Spell; }
        public struct CastFailedEvent { public EntityID PlayerID; public string Reason; }
    }
}
</code></pre>
<h4 id="31-update-playerstatsystemcs-with-takechakra">3.1. Update <code>PlayerStatSystem.cs</code> with <code>TakeChakra</code></h4>
<p>The <code>CastingSystem</code> needs to deduct chakra.</p>
<p>Open <code>res://_Brain/Systems/Biology/PlayerStatSystem.cs</code> and add this method:</p>
<pre><code class="language-csharp">// _Brain/Systems/Biology/PlayerStatSystem.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;

namespace Sigilborne.Systems.Biology
{
    // ... (PlayerStats struct) ...

    public class PlayerStatSystem
    {
        // ... (existing fields and constructor) ...

        public PlayerStats GetPlayerStats() { return _playerStats; }

        public void TakeDamage(float amount) { /* ... */ }

        /// &lt;summary&gt;
        /// Authoritatively deducts chakra from the player.
        /// &lt;/summary&gt;
        public void TakeChakra(float amount)
        {
            if (amount &lt; 0) return;

            _playerStats.Chakra -= amount;
            if (_playerStats.Chakra &lt; 0) _playerStats.Chakra = 0;

            GD.Print($&quot;PlayerStatSystem: Player {_playerStats.PlayerID} used {amount} chakra. New Chakra: {_playerStats.Chakra}&quot;);

            // Publish an event for the Body (UI) to update chakra display
            _eventBus.Publish(new PlayerChakraChangedEvent { PlayerID = _playerStats.PlayerID, NewChakra = _playerStats.Chakra, MaxChakra = _playerStats.MaxChakra });
        }

        // --- Helper Events for Body Sync ---
        public struct PlayerHealthChangedEvent { public EntityID PlayerID; public float NewHealth; public float MaxHealth; }
        public struct PlayerDiedEvent { public EntityID PlayerID; }
        public struct PlayerChakraChangedEvent { public EntityID PlayerID; public float NewChakra; public float MaxChakra; } // New event
    }
}
</code></pre>
<h3 id="4-integrating-castingsystem-into-gamemanager">4. Integrating <code>CastingSystem</code> into <code>GameManager</code></h3>
<ol>
<li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li>
<li>Add a <code>CastingSystem</code> property.</li>
<li>Initialize <code>CastingSystem</code> in <code>InitializeSystems()</code> <strong>before</strong> <code>MagicSystem</code>.</li>
<li>Call <code>CastingSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li>
<li>Pass <code>CastingSystem</code> to <code>MagicSystem</code>'s constructor.</li>
</ol>
<pre><code class="language-csharp">// _Brain/Core/GameManager.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Input;
using Sigilborne.Systems.Movement;
using Sigilborne.Systems.Physics;
using Sigilborne.Systems.Magic;
using Sigilborne.Utils;
using System.Linq;
using Sigilborne.Systems.Magic.Components; // Needed for ProjectileData etc.

public partial class GameManager : Node
{
    public static GameManager Instance { get; private set; }

    // ... (existing system properties) ...
    public ComboResolver ComboResolver { get; private set; }
    public CastingSystem Casting { get; private set; } // Add CastingSystem property
    public MagicSystem Magic { get; private set; }

    public override void _Ready()
    {
        // ... (existing Instance check and InitializeSystems call) ...
        // ... (existing test entity/job code) ...

        // --- Test PlayerStatSystem (Damage) ---
        // ... (existing test damage code) ...
        // --- End Testing PlayerStatSystem ---

        // --- Test Glyph Discovery System ---
        // ... (existing glyph discovery tests) ...

        // --- Test PlayerHotbarSystem ---
        // ... (existing hotbar tests) ...

        // --- Test Glyph Acquisition System ---
        // ... (existing acquisition tests) ...

        // --- Test Combo Resolver and Spell Definitions ---
        GD.Print(&quot;\n--- Testing Combo Resolver and Spell Definitions ---&quot;);

        WorldGlyphDefinition def0 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[0].SymbolID); // Bloom
        WorldGlyphDefinition def1 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[1].SymbolID); // Consume
        WorldGlyphDefinition def2 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[2].SymbolID); // Pulse
        WorldGlyphDefinition def3 = GlyphMap.GetDefinitionBySymbol(GlyphMap.AllWorldGlyphs[3].SymbolID); // e.g., Bind

        Func&lt;WorldGlyphDefinition, GlyphModifierType, float, float&gt; getMod = (def, type, defaultValue) =&gt; 
            def.Modifiers.TryGetValue(type, out float val) ? val : defaultValue;

        // Spell 1: Bloom -&gt; Consume (Example: Toxic Projectile)
        float baseDmg1 = 10f * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def1, GlyphModifierType.DamageMultiplier, 1.0f);
        float chakraCost1 = 5f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f);
        float stabilityCost1 = 0.1f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f);
        ProjectileData projData1 = new ProjectileData(speed: 200f * getMod(def0, GlyphModifierType.Speed, 1.0f), size: 10f * getMod(def1, GlyphModifierType.Radius, 1.0f), pierce: 1, visualId: &quot;projectile_basic&quot;, offset: Vector2.Zero);
        List&lt;StatusEffectData&gt; effects1 = new List&lt;StatusEffectData&gt;();
        if (def0.Subtype == GlyphSubtype.ToxicBloom) effects1.Add(new StatusEffectData(&quot;poison_t1&quot;, getMod(def0, GlyphModifierType.Duration, 3f), getMod(def0, GlyphModifierType.DamageMultiplier, 1f)));
        List&lt;GlyphConcept&gt; spell1Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept };
        SpellDefinition spell1 = new SpellDefinition(&quot;Test_BloomConsume&quot;, spell1Sequence, baseDmg1, chakraCost1, 0.5f, stabilityCost1, 0.05f, false, false,
                                                    projectile: projData1, effects: effects1);
        ComboResolver.RegisterSpell(spell1);

        // Spell 2: Bloom -&gt; Consume -&gt; Pulse (Example: Healing AoE)
        float baseHeal2 = 15f * getMod(def0, GlyphModifierType.HealingAmount, 1.0f) + getMod(def2, GlyphModifierType.HealingAmount, 0f);
        float chakraCost2 = 15f + getMod(def0, GlyphModifierType.StabilityCost, 0f) + getMod(def1, GlyphModifierType.StabilityCost, 0f) + getMod(def2, GlyphModifierType.StabilityCost, 0f);
        float stabilityCost2 = 0.3f + getMod(def0, GlyphModifierType.ResidueGeneration, 0f) + getMod(def1, GlyphModifierType.ResidueGeneration, 0f) + getMod(def2, GlyphModifierType.ResidueGeneration, 0f);
        AoEData aoeData2 = new AoEData(radius: 50f * getMod(def0, GlyphModifierType.Radius, 1.0f) * getMod(def2, GlyphModifierType.Radius, 1.0f), falloff: 0.5f, visualId: &quot;aoe_healing_pulse&quot;, duration: getMod(def0, GlyphModifierType.Duration, 0f) + getMod(def2, GlyphModifierType.Duration, 0f));
        List&lt;StatusEffectData&gt; effects2 = new List&lt;StatusEffectData&gt;();
        if (def0.Subtype == GlyphSubtype.HealingGrowth) effects2.Add(new StatusEffectData(&quot;regen_t1&quot;, aoeData2.Duration, getMod(def0, GlyphModifierType.HealingAmount, 1f)));
        List&lt;GlyphConcept&gt; spell2Sequence = new List&lt;GlyphConcept&gt; { def0.Concept, def1.Concept, def2.Concept };
        SpellDefinition spell2 = new SpellDefinition(&quot;Test_BloomConsumePulse&quot;, spell2Sequence, baseHeal2, chakraCost2, 1.0f, stabilityCost2, 0.1f, false, false,
                                                    explosion: aoeData2, effects: effects2);
        ComboResolver.RegisterSpell(spell2);

        // Spell 3: Pulse -&gt; Bloom (Example: Stun/Slow)
        float baseDmg3 = 15f * getMod(def2, GlyphModifierType.DamageMultiplier, 1.0f) * getMod(def0, GlyphModifierType.DamageMultiplier, 1.0f);
        float chakraCost3 = 8f + getMod(def2, GlyphModifierType.StabilityCost, 0f) + getMod(def0, GlyphModifierType.StabilityCost, 0f);
        float stabilityCost3 = 0.2f + getMod(def2, GlyphModifierType.ResidueGeneration, 0f) + getMod(def0, GlyphModifierType.ResidueGeneration, 0f);
        List&lt;StatusEffectData&gt; effects3 = new List&lt;StatusEffectData&gt; { new StatusEffectData(&quot;stun_short&quot;, 1.0f, 1.0f) };
        if (def2.Subtype == GlyphSubtype.Shockwave) effects3.Add(new StatusEffectData(&quot;slow_t1&quot;, getMod(def2, GlyphModifierType.Duration, 3f), getMod(def2, GlyphModifierType.Speed, 1f)));
        List&lt;GlyphConcept&gt; spell3Sequence = new List&lt;GlyphConcept&gt; { def2.Concept, def0.Concept };
        SpellDefinition spell3 = new SpellDefinition(&quot;Test_PulseBloom&quot;, spell3Sequence, baseDmg3, chakraCost3, 0.7f, stabilityCost3, 0.0f, false, false,
                                                    effects: effects3);
        ComboResolver.RegisterSpell(spell3);

        GD.Print(&quot;\n--- Combo Resolver Trie Structure ---&quot;);
        ComboResolver.PrintTrie();
        GD.Print(&quot;-------------------------------------\n&quot;);

        GD.Print(&quot;--- End Testing Combo Resolver and Spell Definitions ---\n&quot;);
    }

    public override void _PhysicsProcess(double delta)
    {
        Input.ProcessInputBuffer(); 
        Time.Tick(delta);
        World.Tick(delta);
        Movement.Tick(delta);
        Casting.Tick(delta); // Call CastingSystem's tick method
        Magic.Tick(delta); // MagicSystem is called after CastingSystem to allow it to initiate casts
        Events.FlushCommands();
    }

    private void InitializeSystems()
    {
        // ... (existing system initializations up to PlayerStatSystem) ...

        DebugCommands = new DebugCommandSystem(this);
        GD.Print(&quot;  - DebugCommandSystem initialized.&quot;);

        Input = new InputSystem();
        GD.Print(&quot;  - InputSystem initialized.&quot;);

        Movement = new MovementSystem(Entities, Input, Events, Transforms);
        GD.Print(&quot;  - MovementSystem initialized.&quot;);

        Physics = new PhysicsSystem(Entities, Transforms, Events);
        GD.Print(&quot;  - PhysicsSystem initialized.&quot;);

        int currentWorldSeed = 12345;
        int numGlyphsForWorld = 10;
        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);
        GD.Print(&quot;  - WorldGlyphMap initialized.&quot;);

        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);
        GD.Print(&quot;  - PlayerGlyphKnowledgeSystem initialized.&quot;);

        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);
        GD.Print(&quot;  - PlayerHotbarSystem initialized.&quot;);

        ComboResolver = new ComboResolver();
        GD.Print(&quot;  - ComboResolver initialized.&quot;);

        // Initialize CastingSystem BEFORE MagicSystem
        Casting = new CastingSystem(Entities, Events, PlayerStats, Transforms); // Initialize CastingSystem here
        GD.Print(&quot;  - CastingSystem initialized.&quot;);

        // Initialize MagicSystem, passing CastingSystem
        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver, Casting); // Pass CastingSystem
        GD.Print(&quot;  - MagicSystem initialized.&quot;);

        World = new WorldSimulation();
        GD.Print(&quot;  - WorldSimulation initialized.&quot;);
    }
}
</code></pre>
<h4 id="41-update-magicsystemcs-to-pass-castingsystem">4.1. Update <code>MagicSystem.cs</code> to Pass <code>CastingSystem</code></h4>
<p>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code> and modify its constructor and <code>ResolveCombo</code> to interact with <code>CastingSystem</code>.</p>
<pre><code class="language-csharp">// _Brain/Systems/Magic/MagicSystem.cs
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems.Input;

namespace Sigilborne.Systems.Magic
{
    public class MagicSystem
    {
        // ... (existing fields) ...
        private CastingSystem _castingSystem; // New: Reference to CastingSystem

        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,
                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,
                           WorldGlyphMap worldGlyphMap, GameManager gameManager, ComboResolver comboResolver,
                           CastingSystem castingSystem) // Add CastingSystem parameter
        {
            _entityManager = entityManager;
            _inputSystem = inputSystem;
            _eventBus = eventBus;
            _playerHotbar = playerHotbar;
            _playerGlyphKnowledge = playerGlyphKnowledge;
            _worldGlyphMap = worldGlyphMap;
            _gameManager = gameManager;

            _playerEntityID = _entityManager.GetPlayerEntityID();

            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE);
            _comboResolver = comboResolver;
            _castingSystem = castingSystem; // Store CastingSystem reference
            GD.Print(&quot;MagicSystem: Initialized.&quot;);
        }

        // ... (Tick, ProcessGlyphInput methods) ...

        private void ResolveCombo()
        {
            ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY);

            if (recentInputsSpan.IsEmpty) return;

            // Check if player is currently in a state that prevents new casts (TDD 02.4)
            if (_castingSystem.GetPlayerCastingState().CurrentState != CastState.Idle)
            {
                GD.Print($&quot;MagicSystem: Player is not Idle ({_castingSystem.GetPlayerCastingState().CurrentState}), cannot initiate new cast.&quot;);
                return; // Cannot initiate a new cast if not idle
            }

            GD.Print($&quot;MagicSystem: Attempting to resolve combo with {recentInputsSpan.Length} recent inputs.&quot;);

            SpellDefinition resolvedSpell = _comboResolver.ResolveCombo(recentInputsSpan);

            if (resolvedSpell != null)
            {
                // Found a known spell! Now initiate the cast via CastingSystem.
                if (_castingSystem.InitiateCast(resolvedSpell))
                {
                    GD.Print($&quot;MagicSystem: Resolved and initiated cast for known spell: '{resolvedSpell.ID}'!&quot;);
                    _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = false, ResultText = $&quot;Cast {resolvedSpell.ID}!&quot;, ConceptSequence = resolvedSpell.Sequence });
                    _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());
                }
                else
                {
                    GD.Print($&quot;MagicSystem: Failed to initiate cast for '{resolvedSpell.ID}' (e.g., insufficient resources).&quot;);
                    // CastingSystem already published a CastFailedEvent.
                }
                return;
            }
            // ... (existing placeholder resolution logic) ...
            // Simplified logic for single unknown glyph discovery
            if (recentInputsSpan.Length == 1 &amp;&amp; recentInputsSpan[0].KnowledgeState &lt; GlyphKnowledgeState.Known)
            {
                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputsSpan[0].SymbolID, GlyphKnowledgeState.Known);
                GD.Print($&quot;MagicSystem: Player successfully experimented with '{recentInputsSpan[0].SymbolID}' and now KNOWS its concept: {recentInputsSpan[0].Concept}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Discovered {recentInputsSpan[0].Concept}!&quot;, ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputsSpan[0].Concept } });
                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());
                return;
            }

            // Plausible experiment for 2+ known glyphs
            if (recentInputsSpan.Length &gt;= 2 &amp;&amp; recentInputsSpan.ToArray().All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))
            {
                List&lt;GlyphConcept&gt; conceptSequence = recentInputsSpan.ToArray().Select(f =&gt; f.Concept).ToList();
                GD.Print($&quot;MagicSystem: Player experimented with a plausible sequence: {string.Join(&quot; -&gt; &quot;, conceptSequence)}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Plausible experiment! {string.Join(&quot; &quot;, conceptSequence)}&quot;, ConceptSequence = conceptSequence });
                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());
                return;
            }
        }
        // ... (Helper Events) ...
    }
}
</code></pre>
<h4 id="42-update-eventbuscs-for-castingsystem-events">4.2. Update <code>EventBus.cs</code> for CastingSystem Events</h4>
<p>Our <code>CastingSystem</code> publishes <code>CastStateChangedEvent</code>, <code>SpellEffectExecutedEvent</code>, and <code>CastFailedEvent</code>. Our <code>PlayerStatSystem</code> also now publishes <code>PlayerChakraChangedEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p>
<p>Open <code>_Brain/Core/EventBus.cs</code>:</p>
<pre><code class="language-csharp">// _Brain/Core/EventBus.cs
using System;
using System.Collections.Concurrent;
using Godot;
using Sigilborne.Entities;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Magic;
using System.Collections.Generic;

namespace Sigilborne.Core
{
    public class EventBus
    {
        // ... (existing events) ...

        // Player Stat Events (TDD 01.4) - updated with Chakra
        public event Action&lt;EntityID, float, float&gt; OnPlayerHealthChanged;
        public event Action&lt;EntityID&gt; OnPlayerDied;
        public event Action&lt;EntityID, float, float&gt; OnPlayerChakraChanged; // New event

        // Casting System Events (TDD 02.4)
        public event Action&lt;EntityID, CastState, string&gt; OnCastStateChanged; // PlayerID, NewState, SpellID
        public event Action&lt;EntityID, SpellDefinition&gt; OnSpellEffectExecuted; // PlayerID, Spell
        public event Action&lt;EntityID, string&gt; OnCastFailed; // PlayerID, Reason

        // ... (existing _commandBuffer) ...

        public void Publish&lt;TEvent&gt;(TEvent eventData)
        {
            // ... (existing publish conditions) ...
            else if (eventData is PlayerStatSystem.PlayerChakraChangedEvent chakraEvent) // New condition
            {
                OnPlayerChakraChanged?.Invoke(chakraEvent.PlayerID, chakraEvent.NewChakra, chakraEvent.MaxChakra);
            }
            else if (eventData is CastingSystem.CastStateChangedEvent castStateEvent) // New condition
            {
                OnCastStateChanged?.Invoke(castStateEvent.PlayerID, castStateEvent.NewState, castStateEvent.SpellID);
            }
            else if (eventData is CastingSystem.SpellEffectExecutedEvent spellEffectEvent) // New condition
            {
                OnSpellEffectExecuted?.Invoke(spellEffectEvent.PlayerID, spellEffectEvent.Spell);
            }
            else if (eventData is CastingSystem.CastFailedEvent castFailedEvent) // New condition
            {
                OnCastFailed?.Invoke(castFailedEvent.PlayerID, castFailedEvent.Reason);
            }
            else
            {
                GD.PrintErr($&quot;EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.&quot;);
            }
        }
        // ... (AddCommand and FlushCommands methods) ...
    }
}
</code></pre>
<h3 id="5-testing-the-casting-state-machine">5. Testing the Casting State Machine</h3>
<ol>
<li>Save all C# and GDScript files.</li>
<li>Run <code>Main.tscn</code>.</li>
<li>Load <code>Gameplay.tscn</code>.</li>
<li>The player should have 50 Chakra initially.</li>
<li><strong>Test 1 (Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code>)</strong>:<ul>
<li>Quickly press <code>0</code> (for <code>testSymbol</code>, which is <code>Bloom</code>)</li>
<li>Then quickly press <code>1</code> (for <code>testSymbol2</code>, which is <code>Consume</code>)</li>
<li>This sequence should match <code>Test_BloomConsume</code> (Chakra Cost: <code>chakraCost1</code> from <code>GameManager._Ready()</code>, e.g., 5).</li>
<li>You should see:<ul>
<li><code>MagicSystem: Resolved and initiated cast for known spell: 'Test_BloomConsume'!</code></li>
<li><code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: CastStart.</code></li>
<li><code>PlayerStatSystem: Player EntityID(0, Gen:1) used X chakra. New Chakra: Y</code> (Chakra deducted)</li>
<li>After <code>CastTime</code> (0.5s): <code>CastingSystem: Executing effect for spell 'Test_BloomConsume'!</code></li>
<li><code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: Recovery.</code></li>
<li>After <code>Recovery</code> (0.3s): <code>CastingSystem: Player EntityID(0, Gen:1) transitioned to state: Idle.</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Test 2 (Insufficient Chakra)</strong>:<ul>
<li>Repeatedly cast <code>Test_BloomConsume</code> until your Chakra is below its <code>chakraCost1</code>.</li>
<li>The next attempt should result in: <code>CastingSystem: Insufficient Chakra to cast 'Test_BloomConsume'. (Need: X, Have: Y)</code> and <code>MagicSystem: Failed to initiate cast...</code></li>
</ul>
</li>
<li><strong>Test 3 (Casting While Not Idle)</strong>:<ul>
<li>Quickly press <code>0</code> then <code>1</code> (initiates cast).</li>
<li>While in <code>CastStart</code> or <code>Recovery</code> states, quickly press <code>0</code> then <code>1</code> again.</li>
<li>You should see: <code>CastingSystem: Cannot cast spell 'Test_BloomConsume', not in Idle state (CastStart/Recovery).</code></li>
</ul>
</li>
</ol>
<p>This confirms the Casting State Machine is correctly managing the player's casting flow, deducting resources, and enforcing state transitions.</p>
<h3 id="summary">Summary</h3>
<p>You have successfully implemented the <strong>Casting State Machine</strong> in the C# Brain, managing the player's spellcasting flow through <code>Idle</code>, <code>Channeling</code>, <code>CastStart</code>, <code>Casting</code>, and <code>Recovery</code> states. By creating <code>CastingSystem</code> to handle state transitions, enforce <code>CastTime</code> and <code>Recovery</code> periods, and deduct <code>ChakraCost</code> (via <code>PlayerStatSystem</code>), you've established precise control over spell execution. This crucial system strictly adheres to TDD 02.4's specifications, providing a robust foundation for Sigilborne's dynamic magic.</p>
<h3 id="next-steps">Next Steps</h3>
<p>The next chapter will focus on <strong>Visual Feedback - Particles &amp; Animations</strong>, where we will create a <code>ParticleManager</code> and <code>AnimationController</code> in GDScript to react to the C# Brain's casting state changes and spell effect execution events, bringing our spells to life visually.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.sections", "navigation.expand", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>