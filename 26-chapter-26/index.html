
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../25-chapter-25/">
      
      
        <link rel="next" href="../27-chapter-27/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#) - Mastering Sigilborne: Building a Generational Ninja Life Simulator</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="sky" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-42-combo-resolver-trie-structure-for-spell-detection-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-header__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mastering Sigilborne: Building a Generational Ninja Life Simulator
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-nav__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Mastering Sigilborne: Building a Generational Ninja Life Simulator
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-chapter-1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.1: Project Setup for Godot 4.5 with C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-chapter-2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.2: The Brain (C#) - Headless Simulation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-chapter-3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-chapter-4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.4: Directory Structure - Enforcing Separation of Concerns
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-chapter-5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.5: Entity Model - Lightweight ECS-lite in C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../06-chapter-6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.6: Component Architecture - Composition over Inheritance
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07-chapter-7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.7: Job System & Concurrency - Multithreaded Processing
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../08-chapter-8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.8: Thread Safety - Command Buffers & Double Buffering
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../09-chapter-9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.9: Scene Composition - Standardizing Godot Scenes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../10-chapter-10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.10: Naming Conventions & Scene Interfaces
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../11-chapter-11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.11: Animation Event Protocol - Syncing Brain & Body
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../12-chapter-12/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.12: Interop Layer - C# to GDScript Communication
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../13-chapter-13/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.13: Global State Management - Data Ownership
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../14-chapter-14/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.14: Debugging Tools - Console & State Inspector
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../15-chapter-15/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.15: Main Loop Execution Order - Tick vs. Frame
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../16-chapter-16/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../17-chapter-17/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.2: Standard Movement Logic - Velocity & Friction (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../18-chapter-18/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../19-chapter-19/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.4: Physics Layer - Hybrid Movement Pipeline
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../20-chapter-20/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../21-chapter-21/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../22-chapter-22/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../23-chapter-23/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.4: Subtypes & Modifiers - Procedural Nuance for Glyphs (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../24-chapter-24/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.5: Glyph Acquisition - Teachers & Scrolls (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../25-chapter-25/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-42-combo-resolver-trie-structure-for-spell-detection-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-need-for-a-trie-based-combo-resolver" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Need for a Trie-Based Combo Resolver
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-defining-spelldefinition" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Defining SpellDefinition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-the-comboresolver-trie-structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. The ComboResolver (Trie Structure)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-comboresolver-into-magicsystem" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating ComboResolver into MagicSystem
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-integrating-comboresolver-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Integrating ComboResolver into GameManager
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-testing-combo-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Testing Combo Resolution
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../27-chapter-27/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../28-chapter-28/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../29-chapter-29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.5: Visual Feedback - Particles & Animations (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../30-chapter-30/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.1: Biological Simulation - The Bio-Tick (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../31-chapter-31/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.2: Core Stats (Struct)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../32-chapter-32/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../33-chapter-33/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.4: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../34-chapter-34/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.5: Damage & Recovery Pipeline - Wounds & Status Effects (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../35-chapter-35/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../36-chapter-36/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../37-chapter-37/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.8: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../38-chapter-38/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.1: Physics Layer - Hitbox & Hurtbox Detection (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../39-chapter-39/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.2: The Math Layer - Damage Calculator (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../40-chapter-40/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.3: Equipment & Inventory - Inventory Data Structure (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../41-chapter-41/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.4: Equipment Logic - Recalculating Stats (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../42-chapter-42/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../43-chapter-43/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.6: Titan AI State - Specialized State Machine (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../44-chapter-44/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.1: Perception System - Spatial Hashing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../45-chapter-45/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.2: The Senses - Vision, Hearing & Chakra Sense (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../46-chapter-46/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.3: Stealth Mechanics - Visibility & Detection Meter (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../47-chapter-47/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.4: Decision Making: Utility AI (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../48-chapter-48/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.5: Ecology Simulation - Virtual Agents (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../49-chapter-49/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.6: Spawning & Despawning - Hydration/Dehydration (Brain & Body)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../50-chapter-50/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.1: Faction System - The Relationship Graph (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../51-chapter-51/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.2: The Simulation Clock - Game Time & Load Balancing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../52-chapter-52/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.3: Market Simulation - Supply & Demand (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../53-chapter-53/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.4: Trade Routes - Caravans as Arteries (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../54-chapter-54/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.5: Crime & Justice - The Heat System (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../55-chapter-55/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.6: Bounty & Punishment - Escalation & Consequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../56-chapter-56/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.1: Ritual System - Pattern Matching & Execution (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../57-chapter-57/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.2: Seals & Locks - Logical Locks (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../58-chapter-58/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.3: Ritual System - Simple, Advanced & Forbidden (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../59-chapter-59/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.4: Forbidden Contracts & Spirit Contracts (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../60-chapter-60/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.5: Corruption Pacts & Multi-Life Persistence of Rituals (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-42-combo-resolver-trie-structure-for-spell-detection-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-need-for-a-trie-based-combo-resolver" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Need for a Trie-Based Combo Resolver
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-defining-spelldefinition" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Defining SpellDefinition
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-the-comboresolver-trie-structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. The ComboResolver (Trie Structure)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-integrating-comboresolver-into-magicsystem" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Integrating ComboResolver into MagicSystem
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-integrating-comboresolver-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Integrating ComboResolver into GameManager
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-testing-combo-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Testing Combo Resolution
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)</h1>

<h2 id="chapter-42-combo-resolver-trie-structure-for-spell-detection-c">Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)</h2>
<p>With our <code>GlyphInputBuffer</code> accurately storing glyph sequences, the next challenge is efficiently detecting if these sequences correspond to known spells or combo patterns. This chapter implements the <strong>Combo Resolver</strong> using a <strong>Prefix Tree (Trie)</strong> structure, as specified in TDD 02.2. This data structure is ideal for quickly matching input sequences and is fundamental for Sigilborne's dynamic combo system.</p>
<h3 id="1-the-need-for-a-trie-based-combo-resolver">1. The Need for a Trie-Based Combo Resolver</h3>
<p>The GDD (B02.2) emphasizes that "any sequence can be attempted" and "the world's logic interprets them." A Trie allows for:</p>
<ul>
<li><strong>Efficient Prefix Matching</strong>: Quickly determine if a partial input sequence could lead to a valid combo.</li>
<li><strong>Dynamic Combo Registration</strong>: Easily add or remove new combos (spells) to the system.</li>
<li><strong>Hierarchical Structure</strong>: Naturally represents sequences of glyphs.</li>
</ul>
<h3 id="2-defining-spelldefinition">2. Defining <code>SpellDefinition</code></h3>
<p>Before we build the Trie, we need a way to define what a "spell" or "combo" actually <em>is</em>. TDD 02.3 specifies <code>SpellDefinition</code> as data, not code.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/SpellDefinition.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/SpellDefinition.cs
using System;
using System.Collections.Generic;
using Godot; // For Vector2, though not directly used in this struct yet
using Sigilborne.Entities; // For EntityID if spell targets an entity

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Represents the static data defining a single spell or combo technique.
    /// Spells are data-driven to allow for thousands of variations and mythic evolution.
    /// (TDD 02.3)
    /// &lt;/summary&gt;
    public class SpellDefinition
    {
        public string ID { get; private set; } // Unique ID (e.g., &quot;fireball_01&quot;, &quot;bloom_veil_healing_mist&quot;)
        public List&lt;GlyphConcept&gt; Sequence { get; private set; } // The required sequence of GlyphConcepts
        public float BaseDamage { get; private set; }
        public float ChakraCost { get; private set; } // TDD 02.3: ManaCost renamed to ChakraCost
        public float CastTime { get; private set; }
        public float StabilityCost { get; private set; } // GDD B03.2: Strain Accumulation Model
        public float ResidueGeneration { get; private set; } // GDD B03.7: Chaos Residue System
        public bool IsMythic { get; private set; } // TDD 02.3: For Mythic Evolution (C01)
        public bool IsForbidden { get; private set; } // GDD B01.10: Forbidden Glyphs (C04)

        // Components (ECS-lite) - TDD 02.3
        // These will be actual structs or classes in later chapters.
        public ProjectileData Projectile { get; private set; } // Speed, Size, Pierce
        public AoEData Explosion { get; private set; } // Radius, Falloff
        public List&lt;StatusEffectData&gt; Effects { get; private set; } // Burn, Stun

        public SpellDefinition(string id, List&lt;GlyphConcept&gt; sequence, float baseDamage, float chakraCost, float castTime, float stabilityCost, float residueGeneration, bool isMythic, bool isForbidden, ProjectileData projectile = null, AoEData explosion = null, List&lt;StatusEffectData&gt; effects = null)
        {
            ID = id;
            Sequence = sequence ?? new List&lt;GlyphConcept&gt;();
            BaseDamage = baseDamage;
            ChakraCost = chakraCost;
            CastTime = castTime;
            StabilityCost = stabilityCost;
            ResidueGeneration = residueGeneration;
            IsMythic = isMythic;
            IsForbidden = isForbidden;
            Projectile = projectile;
            Explosion = explosion;
            Effects = effects ?? new List&lt;StatusEffectData&gt;();
        }

        public override string ToString()
        {
            string seq = string.Join(&quot;-&gt;&quot;, Sequence.Select(c =&gt; c.ToString()));
            return $&quot;Spell: '{ID}' ({seq}) | Dmg: {BaseDamage}, Chakra: {ChakraCost}, StabCost: {StabilityCost}&quot;;
        }

        // --- Placeholder Component Data Structs (TDD 02.3) ---
        public class ProjectileData { public float Speed; public float Size; public int Pierce; public override string ToString() =&gt; $&quot;Proj(Spd:{Speed},Sz:{Size})&quot;; }
        public class AoEData { public float Radius; public float Falloff; public override string ToString() =&gt; $&quot;AoE(Rad:{Radius})&quot;; }
        public class StatusEffectData { public string EffectID; public float Duration; public override string ToString() =&gt; $&quot;Effect({EffectID})&quot;; }
    }
}
</code></pre>
<h3 id="3-the-comboresolver-trie-structure">3. The <code>ComboResolver</code> (Trie Structure)</h3>
<p>Now, let's implement the Trie. Each node in the Trie will represent a <code>GlyphConcept</code>. Leaf nodes will store the <code>SpellDefinition</code> that corresponds to the completed sequence.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/ComboResolver.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/ComboResolver.cs
using System;
using System.Collections.Generic;
using System.Linq;
using Godot;

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Represents a node in the Trie structure for combo resolution.
    /// (TDD 02.2)
    /// &lt;/summary&gt;
    public class TrieNode
    {
        public Dictionary&lt;GlyphConcept, TrieNode&gt; Children { get; } = new Dictionary&lt;GlyphConcept, TrieNode&gt;();
        public SpellDefinition Spell { get; set; } // Null if not a complete spell, otherwise the SpellDefinition

        public override string ToString()
        {
            return $&quot;Node (Children: {Children.Count}) {(Spell != null ? $&quot;[Spell: {Spell.ID}]&quot; : &quot;&quot;)}&quot;;
        }
    }

    /// &lt;summary&gt;
    /// Uses a Prefix Tree (Trie) to efficiently detect spells from glyph input sequences.
    /// (TDD 02.2)
    /// &lt;/summary&gt;
    public class ComboResolver
    {
        private TrieNode _root = new TrieNode();

        public ComboResolver()
        {
            GD.Print(&quot;ComboResolver: Initialized.&quot;);
        }

        /// &lt;summary&gt;
        /// Registers a new SpellDefinition into the Trie structure.
        /// &lt;/summary&gt;
        public void RegisterSpell(SpellDefinition spell)
        {
            if (spell.Sequence == null || spell.Sequence.Count == 0)
            {
                GD.PrintErr($&quot;ComboResolver: Cannot register spell '{spell.ID}' with empty sequence.&quot;);
                return;
            }

            TrieNode currentNode = _root;
            foreach (GlyphConcept concept in spell.Sequence)
            {
                if (!currentNode.Children.ContainsKey(concept))
                {
                    currentNode.Children[concept] = new TrieNode();
                }
                currentNode = currentNode.Children[concept];
            }
            // If a spell already exists at this node, it means a shorter sequence
            // has the same effect, or we're overwriting. Log a warning.
            if (currentNode.Spell != null)
            {
                GD.PrintWarning($&quot;ComboResolver: Overwriting spell '{currentNode.Spell.ID}' with '{spell.ID}' for sequence '{string.Join(&quot;-&gt;&quot;, spell.Sequence)}'.&quot;);
            }
            currentNode.Spell = spell;
            GD.Print($&quot;ComboResolver: Registered spell '{spell.ID}' with sequence '{string.Join(&quot;-&gt;&quot;, spell.Sequence)}'.&quot;);
        }

        /// &lt;summary&gt;
        /// Attempts to find the longest matching spell in the Trie for a given sequence of glyph inputs.
        /// (TDD 02.2: Algorithm)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;glyphInputs&quot;&gt;The sequence of glyph inputs to check.&lt;/param&gt;
        /// &lt;returns&gt;The longest matching SpellDefinition, or null if no spell is found.&lt;/returns&gt;
        public SpellDefinition ResolveCombo(ReadOnlySpan&lt;GlyphInputFrame&gt; glyphInputs)
        {
            if (glyphInputs.IsEmpty) return null;

            SpellDefinition bestMatch = null;
            TrieNode currentNode = _root;
            int longestMatchLength = 0;

            for (int i = 0; i &lt; glyphInputs.Length; i++)
            {
                GlyphConcept concept = glyphInputs[i].Concept;

                if (currentNode.Children.TryGetValue(concept, out TrieNode nextNode))
                {
                    currentNode = nextNode;
                    // If this node completes a spell, it's a potential match.
                    // We keep searching for a longer match.
                    if (currentNode.Spell != null)
                    {
                        bestMatch = currentNode.Spell;
                        longestMatchLength = i + 1; // Length of the sequence that matched
                    }
                }
                else
                {
                    // No further match for this sequence, break.
                    break;
                }
            }
            return bestMatch;
        }

        // --- Debugging / Utility ---
        public void PrintTrie(TrieNode node = null, string prefix = &quot;&quot;)
        {
            if (node == null) node = _root;

            foreach (var childEntry in node.Children)
            {
                string newPrefix = prefix + childEntry.Key.ToString() + &quot;-&gt;&quot;;
                GD.Print($&quot;{newPrefix}{(childEntry.Value.Spell != null ? $&quot; [Spell: {childEntry.Value.Spell.ID}]&quot; : &quot;&quot;)}&quot;);
                PrintTrie(childEntry.Value, newPrefix);
            }
        }
    }
}
</code></pre>
<h3 id="4-integrating-comboresolver-into-magicsystem">4. Integrating <code>ComboResolver</code> into <code>MagicSystem</code></h3>
<p>Now, <code>MagicSystem</code> will use <code>ComboResolver</code> to detect actual spells.</p>
<ol>
<li>Open <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>.</li>
<li>Add a <code>ComboResolver</code> property.</li>
<li>Modify the <code>MagicSystem</code> constructor to initialize <code>_comboResolver</code>.</li>
<li>Update <code>ResolveCombo</code> to use <code>_comboResolver.ResolveCombo()</code>.</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/MagicSystem.cs
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems.Input;

namespace Sigilborne.Systems.Magic
{
    // ... (GlyphInputFrame struct) ...

    public class MagicSystem
    {
        private EntityManager _entityManager;
        private InputSystem _inputSystem;
        private EventBus _eventBus;
        private PlayerHotbarSystem _playerHotbar;
        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;
        private WorldGlyphMap _worldGlyphMap;
        private GameManager _gameManager;

        private EntityID _playerEntityID;

        private GlyphInputBuffer _glyphInputBuffer;
        private ComboResolver _comboResolver; // New: ComboResolver instance

        private const int MAX_GLYPH_BUFFER_SIZE = 10;
        private const float MAX_COMBO_DELAY = 1.5f;
        private const float GLYPH_DEBOUNCE_TIME = 0.1f;

        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,
                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,
                           WorldGlyphMap worldGlyphMap, GameManager gameManager, ComboResolver comboResolver) // Add ComboResolver
        {
            _entityManager = entityManager;
            _inputSystem = inputSystem;
            _eventBus = eventBus;
            _playerHotbar = playerHotbar;
            _playerGlyphKnowledge = playerGlyphKnowledge;
            _worldGlyphMap = worldGlyphMap;
            _gameManager = gameManager;

            _playerEntityID = _entityManager.GetPlayerEntityID();

            _glyphInputBuffer = new GlyphInputBuffer(MAX_GLYPH_BUFFER_SIZE);
            _comboResolver = comboResolver; // Initialize ComboResolver
            GD.Print(&quot;MagicSystem: Initialized.&quot;);
        }

        // ... (Tick, ProcessGlyphInput methods) ...

        private void ResolveCombo()
        {
            // TDD 02.1: Get recent inputs within the combo delay window.
            ReadOnlySpan&lt;GlyphInputFrame&gt; recentInputsSpan = _glyphInputBuffer.GetRecentUnconsumed(_gameManager.Time.CurrentGameTime - MAX_COMBO_DELAY);

            if (recentInputsSpan.IsEmpty) return;

            GD.Print($&quot;MagicSystem: Attempting to resolve combo with {recentInputsSpan.Length} recent inputs.&quot;);

            // --- NEW: Use ComboResolver to find a known spell (TDD 02.2) ---
            SpellDefinition resolvedSpell = _comboResolver.ResolveCombo(recentInputsSpan);

            if (resolvedSpell != null)
            {
                // Found a known spell!
                GD.Print($&quot;MagicSystem: Resolved known spell: '{resolvedSpell.ID}'!&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = false, ResultText = $&quot;Cast {resolvedSpell.ID}!&quot;, ConceptSequence = resolvedSpell.Sequence });
                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray()); // Mark inputs as consumed
                return;
            }
            // --- END NEW ---

            // --- Existing Placeholder Combo Resolution Logic ---
            // Simplified logic from previous chapter.
            // If player inputs a single unknown glyph, mark it as known.
            if (recentInputsSpan.Length == 1 &amp;&amp; recentInputsSpan[0].KnowledgeState &lt; GlyphKnowledgeState.Known)
            {
                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputsSpan[0].SymbolID, GlyphKnowledgeState.Known);
                GD.Print($&quot;MagicSystem: Player successfully experimented with '{recentInputsSpan[0].SymbolID}' and now KNOWS its concept: {recentInputsSpan[0].Concept}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Discovered {recentInputsSpan[0].Concept}!&quot;, ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputsSpan[0].Concept } });
                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());
                return;
            }

            // Simple check: if two known glyphs are pressed, it's a plausible experiment (GDD B00.7)
            if (recentInputsSpan.Length &gt;= 2 &amp;&amp; recentInputsSpan.ToArray().All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))
            {
                List&lt;GlyphConcept&gt; conceptSequence = recentInputsSpan.ToArray().Select(f =&gt; f.Concept).ToList();
                GD.Print($&quot;MagicSystem: Player experimented with a plausible sequence: {string.Join(&quot; -&gt; &quot;, conceptSequence)}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Plausible experiment! {string.Join(&quot; &quot;, conceptSequence)}&quot;, ConceptSequence = conceptSequence });
                _glyphInputBuffer.MarkConsumed(recentInputsSpan.ToArray());
                return;
            }

            // Fizzle logic is now primarily handled in Tick() if inputs expire, or if explicit invalid combo.
        }
    }
}
</code></pre>
<h3 id="5-integrating-comboresolver-into-gamemanager">5. Integrating <code>ComboResolver</code> into <code>GameManager</code></h3>
<ol>
<li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li>
<li>Add a <code>ComboResolver</code> property.</li>
<li>Initialize <code>ComboResolver</code> in <code>InitializeSystems()</code> <strong>before</strong> <code>MagicSystem</code>.</li>
<li>Pass <code>ComboResolver</code> to <code>MagicSystem</code>'s constructor.</li>
</ol>
<pre><code class="language-csharp">// _Brain/Core/GameManager.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Input;
using Sigilborne.Systems.Movement;
using Sigilborne.Systems.Physics;
using Sigilborne.Systems.Magic;
using Sigilborne.Utils;
using System.Linq;

public partial class GameManager : Node
{
    public static GameManager Instance { get; private set; }

    // ... (existing system properties) ...
    public MagicSystem Magic { get; private set; }
    public ComboResolver ComboResolver { get; private set; } // Add ComboResolver property

    public override void _Ready()
    {
        // ... (existing Instance check and InitializeSystems call) ...
        // ... (existing test entity/job code) ...

        // --- Test Glyph Discovery System ---
        GD.Print(&quot;\n--- Testing Glyph Discovery System ---&quot;);
        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID;
        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID;
        string testSymbol3 = GlyphMap.AllWorldGlyphs[2].SymbolID;
        string testSymbol4 = GlyphMap.AllWorldGlyphs[3].SymbolID; // New for multi-glyph combo
        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s));

        // Reset knowledge for acquisition tests
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Hidden, true);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Hidden, true);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol3, GlyphKnowledgeState.Hidden, true);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol4, GlyphKnowledgeState.Hidden, true); // Reset

        GD.Print($&quot;Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}&quot;);
        // Let MagicSystem handle discovery for testSymbol via hotbar input
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known, true); // Still make testSymbol2 known for hotbar test
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol3, GlyphKnowledgeState.Known, true); // Make testSymbol3 known
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol4, GlyphKnowledgeState.Known, true); // Make testSymbol4 known

        GD.Print($&quot;Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}&quot;);
        GD.Print($&quot;Knowledge of '{testSymbol3}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol3)}&quot;);
        GD.Print($&quot;Knowledge of '{testSymbol4}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol4)}&quot;);

        GD.Print($&quot;Attempt to update unknown symbol '{unknownSymbol}':&quot;);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known);

        GD.Print(&quot;--- End Testing Glyph Discovery System ---\n&quot;);

        // --- Test PlayerHotbarSystem ---
        GD.Print(&quot;\n--- Testing PlayerHotbarSystem ---&quot;);
        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign potentially unknown symbol
        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign known symbol
        PlayerHotbar.AssignGlyphToSlot(2, testSymbol3); // Assign known symbol
        PlayerHotbar.AssignGlyphToSlot(3, testSymbol4); // Assign known symbol
        // ... (existing hotbar tests) ...
        GD.Print(&quot;--- End Testing PlayerHotbarSystem ---\n&quot;);

        // --- Test Glyph Acquisition System ---
        // ... (existing acquisition tests) ...
        GD.Print(&quot;--- End Testing Glyph Acquisition System ---\n&quot;);

        // --- Test Combo Resolver and Spell Definitions ---
        GD.Print(&quot;\n--- Testing Combo Resolver and Spell Definitions ---&quot;);
        // Register some dummy spells for testing the Trie
        // Spell 1: Bloom -&gt; Consume
        List&lt;GlyphConcept&gt; spell1Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol2).Concept };
        SpellDefinition spell1 = new SpellDefinition(&quot;Test_BloomConsume&quot;, spell1Sequence, 10f, 5f, 0.5f, 0.1f, 0.05f, false, false,
                                                    projectile: new SpellDefinition.ProjectileData { Speed = 200, Size = 10 });
        ComboResolver.RegisterSpell(spell1);

        // Spell 2: Bloom -&gt; Consume -&gt; Pulse (longer version)
        List&lt;GlyphConcept&gt; spell2Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol2).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol3).Concept };
        SpellDefinition spell2 = new SpellDefinition(&quot;Test_BloomConsumePulse&quot;, spell2Sequence, 25f, 15f, 1.0f, 0.3f, 0.1f, false, false,
                                                    explosion: new SpellDefinition.AoEData { Radius = 50 });
        ComboResolver.RegisterSpell(spell2);

        // Spell 3: Pulse -&gt; Bloom
        List&lt;GlyphConcept&gt; spell3Sequence = new List&lt;GlyphConcept&gt; { GlyphMap.GetDefinitionBySymbol(testSymbol3).Concept, GlyphMap.GetDefinitionBySymbol(testSymbol).Concept };
        SpellDefinition spell3 = new SpellDefinition(&quot;Test_PulseBloom&quot;, spell3Sequence, 15f, 8f, 0.7f, 0.2f, 0.0f, false, false,
                                                    effects: new List&lt;SpellDefinition.StatusEffectData&gt; { new SpellDefinition.StatusEffectData { EffectID = &quot;slow&quot;, Duration = 3f } });
        ComboResolver.RegisterSpell(spell3);

        GD.Print(&quot;\n--- Combo Resolver Trie Structure ---&quot;);
        ComboResolver.PrintTrie();
        GD.Print(&quot;-------------------------------------\n&quot;);

        GD.Print(&quot;--- End Testing Combo Resolver and Spell Definitions ---\n&quot;);
    }

    public override void _PhysicsProcess(double delta)
    {
        // ... (existing _PhysicsProcess calls) ...
    }

    private void InitializeSystems()
    {
        // ... (existing system initializations up to GlyphMap) ...

        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);
        GD.Print(&quot;  - PlayerGlyphKnowledgeSystem initialized.&quot;);

        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);
        GD.Print(&quot;  - PlayerHotbarSystem initialized.&quot;);

        // Initialize ComboResolver BEFORE MagicSystem
        ComboResolver = new ComboResolver(); // Initialize ComboResolver here
        GD.Print(&quot;  - ComboResolver initialized.&quot;);

        // Initialize MagicSystem, passing GameManager and ComboResolver
        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap, this, ComboResolver); // Pass 'this' and ComboResolver
        GD.Print(&quot;  - MagicSystem initialized.&quot;);

        World = new WorldSimulation();
        GD.Print(&quot;  - WorldSimulation initialized.&quot;);
    }
}
</code></pre>
<h3 id="6-testing-combo-resolution">6. Testing Combo Resolution</h3>
<ol>
<li>Save all C# and GDScript files.</li>
<li>Run <code>Main.tscn</code>.</li>
<li>Load <code>Gameplay.tscn</code>.</li>
<li>Observe the console output for <code>ComboResolver</code> initialization and spell registration. The <code>PrintTrie()</code> output will show the structure.</li>
<li><strong>Test 1 (Single Unknown Glyph)</strong>: Press <code>0</code> (hotbar slot 0, <code>testSymbol</code>, initially <code>Hidden</code>).<ul>
<li>This will still trigger the glyph discovery logic: <code>MagicSystem: Player successfully experimented with 'symbol_leaf' and now KNOWS its concept: Bloom.</code></li>
</ul>
</li>
<li><strong>Test 2 (Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code>)</strong>:<ul>
<li>Quickly press <code>0</code> (for <code>testSymbol</code>, which is <code>Bloom</code> in our seed)</li>
<li>Then quickly press <code>1</code> (for <code>testSymbol2</code>, which is <code>Consume</code> in our seed)</li>
<li>This sequence should match <code>Test_BloomConsume</code>.</li>
<li>You should see: <code>MagicSystem: Resolved known spell: 'Test_BloomConsume'!</code></li>
<li><code>MagicSystem: Combo fizzled...</code> should NOT appear for these resolved combos.</li>
</ul>
</li>
<li><strong>Test 3 (Longer Known Spell - <code>testSymbol</code> -&gt; <code>testSymbol2</code> -&gt; <code>testSymbol3</code>)</strong>:<ul>
<li>Quickly press <code>0</code> (Bloom)</li>
<li>Then <code>1</code> (Consume)</li>
<li>Then <code>2</code> (Pulse)</li>
<li>This sequence should match <code>Test_BloomConsumePulse</code>.</li>
<li>You should see: <code>MagicSystem: Resolved known spell: 'Test_BloomConsumePulse'!</code> (The Trie correctly finds the <em>longest</em> match, even if a shorter prefix also matches a spell).</li>
</ul>
</li>
<li><strong>Test 4 (Fizzle)</strong>:<ul>
<li>Press <code>0</code>. Wait for more than <code>MAX_COMBO_DELAY</code> (1.5 seconds).</li>
<li>Press <code>0</code> again. You should see a <code>MagicSystem: Combo fizzled...</code> message.</li>
</ul>
</li>
<li><strong>Test 5 (Different Order - <code>testSymbol3</code> -&gt; <code>testSymbol</code>)</strong>:<ul>
<li>Quickly press <code>2</code> (Pulse)</li>
<li>Then <code>0</code> (Bloom)</li>
<li>This should match <code>Test_PulseBloom</code>.</li>
<li>You should see: <code>MagicSystem: Resolved known spell: 'Test_PulseBloom'!</code></li>
</ul>
</li>
</ol>
<p>This confirms the <code>ComboResolver</code> (Trie) is correctly identifying known spell sequences, respecting order, and finding the longest match.</p>
<h3 id="summary">Summary</h3>
<p>You have successfully implemented the <strong>Combo Resolver</strong> using a <strong>Prefix Tree (Trie) structure</strong>, efficiently detecting known spell sequences from the glyph input buffer. By defining <code>SpellDefinition</code> as data and integrating <code>ComboResolver</code> into <code>MagicSystem</code>, you've established a robust and flexible system for matching glyph input patterns, strictly adhering to TDD 02.2's specifications. This crucial component is the brain of Sigilborne's dynamic combo system, enabling complex spellcasting and emergent technique discovery.</p>
<h3 id="next-steps">Next Steps</h3>
<p>The next chapter will focus on <strong>Spell Data Architecture</strong>, expanding our <code>SpellDefinition</code> with more detailed data for projectiles, AoE, and status effects, and laying the groundwork for how these definitions will support <code>Mythic Evolution</code>.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.sections", "navigation.expand", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>