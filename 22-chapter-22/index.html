
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../21-chapter-21/">
      
      
        <link rel="next" href="../23-chapter-23/">
      
      
        
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#) - Mastering Sigilborne: Building a Generational Ninja Life Simulator</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="sky" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-33-glyph-experimentation-trial-error-casting-c" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-header__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Mastering Sigilborne: Building a Generational Ninja Life Simulator
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Mastering Sigilborne: Building a Generational Ninja Life Simulator" class="md-nav__button md-logo" aria-label="Mastering Sigilborne: Building a Generational Ninja Life Simulator" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Mastering Sigilborne: Building a Generational Ninja Life Simulator
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-chapter-1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.1: Project Setup for Godot 4.5 with C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-chapter-2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.2: The Brain (C#) - Headless Simulation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-chapter-3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.3: The Body (GDScript) - Reactive Presentation Layer
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-chapter-4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.4: Directory Structure - Enforcing Separation of Concerns
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-chapter-5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.5: Entity Model - Lightweight ECS-lite in C#
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../06-chapter-6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.6: Component Architecture - Composition over Inheritance
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../07-chapter-7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.7: Job System & Concurrency - Multithreaded Processing
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../08-chapter-8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.8: Thread Safety - Command Buffers & Double Buffering
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../09-chapter-9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.9: Scene Composition - Standardizing Godot Scenes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../10-chapter-10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.10: Naming Conventions & Scene Interfaces
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../11-chapter-11/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.11: Animation Event Protocol - Syncing Brain & Body
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../12-chapter-12/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.12: Interop Layer - C# to GDScript Communication
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../13-chapter-13/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.13: Global State Management - Data Ownership
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../14-chapter-14/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.14: Debugging Tools - Console & State Inspector
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../15-chapter-15/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 1.15: Main Loop Execution Order - Tick vs. Frame
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../16-chapter-16/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.1: Input Manager - Capturing Raw Input (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../17-chapter-17/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.2: Standard Movement Logic - Velocity & Friction (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../18-chapter-18/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.3: Shift-Sliding Mechanic - Direction Lock (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../19-chapter-19/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 2.4: Physics Layer - Hybrid Movement Pipeline
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../20-chapter-20/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.1: Glyph Database - Concepts vs. Symbols (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../21-chapter-21/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.2: Glyph Discovery System - Player Knowledge State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-33-glyph-experimentation-trial-error-casting-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-experimentation-loop-input-interpretation-outcome" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Experimentation Loop: Input -&gt; Interpretation -&gt; Outcome
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-mapping-hotbar-input-to-glyph-symbols" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Mapping Hotbar Input to Glyph Symbols
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Mapping Hotbar Input to Glyph Symbols">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-update-glyphconceptscs-with-isvalidconcept" class="md-nav__link">
    <span class="md-ellipsis">
      
        2.1. Update GlyphConcepts.cs with IsValidConcept
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-integrating-playerhotbarsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Integrating PlayerHotbarSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Integrating PlayerHotbarSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-update-eventbuscs-for-hotbar-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1. Update EventBus.cs for Hotbar Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-implementing-the-magicsystem-core-logic" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Implementing the MagicSystem (Core Logic)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-integrating-magicsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Integrating MagicSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. Integrating MagicSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-update-eventbuscs-for-magicsystem-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1. Update EventBus.cs for MagicSystem Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-testing-glyph-experimentation" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Testing Glyph Experimentation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../23-chapter-23/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.4: Subtypes & Modifiers - Procedural Nuance for Glyphs (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../24-chapter-24/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 3.5: Glyph Acquisition - Teachers & Scrolls (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../25-chapter-25/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.1: Input Buffer - Storing Glyph Sequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../26-chapter-26/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.2: Combo Resolver - Trie Structure for Spell Detection (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../27-chapter-27/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.3: Spell Data Architecture - Data-Driven Definitions (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../28-chapter-28/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.4: Casting State Machine - Player Casting Flow (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../29-chapter-29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 4.5: Visual Feedback - Particles & Animations (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../30-chapter-30/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.1: Biological Simulation - The Bio-Tick (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../31-chapter-31/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.2: Core Stats (Struct)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../32-chapter-32/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.3: Metabolism System - Dynamic Decay Rates (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../33-chapter-33/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.4: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../34-chapter-34/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.5: Damage & Recovery Pipeline - Wounds & Status Effects (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../35-chapter-35/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.6: Status Effect Data - Definition vs. Instance (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../36-chapter-36/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.7: Recovery Logic - Health, Stamina, Chakra Regeneration (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../37-chapter-37/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 5.8: Weather & Environment - Global Environmental State (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../38-chapter-38/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.1: Physics Layer - Hitbox & Hurtbox Detection (GDScript)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../39-chapter-39/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.2: The Math Layer - Damage Calculator (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../40-chapter-40/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.3: Equipment & Inventory - Inventory Data Structure (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../41-chapter-41/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.4: Equipment Logic - Recalculating Stats (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../42-chapter-42/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.5: World Boss Mechanics - Multi-Part Entities (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../43-chapter-43/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 6.6: Titan AI State - Specialized State Machine (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../44-chapter-44/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.1: Perception System - Spatial Hashing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../45-chapter-45/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.2: The Senses - Vision, Hearing & Chakra Sense (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../46-chapter-46/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.3: Stealth Mechanics - Visibility & Detection Meter (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../47-chapter-47/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.4: Decision Making: Utility AI (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../48-chapter-48/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.5: Ecology Simulation - Virtual Agents (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../49-chapter-49/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 7.6: Spawning & Despawning - Hydration/Dehydration (Brain & Body)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../50-chapter-50/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.1: Faction System - The Relationship Graph (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../51-chapter-51/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.2: The Simulation Clock - Game Time & Load Balancing (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../52-chapter-52/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.3: Market Simulation - Supply & Demand (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../53-chapter-53/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.4: Trade Routes - Caravans as Arteries (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../54-chapter-54/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.5: Crime & Justice - The Heat System (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../55-chapter-55/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 8.6: Bounty & Punishment - Escalation & Consequences (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../56-chapter-56/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.1: Ritual System - Pattern Matching & Execution (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../57-chapter-57/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.2: Seals & Locks - Logical Locks (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../58-chapter-58/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.3: Ritual System - Simple, Advanced & Forbidden (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../59-chapter-59/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.4: Forbidden Contracts & Spirit Contracts (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../60-chapter-60/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Chapter 9.5: Corruption Pacts & Multi-Life Persistence of Rituals (C#)
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-33-glyph-experimentation-trial-error-casting-c" class="md-nav__link">
    <span class="md-ellipsis">
      
        Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-the-experimentation-loop-input-interpretation-outcome" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. The Experimentation Loop: Input -&gt; Interpretation -&gt; Outcome
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-mapping-hotbar-input-to-glyph-symbols" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Mapping Hotbar Input to Glyph Symbols
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Mapping Hotbar Input to Glyph Symbols">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-update-glyphconceptscs-with-isvalidconcept" class="md-nav__link">
    <span class="md-ellipsis">
      
        2.1. Update GlyphConcepts.cs with IsValidConcept
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-integrating-playerhotbarsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Integrating PlayerHotbarSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Integrating PlayerHotbarSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-update-eventbuscs-for-hotbar-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1. Update EventBus.cs for Hotbar Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-implementing-the-magicsystem-core-logic" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. Implementing the MagicSystem (Core Logic)
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-integrating-magicsystem-into-gamemanager" class="md-nav__link">
    <span class="md-ellipsis">
      
        5. Integrating MagicSystem into GameManager
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. Integrating MagicSystem into GameManager">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-update-eventbuscs-for-magicsystem-events" class="md-nav__link">
    <span class="md-ellipsis">
      
        5.1. Update EventBus.cs for MagicSystem Events
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6-testing-glyph-experimentation" class="md-nav__link">
    <span class="md-ellipsis">
      
        6. Testing Glyph Experimentation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      
        Summary
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next-steps" class="md-nav__link">
    <span class="md-ellipsis">
      
        Next Steps
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Chapter 3.3: Glyph Experimentation - Trial & Error Casting (C#)</h1>

<h2 id="chapter-33-glyph-experimentation-trial-error-casting-c">Chapter 3.3: Glyph Experimentation - Trial &amp; Error Casting (C#)</h2>
<p>With glyph meanings defined and player knowledge tracked, it's time for the player to actually <em>use</em> (or attempt to use) these glyphs. This chapter implements the core <strong>Glyph Experimentation</strong> loop, where players input sequences of glyphs. The system will process these inputs, determine if they form a valid known combo, a new plausible technique, or simply fizzle, and provide appropriate feedback, including revealing glyph meanings, as specified in TDD 15.3.</p>
<p>This is where the magic (or the misfire) truly happens!</p>
<h3 id="1-the-experimentation-loop-input-interpretation-outcome">1. The Experimentation Loop: Input -&gt; Interpretation -&gt; Outcome</h3>
<p>The GDD (B01.4, B02.2) emphasizes freeform combos and interpretation by world logic. This requires:</p>
<ul>
<li><strong>Input Capture</strong>: We already have this via <code>InputSystem</code> and <code>PlayerInputFrame</code>.</li>
<li><strong>Glyph Mapping</strong>: The player presses a hotbar key, which maps to a <code>GlyphSymbolID</code>. This symbol is then looked up in the <code>WorldGlyphMap</code> to get its <code>GlyphConcept</code>.</li>
<li><strong>Sequence Interpretation</strong>: The sequence of <code>GlyphConcept</code>s is analyzed to determine the outcome.</li>
<li><strong>Outcome &amp; Feedback</strong>: Based on the interpretation, a <code>SpellDefinition</code> is either found/created, or a fizzle/miscast occurs, and knowledge is updated.</li>
</ul>
<h3 id="2-mapping-hotbar-input-to-glyph-symbols">2. Mapping Hotbar Input to Glyph Symbols</h3>
<p>First, we need a way to map hotbar key presses to specific <code>GlyphSymbolID</code>s. This mapping will be dynamic and tied to the player's learned glyphs.</p>
<p>We'll create a <code>PlayerHotbarSystem</code> to manage what glyphs are currently "equipped" to the hotbar.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/PlayerHotbarSystem.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/PlayerHotbarSystem.cs
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using Sigilborne.Core;
using Sigilborne.Entities;

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Manages the glyphs (symbols) currently assigned to the player's hotbar slots.
    /// (GDD B05.2: The Recursive Mastery Deck)
    /// &lt;/summary&gt;
    public class PlayerHotbarSystem
    {
        private EntityID _playerEntityID;
        private EventBus _eventBus;
        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;
        private WorldGlyphMap _worldGlyphMap;

        // The hotbar slots. Max 10 slots (TDD 12.5).
        // Stores the SymbolID assigned to each slot. Null if slot is empty.
        private string[] _hotbarSlots = new string[10];

        public PlayerHotbarSystem(EntityID playerEntityID, EventBus eventBus, PlayerGlyphKnowledgeSystem playerGlyphKnowledge, WorldGlyphMap worldGlyphMap)
        {
            _playerEntityID = playerEntityID;
            _eventBus = eventBus;
            _playerGlyphKnowledge = playerGlyphKnowledge;
            _worldGlyphMap = worldGlyphMap;

            // Initially, hotbar is empty.
            // For testing, let's assign the first few known glyphs to the hotbar.
            // In a real game, players would equip these via UI.
            GD.Print($&quot;PlayerHotbarSystem: Initialized for player {_playerEntityID}.&quot;);
        }

        /// &lt;summary&gt;
        /// Assigns a glyph symbol to a specific hotbar slot.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;slotIndex&quot;&gt;The 0-9 index of the hotbar slot.&lt;/param&gt;
        /// &lt;param name=&quot;symbolID&quot;&gt;The ID of the glyph symbol. Null/empty to unequip.&lt;/param&gt;
        /// &lt;returns&gt;True if assignment was successful, false otherwise (e.g., unknown symbol, invalid slot).&lt;/returns&gt;
        public bool AssignGlyphToSlot(int slotIndex, string symbolID)
        {
            if (slotIndex &lt; 0 || slotIndex &gt;= _hotbarSlots.Length)
            {
                GD.PrintErr($&quot;PlayerHotbarSystem: Invalid hotbar slot index: {slotIndex}.&quot;);
                return false;
            }

            if (string.IsNullOrEmpty(symbolID))
            {
                _hotbarSlots[slotIndex] = null; // Unequip
                GD.Print($&quot;PlayerHotbarSystem: Unequipped slot {slotIndex}.&quot;);
                _eventBus.Publish(new HotbarSlotUpdatedEvent { PlayerID = _playerEntityID, SlotIndex = slotIndex, SymbolID = null });
                return true;
            }

            // Check if the player knows this glyph and if it's a valid symbol for this world
            if (_playerGlyphKnowledge.GetGlyphKnowledge(symbolID) &lt; GlyphKnowledgeState.Known)
            {
                GD.PrintErr($&quot;PlayerHotbarSystem: Player does not know glyph '{symbolID}'. Cannot assign to hotbar.&quot;);
                return false;
            }
            if (!_worldGlyphMap.GetDefinitionBySymbol(symbolID).Concept.IsValidConcept()) // Check if symbol maps to a valid concept in this world
            {
                GD.PrintErr($&quot;PlayerHotbarSystem: Symbol '{symbolID}' is not a valid glyph in this world. Cannot assign to hotbar.&quot;);
                return false;
            }

            _hotbarSlots[slotIndex] = symbolID;
            GD.Print($&quot;PlayerHotbarSystem: Assigned '{symbolID}' to slot {slotIndex}.&quot;);
            _eventBus.Publish(new HotbarSlotUpdatedEvent { PlayerID = _playerEntityID, SlotIndex = slotIndex, SymbolID = symbolID });
            return true;
        }

        /// &lt;summary&gt;
        /// Gets the glyph symbol ID assigned to a hotbar slot.
        /// &lt;/summary&gt;
        public string GetGlyphSymbolInSlot(int slotIndex)
        {
            if (slotIndex &gt;= 0 &amp;&amp; slotIndex &lt; _hotbarSlots.Length)
            {
                return _hotbarSlots[slotIndex];
            }
            return null;
        }

        // --- Helper Events for Body Sync ---
        public struct HotbarSlotUpdatedEvent { public EntityID PlayerID; public int SlotIndex; public string SymbolID; }
    }
}
</code></pre>
<h4 id="21-update-glyphconceptscs-with-isvalidconcept">2.1. Update <code>GlyphConcepts.cs</code> with <code>IsValidConcept</code></h4>
<p>We need a helper method to check if a <code>GlyphConcept</code> is valid (i.e., not <code>None</code>).</p>
<p>Open <code>res://_Brain/Systems/Magic/GlyphConcepts.cs</code> and add this extension method:</p>
<pre><code class="language-csharp">// _Brain/Systems/Magic/GlyphConcepts.cs
using System;

namespace Sigilborne.Systems.Magic
{
    // ... (GlyphConcept enum) ...
    // ... (GlyphKnowledgeState enum) ...

    public static class GlyphConceptExtensions
    {
        public static bool IsValidConcept(this GlyphConcept concept)
        {
            return concept != GlyphConcept.None;
        }
    }
}
</code></pre>
<h3 id="3-integrating-playerhotbarsystem-into-gamemanager">3. Integrating <code>PlayerHotbarSystem</code> into <code>GameManager</code></h3>
<ol>
<li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li>
<li>Add a <code>PlayerHotbarSystem</code> property.</li>
<li>Initialize <code>PlayerHotbarSystem</code> in <code>InitializeSystems()</code>.</li>
</ol>
<pre><code class="language-csharp">// _Brain/Core/GameManager.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Input;
using Sigilborne.Systems.Movement;
using Sigilborne.Systems.Physics;
using Sigilborne.Systems.Magic;
using Sigilborne.Utils;
using System.Linq; // For .First() in test

public partial class GameManager : Node
{
    public static GameManager Instance { get; private set; }

    // ... (existing system properties) ...
    public PlayerGlyphKnowledgeSystem PlayerGlyphKnowledge { get; private set; }
    public PlayerHotbarSystem PlayerHotbar { get; private set; } // Add PlayerHotbarSystem property

    public override void _Ready()
    {
        // ... (existing Instance check and InitializeSystems call) ...
        // ... (existing test entity/job code) ...

        // --- Test Glyph Discovery System ---
        GD.Print(&quot;\n--- Testing Glyph Discovery System ---&quot;);
        // Get a symbol from the generated map for testing
        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID; // e.g., &quot;symbol_leaf&quot;
        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID; // e.g., &quot;symbol_cross&quot;
        string unknownSymbol = GlyphSymbols.AllSymbols.First(s =&gt; !GlyphMap.AllWorldGlyphs.Any(g =&gt; g.SymbolID == s));

        GD.Print($&quot;Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}&quot;);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Seen);
        GD.Print($&quot;Knowledge of '{testSymbol}' after 'Seen': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}&quot;);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Known);
        GD.Print($&quot;Knowledge of '{testSymbol}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}&quot;);

        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known); // Make second symbol known for hotbar test
        GD.Print($&quot;Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}&quot;);

        GD.Print($&quot;Attempt to update unknown symbol '{unknownSymbol}':&quot;);
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(unknownSymbol, GlyphKnowledgeState.Known);

        GD.Print(&quot;--- End Testing Glyph Discovery System ---\n&quot;);

        // --- Test PlayerHotbarSystem ---
        GD.Print(&quot;\n--- Testing PlayerHotbarSystem ---&quot;);
        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign known symbol
        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign another known symbol
        PlayerHotbar.AssignGlyphToSlot(2, unknownSymbol); // Attempt to assign unknown symbol (should fail)
        PlayerHotbar.AssignGlyphToSlot(9, testSymbol); // Assign to last slot
        PlayerHotbar.AssignGlyphToSlot(0, null); // Unequip slot 0
        GD.Print($&quot;Glyph in slot 1: {PlayerHotbar.GetGlyphSymbolInSlot(1)}&quot;);
        GD.Print(&quot;--- End Testing PlayerHotbarSystem ---\n&quot;);
    }

    public override void _PhysicsProcess(double delta)
    {
        // ... (existing _PhysicsProcess calls) ...
    }

    private void InitializeSystems()
    {
        Events = new EventBus();
        GD.Print(&quot;  - EventBus initialized.&quot;);

        Time = new TimeSystem();
        GD.Print(&quot;  - TimeSystem initialized.&quot;);

        Entities = new EntityManager(Events);
        GD.Print(&quot;  - EntityManager initialized.&quot;);

        Transforms = new TransformSystem(Entities, Events);
        GD.Print(&quot;  - TransformSystem initialized.&quot;);

        Jobs = new JobSystem(Events);
        GD.Print(&quot;  - JobSystem initialized.&quot;);

        PlayerStats = new PlayerStatSystem(Events, Entities);
        GD.Print(&quot;  - PlayerStatSystem initialized.&quot;);

        DebugCommands = new DebugCommandSystem(this);
        GD.Print(&quot;  - DebugCommandSystem initialized.&quot;);

        Input = new InputSystem();
        GD.Print(&quot;  - InputSystem initialized.&quot;);

        Movement = new MovementSystem(Entities, Input, Events, Transforms);
        GD.Print(&quot;  - MovementSystem initialized.&quot;);

        Physics = new PhysicsSystem(Entities, Transforms, Events);
        GD.Print(&quot;  - PhysicsSystem initialized.&quot;);

        int currentWorldSeed = 12345;
        int numGlyphsForWorld = 10;
        GlyphMap = new WorldGlyphMap(currentWorldSeed, numGlyphsForWorld);
        GD.Print(&quot;  - WorldGlyphMap initialized.&quot;);

        // Player entity is created in _Ready(), so its ID is available when InitializeSystems() is called.
        // This is safe because _Ready() runs before InitializeSystems() in Godot's execution order.
        PlayerGlyphKnowledge = new PlayerGlyphKnowledgeSystem(Entities.GetPlayerEntityID(), GlyphMap, Events);
        GD.Print(&quot;  - PlayerGlyphKnowledgeSystem initialized.&quot;);

        // Initialize PlayerHotbarSystem
        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);
        GD.Print(&quot;  - PlayerHotbarSystem initialized.&quot;);

        World = new WorldSimulation();
        GD.Print(&quot;  - WorldSimulation initialized.&quot;);
    }
}
</code></pre>
<h4 id="31-update-eventbuscs-for-hotbar-events">3.1. Update <code>EventBus.cs</code> for Hotbar Events</h4>
<p>Our <code>PlayerHotbarSystem</code> publishes <code>HotbarSlotUpdatedEvent</code>. We need to define this <code>Action</code> delegate in <code>EventBus</code>.</p>
<p>Open <code>_Brain/Core/EventBus.cs</code>:</p>
<pre><code class="language-csharp">// _Brain/Core/EventBus.cs
using System;
using System.Collections.Concurrent;
using Godot;
using Sigilborne.Entities;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Magic;
using System.Collections.Generic;

namespace Sigilborne.Core
{
    public class EventBus
    {
        // ... (existing events) ...

        // Hotbar Events (TDD 12.5)
        public event Action&lt;EntityID, int, string&gt; OnHotbarSlotUpdated;

        // ... (existing _commandBuffer) ...

        public void Publish&lt;TEvent&gt;(TEvent eventData)
        {
            // ... (existing publish conditions) ...
            else if (eventData is PlayerHotbarSystem.HotbarSlotUpdatedEvent hotbarEvent) // New condition
            {
                OnHotbarSlotUpdated?.Invoke(hotbarEvent.PlayerID, hotbarEvent.SlotIndex, hotbarEvent.SymbolID);
            }
            else
            {
                GD.PrintErr($&quot;EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.&quot;);
            }
        }
        // ... (AddCommand and FlushCommands methods) ...
    }
}
</code></pre>
<h3 id="4-implementing-the-magicsystem-core-logic">4. Implementing the <code>MagicSystem</code> (Core Logic)</h3>
<p>This system will take hotbar inputs, resolve them into glyph concepts, and then (in later chapters) trigger spell casting. For now, it will focus on processing the input sequence and providing feedback.</p>
<ol>
<li>Create <code>res://_Brain/Systems/Magic/MagicSystem.cs</code>:</li>
</ol>
<pre><code class="language-csharp">// _Brain/Systems/Magic/MagicSystem.cs
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems.Input; // To get hotbar input

namespace Sigilborne.Systems.Magic
{
    /// &lt;summary&gt;
    /// Represents a single glyph input by the player as part of a sequence.
    /// (TDD 02.1)
    /// &lt;/summary&gt;
    public struct GlyphInputFrame
    {
        public string SymbolID;     // The visual symbol ID (e.g., &quot;symbol_triangle&quot;)
        public GlyphConcept Concept; // The resolved mechanical concept (e.g., GlyphConcept.Fire)
        public double Timestamp;    // When this input occurred (real time)
        public bool Consumed;       // Whether this input has been part of a successfully resolved combo

        public GlyphInputFrame(string symbolID, GlyphConcept concept, double timestamp)
        {
            SymbolID = symbolID;
            Concept = concept;
            Timestamp = timestamp;
            Consumed = false;
        }

        public override string ToString()
        {
            return $&quot;'{SymbolID}' ({Concept}) @ {Timestamp:F3}&quot;;
        }
    }

    /// &lt;summary&gt;
    /// Manages the core magic system: processing glyph input sequences,
    /// resolving combos, and triggering spell effects.
    /// (TDD 02.1: InputBuffer, TDD 02.2: Combo Resolver)
    /// &lt;/summary&gt;
    public class MagicSystem
    {
        private EntityManager _entityManager;
        private InputSystem _inputSystem;
        private EventBus _eventBus;
        private PlayerHotbarSystem _playerHotbar;
        private PlayerGlyphKnowledgeSystem _playerGlyphKnowledge;
        private WorldGlyphMap _worldGlyphMap;

        private EntityID _playerEntityID;

        // TDD 02.1: InputBuffer - We'll use a List as a circular buffer for simplicity in C#.
        private List&lt;GlyphInputFrame&gt; _glyphInputBuffer = new List&lt;GlyphInputFrame&gt;();
        private const int MAX_GLYPH_BUFFER_SIZE = 10; // Max glyphs in a sequence
        private const float MAX_COMBO_DELAY = 1.5f; // Max time between glyph inputs for a combo (GDD B05.6)

        public MagicSystem(EntityManager entityManager, InputSystem inputSystem, EventBus eventBus,
                           PlayerHotbarSystem playerHotbar, PlayerGlyphKnowledgeSystem playerGlyphKnowledge,
                           WorldGlyphMap worldGlyphMap)
        {
            _entityManager = entityManager;
            _inputSystem = inputSystem;
            _eventBus = eventBus;
            _playerHotbar = playerHotbar;
            _playerGlyphKnowledge = playerGlyphKnowledge;
            _worldGlyphMap = worldGlyphMap;

            _playerEntityID = _entityManager.GetPlayerEntityID(); // Get player's ID

            GD.Print(&quot;MagicSystem: Initialized.&quot;);
        }

        /// &lt;summary&gt;
        /// Main update loop for the MagicSystem.
        /// Called during GameManager._PhysicsProcess (Phase 2).
        /// &lt;/summary&gt;
        public void Tick(double delta)
        {
            PlayerInputFrame currentInput = _inputSystem.GetLatestInput();
            double currentTime = _gameManager.Time.CurrentGameTime; // Assuming GameManager is accessible

            // Process hotbar inputs for glyphs
            for (int i = 0; i &lt; currentInput.HotbarKeys.Length; i++)
            {
                if (currentInput.HotbarKeys[i]) // If hotbar key is pressed
                {
                    string symbolID = _playerHotbar.GetGlyphSymbolInSlot(i);
                    if (symbolID != null)
                    {
                        ProcessGlyphInput(symbolID, currentTime);
                    }
                }
            }

            // Clean up old inputs from the buffer (GDD B05.6: Combo Timing Window)
            _glyphInputBuffer.RemoveAll(f =&gt; (currentTime - f.Timestamp) &gt; MAX_COMBO_DELAY * 2); // Keep for a bit longer than max combo delay
        }

        /// &lt;summary&gt;
        /// Processes a single glyph input (from hotbar press).
        /// Adds it to the buffer and attempts to resolve a combo.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;symbolID&quot;&gt;The symbol ID of the glyph that was input.&lt;/param&gt;
        /// &lt;param name=&quot;timestamp&quot;&gt;The real-time timestamp of the input.&lt;/param&gt;
        private void ProcessGlyphInput(string symbolID, double timestamp)
        {
            // Check if this glyph was already input very recently (debounce)
            if (_glyphInputBuffer.Any(f =&gt; f.SymbolID == symbolID &amp;&amp; (timestamp - f.Timestamp) &lt; 0.1f)) // 0.1s debounce
            {
                return;
            }

            // Get player's knowledge of this glyph (TDD 15.3)
            GlyphKnowledgeState knowledge = _playerGlyphKnowledge.GetGlyphKnowledge(symbolID);
            if (knowledge == GlyphKnowledgeState.Hidden)
            {
                // If player doesn't even know the symbol, just mark as seen.
                _playerGlyphKnowledge.UpdateGlyphKnowledge(symbolID, GlyphKnowledgeState.Seen);
                GD.Print($&quot;MagicSystem: Player saw symbol '{symbolID}'.&quot;);
                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = false });
                return;
            }

            // If player knows the symbol, get its concept
            WorldGlyphDefinition glyphDef = _worldGlyphMap.GetDefinitionBySymbol(symbolID);
            if (!glyphDef.Concept.IsValidConcept())
            {
                GD.PrintErr($&quot;MagicSystem: Glyph symbol '{symbolID}' has no valid concept in this world. Cannot process.&quot;);
                _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = GlyphConcept.None, KnowledgeState = knowledge, IsKnown = true, IsValid = false });
                return;
            }

            // Add to input buffer (TDD 02.1)
            _glyphInputBuffer.Add(new GlyphInputFrame(symbolID, glyphDef.Concept, timestamp));
            if (_glyphInputBuffer.Count &gt; MAX_GLYPH_BUFFER_SIZE)
            {
                _glyphInputBuffer.RemoveAt(0); // Maintain max size
            }

            GD.Print($&quot;MagicSystem: Player input glyph: {glyphDef}. Buffer size: {_glyphInputBuffer.Count}&quot;);
            _eventBus.Publish(new GlyphInputEvent { PlayerID = _playerEntityID, SymbolID = symbolID, Concept = glyphDef.Concept, KnowledgeState = knowledge, IsKnown = true, IsValid = true });

            // Attempt to resolve combo (TDD 02.2)
            ResolveCombo();
        }

        /// &lt;summary&gt;
        /// Attempts to resolve a combo from the current glyph input buffer.
        /// (TDD 02.2: Combo Resolver)
        /// &lt;/summary&gt;
        private void ResolveCombo()
        {
            if (_glyphInputBuffer.Count == 0) return;

            // Get recent inputs within the combo delay window (GDD B05.6)
            List&lt;GlyphInputFrame&gt; recentInputs = _glyphInputBuffer
                .Where(f =&gt; (GameManager.Instance.Time.CurrentGameTime - f.Timestamp) &lt;= MAX_COMBO_DELAY)
                .OrderBy(f =&gt; f.Timestamp) // Ensure correct order
                .ToList();

            if (recentInputs.Count == 0) return;

            GD.Print($&quot;MagicSystem: Attempting to resolve combo with {recentInputs.Count} recent inputs.&quot;);

            // --- Combo Resolution Logic (Placeholder for now) ---
            // In later chapters, this is where a Trie structure (TDD 02.2)
            // or complex interpretation model (GDD B02.2) would go.
            // For now, we'll simulate a simple &quot;known&quot; combo if it's a single known glyph.

            // TDD 15.3: Feedback - If player inputs a known glyph, mark it as known.
            if (recentInputs.Count == 1 &amp;&amp; recentInputs[0].KnowledgeState &lt; GlyphKnowledgeState.Known)
            {
                _playerGlyphKnowledge.UpdateGlyphKnowledge(recentInputs[0].SymbolID, GlyphKnowledgeState.Known);
                GD.Print($&quot;MagicSystem: Player successfully experimented with '{recentInputs[0].SymbolID}' and now KNOWS its concept: {recentInputs[0].Concept}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Discovered {recentInputs[0].Concept}!&quot;, ConceptSequence = new List&lt;GlyphConcept&gt; { recentInputs[0].Concept } });
                MarkInputsConsumed(recentInputs);
                return;
            }

            // Simple check: if two known glyphs are pressed, it's a plausible experiment (GDD B05.7)
            if (recentInputs.Count &gt;= 2 &amp;&amp; recentInputs.All(f =&gt; f.KnowledgeState &gt;= GlyphKnowledgeState.Known))
            {
                List&lt;GlyphConcept&gt; conceptSequence = recentInputs.Select(f =&gt; f.Concept).ToList();
                GD.Print($&quot;MagicSystem: Player experimented with a plausible sequence: {string.Join(&quot; -&gt; &quot;, conceptSequence)}.&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = true, IsDiscovery = true, ResultText = $&quot;Plausible experiment! {string.Join(&quot; &quot;, conceptSequence)}&quot;, ConceptSequence = conceptSequence });
                MarkInputsConsumed(recentInputs);
                return;
            }

            // If buffer is full and no combo resolved, or oldest input expired, it's a fizzle (GDD B05.7)
            if (_glyphInputBuffer.Count == MAX_GLYPH_BUFFER_SIZE &amp;&amp; recentInputs.Count == 0)
            {
                GD.Print($&quot;MagicSystem: Combo fizzled (inputs too slow or no valid sequence).&quot;);
                _eventBus.Publish(new ComboResolvedEvent { PlayerID = _playerEntityID, IsSuccess = false, IsDiscovery = false, ResultText = &quot;Fizzle!&quot;, ConceptSequence = new List&lt;GlyphConcept&gt;() });
                _glyphInputBuffer.Clear(); // Clear buffer on fizzle
            }
        }

        /// &lt;summary&gt;
        /// Marks glyph inputs as consumed after a combo is resolved.
        /// (TDD 02.1)
        /// &lt;/summary&gt;
        private void MarkInputsConsumed(List&lt;GlyphInputFrame&gt; inputs)
        {
            foreach (var input in inputs)
            {
                int index = _glyphInputBuffer.IndexOf(input);
                if (index != -1)
                {
                    _glyphInputBuffer[index] = new GlyphInputFrame(input.SymbolID, input.Concept, input.Timestamp) { Consumed = true };
                }
            }
            _glyphInputBuffer.RemoveAll(f =&gt; f.Consumed); // Remove consumed inputs
        }

        // --- Helper Events for Body Sync ---
        public struct GlyphInputEvent { public EntityID PlayerID; public string SymbolID; public GlyphConcept Concept; public GlyphKnowledgeState KnowledgeState; public bool IsKnown; public bool IsValid; }
        public struct ComboResolvedEvent { public EntityID PlayerID; public bool IsSuccess; public bool IsDiscovery; public string ResultText; public List&lt;GlyphConcept&gt; ConceptSequence; }
    }
}
</code></pre>
<p><strong>Explanation of <code>MagicSystem.cs</code>:</strong></p>
<ul>
<li><strong><code>GlyphInputFrame</code></strong>: A struct to store each individual glyph input (symbol, concept, timestamp, consumed status).</li>
<li><strong><code>_glyphInputBuffer</code></strong>: A <code>List&lt;GlyphInputFrame&gt;</code> acting as our circular input buffer (TDD 02.1).</li>
<li><strong><code>MAX_COMBO_DELAY</code></strong>: Defines the maximum time between glyphs for them to be considered part of the same combo (GDD B05.6).</li>
<li><strong><code>Tick(double delta)</code></strong>:<ul>
<li>Iterates through the <code>PlayerInputFrame.HotbarKeys</code>.</li>
<li>If a hotbar key is pressed, it calls <code>ProcessGlyphInput()</code>.</li>
<li>Cleans up old, expired inputs from the buffer.</li>
</ul>
</li>
<li><strong><code>ProcessGlyphInput()</code></strong>:<ul>
<li><strong>Debounces</strong>: Prevents multiple inputs from a single key press.</li>
<li><strong>Knowledge Check</strong>: If the glyph is <code>Hidden</code>, it updates to <code>Seen</code> (GDD B01.4.C).</li>
<li>Resolves <code>GlyphConcept</code> from <code>WorldGlyphMap</code>.</li>
<li>Adds the <code>GlyphInputFrame</code> to <code>_glyphInputBuffer</code>.</li>
<li>Publishes a <code>GlyphInputEvent</code> for UI feedback.</li>
<li>Calls <code>ResolveCombo()</code>.</li>
</ul>
</li>
<li><strong><code>ResolveCombo()</code></strong>:<ul>
<li>Filters <code>_glyphInputBuffer</code> for recent inputs within <code>MAX_COMBO_DELAY</code>.</li>
<li><strong>Placeholder Logic</strong>:<ul>
<li>If a single <code>Seen</code> glyph is input, it's marked as <code>Known</code> (TDD 15.3: Feedback).</li>
<li>If two or more <code>Known</code> glyphs are input, it's a "plausible experiment" (GDD B05.7).</li>
<li>If the buffer fills up and no combo is resolved, it's a "fizzle."</li>
</ul>
</li>
<li>Publishes a <code>ComboResolvedEvent</code> with the outcome.</li>
<li>Calls <code>MarkInputsConsumed()</code> on successful combos.</li>
</ul>
</li>
<li><strong><code>MarkInputsConsumed()</code></strong>: Clears inputs that were part of a successful combo.</li>
</ul>
<h3 id="5-integrating-magicsystem-into-gamemanager">5. Integrating <code>MagicSystem</code> into <code>GameManager</code></h3>
<ol>
<li>Add <code>using Sigilborne.Systems.Magic;</code> at the top of <code>_Brain/Core/GameManager.cs</code>.</li>
<li>Add a <code>MagicSystem</code> property.</li>
<li>Initialize <code>MagicSystem</code> in <code>InitializeSystems()</code>.</li>
<li>Call <code>MagicSystem.Tick(delta)</code> in <code>_PhysicsProcess</code> (Phase 2).</li>
</ol>
<pre><code class="language-csharp">// _Brain/Core/GameManager.cs
using Godot;
using System;
using Sigilborne.Core;
using Sigilborne.Entities;
using Sigilborne.Systems;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Input;
using Sigilborne.Systems.Movement;
using Sigilborne.Systems.Physics;
using Sigilborne.Systems.Magic;
using Sigilborne.Utils;
using System.Linq;

public partial class GameManager : Node
{
    public static GameManager Instance { get; private set; }

    // ... (existing system properties) ...
    public PlayerHotbarSystem PlayerHotbar { get; private set; }
    public MagicSystem Magic { get; private set; } // Add MagicSystem property

    public override void _Ready()
    {
        // ... (existing Instance check and InitializeSystems call) ...
        // ... (existing test entity/job code) ...

        // --- Test Glyph Discovery System ---
        GD.Print(&quot;\n--- Testing Glyph Discovery System ---&quot;);
        string testSymbol = GlyphMap.AllWorldGlyphs[0].SymbolID;
        string testSymbol2 = GlyphMap.AllWorldGlyphs[1].SymbolID;
        // Make sure testSymbol is only Seen initially for experimentation
        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Hidden, true); // Force reset to Hidden
        GD.Print($&quot;Initial knowledge of '{testSymbol}': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol)}&quot;);
        // PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Seen); // Will be handled by MagicSystem
        // PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol, GlyphKnowledgeState.Known); // Will be handled by MagicSystem

        PlayerGlyphKnowledge.UpdateGlyphKnowledge(testSymbol2, GlyphKnowledgeState.Known); // Make second symbol known for hotbar test
        GD.Print($&quot;Knowledge of '{testSymbol2}' after 'Known': {PlayerGlyphKnowledge.GetGlyphKnowledge(testSymbol2)}&quot;);

        // ... (existing unknown symbol test) ...
        GD.Print(&quot;--- End Testing Glyph Discovery System ---\n&quot;);

        // --- Test PlayerHotbarSystem ---
        GD.Print(&quot;\n--- Testing PlayerHotbarSystem ---&quot;);
        PlayerHotbar.AssignGlyphToSlot(0, testSymbol); // Assign potentially unknown symbol
        PlayerHotbar.AssignGlyphToSlot(1, testSymbol2); // Assign known symbol
        // ... (existing hotbar tests) ...
        GD.Print(&quot;--- End Testing PlayerHotbarSystem ---\n&quot;);
    }

    public override void _PhysicsProcess(double delta)
    {
        Input.ProcessInputBuffer(); 
        Time.Tick(delta);
        World.Tick(delta);
        Movement.Tick(delta);
        Magic.Tick(delta); // Call MagicSystem's tick method
        Events.FlushCommands();
    }

    private void InitializeSystems()
    {
        // ... (existing system initializations) ...

        PlayerHotbar = new PlayerHotbarSystem(Entities.GetPlayerEntityID(), Events, PlayerGlyphKnowledge, GlyphMap);
        GD.Print(&quot;  - PlayerHotbarSystem initialized.&quot;);

        // Initialize MagicSystem
        Magic = new MagicSystem(Entities, Input, Events, PlayerHotbar, PlayerGlyphKnowledge, GlyphMap);
        GD.Print(&quot;  - MagicSystem initialized.&quot;);

        World = new WorldSimulation();
        GD.Print(&quot;  - WorldSimulation initialized.&quot;);
    }
}
</code></pre>
<h4 id="51-update-eventbuscs-for-magicsystem-events">5.1. Update <code>EventBus.cs</code> for MagicSystem Events</h4>
<p>Our <code>MagicSystem</code> publishes <code>GlyphInputEvent</code> and <code>ComboResolvedEvent</code>. We need to define these <code>Action</code> delegates in <code>EventBus</code>.</p>
<p>Open <code>_Brain/Core/EventBus.cs</code>:</p>
<pre><code class="language-csharp">// _Brain/Core/EventBus.cs
using System;
using System.Collections.Concurrent;
using Godot;
using Sigilborne.Entities;
using Sigilborne.Systems.Biology;
using Sigilborne.Systems.Magic;
using System.Collections.Generic;

namespace Sigilborne.Core
{
    public class EventBus
    {
        // ... (existing events) ...

        // Magic System Events (TDD 15.3, TDD 02.1)
        public event Action&lt;EntityID, string, GlyphConcept, GlyphKnowledgeState, bool, bool&gt; OnGlyphInput; // PlayerID, SymbolID, Concept, KnowledgeState, IsKnown, IsValid
        public event Action&lt;EntityID, bool, bool, string, List&lt;GlyphConcept&gt;&gt; OnComboResolved; // PlayerID, IsSuccess, IsDiscovery, ResultText, ConceptSequence

        // ... (existing _commandBuffer) ...

        public void Publish&lt;TEvent&gt;(TEvent eventData)
        {
            // ... (existing publish conditions) ...
            else if (eventData is MagicSystem.GlyphInputEvent glyphInputEvent) // New condition
            {
                OnGlyphInput?.Invoke(glyphInputEvent.PlayerID, glyphInputEvent.SymbolID, glyphInputEvent.Concept, glyphInputEvent.KnowledgeState, glyphInputEvent.IsKnown, glyphInputEvent.IsValid);
            }
            else if (eventData is MagicSystem.ComboResolvedEvent comboResolvedEvent) // New condition
            {
                OnComboResolved?.Invoke(comboResolvedEvent.PlayerID, comboResolvedEvent.IsSuccess, comboResolvedEvent.IsDiscovery, comboResolvedEvent.ResultText, comboResolvedEvent.ConceptSequence);
            }
            else
            {
                GD.PrintErr($&quot;EventBus: Attempted to publish unknown event type: {typeof(TEvent).Name}. Ensure it's handled in Publish&lt;TEvent&gt;.&quot;);
            }
        }
        // ... (AddCommand and FlushCommands methods) ...
    }
}
</code></pre>
<h3 id="6-testing-glyph-experimentation">6. Testing Glyph Experimentation</h3>
<ol>
<li>Save all C# and GDScript files.</li>
<li>Run <code>Main.tscn</code>.</li>
<li>Load <code>Gameplay.tscn</code>.</li>
<li>In the Output console, observe the initial glyph knowledge and hotbar setup. The <code>testSymbol</code> (e.g., <code>symbol_leaf</code>) should be <code>Hidden</code>. The <code>testSymbol2</code> (e.g., <code>symbol_cross</code>) should be <code>Known</code>.</li>
<li><strong>Test 1 (Single Unknown Glyph)</strong>: Press <code>1</code> (hotbar slot 0). This is our <code>testSymbol</code>.<ul>
<li>You should see <code>MagicSystem: Player saw symbol 'symbol_leaf'.</code></li>
<li>Then <code>PlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Hidden to Seen.</code></li>
<li>Then <code>MagicSystem: Player input glyph: 'symbol_leaf' (Bloom) @ X.XX. Buffer size: 1</code></li>
<li>Then <code>MagicSystem: Player successfully experimented with 'symbol_leaf' and now KNOWS its concept: Bloom.</code></li>
<li>And <code>PlayerGlyphKnowledgeSystem: Player EntityID(0, Gen:1) knowledge of 'symbol_leaf' updated from Seen to Known.</code></li>
<li>This sequence demonstrates the discovery of a glyph's meaning through solo experimentation.</li>
</ul>
</li>
<li><strong>Test 2 (Two Known Glyphs - Plausible Experiment)</strong>:<ul>
<li>Quickly press <code>0</code> (hotbar slot 0, which is <code>testSymbol</code>, now <code>Known</code>).</li>
<li>Then quickly press <code>1</code> (hotbar slot 1, which is <code>testSymbol2</code>, <code>Known</code>).</li>
<li>You should see <code>MagicSystem: Player input glyph...</code> for both.</li>
<li>Then <code>MagicSystem: Player experimented with a plausible sequence: Bloom -&gt; Consume.</code> (or whatever your concepts are). This simulates a new combo discovery.</li>
</ul>
</li>
<li><strong>Test 3 (Fizzle)</strong>:<ul>
<li>Press <code>0</code>. Wait for more than <code>MAX_COMBO_DELAY</code> (1.5 seconds).</li>
<li>Press <code>0</code> again.</li>
<li>You should see a <code>MagicSystem: Combo fizzled...</code> message. The buffer cleared.</li>
</ul>
</li>
</ol>
<p>This confirms the basic glyph experimentation loop, including knowledge progression and combo resolution, is working.</p>
<h3 id="summary">Summary</h3>
<p>You have successfully implemented the core <strong>Glyph Experimentation</strong> loop for Sigilborne, allowing players to input glyph sequences, process their hotbar choices, and interpret the outcomes. By creating <code>PlayerHotbarSystem</code> to manage equipped glyphs and enhancing <code>MagicSystem</code> to process inputs, track knowledge, and resolve rudimentary combos (or fizzles), you've established the foundation for dynamic spellcasting and discovery. This system correctly handles knowledge progression from <code>Hidden</code> to <code>Known</code> and provides feedback for plausible experiments, strictly adhering to TDD 15.3's specifications.</p>
<h3 id="next-steps">Next Steps</h3>
<p>The next chapter will focus on <strong>Subtypes &amp; Modifiers</strong>, expanding our <code>WorldGlyphDefinition</code> to include procedural subtypes that add nuance and variety to each glyph's actual effect based on world-specific conditions, further enhancing replayability.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.sections", "navigation.expand", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
    
  </body>
</html>